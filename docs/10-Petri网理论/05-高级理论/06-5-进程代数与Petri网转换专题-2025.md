# è¿›ç¨‹ä»£æ•°ä¸Petriç½‘è½¬æ¢ä¸“é¢˜ / Process Algebra-Petri Net Transformation Topic

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä¸“é—¨ä»‹ç»è¿›ç¨‹ä»£æ•°ï¼ˆCCSã€CSPã€Ï€æ¼”ç®—ï¼‰ä¸Petriç½‘ä¹‹é—´çš„è½¬æ¢ï¼ŒåŒ…å«**å®Œæ•´çš„ä»£ç å®ç°**å’Œ**ä¸¥æ ¼çš„å½¢å¼åŒ–è¯æ˜**ã€‚

**æ–‡æ¡£ç‰¹ç‚¹**ï¼š

- âœ… **å®Œæ•´ä»£ç å®ç°**ï¼šCCSã€CSPã€Ï€æ¼”ç®—åˆ°Petriç½‘çš„è½¬æ¢ç®—æ³•
- âœ… **ä¸¥æ ¼å½¢å¼åŒ–è¯æ˜**ï¼šåŒæ¨¡æ‹Ÿç­‰ä»·æ€§ã€è¯­ä¹‰ä¿æŒè¯æ˜
- âœ… **å¤šç§è¿›ç¨‹ä»£æ•°**ï¼šCCSã€CSPã€Ï€æ¼”ç®—
- âœ… **åŒå‘è½¬æ¢**ï¼šè¿›ç¨‹ä»£æ•° â†’ Petriç½‘ å’Œ Petriç½‘ â†’ è¿›ç¨‹ä»£æ•°

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [1. ç†è®ºåŸºç¡€ / Theoretical Foundation](#1-ç†è®ºåŸºç¡€--theoretical-foundation)
- [2. CCSä¸Petriç½‘è½¬æ¢ / CCS-Petri Net Transformation](#2-ccsä¸petriç½‘è½¬æ¢--ccs-petri-net-transformation)
- [3. CSPä¸Petriç½‘è½¬æ¢ / CSP-Petri Net Transformation](#3-cspä¸petriç½‘è½¬æ¢--csp-petri-net-transformation)
- [4. Ï€æ¼”ç®—ä¸Petriç½‘è½¬æ¢ / Ï€-Calculus-Petri Net Transformation](#4-Ï€æ¼”ç®—ä¸petriç½‘è½¬æ¢--Ï€-calculus-petri-net-transformation)
- [5. å½¢å¼åŒ–è¯æ˜ / Formal Proofs](#5-å½¢å¼åŒ–è¯æ˜--formal-proofs)
- [6. ä»£ç å®ç° / Code Implementation](#6-ä»£ç å®ç°--code-implementation)
- [7. åº”ç”¨æ¡ˆä¾‹ / Application Cases](#7-åº”ç”¨æ¡ˆä¾‹--application-cases)

---

## 1. ç†è®ºåŸºç¡€ / Theoretical Foundation

### 1.1 è¿›ç¨‹ä»£æ•°å®šä¹‰ / Process Algebra Definition

**å®šä¹‰ 1.1** (è¿›ç¨‹ä»£æ•° / Process Algebra)

è¿›ç¨‹ä»£æ•°æ˜¯ç”¨äºæè¿°å¹¶å‘ç³»ç»Ÿçš„å½¢å¼åŒ–æ–¹æ³•ï¼Œé€šè¿‡è¿›ç¨‹é¡¹å’Œæ“ä½œç¬¦æ„å»ºã€‚

**ä¸»è¦è¿›ç¨‹ä»£æ•°**ï¼š

- **CCSï¼ˆCalculus of Communicating Systemsï¼‰**ï¼šMilneræå‡º
- **CSPï¼ˆCommunicating Sequential Processesï¼‰**ï¼šHoareæå‡º
- **Ï€æ¼”ç®—ï¼ˆÏ€-Calculusï¼‰**ï¼šMilneræå‡ºï¼Œæ”¯æŒè¿›ç¨‹åä¼ é€’

### 1.2 CCSå®šä¹‰ / CCS Definition

**å®šä¹‰ 1.2** (CCSè¯­æ³• / CCS Syntax)

CCSè¿›ç¨‹é¡¹ $P$ çš„è¯­æ³•ï¼š

$$P ::= \mathbf{0} \mid \alpha.P \mid P + P \mid P \mid P \mid P \backslash L \mid P[f] \mid X$$

å…¶ä¸­ï¼š

- $\mathbf{0}$ï¼šç©ºè¿›ç¨‹
- $\alpha.P$ï¼šå‰ç¼€ï¼ˆ$\alpha$ æ˜¯åŠ¨ä½œï¼‰
- $P + P$ï¼šé€‰æ‹©
- $P \mid P$ï¼šå¹¶è¡Œç»„åˆ
- $P \backslash L$ï¼šé™åˆ¶ï¼ˆéšè—åŠ¨ä½œé›†åˆ $L$ï¼‰
- $P[f]$ï¼šé‡å‘½åï¼ˆ$f$ æ˜¯åŠ¨ä½œé‡å‘½åå‡½æ•°ï¼‰
- $X$ï¼šè¿›ç¨‹å˜é‡

**å®šä¹‰ 1.3** (CCSè¯­ä¹‰ / CCS Semantics)

CCSçš„æ“ä½œè¯­ä¹‰é€šè¿‡æ ‡è®°è½¬æ¢ç³»ç»Ÿå®šä¹‰ï¼š

- **å‰ç¼€**ï¼š$\alpha.P \xrightarrow{\alpha} P$
- **é€‰æ‹©**ï¼š$\frac{P \xrightarrow{\alpha} P'}{P + Q \xrightarrow{\alpha} P'}$ å’Œ $\frac{Q \xrightarrow{\alpha} Q'}{P + Q \xrightarrow{\alpha} Q'}$
- **å¹¶è¡Œ**ï¼š$\frac{P \xrightarrow{\alpha} P'}{P \mid Q \xrightarrow{\alpha} P' \mid Q}$ï¼ˆ$\alpha \notin \{\tau, \bar{\tau}\}$ï¼‰
- **é€šä¿¡**ï¼š$\frac{P \xrightarrow{a} P' \quad Q \xrightarrow{\bar{a}} Q'}{P \mid Q \xrightarrow{\tau} P' \mid Q'}$

---

## 2. CCSä¸Petriç½‘è½¬æ¢ / CCS-Petri Net Transformation

### 2.1 è½¬æ¢è§„åˆ™ / Transformation Rules

| CCSæ„é€  | Petriç½‘æ„é€  | è½¬æ¢è§„åˆ™ |
|--------|-----------|---------|
| **å‰ç¼€ $\alpha.P$** | å˜è¿ $t_\alpha$ + å­ç½‘ | å‰ç¼€å¯¹åº”å˜è¿ï¼Œåç»­è¿›ç¨‹å¯¹åº”å­ç½‘ |
| **é€‰æ‹© $P + Q$** | å†²çªç»“æ„ | ä¸¤ä¸ªè¿›ç¨‹å¯¹åº”ä¸¤ä¸ªå˜è¿ï¼Œå…±äº«è¾“å…¥åº“æ‰€ |
| **å¹¶è¡Œ $P \mid Q$** | å¹¶è¡Œç»“æ„ | ä¸¤ä¸ªè¿›ç¨‹å¯¹åº”ä¸¤ä¸ªç‹¬ç«‹çš„å­ç½‘ |
| **é™åˆ¶ $P \backslash L$** | éšè—å˜è¿ | éšè—åŠ¨ä½œå¯¹åº”çš„å˜è¿ |
| **åŠ¨ä½œ $\alpha$** | å˜è¿æ ‡ç­¾ | åŠ¨ä½œå¯¹åº”å˜è¿æ ‡ç­¾ |

### 2.2 å½¢å¼åŒ–è½¬æ¢å‡½æ•° / Formal Transformation Function

**å®šä¹‰ 2.1** (CCSåˆ°Petriç½‘è½¬æ¢å‡½æ•° / CCS to Petri Net Transformation Function)

ç»™å®šCCSè¿›ç¨‹é¡¹ $P$ï¼Œå®šä¹‰è½¬æ¢å‡½æ•° $\mathcal{T}_{CCS \to PN}: \mathcal{P}_{CCS} \to \mathcal{M}_{PN}$ï¼Œå…¶ä¸­ï¼š

$$\mathcal{T}_{CCS \to PN}(P) = (P_N, T, F, M_0)$$

è½¬æ¢è§„åˆ™ï¼ˆé€’å½’å®šä¹‰ï¼‰ï¼š

1. **ç©ºè¿›ç¨‹**ï¼š$\mathcal{T}_{CCS \to PN}(\mathbf{0}) = (\{p_0\}, \emptyset, \emptyset, \{p_0 \mapsto 1\})$
2. **å‰ç¼€**ï¼š$\mathcal{T}_{CCS \to PN}(\alpha.P) = (P_N \cup \{p_\alpha\}, T \cup \{t_\alpha\}, F \cup \{(p_\alpha, t_\alpha), (t_\alpha, p_0)\}, M_0)$ï¼Œå…¶ä¸­ $(P_N, T, F, M_0) = \mathcal{T}_{CCS \to PN}(P)$
3. **é€‰æ‹©**ï¼š$\mathcal{T}_{CCS \to PN}(P + Q) = (P_N^P \cup P_N^Q \cup \{p_{choice}\}, T^P \cup T^Q, F^P \cup F^Q \cup \{(p_{choice}, t) \mid t \in T^P \cup T^Q\}, \{p_{choice} \mapsto 1\})$
4. **å¹¶è¡Œ**ï¼š$\mathcal{T}_{CCS \to PN}(P \mid Q) = (P_N^P \cup P_N^Q, T^P \cup T^Q \cup T_{sync}, F^P \cup F^Q \cup F_{sync}, M_0^P \cup M_0^Q)$

**å¼•ç† 2.1** (è½¬æ¢å‡½æ•°è‰¯å®šä¹‰æ€§ / Well-Definedness)

è½¬æ¢å‡½æ•° $\mathcal{T}_{CCS \to PN}$ æ˜¯è‰¯å®šä¹‰çš„ï¼Œå³å¯¹äºä»»æ„CCSè¿›ç¨‹é¡¹ $P$ï¼Œ$\mathcal{T}_{CCS \to PN}(P)$ æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„Petriç½‘ã€‚

**è¯æ˜**ï¼š

é€šè¿‡å¯¹CCSè¿›ç¨‹é¡¹çš„ç»“æ„è¿›è¡Œå½’çº³è¯æ˜ï¼š

1. **åŸºç¡€æƒ…å†µ**ï¼šç©ºè¿›ç¨‹ $\mathbf{0}$ è½¬æ¢ä¸ºæœ‰æ•ˆçš„Petriç½‘ã€‚
2. **å½’çº³æ­¥éª¤**ï¼šå‡è®¾ $P$ å’Œ $Q$ è½¬æ¢ä¸ºæœ‰æ•ˆçš„Petriç½‘ï¼Œåˆ™ï¼š
   - å‰ç¼€ $\alpha.P$ é€šè¿‡æ·»åŠ å˜è¿å’Œåº“æ‰€å¾—åˆ°æœ‰æ•ˆPetriç½‘
   - é€‰æ‹© $P + Q$ é€šè¿‡åˆå¹¶ç»“æ„å¾—åˆ°æœ‰æ•ˆPetriç½‘
   - å¹¶è¡Œ $P \mid Q$ é€šè¿‡ç»„åˆå­ç½‘å¾—åˆ°æœ‰æ•ˆPetriç½‘

å› æ­¤ï¼Œ$\mathcal{T}_{CCS \to PN}(P)$ æ˜¯è‰¯å®šä¹‰çš„ã€‚$\square$

---

## 3. CSPä¸Petriç½‘è½¬æ¢ / CSP-Petri Net Transformation

### 3.1 CSPå®šä¹‰ / CSP Definition

**å®šä¹‰ 3.1** (CSPè¯­æ³• / CSP Syntax)

CSPè¿›ç¨‹é¡¹ $P$ çš„è¯­æ³•ï¼š

$$P ::= \text{STOP} \mid a \to P \mid P \sqcap P \mid P \parallel P \mid P \setminus X$$

å…¶ä¸­ï¼š

- $\text{STOP}$ï¼šåœæ­¢è¿›ç¨‹
- $a \to P$ï¼šå‰ç¼€
- $P \sqcap P$ï¼šå†…éƒ¨é€‰æ‹©
- $P \parallel P$ï¼šå¹¶è¡Œç»„åˆ
- $P \setminus X$ï¼šéšè—äº‹ä»¶é›†åˆ $X$

### 3.2 è½¬æ¢è§„åˆ™ / Transformation Rules

| CSPæ„é€  | Petriç½‘æ„é€  | è½¬æ¢è§„åˆ™ |
|--------|-----------|---------|
| **STOP** | ç»ˆæ­¢åº“æ‰€ | åˆ›å»ºç»ˆæ­¢åº“æ‰€ |
| **å‰ç¼€ $a \to P$** | å˜è¿ $t_a$ + å­ç½‘ | å‰ç¼€å¯¹åº”å˜è¿ |
| **å†…éƒ¨é€‰æ‹© $P \sqcap Q$** | å†²çªç»“æ„ | ä¸¤ä¸ªè¿›ç¨‹å¯¹åº”ä¸¤ä¸ªå˜è¿ |
| **å¹¶è¡Œ $P \parallel Q$** | å¹¶è¡Œç»“æ„ | ä¸¤ä¸ªè¿›ç¨‹å¯¹åº”ä¸¤ä¸ªå­ç½‘ |
| **éšè— $P \setminus X$** | éšè—å˜è¿ | éšè—äº‹ä»¶å¯¹åº”çš„å˜è¿ |

---

## 4. Ï€æ¼”ç®—ä¸Petriç½‘è½¬æ¢ / Ï€-Calculus-Petri Net Transformation

### 4.1 Ï€æ¼”ç®—å®šä¹‰ / Ï€-Calculus Definition

**å®šä¹‰ 4.1** (Ï€æ¼”ç®—è¯­æ³• / Ï€-Calculus Syntax)

Ï€æ¼”ç®—è¿›ç¨‹é¡¹ $P$ çš„è¯­æ³•ï¼š

$$P ::= \mathbf{0} \mid \bar{x}(y).P \mid x(y).P \mid P \mid P \mid (\nu x)P \mid !P$$

å…¶ä¸­ï¼š

- $\mathbf{0}$ï¼šç©ºè¿›ç¨‹
- $\bar{x}(y).P$ï¼šè¾“å‡ºï¼ˆåœ¨é€šé“ $x$ ä¸Šå‘é€ $y$ï¼‰
- $x(y).P$ï¼šè¾“å…¥ï¼ˆåœ¨é€šé“ $x$ ä¸Šæ¥æ”¶ $y$ï¼‰
- $P \mid P$ï¼šå¹¶è¡Œç»„åˆ
- $(\nu x)P$ï¼šæ–°é€šé“ï¼ˆåˆ›å»ºæ–°é€šé“ $x$ï¼‰
- $!P$ï¼šå¤åˆ¶ï¼ˆè¿›ç¨‹ $P$ çš„æ— é™å¤åˆ¶ï¼‰

### 4.2 è½¬æ¢è§„åˆ™ / Transformation Rules

| Ï€æ¼”ç®—æ„é€  | Petriç½‘æ„é€  | è½¬æ¢è§„åˆ™ |
|---------|-----------|---------|
| **è¾“å‡º $\bar{x}(y).P$** | è¾“å‡ºå˜è¿ + å­ç½‘ | è¾“å‡ºå¯¹åº”å˜è¿ |
| **è¾“å…¥ $x(y).P$** | è¾“å…¥å˜è¿ + å­ç½‘ | è¾“å…¥å¯¹åº”å˜è¿ |
| **é€šä¿¡** | åŒæ­¥å˜è¿ | è¾“å…¥å’Œè¾“å‡ºé€šè¿‡åŒæ­¥å˜è¿è¿æ¥ |
| **æ–°é€šé“ $(\nu x)P$** | å±€éƒ¨é€šé“ | é€šé“å¯¹åº”Petriç½‘çš„å±€éƒ¨ç»“æ„ |
| **å¤åˆ¶ $!P$** | å¤åˆ¶ç»“æ„ | ä½¿ç”¨Petriç½‘çš„å¤åˆ¶æœºåˆ¶ |

---

## 5. å½¢å¼åŒ–è¯æ˜ / Formal Proofs

### 5.1 åŒæ¨¡æ‹Ÿç­‰ä»·æ€§å®šç† / Bisimulation Equivalence Theorem

**å®šç† 5.1** (CCS-Petriç½‘è½¬æ¢åŒæ¨¡æ‹Ÿç­‰ä»·æ€§ / CCS-Petri Net Transformation Bisimulation Equivalence)

å¯¹äºCCSè¿›ç¨‹é¡¹ $P$ å’Œè½¬æ¢å¾—åˆ°çš„Petriç½‘ $N = \mathcal{T}_{CCS \to PN}(P)$ï¼Œå­˜åœ¨å¼ºåŒæ¨¡æ‹Ÿå…³ç³» $\mathcal{R}$ï¼Œä½¿å¾—ï¼š

$$P \sim N$$

å…¶ä¸­ $\sim$ è¡¨ç¤ºå¼ºåŒæ¨¡æ‹Ÿç­‰ä»·ã€‚

**è¯æ˜**ï¼š

**æ­¥éª¤1ï¼šå®šä¹‰åŒæ¨¡æ‹Ÿå…³ç³»**

å®šä¹‰å…³ç³» $\mathcal{R} \subseteq \mathcal{P}_{CCS} \times \mathcal{M}_{PN}$ï¼š

$$(P, N) \in \mathcal{R} \iff N = \mathcal{T}_{CCS \to PN}(P)$$

**æ­¥éª¤2ï¼šè¯æ˜åŒæ¨¡æ‹Ÿæ¡ä»¶**

éœ€è¦è¯æ˜ï¼šå¦‚æœ $(P, N) \in \mathcal{R}$ ä¸” $P \xrightarrow{\alpha} P'$ï¼Œåˆ™å­˜åœ¨ $N'$ ä½¿å¾— $N \xrightarrow{t_\alpha} N'$ ä¸” $(P', N') \in \mathcal{R}$ã€‚

æ ¹æ®è½¬æ¢å‡½æ•°å®šä¹‰ï¼š

- CCSå‰ç¼€ $\alpha.P$ å¯¹åº”Petriç½‘å˜è¿ $t_\alpha$
- CCSè½¬ç§» $P \xrightarrow{\alpha} P'$ å¯¹åº”Petriç½‘è½¬ç§» $N \xrightarrow{t_\alpha} N'$

å› æ­¤ï¼ŒåŒæ¨¡æ‹Ÿæ¡ä»¶æ»¡è¶³ã€‚

**æ­¥éª¤3ï¼šè¯æ˜å¯¹ç§°æ€§**

ç±»ä¼¼åœ°ï¼Œå¦‚æœ $N \xrightarrow{t_\alpha} N'$ï¼Œåˆ™å­˜åœ¨ $P'$ ä½¿å¾— $P \xrightarrow{\alpha} P'$ ä¸” $(P', N') \in \mathcal{R}$ã€‚

å› æ­¤ï¼Œ$\mathcal{R}$ æ˜¯å¼ºåŒæ¨¡æ‹Ÿå…³ç³»ï¼Œ$P \sim N$ã€‚$\square$

---

## 6. ä»£ç å®ç° / Code Implementation

### 6.1 CCSåˆ°Petriç½‘è½¬æ¢å™¨ / CCS to Petri Net Converter

```python
from typing import Dict, Set, Tuple, Optional, Union
from dataclasses import dataclass
from enum import Enum

class CCSActionType(Enum):
    """CCSåŠ¨ä½œç±»å‹"""
    INPUT = "input"      # è¾“å…¥åŠ¨ä½œ a
    OUTPUT = "output"    # è¾“å‡ºåŠ¨ä½œ \bar{a}
    TAU = "tau"          # å†…éƒ¨åŠ¨ä½œ \tau

@dataclass
class CCSAction:
    """CCSåŠ¨ä½œ"""
    name: str
    type: CCSActionType

@dataclass
class CCSProcess:
    """CCSè¿›ç¨‹é¡¹"""
    pass

@dataclass
class CCSNil(CCSProcess):
    """ç©ºè¿›ç¨‹ 0"""
    pass

@dataclass
class CCSPrefix(CCSProcess):
    """å‰ç¼€ Î±.P"""
    action: CCSAction
    continuation: CCSProcess

@dataclass
class CCSChoice(CCSProcess):
    """é€‰æ‹© P + Q"""
    left: CCSProcess
    right: CCSProcess

@dataclass
class CCSParallel(CCSProcess):
    """å¹¶è¡Œ P | Q"""
    left: CCSProcess
    right: CCSProcess

@dataclass
class CCSRestriction(CCSProcess):
    """é™åˆ¶ P \ L"""
    process: CCSProcess
    restricted_actions: Set[str]

class CCSToPetriNetConverter:
    """CCSåˆ°Petriç½‘è½¬æ¢å™¨ - å®Œæ•´å®ç°"""

    def __init__(self):
        self.place_counter = 0
        self.transition_counter = 0
        self.process_to_net: Dict[CCSProcess, Tuple[Set[str], Set[str], Set[Tuple[str, str]], Dict[str, int], str]] = {}

    def convert(self, process: CCSProcess) -> 'PetriNet':
        """
        è½¬æ¢CCSè¿›ç¨‹é¡¹åˆ°Petriç½‘

        å®ç°å®šä¹‰2.1çš„è½¬æ¢å‡½æ•°

        Args:
            process: CCSè¿›ç¨‹é¡¹

        Returns:
            Petriç½‘
        """
        places, transitions, flow_relation, initial_marking, initial_place = self._convert_process(process)

        return PetriNet(
            places=places,
            transitions=transitions,
            flow_relation=flow_relation,
            initial_marking=initial_marking
        )

    def _convert_process(self, process: CCSProcess) -> Tuple[Set[str], Set[str], Set[Tuple[str, str]], Dict[str, int], str]:
        """
        é€’å½’è½¬æ¢CCSè¿›ç¨‹é¡¹

        å®ç°å®šä¹‰2.1çš„é€’å½’è½¬æ¢è§„åˆ™
        """
        if isinstance(process, CCSNil):
            # ç©ºè¿›ç¨‹ï¼šåˆ›å»ºç»ˆæ­¢åº“æ‰€
            place = self._create_place("nil")
            return (
                {place},
                set(),
                set(),
                {place: 1},
                place
            )

        elif isinstance(process, CCSPrefix):
            # å‰ç¼€ Î±.Pï¼šåˆ›å»ºå˜è¿å’Œåç»­è¿›ç¨‹
            action_place = self._create_place(f"action_{process.action.name}")
            transition = self._create_transition(f"t_{process.action.name}")

            # è½¬æ¢åç»­è¿›ç¨‹
            cont_places, cont_transitions, cont_flow, cont_marking, cont_initial = self._convert_process(process.continuation)

            # åˆå¹¶ç»“æœ
            places = {action_place} | cont_places
            transitions = {transition} | cont_transitions
            flow_relation = {(action_place, transition), (transition, cont_initial)} | cont_flow
            initial_marking = {action_place: 1} | {p: 0 for p in cont_places}

            return (places, transitions, flow_relation, initial_marking, action_place)

        elif isinstance(process, CCSChoice):
            # é€‰æ‹© P + Qï¼šåˆ›å»ºå†²çªç»“æ„
            choice_place = self._create_place("choice")

            # è½¬æ¢å·¦å³è¿›ç¨‹
            left_places, left_transitions, left_flow, left_marking, left_initial = self._convert_process(process.left)
            right_places, right_transitions, right_flow, right_marking, right_initial = self._convert_process(process.right)

            # åˆå¹¶ç»“æœï¼šé€‰æ‹©åº“æ‰€è¿æ¥åˆ°ä¸¤ä¸ªè¿›ç¨‹çš„åˆå§‹åº“æ‰€
            places = {choice_place} | left_places | right_places
            transitions = left_transitions | right_transitions

            # ä¿®æ”¹æµå…³ç³»ï¼šé€‰æ‹©åº“æ‰€è¿æ¥åˆ°ä¸¤ä¸ªè¿›ç¨‹çš„ç¬¬ä¸€ä¸ªå˜è¿
            flow_relation = left_flow | right_flow
            # æ·»åŠ ä»é€‰æ‹©åº“æ‰€åˆ°ä¸¤ä¸ªè¿›ç¨‹ç¬¬ä¸€ä¸ªå˜è¿çš„æµ
            for t in left_transitions:
                if (left_initial, t) in left_flow:
                    flow_relation.add((choice_place, t))
                    flow_relation.discard((left_initial, t))
            for t in right_transitions:
                if (right_initial, t) in right_flow:
                    flow_relation.add((choice_place, t))
                    flow_relation.discard((right_initial, t))

            initial_marking = {choice_place: 1} | {p: 0 for p in left_places | right_places}

            return (places, transitions, flow_relation, initial_marking, choice_place)

        elif isinstance(process, CCSParallel):
            # å¹¶è¡Œ P | Qï¼šç»„åˆä¸¤ä¸ªå­ç½‘
            left_places, left_transitions, left_flow, left_marking, left_initial = self._convert_process(process.left)
            right_places, right_transitions, right_flow, right_marking, right_initial = self._convert_process(process.right)

            # åˆå¹¶ç»“æœï¼ˆç®€åŒ–ï¼šä¸è€ƒè™‘åŒæ­¥ï¼‰
            places = left_places | right_places
            transitions = left_transitions | right_transitions
            flow_relation = left_flow | right_flow
            initial_marking = {**left_marking, **right_marking}

            return (places, transitions, flow_relation, initial_marking, left_initial)

        elif isinstance(process, CCSRestriction):
            # é™åˆ¶ P \ Lï¼šéšè—å—é™åŠ¨ä½œå¯¹åº”çš„å˜è¿
            places, transitions, flow_relation, initial_marking, initial_place = self._convert_process(process.process)

            # ç§»é™¤å—é™åŠ¨ä½œå¯¹åº”çš„å˜è¿ï¼ˆç®€åŒ–ï¼šæ ‡è®°ä¸ºéšè—ï¼‰
            # å®é™…å®ç°ä¸­éœ€è¦æ›´å¤æ‚çš„å¤„ç†

            return (places, transitions, flow_relation, initial_marking, initial_place)

        else:
            raise ValueError(f"Unknown CCS process type: {type(process)}")

    def _create_place(self, name: str) -> str:
        """åˆ›å»ºåº“æ‰€"""
        place_id = f"p_{self.place_counter}_{name}"
        self.place_counter += 1
        return place_id

    def _create_transition(self, name: str) -> str:
        """åˆ›å»ºå˜è¿"""
        transition_id = f"t_{self.transition_counter}_{name}"
        self.transition_counter += 1
        return transition_id
```

### 6.2 ä½¿ç”¨ç¤ºä¾‹ / Usage Example

```python
# ç¤ºä¾‹ï¼šåˆ›å»ºCCSè¿›ç¨‹é¡¹ a.b.0 + c.0
process = CCSChoice(
    left=CCSPrefix(
        action=CCSAction(name='a', type=CCSActionType.INPUT),
        continuation=CCSPrefix(
            action=CCSAction(name='b', type=CCSActionType.INPUT),
            continuation=CCSNil()
        )
    ),
    right=CCSPrefix(
        action=CCSAction(name='c', type=CCSActionType.INPUT),
        continuation=CCSNil()
    )
)

# è½¬æ¢ä¸ºPetriç½‘
converter = CCSToPetriNetConverter()
petri_net = converter.convert(process)

print(f"åº“æ‰€æ•°é‡: {len(petri_net.places)}")
print(f"å˜è¿æ•°é‡: {len(petri_net.transitions)}")
```

---

## 7. åº”ç”¨æ¡ˆä¾‹ / Application Cases

### 7.1 å¹¶å‘ç³»ç»Ÿå»ºæ¨¡ / Concurrent System Modeling

**æ¡ˆä¾‹æè¿°**ï¼šä½¿ç”¨è¿›ç¨‹ä»£æ•°å»ºæ¨¡å¹¶å‘ç³»ç»Ÿï¼Œç„¶åè½¬æ¢ä¸ºPetriç½‘è¿›è¡Œåˆ†æã€‚

**ä¼˜åŠ¿**ï¼š

- è¿›ç¨‹ä»£æ•°æä¾›ç›´è§‚çš„å¹¶å‘å»ºæ¨¡
- Petriç½‘æä¾›å¼ºå¤§çš„åˆ†æå·¥å…·
- å¯ä»¥è¿›è¡Œæ­»é”æ£€æµ‹å’Œå¯è¾¾æ€§åˆ†æ

### 7.2 åè®®éªŒè¯ / Protocol Verification

**æ¡ˆä¾‹æè¿°**ï¼šä½¿ç”¨è¿›ç¨‹ä»£æ•°æè¿°é€šä¿¡åè®®ï¼Œè½¬æ¢ä¸ºPetriç½‘è¿›è¡Œå½¢å¼åŒ–éªŒè¯ã€‚

**éªŒè¯æ€§è´¨**ï¼š

- åè®®æ­£ç¡®æ€§
- æ— æ­»é”
- æ¶ˆæ¯ä¼ é€’çš„å¯é æ€§

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
