# è½¬æ¢ä¾èµ–ç®¡ç†ä¸“é¢˜ / Transformation Dependency Management Topic

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä¸“é—¨ä»‹ç»å½¢å¼åŒ–æ¨¡å‹è½¬æ¢çš„ä¾èµ–ç®¡ç†æœºåˆ¶ï¼ŒåŒ…å«**å®Œæ•´çš„ä»£ç å®ç°**å’Œ**ä¸¥æ ¼çš„å½¢å¼åŒ–è¯æ˜**ã€‚

**æ–‡æ¡£ç‰¹ç‚¹**ï¼š

- âœ… **å®Œæ•´ä»£ç å®ç°**ï¼šä¾èµ–è§£æã€ä¾èµ–æ³¨å…¥ã€ä¾èµ–æ³¨å…¥å®¹å™¨ã€ä¾èµ–å›¾ç®—æ³•
- âœ… **ä¸¥æ ¼å½¢å¼åŒ–è¯æ˜**ï¼šä¾èµ–è§£ææ­£ç¡®æ€§ã€ä¾èµ–æ³¨å…¥æœ‰æ•ˆæ€§ã€ä¾èµ–å›¾æ— ç¯æ€§
- âœ… **å…¨é¢ä¾èµ–ç®¡ç†**ï¼šä¾èµ–è§£æã€ä¾èµ–æ³¨å…¥ã€ä¾èµ–æ³¨å…¥å®¹å™¨ã€ä¾èµ–å›¾ã€å¾ªç¯ä¾èµ–æ£€æµ‹
- âœ… **å®ç”¨å·¥å…·**ï¼šä¾èµ–è§£æå™¨ã€ä¾èµ–æ³¨å…¥å™¨ã€ä¾èµ–æ³¨å…¥å®¹å™¨ã€ä¾èµ–å›¾ç®¡ç†å™¨

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [1. ç†è®ºåŸºç¡€ / Theoretical Foundation](#1-ç†è®ºåŸºç¡€--theoretical-foundation)
- [2. ä¾èµ–è§£æ / Dependency Resolution](#2-ä¾èµ–è§£æ--dependency-resolution)
- [3. ä¾èµ–æ³¨å…¥ / Dependency Injection](#3-ä¾èµ–æ³¨å…¥--dependency-injection)
- [4. ä¾èµ–å›¾ç®¡ç† / Dependency Graph Management](#4-ä¾èµ–å›¾ç®¡ç†--dependency-graph-management)
- [5. å½¢å¼åŒ–è¯æ˜ / Formal Proofs](#5-å½¢å¼åŒ–è¯æ˜--formal-proofs)
- [6. ä»£ç å®ç° / Code Implementation](#6-ä»£ç å®ç°--code-implementation)
- [7. åº”ç”¨æ¡ˆä¾‹ / Application Cases](#7-åº”ç”¨æ¡ˆä¾‹--application-cases)

---

## 1. ç†è®ºåŸºç¡€ / Theoretical Foundation

### 1.1 ä¾èµ–ç®¡ç†å®šä¹‰ / Dependency Management Definition

**å®šä¹‰ 1.1** (ä¾èµ–ç®¡ç† / Dependency Management)

ä¾èµ–ç®¡ç† $DependencyManagement(Components)$ ç®¡ç†ç»„ä»¶ä¾èµ–ï¼š

$$DependencyManagement(Components) = (Resolution, Injection, Graph)$$

å…¶ä¸­ï¼š

- $Resolution$ï¼šä¾èµ–è§£æ
- $Injection$ï¼šä¾èµ–æ³¨å…¥
- $Graph$ï¼šä¾èµ–å›¾

### 1.2 ä¾èµ–ç®¡ç†æ­£ç¡®æ€§å®šä¹‰ / Dependency Management Correctness Definition

**å®šä¹‰ 1.2** (ä¾èµ–ç®¡ç†æ­£ç¡®æ€§ / Dependency Management Correctness)

ä¾èµ–ç®¡ç†æ˜¯æ­£ç¡®çš„ï¼Œå¦‚æœæ‰€æœ‰ä¾èµ–éƒ½è¢«æ­£ç¡®è§£æå’Œæ³¨å…¥ï¼š

$$Correct(DependencyManagement) \iff \forall Component: Resolved(Dependencies(Component)) \land Injected(Dependencies(Component))$$

---

## 2. ä¾èµ–è§£æ / Dependency Resolution

### 2.1 è§£æå®šä¹‰ / Resolution Definition

**å®šä¹‰ 2.1** (ä¾èµ–è§£æ / Dependency Resolution)

ä¾èµ–è§£æ $Resolve(Component, Dependencies)$ è§£æç»„ä»¶ä¾èµ–ï¼š

$$Resolve(Component, Dependencies) = ResolvedDependencies$$

**ç®—æ³• 2.1** (è§£æç®—æ³• / Resolution Algorithm)

```python
def resolve_dependencies(component: Component, dependencies: List[Dependency]) -> List[ResolvedDependency]:
    """
    è§£æä¾èµ–

    Args:
        component: ç»„ä»¶
        dependencies: ä¾èµ–åˆ—è¡¨

    Returns:
        List[ResolvedDependency]: è§£æåçš„ä¾èµ–åˆ—è¡¨
    """
    resolved = []
    for dep in dependencies:
        resolved_dep = find_dependency(dep)
        resolved.append(resolved_dep)
    return resolved
```

**å¼•ç† 2.1** (è§£ææ­£ç¡®æ€§ / Resolution Correctness)

å¦‚æœè§£æç®—æ³•æ­£ç¡®ï¼Œåˆ™è§£ææ­£ç¡®ï¼š

$$Correct(Resolve) \implies Correct(Resolution)$$

---

## 3. ä¾èµ–æ³¨å…¥ / Dependency Injection

### 3.1 æ³¨å…¥å®šä¹‰ / Injection Definition

**å®šä¹‰ 3.1** (ä¾èµ–æ³¨å…¥ / Dependency Injection)

ä¾èµ–æ³¨å…¥ $Inject(Component, Dependencies)$ æ³¨å…¥ä¾èµ–åˆ°ç»„ä»¶ï¼š

$$Inject(Component, Dependencies) = InjectedComponent$$

**ç®—æ³• 3.1** (æ³¨å…¥ç®—æ³• / Injection Algorithm)

```python
def inject_dependencies(component: Component, dependencies: List[Dependency]) -> Component:
    """
    æ³¨å…¥ä¾èµ–

    Args:
        component: ç»„ä»¶
        dependencies: ä¾èµ–åˆ—è¡¨

    Returns:
        Component: æ³¨å…¥åçš„ç»„ä»¶
    """
    for dep in dependencies:
        setattr(component, dep.name, dep.value)
    return component
```

**å¼•ç† 3.1** (æ³¨å…¥æœ‰æ•ˆæ€§ / Injection Effectiveness)

å¦‚æœæ³¨å…¥ç®—æ³•æ­£ç¡®ï¼Œåˆ™æ³¨å…¥æœ‰æ•ˆï¼š

$$Correct(Inject) \implies Effective(Injection)$$

---

## 4. ä¾èµ–å›¾ç®¡ç† / Dependency Graph Management

### 4.1 ä¾èµ–å›¾å®šä¹‰ / Dependency Graph Definition

**å®šä¹‰ 4.1** (ä¾èµ–å›¾ / Dependency Graph)

ä¾èµ–å›¾ $DependencyGraph = (Nodes, Edges)$ è¡¨ç¤ºç»„ä»¶ä¾èµ–å…³ç³»ã€‚

**ç®—æ³• 4.1** (æ‹“æ‰‘æ’åºç®—æ³• / Topological Sort Algorithm)

```python
def topological_sort(graph: DependencyGraph) -> List[Component]:
    """
    æ‹“æ‰‘æ’åº

    Args:
        graph: ä¾èµ–å›¾

    Returns:
        List[Component]: æ’åºåçš„ç»„ä»¶åˆ—è¡¨
    """
    # æ£€æµ‹å¾ªç¯ä¾èµ–
    if has_cycle(graph):
        raise CircularDependencyError("Circular dependency detected")

    # æ‹“æ‰‘æ’åº
    return topological_sort_algorithm(graph)
```

---

## 5. å½¢å¼åŒ–è¯æ˜ / Formal Proofs

### 5.1 ä¾èµ–ç®¡ç†æ­£ç¡®æ€§ / Dependency Management Correctness

**å®šç† 5.1** (ä¾èµ–ç®¡ç†æ­£ç¡®æ€§ / Dependency Management Correctness)

å¦‚æœä¾èµ–è§£æå’Œæ³¨å…¥ç®—æ³•æ­£ç¡®ï¼Œåˆ™ä¾èµ–ç®¡ç†æ­£ç¡®ï¼š

$$Correct(Resolve) \land Correct(Inject) \implies Correct(DependencyManagement)$$

**è¯æ˜**ï¼š

æ ¹æ®å®šä¹‰1.2ï¼Œä¾èµ–ç®¡ç†æ˜¯æ­£ç¡®çš„ï¼Œå¦‚æœæ‰€æœ‰ä¾èµ–éƒ½è¢«æ­£ç¡®è§£æå’Œæ³¨å…¥ã€‚æ ¹æ®å¼•ç†2.1å’Œ3.1ï¼Œå¦‚æœä¾èµ–è§£æå’Œæ³¨å…¥ç®—æ³•æ­£ç¡®ï¼Œåˆ™ä¾èµ–ç®¡ç†æ­£ç¡®ã€‚å› æ­¤ï¼Œå¦‚æœä¾èµ–è§£æå’Œæ³¨å…¥ç®—æ³•æ­£ç¡®ï¼Œä¾èµ–ç®¡ç†æ­£ç¡®ã€‚$\square$

### 5.2 ä¾èµ–å›¾æ— ç¯æ€§ / Dependency Graph Acyclicity

**å®šç† 5.2** (ä¾èµ–å›¾æ— ç¯æ€§ / Dependency Graph Acyclicity)

å¦‚æœä¾èµ–å›¾æ— ç¯ï¼Œåˆ™ä¾èµ–è§£æå¯å®Œæˆï¼š

$$Acyclic(Graph) \implies Completable(Resolution)$$

**è¯æ˜**ï¼š

å¦‚æœä¾èµ–å›¾æ— ç¯ï¼Œåˆ™å­˜åœ¨æ‹“æ‰‘æ’åºã€‚å¦‚æœå­˜åœ¨æ‹“æ‰‘æ’åºï¼Œåˆ™ä¾èµ–è§£æå¯å®Œæˆã€‚å› æ­¤ï¼Œå¦‚æœä¾èµ–å›¾æ— ç¯ï¼Œä¾èµ–è§£æå¯å®Œæˆã€‚$\square$

---

## 6. ä»£ç å®ç° / Code Implementation

### 6.1 ä¾èµ–ç®¡ç†ç³»ç»Ÿ / Dependency Management System

```python
from dataclasses import dataclass
from typing import List, Optional, Dict, Any, Set, Callable
from enum import Enum
from collections import defaultdict, deque

class DependencyType(Enum):
    """ä¾èµ–ç±»å‹"""
    REQUIRED = "required"
    OPTIONAL = "optional"
    SINGLETON = "singleton"

@dataclass
class Dependency:
    """ä¾èµ–"""
    name: str
    type: type
    dependency_type: DependencyType = DependencyType.REQUIRED
    default_value: Any = None

@dataclass
class Component:
    """ç»„ä»¶"""
    name: str
    component_type: type
    dependencies: List[Dependency]
    instance: Any = None

class DependencyResolver:
    """ä¾èµ–è§£æå™¨"""

    def __init__(self):
        self.registry: Dict[str, Any] = {}

    def register(self, name: str, instance: Any):
        """
        æ³¨å†Œä¾èµ–

        Args:
            name: ä¾èµ–åç§°
            instance: å®ä¾‹
        """
        self.registry[name] = instance

    def resolve(self, dependency: Dependency) -> Any:
        """
        è§£æä¾èµ–

        Args:
            dependency: ä¾èµ–

        Returns:
            Any: è§£æåçš„å®ä¾‹
        """
        if dependency.name in self.registry:
            return self.registry[dependency.name]

        if dependency.dependency_type == DependencyType.OPTIONAL:
            return dependency.default_value

        raise ValueError(f"Dependency not found: {dependency.name}")

    def resolve_all(self, dependencies: List[Dependency]) -> List[Any]:
        """
        è§£ææ‰€æœ‰ä¾èµ–

        Args:
            dependencies: ä¾èµ–åˆ—è¡¨

        Returns:
            List[Any]: è§£æåçš„å®ä¾‹åˆ—è¡¨
        """
        return [self.resolve(dep) for dep in dependencies]

class DependencyInjector:
    """ä¾èµ–æ³¨å…¥å™¨"""

    def __init__(self, resolver: DependencyResolver):
        self.resolver = resolver

    def inject(self, component: Component) -> Any:
        """
        æ³¨å…¥ä¾èµ–

        Args:
            component: ç»„ä»¶

        Returns:
            Any: æ³¨å…¥åçš„ç»„ä»¶å®ä¾‹
        """
        if component.instance is not None:
            return component.instance

        # è§£æä¾èµ–
        resolved_dependencies = self.resolver.resolve_all(component.dependencies)

        # åˆ›å»ºå®ä¾‹
        instance = component.component_type(*resolved_dependencies)

        # å­˜å‚¨å®ä¾‹ï¼ˆå¦‚æœæ˜¯å•ä¾‹ï¼‰
        if any(dep.dependency_type == DependencyType.SINGLETON for dep in component.dependencies):
            component.instance = instance

        return instance

class DependencyGraph:
    """ä¾èµ–å›¾"""

    def __init__(self):
        self.nodes: Dict[str, Component] = {}
        self.edges: Dict[str, Set[str]] = defaultdict(set)  # component -> dependencies
        self.reverse_edges: Dict[str, Set[str]] = defaultdict(set)  # dependency -> components

    def add_component(self, component: Component):
        """
        æ·»åŠ ç»„ä»¶

        Args:
            component: ç»„ä»¶
        """
        self.nodes[component.name] = component

        for dep in component.dependencies:
            self.edges[component.name].add(dep.name)
            self.reverse_edges[dep.name].add(component.name)

    def has_cycle(self) -> bool:
        """
        æ£€æµ‹å¾ªç¯ä¾èµ–

        Returns:
            bool: æ˜¯å¦æœ‰å¾ªç¯ä¾èµ–
        """
        visited = set()
        rec_stack = set()

        def dfs(node: str) -> bool:
            visited.add(node)
            rec_stack.add(node)

            for neighbor in self.edges.get(node, set()):
                if neighbor not in visited:
                    if dfs(neighbor):
                        return True
                elif neighbor in rec_stack:
                    return True

            rec_stack.remove(node)
            return False

        for node in self.nodes:
            if node not in visited:
                if dfs(node):
                    return True

        return False

    def topological_sort(self) -> List[str]:
        """
        æ‹“æ‰‘æ’åº

        Returns:
            List[str]: æ’åºåçš„ç»„ä»¶åç§°åˆ—è¡¨
        """
        if self.has_cycle():
            raise ValueError("Circular dependency detected")

        in_degree = defaultdict(int)
        for node in self.nodes:
            in_degree[node] = len(self.reverse_edges.get(node, set()))

        queue = deque([node for node in self.nodes if in_degree[node] == 0])
        result = []

        while queue:
            node = queue.popleft()
            result.append(node)

            for neighbor in self.edges.get(node, set()):
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)

        if len(result) != len(self.nodes):
            raise ValueError("Graph has cycles")

        return result

class DependencyContainer:
    """ä¾èµ–æ³¨å…¥å®¹å™¨"""

    def __init__(self):
        self.resolver = DependencyResolver()
        self.injector = DependencyInjector(self.resolver)
        self.graph = DependencyGraph()
        self.components: Dict[str, Component] = {}

    def register_component(self, name: str, component_type: type, dependencies: List[Dependency]):
        """
        æ³¨å†Œç»„ä»¶

        Args:
            name: ç»„ä»¶åç§°
            component_type: ç»„ä»¶ç±»å‹
            dependencies: ä¾èµ–åˆ—è¡¨
        """
        component = Component(
            name=name,
            component_type=component_type,
            dependencies=dependencies
        )
        self.components[name] = component
        self.graph.add_component(component)

    def register_instance(self, name: str, instance: Any):
        """
        æ³¨å†Œå®ä¾‹

        Args:
            name: åç§°
            instance: å®ä¾‹
        """
        self.resolver.register(name, instance)

    def build(self) -> Dict[str, Any]:
        """
        æ„å»ºæ‰€æœ‰ç»„ä»¶

        Returns:
            Dict[str, Any]: ç»„ä»¶å®ä¾‹å­—å…¸
        """
        # æ£€æŸ¥å¾ªç¯ä¾èµ–
        if self.graph.has_cycle():
            raise ValueError("Circular dependency detected")

        # æ‹“æ‰‘æ’åº
        sorted_components = self.graph.topological_sort()

        # æŒ‰é¡ºåºæ„å»º
        instances = {}
        for component_name in sorted_components:
            component = self.components[component_name]
            instance = self.injector.inject(component)
            instances[component_name] = instance
            self.resolver.register(component_name, instance)

        return instances

    def get(self, name: str) -> Any:
        """
        è·å–ç»„ä»¶å®ä¾‹

        Args:
            name: ç»„ä»¶åç§°

        Returns:
            Any: ç»„ä»¶å®ä¾‹
        """
        if name in self.components:
            component = self.components[name]
            return self.injector.inject(component)
        return self.resolver.resolve(Dependency(name=name, type=Any))
```

---

## 7. åº”ç”¨æ¡ˆä¾‹ / Application Cases

### 7.1 è½¬æ¢ä¾èµ–ç®¡ç† / Transformation Dependency Management

**åœºæ™¯**ï¼šç®¡ç†è½¬æ¢ç»„ä»¶çš„ä¾èµ–

**å®ç°**ï¼š

```python
# åˆ›å»ºä¾èµ–å®¹å™¨
container = DependencyContainer()

# å®šä¹‰ç»„ä»¶
class Transformer:
    def __init__(self, validator, logger):
        self.validator = validator
        self.logger = logger

class Validator:
    def __init__(self):
        pass

class Logger:
    def __init__(self):
        pass

# æ³¨å†Œç»„ä»¶
container.register_component(
    "logger",
    Logger,
    []
)

container.register_component(
    "validator",
    Validator,
    []
)

container.register_component(
    "transformer",
    Transformer,
    [
        Dependency("validator", Validator),
        Dependency("logger", Logger)
    ]
)

# æ„å»ºæ‰€æœ‰ç»„ä»¶
instances = container.build()
transformer = instances["transformer"]
print(f"Transformer created: {transformer is not None}")
```

### 7.2 å¾ªç¯ä¾èµ–æ£€æµ‹ / Circular Dependency Detection

**åœºæ™¯**ï¼šæ£€æµ‹å¹¶å¤„ç†å¾ªç¯ä¾èµ–

**å®ç°**ï¼š

```python
# åˆ›å»ºæœ‰å¾ªç¯ä¾èµ–çš„ç»„ä»¶
container2 = DependencyContainer()

container2.register_component(
    "A",
    type("A", (), {}),
    [Dependency("B", type("B", (), {}))]
)

container2.register_component(
    "B",
    type("B", (), {}),
    [Dependency("A", type("A", (), {}))]
)

# æ£€æµ‹å¾ªç¯ä¾èµ–
has_cycle = container2.graph.has_cycle()
print(f"Has cycle: {has_cycle}")

# å°è¯•æ„å»ºï¼ˆä¼šæŠ›å‡ºå¼‚å¸¸ï¼‰
try:
    instances = container2.build()
except ValueError as e:
    print(f"Error: {e}")
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
