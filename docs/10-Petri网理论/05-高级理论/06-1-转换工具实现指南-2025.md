# å½¢å¼åŒ–æ¨¡å‹è½¬æ¢å·¥å…·å®ç°æŒ‡å— / Formal Model Transformation Tools Implementation Guide

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£æä¾›å½¢å¼åŒ–æ¨¡å‹è½¬æ¢å·¥å…·çš„å®Œæ•´å®ç°æŒ‡å—ï¼ŒåŒ…æ‹¬Pythonå·¥å…·åº“è®¾è®¡ã€APIæ¥å£ã€ä½¿ç”¨ç¤ºä¾‹å’Œæœ€ä½³å®è·µã€‚

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**çŠ¶æ€**: ğŸš€ æŒç»­æ›´æ–°ä¸­

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [å½¢å¼åŒ–æ¨¡å‹è½¬æ¢å·¥å…·å®ç°æŒ‡å— / Formal Model Transformation Tools Implementation Guide](#å½¢å¼åŒ–æ¨¡å‹è½¬æ¢å·¥å…·å®ç°æŒ‡å—--formal-model-transformation-tools-implementation-guide)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [1. å·¥å…·æ¶æ„è®¾è®¡ / Tool Architecture Design](#1-å·¥å…·æ¶æ„è®¾è®¡--tool-architecture-design)
    - [1.1 æ•´ä½“æ¶æ„ / Overall Architecture](#11-æ•´ä½“æ¶æ„--overall-architecture)
    - [1.2 è®¾è®¡æ¨¡å¼ / Design Patterns](#12-è®¾è®¡æ¨¡å¼--design-patterns)
  - [2. æ ¸å¿ƒAPIæ¥å£ / Core API Interfaces](#2-æ ¸å¿ƒapiæ¥å£--core-api-interfaces)
    - [2.1 åŸºç¡€è½¬æ¢å™¨æ¥å£ / Base Transformer Interface](#21-åŸºç¡€è½¬æ¢å™¨æ¥å£--base-transformer-interface)
    - [2.2 æ¨¡å‹å®šä¹‰æ¥å£ / Model Definition Interfaces](#22-æ¨¡å‹å®šä¹‰æ¥å£--model-definition-interfaces)
  - [3. è½¬æ¢å™¨å®ç° / Transformer Implementations](#3-è½¬æ¢å™¨å®ç°--transformer-implementations)
    - [3.1 FSMåˆ°Petriç½‘è½¬æ¢å™¨ / FSM to Petri Net Transformer](#31-fsmåˆ°petriç½‘è½¬æ¢å™¨--fsm-to-petri-net-transformer)
    - [3.2 BPMNåˆ°å·¥ä½œæµç½‘è½¬æ¢å™¨ / BPMN to Workflow Net Transformer](#32-bpmnåˆ°å·¥ä½œæµç½‘è½¬æ¢å™¨--bpmn-to-workflow-net-transformer)
  - [4. ä½¿ç”¨ç¤ºä¾‹ / Usage Examples](#4-ä½¿ç”¨ç¤ºä¾‹--usage-examples)
    - [4.1 FSMåˆ°Petriç½‘è½¬æ¢ç¤ºä¾‹ / FSM to Petri Net Example](#41-fsmåˆ°petriç½‘è½¬æ¢ç¤ºä¾‹--fsm-to-petri-net-example)
    - [4.2 BPMNåˆ°å·¥ä½œæµç½‘è½¬æ¢ç¤ºä¾‹ / BPMN to Workflow Net Example](#42-bpmnåˆ°å·¥ä½œæµç½‘è½¬æ¢ç¤ºä¾‹--bpmn-to-workflow-net-example)
  - [5. æœ€ä½³å®è·µ / Best Practices](#5-æœ€ä½³å®è·µ--best-practices)
    - [5.1 è½¬æ¢å‰éªŒè¯ / Pre-Transformation Validation](#51-è½¬æ¢å‰éªŒè¯--pre-transformation-validation)
    - [5.2 æ‰¹é‡è½¬æ¢ / Batch Transformation](#52-æ‰¹é‡è½¬æ¢--batch-transformation)
    - [5.3 è½¬æ¢ç¼“å­˜ / Transformation Caching](#53-è½¬æ¢ç¼“å­˜--transformation-caching)
  - [6. å·¥å…·é›†æˆ / Tool Integration](#6-å·¥å…·é›†æˆ--tool-integration)
    - [6.1 ä¸CPN Toolsé›†æˆ / Integration with CPN Tools](#61-ä¸cpn-toolsé›†æˆ--integration-with-cpn-tools)
    - [6.2 ä¸ProMé›†æˆ / Integration with ProM](#62-ä¸promé›†æˆ--integration-with-prom)
    - [6.3 ä¸NetworkXé›†æˆ / Integration with NetworkX](#63-ä¸networkxé›†æˆ--integration-with-networkx)
  - [7. æµ‹è¯•æ¡†æ¶ / Testing Framework](#7-æµ‹è¯•æ¡†æ¶--testing-framework)
    - [7.1 å•å…ƒæµ‹è¯• / Unit Tests](#71-å•å…ƒæµ‹è¯•--unit-tests)
    - [7.2 æ€§èƒ½æµ‹è¯• / Performance Tests](#72-æ€§èƒ½æµ‹è¯•--performance-tests)

---

## 1. å·¥å…·æ¶æ„è®¾è®¡ / Tool Architecture Design

### 1.1 æ•´ä½“æ¶æ„ / Overall Architecture

```python
"""
å½¢å¼åŒ–æ¨¡å‹è½¬æ¢å·¥å…·åº“æ¶æ„

æ ¸å¿ƒç»„ä»¶ï¼š
1. æ¨¡å‹å®šä¹‰æ¨¡å—ï¼ˆModel Definitionsï¼‰
2. è½¬æ¢å™¨æ¨¡å—ï¼ˆTransformersï¼‰
3. éªŒè¯æ¨¡å—ï¼ˆVerificationï¼‰
4. å·¥å…·é›†æˆæ¨¡å—ï¼ˆTool Integrationï¼‰
"""

# ç›®å½•ç»“æ„
"""
model_transformation/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ fsm.py          # æœ‰é™çŠ¶æ€æœºæ¨¡å‹
â”‚   â”œâ”€â”€ petri_net.py     # Petriç½‘æ¨¡å‹
â”‚   â”œâ”€â”€ bpmn.py          # BPMNæ¨¡å‹
â”‚   â”œâ”€â”€ workflow_net.py  # å·¥ä½œæµç½‘æ¨¡å‹
â”‚   â”œâ”€â”€ lts.py           # æ ‡è®°è½¬æ¢ç³»ç»Ÿ
â”‚   â””â”€â”€ turing_machine.py # å›¾çµæœºæ¨¡å‹
â”œâ”€â”€ transformers/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ base.py          # åŸºç¡€è½¬æ¢å™¨
â”‚   â”œâ”€â”€ fsm_petri.py     # FSM-Petriç½‘è½¬æ¢å™¨
â”‚   â”œâ”€â”€ bpmn_workflow.py # BPMN-å·¥ä½œæµç½‘è½¬æ¢å™¨
â”‚   â”œâ”€â”€ lts_petri.py     # LTS-Petriç½‘è½¬æ¢å™¨
â”‚   â””â”€â”€ turing_petri.py  # å›¾çµæœº-Petriç½‘è½¬æ¢å™¨
â”œâ”€â”€ verification/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ equivalence.py   # ç­‰ä»·æ€§éªŒè¯
â”‚   â””â”€â”€ properties.py    # æ€§è´¨éªŒè¯
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ visualization.py # å¯è§†åŒ–å·¥å…·
â”‚   â””â”€â”€ export.py        # å¯¼å‡ºå·¥å…·
â””â”€â”€ tests/
    â”œâ”€â”€ __init__.py
    â””â”€â”€ test_transformers.py
"""
```

### 1.2 è®¾è®¡æ¨¡å¼ / Design Patterns

**ä½¿ç”¨çš„è®¾è®¡æ¨¡å¼**ï¼š

1. **ç­–ç•¥æ¨¡å¼ï¼ˆStrategy Patternï¼‰**ï¼šä¸åŒçš„è½¬æ¢ç®—æ³•ä½œä¸ºç­–ç•¥
2. **å·¥å‚æ¨¡å¼ï¼ˆFactory Patternï¼‰**ï¼šåˆ›å»ºè½¬æ¢å™¨å®ä¾‹
3. **é€‚é…å™¨æ¨¡å¼ï¼ˆAdapter Patternï¼‰**ï¼šé€‚é…ä¸åŒæ¨¡å‹æ ¼å¼
4. **è§‚å¯Ÿè€…æ¨¡å¼ï¼ˆObserver Patternï¼‰**ï¼šè½¬æ¢è¿‡ç¨‹ç›‘æ§

---

## 2. æ ¸å¿ƒAPIæ¥å£ / Core API Interfaces

### 2.1 åŸºç¡€è½¬æ¢å™¨æ¥å£ / Base Transformer Interface

```python
from abc import ABC, abstractmethod
from typing import TypeVar, Generic, Optional, Dict, Any

T = TypeVar('T')  # æºæ¨¡å‹ç±»å‹
U = TypeVar('U')  # ç›®æ ‡æ¨¡å‹ç±»å‹

class ModelTransformer(ABC, Generic[T, U]):
    """æ¨¡å‹è½¬æ¢å™¨æŠ½è±¡åŸºç±»"""

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        åˆå§‹åŒ–è½¬æ¢å™¨

        Args:
            config: è½¬æ¢é…ç½®
        """
        self.config = config or {}
        self.statistics = {
            'transformation_count': 0,
            'success_count': 0,
            'failure_count': 0,
            'total_time': 0.0
        }

    @abstractmethod
    def transform(self, source_model: T) -> U:
        """
        è½¬æ¢æºæ¨¡å‹åˆ°ç›®æ ‡æ¨¡å‹

        Args:
            source_model: æºæ¨¡å‹

        Returns:
            ç›®æ ‡æ¨¡å‹

        Raises:
            TransformationError: è½¬æ¢å¤±è´¥
        """
        pass

    @abstractmethod
    def verify_equivalence(self, source_model: T, target_model: U) -> bool:
        """
        éªŒè¯è½¬æ¢åçš„æ¨¡å‹ä¸æºæ¨¡å‹ç­‰ä»·

        Args:
            source_model: æºæ¨¡å‹
            target_model: ç›®æ ‡æ¨¡å‹

        Returns:
            æ˜¯å¦ç­‰ä»·
        """
        pass

    def get_statistics(self) -> Dict[str, Any]:
        """è·å–è½¬æ¢ç»Ÿè®¡ä¿¡æ¯"""
        return self.statistics.copy()

    def reset_statistics(self):
        """é‡ç½®ç»Ÿè®¡ä¿¡æ¯"""
        self.statistics = {
            'transformation_count': 0,
            'success_count': 0,
            'failure_count': 0,
            'total_time': 0.0
        }
```

### 2.2 æ¨¡å‹å®šä¹‰æ¥å£ / Model Definition Interfaces

```python
from dataclasses import dataclass
from typing import Set, Dict, List, Tuple, Optional

@dataclass
class FiniteStateMachine:
    """æœ‰é™çŠ¶æ€æœºæ¨¡å‹"""
    states: Set[str]
    alphabet: Set[str]
    transitions: Dict[Tuple[str, str], str]  # (state, symbol) -> next_state
    initial_state: str
    accepting_states: Set[str]

    def validate(self) -> bool:
        """éªŒè¯æ¨¡å‹æœ‰æ•ˆæ€§"""
        if self.initial_state not in self.states:
            return False
        if not self.accepting_states.issubset(self.states):
            return False
        for (state, symbol), next_state in self.transitions.items():
            if state not in self.states or next_state not in self.states:
                return False
        return True

@dataclass
class PetriNet:
    """Petriç½‘æ¨¡å‹"""
    places: Set[str]
    transitions: Set[str]
    flow_relation: Set[Tuple[str, str]]  # (source, target)
    initial_marking: Dict[str, int]

    def validate(self) -> bool:
        """éªŒè¯æ¨¡å‹æœ‰æ•ˆæ€§"""
        # æ£€æŸ¥æµå…³ç³»ä¸­çš„èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨
        for source, target in self.flow_relation:
            if source not in self.places and source not in self.transitions:
                return False
            if target not in self.places and target not in self.transitions:
                return False
        # æ£€æŸ¥åˆå§‹æ ‡è¯†ä¸­çš„åº“æ‰€æ˜¯å¦å­˜åœ¨
        for place in self.initial_marking:
            if place not in self.places:
                return False
        return True
```

---

## 3. è½¬æ¢å™¨å®ç° / Transformer Implementations

### 3.1 FSMåˆ°Petriç½‘è½¬æ¢å™¨ / FSM to Petri Net Transformer

```python
import time
from typing import Dict, Set, Tuple

class FSMToPetriNetTransformer(ModelTransformer[FiniteStateMachine, PetriNet]):
    """FSMåˆ°Petriç½‘è½¬æ¢å™¨"""

    def transform(self, source_model: FiniteStateMachine) -> PetriNet:
        """è½¬æ¢FSMåˆ°Petriç½‘"""
        start_time = time.time()
        self.statistics['transformation_count'] += 1

        try:
            # éªŒè¯æºæ¨¡å‹
            if not source_model.validate():
                raise TransformationError("Invalid FSM model")

            places = set()
            transitions = set()
            flow_relation = set()
            initial_marking = {}

            # ä¸ºæ¯ä¸ªçŠ¶æ€åˆ›å»ºåº“æ‰€
            state_to_place = {}
            for state in source_model.states:
                place = f"p_{state}"
                places.add(place)
                state_to_place[state] = place
                initial_marking[place] = 0

            # è®¾ç½®åˆå§‹æ ‡è¯†
            initial_place = state_to_place[source_model.initial_state]
            initial_marking[initial_place] = 1

            # ä¸ºæ¯ä¸ªè½¬ç§»åˆ›å»ºå˜è¿
            for (state, symbol), next_state in source_model.transitions.items():
                transition = f"t_{state}_{symbol}"
                transitions.add(transition)

                source_place = state_to_place[state]
                target_place = state_to_place[next_state]

                flow_relation.add((source_place, transition))
                flow_relation.add((transition, target_place))

            petri_net = PetriNet(
                places=places,
                transitions=transitions,
                flow_relation=flow_relation,
                initial_marking=initial_marking
            )

            # éªŒè¯ç›®æ ‡æ¨¡å‹
            if not petri_net.validate():
                raise TransformationError("Generated invalid Petri net")

            elapsed_time = time.time() - start_time
            self.statistics['success_count'] += 1
            self.statistics['total_time'] += elapsed_time

            return petri_net

        except Exception as e:
            self.statistics['failure_count'] += 1
            raise TransformationError(f"Transformation failed: {str(e)}")

    def verify_equivalence(self, source_model: FiniteStateMachine,
                          target_model: PetriNet) -> bool:
        """éªŒè¯FSMå’ŒPetriç½‘ç­‰ä»·"""
        # å®ç°ç­‰ä»·æ€§æ£€æŸ¥
        # 1. æ£€æŸ¥çŠ¶æ€å¯¹åº”å…³ç³»
        # 2. æ£€æŸ¥è½¬ç§»å¯¹åº”å…³ç³»
        # 3. æ£€æŸ¥è¯­è¨€ç­‰ä»·æ€§
        return True  # ç®€åŒ–å®ç°
```

### 3.2 BPMNåˆ°å·¥ä½œæµç½‘è½¬æ¢å™¨ / BPMN to Workflow Net Transformer

```python
class BPMNToWorkflowNetTransformer(ModelTransformer[BPMNModel, WorkflowNet]):
    """BPMNåˆ°å·¥ä½œæµç½‘è½¬æ¢å™¨"""

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__(config)
        self.place_counter = 0
        self.transition_counter = 0
        self.place_map: Dict[str, str] = {}
        self.transition_map: Dict[str, str] = {}

    def transform(self, source_model: BPMNModel) -> WorkflowNet:
        """è½¬æ¢BPMNåˆ°å·¥ä½œæµç½‘"""
        # å®ç°è§å‰é¢ç« èŠ‚çš„å®Œæ•´ç®—æ³•
        pass

    def verify_equivalence(self, source_model: BPMNModel,
                          target_model: WorkflowNet) -> bool:
        """éªŒè¯BPMNå’Œå·¥ä½œæµç½‘ç­‰ä»·"""
        # å®ç°ç­‰ä»·æ€§æ£€æŸ¥
        pass
```

---

## 4. ä½¿ç”¨ç¤ºä¾‹ / Usage Examples

### 4.1 FSMåˆ°Petriç½‘è½¬æ¢ç¤ºä¾‹ / FSM to Petri Net Example

```python
from model_transformation.models.fsm import FiniteStateMachine
from model_transformation.transformers.fsm_petri import FSMToPetriNetTransformer

# åˆ›å»ºFSMæ¨¡å‹
fsm = FiniteStateMachine(
    states={'q0', 'q1', 'q2'},
    alphabet={'a', 'b'},
    transitions={
        ('q0', 'a'): 'q1',
        ('q1', 'b'): 'q2',
        ('q2', 'a'): 'q0'
    },
    initial_state='q0',
    accepting_states={'q2'}
)

# åˆ›å»ºè½¬æ¢å™¨
transformer = FSMToPetriNetTransformer()

# æ‰§è¡Œè½¬æ¢
petri_net = transformer.transform(fsm)

# éªŒè¯ç­‰ä»·æ€§
is_equivalent = transformer.verify_equivalence(fsm, petri_net)
print(f"Models are equivalent: {is_equivalent}")

# æŸ¥çœ‹ç»Ÿè®¡ä¿¡æ¯
stats = transformer.get_statistics()
print(f"Transformation statistics: {stats}")
```

### 4.2 BPMNåˆ°å·¥ä½œæµç½‘è½¬æ¢ç¤ºä¾‹ / BPMN to Workflow Net Example

```python
from model_transformation.models.bpmn import BPMNModel
from model_transformation.transformers.bpmn_workflow import BPMNToWorkflowNetTransformer

# åŠ è½½BPMNæ¨¡å‹ï¼ˆä»æ–‡ä»¶æˆ–APIï¼‰
bpmn_model = load_bpmn_from_file("process.bpmn")

# åˆ›å»ºè½¬æ¢å™¨ï¼ˆå¸¦é…ç½®ï¼‰
config = {
    'support_all_bpmn_elements': True,
    'handle_subprocesses': True,
    'handle_compensation': True
}
transformer = BPMNToWorkflowNetTransformer(config=config)

# æ‰§è¡Œè½¬æ¢
workflow_net = transformer.transform(bpmn_model)

# å¯¼å‡ºç»“æœ
export_to_pnml(workflow_net, "process.pnml")
```

---

## 5. æœ€ä½³å®è·µ / Best Practices

### 5.1 è½¬æ¢å‰éªŒè¯ / Pre-Transformation Validation

```python
def safe_transform(transformer: ModelTransformer, source_model: Any) -> Any:
    """å®‰å…¨çš„è½¬æ¢å‡½æ•°ï¼ŒåŒ…å«éªŒè¯"""
    # 1. éªŒè¯æºæ¨¡å‹
    if hasattr(source_model, 'validate'):
        if not source_model.validate():
            raise ValueError("Source model is invalid")

    # 2. æ‰§è¡Œè½¬æ¢
    try:
        target_model = transformer.transform(source_model)
    except Exception as e:
        logger.error(f"Transformation failed: {e}")
        raise

    # 3. éªŒè¯ç›®æ ‡æ¨¡å‹
    if hasattr(target_model, 'validate'):
        if not target_model.validate():
            raise ValueError("Target model is invalid")

    # 4. éªŒè¯ç­‰ä»·æ€§
    if not transformer.verify_equivalence(source_model, target_model):
        logger.warning("Models may not be equivalent")

    return target_model
```

### 5.2 æ‰¹é‡è½¬æ¢ / Batch Transformation

```python
def batch_transform(transformer: ModelTransformer,
                   source_models: List[Any]) -> List[Any]:
    """æ‰¹é‡è½¬æ¢æ¨¡å‹"""
    results = []
    for i, model in enumerate(source_models):
        try:
            result = transformer.transform(model)
            results.append(result)
            logger.info(f"Transformed model {i+1}/{len(source_models)}")
        except Exception as e:
            logger.error(f"Failed to transform model {i+1}: {e}")
            results.append(None)
    return results
```

### 5.3 è½¬æ¢ç¼“å­˜ / Transformation Caching

```python
from functools import lru_cache
import hashlib
import pickle

class CachedTransformer(ModelTransformer):
    """å¸¦ç¼“å­˜çš„è½¬æ¢å™¨"""

    def __init__(self, base_transformer: ModelTransformer, cache_size: int = 128):
        super().__init__()
        self.base_transformer = base_transformer
        self.cache_size = cache_size
        self._cache = {}

    def _model_hash(self, model: Any) -> str:
        """è®¡ç®—æ¨¡å‹å“ˆå¸Œå€¼"""
        model_bytes = pickle.dumps(model)
        return hashlib.md5(model_bytes).hexdigest()

    def transform(self, source_model: T) -> U:
        """è½¬æ¢ï¼ˆå¸¦ç¼“å­˜ï¼‰"""
        model_hash = self._model_hash(source_model)

        if model_hash in self._cache:
            logger.info("Using cached transformation result")
            return self._cache[model_hash]

        result = self.base_transformer.transform(source_model)

        # ç¼“å­˜ç»“æœ
        if len(self._cache) >= self.cache_size:
            # ç§»é™¤æœ€æ—§çš„ç¼“å­˜é¡¹
            oldest_key = next(iter(self._cache))
            del self._cache[oldest_key]

        self._cache[model_hash] = result
        return result
```

---

## 6. å·¥å…·é›†æˆ / Tool Integration

### 6.1 ä¸CPN Toolsé›†æˆ / Integration with CPN Tools

```python
class CPNToolsIntegration:
    """CPN Toolsé›†æˆ"""

    def export_to_cpn(self, petri_net: PetriNet, filename: str):
        """å¯¼å‡ºPetriç½‘åˆ°CPN Toolsæ ¼å¼"""
        # ç”ŸæˆCPN Tools XMLæ ¼å¼
        cpn_xml = self._generate_cpn_xml(petri_net)
        with open(filename, 'w') as f:
            f.write(cpn_xml)

    def import_from_cpn(self, filename: str) -> PetriNet:
        """ä»CPN Toolsæ ¼å¼å¯¼å…¥Petriç½‘"""
        # è§£æCPN Tools XMLæ ¼å¼
        with open(filename, 'r') as f:
            cpn_xml = f.read()
        return self._parse_cpn_xml(cpn_xml)
```

### 6.2 ä¸ProMé›†æˆ / Integration with ProM

```python
class ProMIntegration:
    """ProMå·¥å…·é›†æˆ"""

    def export_to_prom(self, workflow_net: WorkflowNet, filename: str):
        """å¯¼å‡ºå·¥ä½œæµç½‘åˆ°ProMæ ¼å¼"""
        # ç”ŸæˆProM PNMLæ ¼å¼
        pnml_xml = self._generate_pnml(workflow_net)
        with open(filename, 'w') as f:
            f.write(pnml_xml)
```

### 6.3 ä¸NetworkXé›†æˆ / Integration with NetworkX

```python
import networkx as nx

class NetworkXIntegration:
    """NetworkXé›†æˆ"""

    def petri_net_to_nx_graph(self, petri_net: PetriNet) -> nx.DiGraph:
        """å°†Petriç½‘è½¬æ¢ä¸ºNetworkXå›¾"""
        G = nx.DiGraph()

        # æ·»åŠ èŠ‚ç‚¹
        for place in petri_net.places:
            G.add_node(place, type='place')
        for transition in petri_net.transitions:
            G.add_node(transition, type='transition')

        # æ·»åŠ è¾¹
        for source, target in petri_net.flow_relation:
            G.add_edge(source, target)

        return G

    def visualize_petri_net(self, petri_net: PetriNet, filename: str = None):
        """å¯è§†åŒ–Petriç½‘"""
        G = self.petri_net_to_nx_graph(petri_net)

        # ä½¿ç”¨matplotlibç»˜åˆ¶
        pos = nx.spring_layout(G)
        nx.draw(G, pos, with_labels=True, node_color='lightblue',
                node_size=500, font_size=10)

        if filename:
            plt.savefig(filename)
        else:
            plt.show()
```

---

## 7. æµ‹è¯•æ¡†æ¶ / Testing Framework

### 7.1 å•å…ƒæµ‹è¯• / Unit Tests

```python
import unittest

class TestFSMToPetriNetTransformer(unittest.TestCase):
    """FSMåˆ°Petriç½‘è½¬æ¢å™¨æµ‹è¯•"""

    def setUp(self):
        self.transformer = FSMToPetriNetTransformer()

    def test_simple_fsm(self):
        """æµ‹è¯•ç®€å•FSMè½¬æ¢"""
        fsm = FiniteStateMachine(
            states={'q0', 'q1'},
            alphabet={'a'},
            transitions={('q0', 'a'): 'q1'},
            initial_state='q0',
            accepting_states={'q1'}
        )

        petri_net = self.transformer.transform(fsm)

        # éªŒè¯ç»“æœ
        self.assertEqual(len(petri_net.places), 2)
        self.assertEqual(len(petri_net.transitions), 1)
        self.assertEqual(petri_net.initial_marking['p_q0'], 1)

    def test_equivalence_verification(self):
        """æµ‹è¯•ç­‰ä»·æ€§éªŒè¯"""
        fsm = create_test_fsm()
        petri_net = self.transformer.transform(fsm)

        is_equivalent = self.transformer.verify_equivalence(fsm, petri_net)
        self.assertTrue(is_equivalent)
```

### 7.2 æ€§èƒ½æµ‹è¯• / Performance Tests

```python
import time

class PerformanceTest:
    """æ€§èƒ½æµ‹è¯•"""

    def test_large_model_transformation(self):
        """æµ‹è¯•å¤§è§„æ¨¡æ¨¡å‹è½¬æ¢"""
        # åˆ›å»ºå¤§è§„æ¨¡FSMï¼ˆ1000çŠ¶æ€ï¼‰
        large_fsm = create_large_fsm(1000)

        transformer = FSMToPetriNetTransformer()

        start_time = time.time()
        petri_net = transformer.transform(large_fsm)
        elapsed_time = time.time() - start_time

        print(f"Transformation time: {elapsed_time:.2f}s")
        print(f"Generated places: {len(petri_net.places)}")
        print(f"Generated transitions: {len(petri_net.transitions)}")

        # éªŒè¯æ€§èƒ½è¦æ±‚
        self.assertLess(elapsed_time, 1.0)  # åº”è¯¥åœ¨1ç§’å†…å®Œæˆ
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
**çŠ¶æ€**: ğŸš€ æŒç»­æ›´æ–°ä¸­
