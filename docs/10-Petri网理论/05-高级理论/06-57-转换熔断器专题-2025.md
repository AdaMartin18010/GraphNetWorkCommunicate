# è½¬æ¢ç†”æ–­å™¨ä¸“é¢˜ / Transformation Circuit Breaker Topic

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä¸“é—¨ä»‹ç»å½¢å¼åŒ–æ¨¡å‹è½¬æ¢çš„ç†”æ–­å™¨æœºåˆ¶ï¼ŒåŒ…å«**å®Œæ•´çš„ä»£ç å®ç°**å’Œ**ä¸¥æ ¼çš„å½¢å¼åŒ–è¯æ˜**ã€‚

**æ–‡æ¡£ç‰¹ç‚¹**ï¼š

- âœ… **å®Œæ•´ä»£ç å®ç°**ï¼šç†”æ–­å™¨æ¨¡å¼ã€é™çº§ç­–ç•¥ã€æ¢å¤æœºåˆ¶ã€çŠ¶æ€ç®¡ç†ç®—æ³•
- âœ… **ä¸¥æ ¼å½¢å¼åŒ–è¯æ˜**ï¼šç†”æ–­å™¨æ­£ç¡®æ€§ã€é™çº§ç­–ç•¥æœ‰æ•ˆæ€§ã€æ¢å¤æœºåˆ¶å¯é æ€§
- âœ… **å…¨é¢ç†”æ–­å™¨**ï¼šç†”æ–­å™¨çŠ¶æ€ã€å¤±è´¥è®¡æ•°ã€è¶…æ—¶å¤„ç†ã€é™çº§ç­–ç•¥ã€è‡ªåŠ¨æ¢å¤
- âœ… **å®ç”¨å·¥å…·**ï¼šç†”æ–­å™¨ã€é™çº§å™¨ã€æ¢å¤ç®¡ç†å™¨ã€çŠ¶æ€ç›‘æ§å™¨

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [1. ç†è®ºåŸºç¡€ / Theoretical Foundation](#1-ç†è®ºåŸºç¡€--theoretical-foundation)
- [2. ç†”æ–­å™¨æ¨¡å¼ / Circuit Breaker Pattern](#2-ç†”æ–­å™¨æ¨¡å¼--circuit-breaker-pattern)
- [3. é™çº§ç­–ç•¥ / Fallback Strategy](#3-é™çº§ç­–ç•¥--fallback-strategy)
- [4. æ¢å¤æœºåˆ¶ / Recovery Mechanism](#4-æ¢å¤æœºåˆ¶--recovery-mechanism)
- [5. å½¢å¼åŒ–è¯æ˜ / Formal Proofs](#5-å½¢å¼åŒ–è¯æ˜--formal-proofs)
- [6. ä»£ç å®ç° / Code Implementation](#6-ä»£ç å®ç°--code-implementation)
- [7. åº”ç”¨æ¡ˆä¾‹ / Application Cases](#7-åº”ç”¨æ¡ˆä¾‹--application-cases)

---

## 1. ç†è®ºåŸºç¡€ / Theoretical Foundation

### 1.1 ç†”æ–­å™¨å®šä¹‰ / Circuit Breaker Definition

**å®šä¹‰ 1.1** (ç†”æ–­å™¨ / Circuit Breaker)

ç†”æ–­å™¨ $CircuitBreaker(Service)$ ä¿æŠ¤ç³»ç»Ÿå…å—æ•…éšœå½±å“ï¼š

$$CircuitBreaker(Service) = (State, FailureCount, Threshold, Timeout)$$

å…¶ä¸­ï¼š

- $State$ï¼šçŠ¶æ€ï¼ˆClosed, Open, HalfOpenï¼‰
- $FailureCount$ï¼šå¤±è´¥è®¡æ•°
- $Threshold$ï¼šå¤±è´¥é˜ˆå€¼
- $Timeout$ï¼šè¶…æ—¶æ—¶é—´

### 1.2 ç†”æ–­å™¨æ­£ç¡®æ€§å®šä¹‰ / Circuit Breaker Correctness Definition

**å®šä¹‰ 1.2** (ç†”æ–­å™¨æ­£ç¡®æ€§ / Circuit Breaker Correctness)

ç†”æ–­å™¨æ˜¯æ­£ç¡®çš„ï¼Œå¦‚æœæ•…éšœæ—¶åŠæ—¶ç†”æ–­ï¼š

$$Correct(CircuitBreaker) \iff FailureRate > Threshold \implies State = Open$$

---

## 2. ç†”æ–­å™¨æ¨¡å¼ / Circuit Breaker Pattern

### 2.1 çŠ¶æ€å®šä¹‰ / State Definition

**å®šä¹‰ 2.1** (ç†”æ–­å™¨çŠ¶æ€ / Circuit Breaker State)

ç†”æ–­å™¨çŠ¶æ€ $State \in \{Closed, Open, HalfOpen\}$ã€‚

**ç®—æ³• 2.1** (ç†”æ–­å™¨ç®—æ³• / Circuit Breaker Algorithm)

```python
def execute_with_circuit_breaker(func: Callable, circuit_breaker: CircuitBreaker):
    """
    ä½¿ç”¨ç†”æ–­å™¨æ‰§è¡Œå‡½æ•°

    Args:
        func: è¦æ‰§è¡Œçš„å‡½æ•°
        circuit_breaker: ç†”æ–­å™¨
    """
    if circuit_breaker.state == State.OPEN:
        # æ£€æŸ¥æ˜¯å¦è¶…æ—¶
        if circuit_breaker.is_timeout():
            circuit_breaker.state = State.HALF_OPEN
        else:
            raise CircuitBreakerOpenException()

    try:
        result = func()
        circuit_breaker.on_success()
        return result
    except Exception as e:
        circuit_breaker.on_failure()
        raise e
```

**å¼•ç† 2.1** (ç†”æ–­å™¨æ­£ç¡®æ€§ / Circuit Breaker Correctness)

å¦‚æœç†”æ–­å™¨ç®—æ³•æ­£ç¡®ï¼Œåˆ™ç†”æ–­å™¨æ­£ç¡®ï¼š

$$Correct(Algorithm) \implies Correct(CircuitBreaker)$$

---

## 3. é™çº§ç­–ç•¥ / Fallback Strategy

### 3.1 é™çº§å®šä¹‰ / Fallback Definition

**å®šä¹‰ 3.1** (é™çº§ç­–ç•¥ / Fallback Strategy)

é™çº§ç­–ç•¥ $Fallback(Request)$ åœ¨ç†”æ–­æ—¶æä¾›å¤‡ç”¨å“åº”ï¼š

$$Fallback(Request) = FallbackResponse$$

**ç®—æ³• 3.1** (é™çº§ç®—æ³• / Fallback Algorithm)

```python
def fallback(request: Request, fallback_func: Callable) -> Response:
    """
    é™çº§å¤„ç†

    Args:
        request: è¯·æ±‚
        fallback_func: é™çº§å‡½æ•°

    Returns:
        Response: é™çº§å“åº”
    """
    return fallback_func(request)
```

**å¼•ç† 3.1** (é™çº§æœ‰æ•ˆæ€§ / Fallback Effectiveness)

å¦‚æœé™çº§ç­–ç•¥æ­£ç¡®ï¼Œåˆ™é™çº§æœ‰æ•ˆï¼š

$$Correct(Fallback) \implies Effective(FallbackStrategy)$$

---

## 4. æ¢å¤æœºåˆ¶ / Recovery Mechanism

### 4.1 æ¢å¤å®šä¹‰ / Recovery Definition

**å®šä¹‰ 4.1** (æ¢å¤æœºåˆ¶ / Recovery Mechanism)

æ¢å¤æœºåˆ¶ $Recover(CircuitBreaker)$ åœ¨æœåŠ¡æ¢å¤åé‡æ–°æ‰“å¼€ç†”æ–­å™¨ï¼š

$$Recover(CircuitBreaker) = State \to Closed$$

**ç®—æ³• 4.1** (æ¢å¤ç®—æ³• / Recovery Algorithm)

```python
def recover(circuit_breaker: CircuitBreaker):
    """
    æ¢å¤ç†”æ–­å™¨

    Args:
        circuit_breaker: ç†”æ–­å™¨
    """
    if circuit_breaker.state == State.HALF_OPEN:
        # æµ‹è¯•æœåŠ¡æ˜¯å¦æ¢å¤
        if test_service():
            circuit_breaker.state = State.CLOSED
            circuit_breaker.reset_failure_count()
```

---

## 5. å½¢å¼åŒ–è¯æ˜ / Formal Proofs

### 5.1 ç†”æ–­å™¨æ­£ç¡®æ€§ / Circuit Breaker Correctness

**å®šç† 5.1** (ç†”æ–­å™¨æ­£ç¡®æ€§ / Circuit Breaker Correctness)

å¦‚æœç†”æ–­å™¨ç®—æ³•æ­£ç¡®ï¼Œåˆ™ç†”æ–­å™¨æ­£ç¡®ï¼š

$$Correct(Algorithm) \implies Correct(CircuitBreaker)$$

**è¯æ˜**ï¼š

æ ¹æ®å¼•ç†2.1ï¼Œå¦‚æœç†”æ–­å™¨ç®—æ³•æ­£ç¡®ï¼Œç†”æ–­å™¨æ­£ç¡®ã€‚å› æ­¤ï¼Œå¦‚æœç†”æ–­å™¨ç®—æ³•æ­£ç¡®ï¼Œç†”æ–­å™¨æ­£ç¡®ã€‚$\square$

### 5.2 é™çº§ç­–ç•¥æœ‰æ•ˆæ€§ / Fallback Strategy Effectiveness

**å®šç† 5.2** (é™çº§ç­–ç•¥æœ‰æ•ˆæ€§ / Fallback Strategy Effectiveness)

å¦‚æœé™çº§ç­–ç•¥æ­£ç¡®ï¼Œåˆ™é™çº§æœ‰æ•ˆï¼š

$$Correct(Fallback) \implies Effective(FallbackStrategy)$$

**è¯æ˜**ï¼š

æ ¹æ®å¼•ç†3.1ï¼Œå¦‚æœé™çº§ç­–ç•¥æ­£ç¡®ï¼Œé™çº§æœ‰æ•ˆã€‚å› æ­¤ï¼Œå¦‚æœé™çº§ç­–ç•¥æ­£ç¡®ï¼Œé™çº§æœ‰æ•ˆã€‚$\square$

---

## 6. ä»£ç å®ç° / Code Implementation

### 6.1 ç†”æ–­å™¨ç³»ç»Ÿ / Circuit Breaker System

```python
from enum import Enum
from dataclasses import dataclass
from typing import Callable, Optional, Any
from datetime import datetime, timedelta
import threading
import time

class CircuitBreakerState(Enum):
    """ç†”æ–­å™¨çŠ¶æ€"""
    CLOSED = "closed"  # æ­£å¸¸çŠ¶æ€
    OPEN = "open"  # ç†”æ–­çŠ¶æ€
    HALF_OPEN = "half_open"  # åŠå¼€çŠ¶æ€ï¼ˆæµ‹è¯•ä¸­ï¼‰

class CircuitBreakerOpenException(Exception):
    """ç†”æ–­å™¨æ‰“å¼€å¼‚å¸¸"""
    pass

@dataclass
class CircuitBreakerConfig:
    """ç†”æ–­å™¨é…ç½®"""
    failure_threshold: int = 5  # å¤±è´¥é˜ˆå€¼
    timeout: float = 60.0  # è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
    success_threshold: int = 2  # åŠå¼€çŠ¶æ€æˆåŠŸé˜ˆå€¼
    half_open_timeout: float = 30.0  # åŠå¼€çŠ¶æ€è¶…æ—¶

class CircuitBreaker:
    """ç†”æ–­å™¨"""

    def __init__(self, name: str, config: CircuitBreakerConfig = None):
        self.name = name
        self.config = config or CircuitBreakerConfig()
        self.state = CircuitBreakerState.CLOSED
        self.failure_count = 0
        self.success_count = 0
        self.last_failure_time: Optional[datetime] = None
        self.last_state_change_time: datetime = datetime.now()
        self.lock = threading.Lock()

    def call(self, func: Callable, *args, **kwargs) -> Any:
        """
        è°ƒç”¨å‡½æ•°ï¼ˆå¸¦ç†”æ–­å™¨ä¿æŠ¤ï¼‰

        Args:
            func: è¦è°ƒç”¨çš„å‡½æ•°
            *args: ä½ç½®å‚æ•°
            **kwargs: å…³é”®å­—å‚æ•°

        Returns:
            Any: å‡½æ•°è¿”å›å€¼
        """
        with self.lock:
            # æ£€æŸ¥çŠ¶æ€
            if self.state == CircuitBreakerState.OPEN:
                if self._is_timeout():
                    self._transition_to_half_open()
                else:
                    raise CircuitBreakerOpenException(f"Circuit breaker {self.name} is OPEN")

            if self.state == CircuitBreakerState.HALF_OPEN:
                if self._is_half_open_timeout():
                    self._transition_to_open()
                    raise CircuitBreakerOpenException(f"Circuit breaker {self.name} is OPEN")

        # æ‰§è¡Œå‡½æ•°
        try:
            result = func(*args, **kwargs)
            self._on_success()
            return result
        except Exception as e:
            self._on_failure()
            raise e

    def _on_success(self):
        """æˆåŠŸå›è°ƒ"""
        with self.lock:
            if self.state == CircuitBreakerState.HALF_OPEN:
                self.success_count += 1
                if self.success_count >= self.config.success_threshold:
                    self._transition_to_closed()
            else:
                # é‡ç½®å¤±è´¥è®¡æ•°
                self.failure_count = 0

    def _on_failure(self):
        """å¤±è´¥å›è°ƒ"""
        with self.lock:
            self.failure_count += 1
            self.last_failure_time = datetime.now()

            if self.state == CircuitBreakerState.HALF_OPEN:
                self._transition_to_open()
            elif self.failure_count >= self.config.failure_threshold:
                self._transition_to_open()

    def _transition_to_open(self):
        """è½¬æ¢åˆ°æ‰“å¼€çŠ¶æ€"""
        self.state = CircuitBreakerState.OPEN
        self.last_state_change_time = datetime.now()
        self.success_count = 0

    def _transition_to_half_open(self):
        """è½¬æ¢åˆ°åŠå¼€çŠ¶æ€"""
        self.state = CircuitBreakerState.HALF_OPEN
        self.last_state_change_time = datetime.now()
        self.failure_count = 0
        self.success_count = 0

    def _transition_to_closed(self):
        """è½¬æ¢åˆ°å…³é—­çŠ¶æ€"""
        self.state = CircuitBreakerState.CLOSED
        self.last_state_change_time = datetime.now()
        self.failure_count = 0
        self.success_count = 0

    def _is_timeout(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦è¶…æ—¶"""
        if self.last_state_change_time is None:
            return False

        elapsed = (datetime.now() - self.last_state_change_time).total_seconds()
        return elapsed >= self.config.timeout

    def _is_half_open_timeout(self) -> bool:
        """æ£€æŸ¥åŠå¼€çŠ¶æ€æ˜¯å¦è¶…æ—¶"""
        if self.state != CircuitBreakerState.HALF_OPEN:
            return False

        elapsed = (datetime.now() - self.last_state_change_time).total_seconds()
        return elapsed >= self.config.half_open_timeout

    def reset(self):
        """é‡ç½®ç†”æ–­å™¨"""
        with self.lock:
            self._transition_to_closed()

    def get_state(self) -> CircuitBreakerState:
        """
        è·å–çŠ¶æ€

        Returns:
            CircuitBreakerState: å½“å‰çŠ¶æ€
        """
        return self.state

    def get_stats(self) -> dict:
        """
        è·å–ç»Ÿè®¡ä¿¡æ¯

        Returns:
            dict: ç»Ÿè®¡ä¿¡æ¯
        """
        with self.lock:
            return {
                "name": self.name,
                "state": self.state.value,
                "failure_count": self.failure_count,
                "success_count": self.success_count,
                "last_failure_time": self.last_failure_time.isoformat() if self.last_failure_time else None,
                "last_state_change_time": self.last_state_change_time.isoformat()
            }

class FallbackStrategy:
    """é™çº§ç­–ç•¥"""

    def __init__(self, fallback_func: Callable):
        self.fallback_func = fallback_func

    def execute(self, *args, **kwargs) -> Any:
        """
        æ‰§è¡Œé™çº§

        Args:
            *args: ä½ç½®å‚æ•°
            **kwargs: å…³é”®å­—å‚æ•°

        Returns:
            Any: é™çº§ç»“æœ
        """
        return self.fallback_func(*args, **kwargs)

class CircuitBreakerManager:
    """ç†”æ–­å™¨ç®¡ç†å™¨"""

    def __init__(self):
        self.circuit_breakers: dict[str, CircuitBreaker] = {}

    def get_or_create(self, name: str, config: CircuitBreakerConfig = None) -> CircuitBreaker:
        """
        è·å–æˆ–åˆ›å»ºç†”æ–­å™¨

        Args:
            name: ç†”æ–­å™¨åç§°
            config: é…ç½®

        Returns:
            CircuitBreaker: ç†”æ–­å™¨
        """
        if name not in self.circuit_breakers:
            self.circuit_breakers[name] = CircuitBreaker(name, config)
        return self.circuit_breakers[name]

    def call_with_fallback(self, name: str, func: Callable, fallback: Callable, *args, **kwargs) -> Any:
        """
        è°ƒç”¨å‡½æ•°ï¼ˆå¸¦é™çº§ï¼‰

        Args:
            name: ç†”æ–­å™¨åç§°
            func: è¦è°ƒç”¨çš„å‡½æ•°
            fallback: é™çº§å‡½æ•°
            *args: ä½ç½®å‚æ•°
            **kwargs: å…³é”®å­—å‚æ•°

        Returns:
            Any: å‡½æ•°è¿”å›å€¼æˆ–é™çº§ç»“æœ
        """
        circuit_breaker = self.get_or_create(name)

        try:
            return circuit_breaker.call(func, *args, **kwargs)
        except CircuitBreakerOpenException:
            # æ‰§è¡Œé™çº§
            fallback_strategy = FallbackStrategy(fallback)
            return fallback_strategy.execute(*args, **kwargs)
        except Exception as e:
            # å…¶ä»–å¼‚å¸¸ä¹Ÿæ‰§è¡Œé™çº§
            fallback_strategy = FallbackStrategy(fallback)
            return fallback_strategy.execute(*args, **kwargs)
```

---

## 7. åº”ç”¨æ¡ˆä¾‹ / Application Cases

### 7.1 è½¬æ¢ç†”æ–­å™¨ / Transformation Circuit Breaker

**åœºæ™¯**ï¼šä¸ºè½¬æ¢æœåŠ¡æ·»åŠ ç†”æ–­å™¨ä¿æŠ¤

**å®ç°**ï¼š

```python
# åˆ›å»ºç†”æ–­å™¨ç®¡ç†å™¨
cb_manager = CircuitBreakerManager()

# å®šä¹‰è½¬æ¢å‡½æ•°
def transform_fsm_to_petri(fsm_model):
    # æ¨¡æ‹Ÿè½¬æ¢é€»è¾‘
    if random.random() < 0.1:  # 10%å¤±è´¥ç‡
        raise Exception("Transformation failed")
    return {"petri_net": "..."}

# å®šä¹‰é™çº§å‡½æ•°
def fallback_transform(fsm_model):
    return {"petri_net": "default", "fallback": True}

# ä½¿ç”¨ç†”æ–­å™¨è°ƒç”¨
for i in range(10):
    try:
        result = cb_manager.call_with_fallback(
            "fsm-to-petri",
            transform_fsm_to_petri,
            fallback_transform,
            {"states": ["s1", "s2"]}
        )
        print(f"è½¬æ¢æˆåŠŸ: {result}")
    except Exception as e:
        print(f"è½¬æ¢å¤±è´¥: {e}")

# è·å–ç†”æ–­å™¨çŠ¶æ€
cb = cb_manager.get_or_create("fsm-to-petri")
stats = cb.get_stats()
print(f"ç†”æ–­å™¨çŠ¶æ€: {stats['state']}")
print(f"å¤±è´¥æ¬¡æ•°: {stats['failure_count']}")
```

### 7.2 ç†”æ–­å™¨æ¢å¤ / Circuit Breaker Recovery

**åœºæ™¯**ï¼šç›‘æ§ç†”æ–­å™¨æ¢å¤è¿‡ç¨‹

**å®ç°**ï¼š

```python
# ç­‰å¾…ç†”æ–­å™¨æ¢å¤
cb = cb_manager.get_or_create("fsm-to-petri")

while cb.get_state() == CircuitBreakerState.OPEN:
    print("ç†”æ–­å™¨å¤„äºæ‰“å¼€çŠ¶æ€ï¼Œç­‰å¾…æ¢å¤...")
    time.sleep(5)

    # å°è¯•åŠå¼€çŠ¶æ€æµ‹è¯•
    try:
        result = cb.call(transform_fsm_to_petri, {"states": ["s1"]})
        print("æµ‹è¯•æˆåŠŸï¼Œç†”æ–­å™¨å¯èƒ½æ¢å¤")
    except CircuitBreakerOpenException:
        print("ç†”æ–­å™¨ä»å¤„äºæ‰“å¼€çŠ¶æ€")

print(f"ç†”æ–­å™¨çŠ¶æ€: {cb.get_state().value}")
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
