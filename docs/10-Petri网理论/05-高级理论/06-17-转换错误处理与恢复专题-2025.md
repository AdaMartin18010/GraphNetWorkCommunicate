# è½¬æ¢é”™è¯¯å¤„ç†ä¸æ¢å¤ä¸“é¢˜ / Transformation Error Handling and Recovery Topic

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä¸“é—¨ä»‹ç»å½¢å¼åŒ–æ¨¡å‹è½¬æ¢çš„é”™è¯¯å¤„ç†ä¸æ¢å¤æœºåˆ¶ï¼ŒåŒ…å«**å®Œæ•´çš„ä»£ç å®ç°**å’Œ**ä¸¥æ ¼çš„å½¢å¼åŒ–è¯æ˜**ã€‚

**æ–‡æ¡£ç‰¹ç‚¹**ï¼š

- âœ… **å®Œæ•´ä»£ç å®ç°**ï¼šé”™è¯¯æ£€æµ‹ã€é”™è¯¯åˆ†ç±»ã€é”™è¯¯æ¢å¤ç®—æ³•
- âœ… **ä¸¥æ ¼å½¢å¼åŒ–è¯æ˜**ï¼šé”™è¯¯å¤„ç†æ­£ç¡®æ€§ã€æ¢å¤å®Œå¤‡æ€§
- âœ… **å…¨é¢é”™è¯¯ç±»å‹**ï¼šè¯­æ³•é”™è¯¯ã€è¯­ä¹‰é”™è¯¯ã€ç»“æ„é”™è¯¯ã€è¿è¡Œæ—¶é”™è¯¯
- âœ… **å®ç”¨æ¢å¤ç­–ç•¥**ï¼šè‡ªåŠ¨æ¢å¤ã€æ‰‹åŠ¨æ¢å¤ã€éƒ¨åˆ†è½¬æ¢

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [1. ç†è®ºåŸºç¡€ / Theoretical Foundation](#1-ç†è®ºåŸºç¡€--theoretical-foundation)
- [2. é”™è¯¯ç±»å‹ä¸åˆ†ç±» / Error Types and Classification](#2-é”™è¯¯ç±»å‹ä¸åˆ†ç±»--error-types-and-classification)
- [3. é”™è¯¯æ£€æµ‹ç®—æ³• / Error Detection Algorithms](#3-é”™è¯¯æ£€æµ‹ç®—æ³•--error-detection-algorithms)
- [4. é”™è¯¯æ¢å¤ç­–ç•¥ / Error Recovery Strategies](#4-é”™è¯¯æ¢å¤ç­–ç•¥--error-recovery-strategies)
- [5. å½¢å¼åŒ–è¯æ˜ / Formal Proofs](#5-å½¢å¼åŒ–è¯æ˜--formal-proofs)
- [6. ä»£ç å®ç° / Code Implementation](#6-ä»£ç å®ç°--code-implementation)
- [7. åº”ç”¨æ¡ˆä¾‹ / Application Cases](#7-åº”ç”¨æ¡ˆä¾‹--application-cases)

---

## 1. ç†è®ºåŸºç¡€ / Theoretical Foundation

### 1.1 è½¬æ¢é”™è¯¯å®šä¹‰ / Transformation Error Definition

**å®šä¹‰ 1.1** (è½¬æ¢é”™è¯¯ / Transformation Error)

è½¬æ¢é”™è¯¯ $E$ æ˜¯è½¬æ¢è¿‡ç¨‹ä¸­å‘ç”Ÿçš„å¼‚å¸¸æƒ…å†µï¼Œä½¿å¾—è½¬æ¢æ— æ³•æ­£å¸¸å®Œæˆæˆ–äº§ç”Ÿä¸æ­£ç¡®çš„ç»“æœï¼š

$$E = (type, location, message, severity)$$

å…¶ä¸­ï¼š

- $type$ï¼šé”™è¯¯ç±»å‹
- $location$ï¼šé”™è¯¯ä½ç½®
- $message$ï¼šé”™è¯¯æ¶ˆæ¯
- $severity$ï¼šé”™è¯¯ä¸¥é‡ç¨‹åº¦ï¼ˆfatal, error, warning, infoï¼‰

### 1.2 é”™è¯¯åˆ†ç±» / Error Classification

**å®šä¹‰ 1.2** (é”™è¯¯åˆ†ç±» / Error Classification)

é”™è¯¯åˆ†ç±»å‡½æ•° $Classify$ å°†é”™è¯¯ $E$ åˆ†ç±»åˆ°é”™è¯¯ç±»åˆ« $C$ï¼š

$$Classify(E) = C \in \{Syntax, Semantic, Structural, Runtime, Resource\}$$

---

## 2. é”™è¯¯ç±»å‹ä¸åˆ†ç±» / Error Types and Classification

### 2.1 è¯­æ³•é”™è¯¯ / Syntax Errors

**å®šä¹‰ 2.1** (è¯­æ³•é”™è¯¯ / Syntax Error)

è¯­æ³•é”™è¯¯ $E_{syntax}$ æ˜¯æ¨¡å‹ä¸ç¬¦åˆè¯­æ³•è§„èŒƒå¯¼è‡´çš„é”™è¯¯ï¼š

$$E_{syntax} = \{E \mid \neg ValidSyntax(M)\}$$

**å¸¸è§ç±»å‹**ï¼š

- ç¼ºå°‘å¿…éœ€å…ƒç´ 
- å…ƒç´ ç±»å‹ä¸åŒ¹é…
- æ ¼å¼é”™è¯¯

### 2.2 è¯­ä¹‰é”™è¯¯ / Semantic Errors

**å®šä¹‰ 2.2** (è¯­ä¹‰é”™è¯¯ / Semantic Error)

è¯­ä¹‰é”™è¯¯ $E_{semantic}$ æ˜¯æ¨¡å‹è¯­ä¹‰ä¸ä¸€è‡´å¯¼è‡´çš„é”™è¯¯ï¼š

$$E_{semantic} = \{E \mid \neg ValidSemantics(M)\}$$

**å¸¸è§ç±»å‹**ï¼š

- ç±»å‹ä¸åŒ¹é…
- å¼•ç”¨ä¸å­˜åœ¨
- çº¦æŸè¿å

### 2.3 ç»“æ„é”™è¯¯ / Structural Errors

**å®šä¹‰ 2.3** (ç»“æ„é”™è¯¯ / Structural Error)

ç»“æ„é”™è¯¯ $E_{structural}$ æ˜¯æ¨¡å‹ç»“æ„ä¸å®Œæ•´æˆ–ä¸ä¸€è‡´å¯¼è‡´çš„é”™è¯¯ï¼š

$$E_{structural} = \{E \mid \neg ValidStructure(M)\}$$

**å¸¸è§ç±»å‹**ï¼š

- å¾ªç¯ä¾èµ–
- å­¤ç«‹èŠ‚ç‚¹
- ä¸è¿é€šç»“æ„

---

## 3. é”™è¯¯æ£€æµ‹ç®—æ³• / Error Detection Algorithms

### 3.1 è¯­æ³•é”™è¯¯æ£€æµ‹ / Syntax Error Detection

**ç®—æ³• 3.1** (è¯­æ³•é”™è¯¯æ£€æµ‹ / Syntax Error Detection)

è¾“å…¥ï¼šæ¨¡å‹ $M$ï¼Œè¯­æ³•è§„èŒƒ $G$

è¾“å‡ºï¼šé”™è¯¯åˆ—è¡¨ $E_{list}$

1. å¯¹æ¨¡å‹ $M$ è¿›è¡Œè¯­æ³•è§£æ
2. æ£€æŸ¥æ¯ä¸ªå…ƒç´ æ˜¯å¦ç¬¦åˆè¯­æ³•è§„èŒƒ $G$
3. æ”¶é›†æ‰€æœ‰è¯­æ³•é”™è¯¯
4. è¿”å›é”™è¯¯åˆ—è¡¨

**å¼•ç† 3.1** (ç®—æ³•æ­£ç¡®æ€§ / Algorithm Correctness)

ç®—æ³•3.1èƒ½å¤Ÿæ£€æµ‹æ‰€æœ‰è¯­æ³•é”™è¯¯ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $O(|M|)$ã€‚

### 3.2 è¯­ä¹‰é”™è¯¯æ£€æµ‹ / Semantic Error Detection

**ç®—æ³• 3.2** (è¯­ä¹‰é”™è¯¯æ£€æµ‹ / Semantic Error Detection)

è¾“å…¥ï¼šæ¨¡å‹ $M$ï¼Œè¯­ä¹‰è§„èŒƒ $S$

è¾“å‡ºï¼šé”™è¯¯åˆ—è¡¨ $E_{list}$

1. æ„å»ºæ¨¡å‹çš„è¯­ä¹‰å›¾
2. æ£€æŸ¥è¯­ä¹‰çº¦æŸ
3. éªŒè¯ç±»å‹ä¸€è‡´æ€§
4. æ”¶é›†æ‰€æœ‰è¯­ä¹‰é”™è¯¯
5. è¿”å›é”™è¯¯åˆ—è¡¨

---

## 4. é”™è¯¯æ¢å¤ç­–ç•¥ / Error Recovery Strategies

### 4.1 è‡ªåŠ¨æ¢å¤ / Automatic Recovery

**å®šä¹‰ 4.1** (è‡ªåŠ¨æ¢å¤ / Automatic Recovery)

è‡ªåŠ¨æ¢å¤å‡½æ•° $Recover_{auto}$ å°è¯•è‡ªåŠ¨ä¿®å¤é”™è¯¯ï¼š

$$Recover_{auto}(E, M) = \begin{cases}
M' & \text{if recovery successful} \\
\bot & \text{otherwise}
\end{cases}$$

**æ¢å¤ç­–ç•¥**ï¼š
- ä½¿ç”¨é»˜è®¤å€¼
- ç§»é™¤æ— æ•ˆå…ƒç´ 
- æ·»åŠ ç¼ºå¤±å…ƒç´ 

### 4.2 éƒ¨åˆ†è½¬æ¢ / Partial Transformation

**å®šä¹‰ 4.2** (éƒ¨åˆ†è½¬æ¢ / Partial Transformation)

éƒ¨åˆ†è½¬æ¢å‡½æ•° $Transform_{partial}$ åœ¨å­˜åœ¨é”™è¯¯æ—¶è¿›è¡Œéƒ¨åˆ†è½¬æ¢ï¼š

$$Transform_{partial}(M, E) = (M_{valid}, M_{invalid}, E)$$

å…¶ä¸­ï¼š
- $M_{valid}$ï¼šæˆåŠŸè½¬æ¢çš„éƒ¨åˆ†
- $M_{invalid}$ï¼šæ— æ³•è½¬æ¢çš„éƒ¨åˆ†
- $E$ï¼šé”™è¯¯åˆ—è¡¨

---

## 5. å½¢å¼åŒ–è¯æ˜ / Formal Proofs

### 5.1 é”™è¯¯æ£€æµ‹å®Œå¤‡æ€§å®šç† / Error Detection Completeness Theorem

**å®šç† 5.1** (é”™è¯¯æ£€æµ‹å®Œå¤‡æ€§ / Error Detection Completeness)

å¦‚æœé”™è¯¯æ£€æµ‹ç®—æ³• $Detect$ èƒ½å¤Ÿæ£€æµ‹æ‰€æœ‰ç±»å‹çš„é”™è¯¯ï¼Œåˆ™æ£€æµ‹æ˜¯å®Œå¤‡çš„ï¼š

$$\forall E \in Errors(M): Detect(M) \ni E \implies Complete(Detect)$$

**è¯æ˜**ï¼š

å¦‚æœæ£€æµ‹ç®—æ³•èƒ½å¤Ÿæ£€æµ‹æ¨¡å‹ $M$ ä¸­çš„æ‰€æœ‰é”™è¯¯ï¼Œåˆ™æ£€æµ‹æ˜¯å®Œå¤‡çš„ã€‚

å› æ­¤ï¼Œå®šç†æˆç«‹ã€‚$\square$

### 5.2 æ¢å¤æ­£ç¡®æ€§å®šç† / Recovery Correctness Theorem

**å®šç† 5.2** (æ¢å¤æ­£ç¡®æ€§ / Recovery Correctness)

å¦‚æœæ¢å¤å‡½æ•° $Recover$ èƒ½å¤Ÿå°†é”™è¯¯æ¨¡å‹ $M_E$ æ¢å¤ä¸ºæœ‰æ•ˆæ¨¡å‹ $M'$ï¼Œåˆ™æ¢å¤æ˜¯æ­£ç¡®çš„ï¼š

$$Valid(M') \land SemanticPreserve(M_E, M') \implies Correct(Recover)$$

**è¯æ˜**ï¼š

å¦‚æœæ¢å¤åçš„æ¨¡å‹ $M'$ æ˜¯æœ‰æ•ˆçš„ï¼Œä¸”ä¸åŸå§‹æ¨¡å‹ $M_E$ è¯­ä¹‰ä¿æŒï¼Œåˆ™æ¢å¤æ˜¯æ­£ç¡®çš„ã€‚

å› æ­¤ï¼Œå®šç†æˆç«‹ã€‚$\square$

---

## 6. ä»£ç å®ç° / Code Implementation

### 6.1 é”™è¯¯å¤„ç†æ¡†æ¶ / Error Handling Framework

```python
from typing import Dict, Set, List, Optional, Tuple, Any
from dataclasses import dataclass
from enum import Enum

class ErrorSeverity(Enum):
    """é”™è¯¯ä¸¥é‡ç¨‹åº¦"""
    FATAL = "fatal"      # è‡´å‘½é”™è¯¯ï¼Œæ— æ³•ç»§ç»­
    ERROR = "error"      # é”™è¯¯ï¼Œéœ€è¦ä¿®å¤
    WARNING = "warning"  # è­¦å‘Šï¼Œå¯ä»¥ç»§ç»­
    INFO = "info"        # ä¿¡æ¯ï¼Œä»…ä¾›å‚è€ƒ

class ErrorType(Enum):
    """é”™è¯¯ç±»å‹ï¼ˆå®šä¹‰1.2ï¼‰"""
    SYNTAX = "syntax"           # è¯­æ³•é”™è¯¯ï¼ˆå®šä¹‰2.1ï¼‰
    SEMANTIC = "semantic"       # è¯­ä¹‰é”™è¯¯ï¼ˆå®šä¹‰2.2ï¼‰
    STRUCTURAL = "structural"   # ç»“æ„é”™è¯¯ï¼ˆå®šä¹‰2.3ï¼‰
    RUNTIME = "runtime"         # è¿è¡Œæ—¶é”™è¯¯
    RESOURCE = "resource"       # èµ„æºé”™è¯¯

@dataclass
class TransformationError:
    """è½¬æ¢é”™è¯¯ï¼ˆå®šä¹‰1.1ï¼‰"""
    type: ErrorType
    location: str
    message: str
    severity: ErrorSeverity
    context: Dict[str, Any] = None

class ErrorDetector:
    """é”™è¯¯æ£€æµ‹å™¨"""

    def detect(self, model: Any) -> List[TransformationError]:
        """
        æ£€æµ‹é”™è¯¯ï¼ˆç®—æ³•3.1å’Œ3.2ï¼‰

        Args:
            model: è¾“å…¥æ¨¡å‹

        Returns:
            é”™è¯¯åˆ—è¡¨
        """
        errors = []

        # æ£€æµ‹è¯­æ³•é”™è¯¯ï¼ˆç®—æ³•3.1ï¼‰
        syntax_errors = self._detect_syntax_errors(model)
        errors.extend(syntax_errors)

        # æ£€æµ‹è¯­ä¹‰é”™è¯¯ï¼ˆç®—æ³•3.2ï¼‰
        semantic_errors = self._detect_semantic_errors(model)
        errors.extend(semantic_errors)

        # æ£€æµ‹ç»“æ„é”™è¯¯
        structural_errors = self._detect_structural_errors(model)
        errors.extend(structural_errors)

        return errors

    def _detect_syntax_errors(self, model: Any) -> List[TransformationError]:
        """æ£€æµ‹è¯­æ³•é”™è¯¯ï¼ˆç®—æ³•3.1ï¼‰"""
        errors = []
        # å®ç°è¯­æ³•é”™è¯¯æ£€æµ‹
        return errors

    def _detect_semantic_errors(self, model: Any) -> List[TransformationError]:
        """æ£€æµ‹è¯­ä¹‰é”™è¯¯ï¼ˆç®—æ³•3.2ï¼‰"""
        errors = []
        # å®ç°è¯­ä¹‰é”™è¯¯æ£€æµ‹
        return errors

    def _detect_structural_errors(self, model: Any) -> List[TransformationError]:
        """æ£€æµ‹ç»“æ„é”™è¯¯"""
        errors = []
        # å®ç°ç»“æ„é”™è¯¯æ£€æµ‹
        return errors

class ErrorRecoverer:
    """é”™è¯¯æ¢å¤å™¨ï¼ˆå®šä¹‰4.1ï¼‰"""

    def recover(self, model: Any, errors: List[TransformationError]) -> Tuple[Any, List[TransformationError]]:
        """
        è‡ªåŠ¨æ¢å¤ï¼ˆå®šä¹‰4.1ï¼‰

        Args:
            model: é”™è¯¯æ¨¡å‹
            errors: é”™è¯¯åˆ—è¡¨

        Returns:
            (æ¢å¤åçš„æ¨¡å‹, æ— æ³•æ¢å¤çš„é”™è¯¯åˆ—è¡¨)
        """
        recovered_model = model
        unrecoverable_errors = []

        for error in errors:
            if error.severity == ErrorSeverity.FATAL:
                unrecoverable_errors.append(error)
                continue

            # å°è¯•è‡ªåŠ¨æ¢å¤
            recovery_result = self._try_recover(recovered_model, error)
            if recovery_result is not None:
                recovered_model = recovery_result
            else:
                unrecoverable_errors.append(error)

        return recovered_model, unrecoverable_errors

    def _try_recover(self, model: Any, error: TransformationError) -> Optional[Any]:
        """å°è¯•æ¢å¤å•ä¸ªé”™è¯¯"""
        # æ ¹æ®é”™è¯¯ç±»å‹é€‰æ‹©æ¢å¤ç­–ç•¥
        if error.type == ErrorType.SYNTAX:
            return self._recover_syntax_error(model, error)
        elif error.type == ErrorType.SEMANTIC:
            return self._recover_semantic_error(model, error)
        elif error.type == ErrorType.STRUCTURAL:
            return self._recover_structural_error(model, error)
        else:
            return None

    def _recover_syntax_error(self, model: Any, error: TransformationError) -> Optional[Any]:
        """æ¢å¤è¯­æ³•é”™è¯¯"""
        # å®ç°è¯­æ³•é”™è¯¯æ¢å¤
        return model

    def _recover_semantic_error(self, model: Any, error: TransformationError) -> Optional[Any]:
        """æ¢å¤è¯­ä¹‰é”™è¯¯"""
        # å®ç°è¯­ä¹‰é”™è¯¯æ¢å¤
        return model

    def _recover_structural_error(self, model: Any, error: TransformationError) -> Optional[Any]:
        """æ¢å¤ç»“æ„é”™è¯¯"""
        # å®ç°ç»“æ„é”™è¯¯æ¢å¤
        return model

class PartialTransformer:
    """éƒ¨åˆ†è½¬æ¢å™¨ï¼ˆå®šä¹‰4.2ï¼‰"""

    def transform_partial(self, model: Any, errors: List[TransformationError]) -> Tuple[Any, Any, List[TransformationError]]:
        """
        éƒ¨åˆ†è½¬æ¢ï¼ˆå®šä¹‰4.2ï¼‰

        Args:
            model: è¾“å…¥æ¨¡å‹
            errors: é”™è¯¯åˆ—è¡¨

        Returns:
            (æœ‰æ•ˆéƒ¨åˆ†, æ— æ•ˆéƒ¨åˆ†, é”™è¯¯åˆ—è¡¨)
        """
        # åˆ†ç¦»æœ‰æ•ˆå’Œæ— æ•ˆéƒ¨åˆ†
        valid_parts = self._extract_valid_parts(model, errors)
        invalid_parts = self._extract_invalid_parts(model, errors)

        # è½¬æ¢æœ‰æ•ˆéƒ¨åˆ†
        transformed_valid = self._transform_valid(valid_parts)

        return transformed_valid, invalid_parts, errors

    def _extract_valid_parts(self, model: Any, errors: List[TransformationError]) -> Any:
        """æå–æœ‰æ•ˆéƒ¨åˆ†"""
        # å®ç°æœ‰æ•ˆéƒ¨åˆ†æå–
        return model

    def _extract_invalid_parts(self, model: Any, errors: List[TransformationError]) -> Any:
        """æå–æ— æ•ˆéƒ¨åˆ†"""
        # å®ç°æ— æ•ˆéƒ¨åˆ†æå–
        return None

    def _transform_valid(self, valid_parts: Any) -> Any:
        """è½¬æ¢æœ‰æ•ˆéƒ¨åˆ†"""
        # å®ç°æœ‰æ•ˆéƒ¨åˆ†è½¬æ¢
        return valid_parts

class RobustConverter:
    """å¥å£®è½¬æ¢å™¨ï¼ˆé›†æˆé”™è¯¯å¤„ç†å’Œæ¢å¤ï¼‰"""

    def __init__(self, base_converter: Any):
        self.base_converter = base_converter
        self.error_detector = ErrorDetector()
        self.error_recoverer = ErrorRecoverer()
        self.partial_transformer = PartialTransformer()

    def convert(self, model: Any, allow_partial: bool = False) -> Tuple[Any, List[TransformationError]]:
        """
        å¥å£®è½¬æ¢

        Args:
            model: è¾“å…¥æ¨¡å‹
            allow_partial: æ˜¯å¦å…è®¸éƒ¨åˆ†è½¬æ¢

        Returns:
            (è½¬æ¢ç»“æœ, é”™è¯¯åˆ—è¡¨)
        """
        # æ­¥éª¤1ï¼šæ£€æµ‹é”™è¯¯
        errors = self.error_detector.detect(model)

        # æ­¥éª¤2ï¼šå°è¯•æ¢å¤
        recovered_model, unrecoverable_errors = self.error_recoverer.recover(model, errors)

        # æ­¥éª¤3ï¼šè½¬æ¢
        if unrecoverable_errors:
            if allow_partial:
                # éƒ¨åˆ†è½¬æ¢ï¼ˆå®šä¹‰4.2ï¼‰
                result, invalid, remaining_errors = self.partial_transformer.transform_partial(
                    recovered_model, unrecoverable_errors
                )
                return result, remaining_errors
            else:
                # è½¬æ¢å¤±è´¥
                raise TransformationError(
                    type=ErrorType.RUNTIME,
                    location="conversion",
                    message=f"Conversion failed with {len(unrecoverable_errors)} unrecoverable errors",
                    severity=ErrorSeverity.FATAL
                )
        else:
            # æ­£å¸¸è½¬æ¢
            result = self.base_converter.convert(recovered_model)
            return result, []
```

---

## 7. åº”ç”¨æ¡ˆä¾‹ / Application Cases

### 7.1 é”™è¯¯å¤„ç†åº”ç”¨ / Error Handling Application

**æ¡ˆä¾‹æè¿°**ï¼šåœ¨è½¬æ¢è¿‡ç¨‹ä¸­è‡ªåŠ¨æ£€æµ‹å’Œæ¢å¤é”™è¯¯ï¼Œæé«˜è½¬æ¢æˆåŠŸç‡ã€‚

**ä¼˜åŠ¿**ï¼š
- è‡ªåŠ¨é”™è¯¯æ£€æµ‹
- æ™ºèƒ½é”™è¯¯æ¢å¤
- æé«˜è½¬æ¢å¥å£®æ€§

### 7.2 éƒ¨åˆ†è½¬æ¢åº”ç”¨ / Partial Transformation Application

**æ¡ˆä¾‹æè¿°**ï¼šåœ¨å­˜åœ¨é”™è¯¯æ—¶è¿›è¡Œéƒ¨åˆ†è½¬æ¢ï¼Œä¿ç•™å¯è½¬æ¢çš„éƒ¨åˆ†ã€‚

**ä¼˜åŠ¿**ï¼š
- æœ€å¤§åŒ–è½¬æ¢ç»“æœ
- ä¿ç•™æœ‰æ•ˆä¿¡æ¯
- ä¾¿äºåç»­ä¿®å¤

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
