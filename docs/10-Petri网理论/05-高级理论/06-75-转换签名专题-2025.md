# è½¬æ¢ç­¾åä¸“é¢˜ / Transformation Digital Signature Topic

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä¸“é—¨ä»‹ç»å½¢å¼åŒ–æ¨¡å‹è½¬æ¢çš„æ•°å­—ç­¾åæœºåˆ¶ï¼ŒåŒ…å«**å®Œæ•´çš„ä»£ç å®ç°**å’Œ**ä¸¥æ ¼çš„å½¢å¼åŒ–è¯æ˜**ã€‚

**æ–‡æ¡£ç‰¹ç‚¹**ï¼š

- âœ… **å®Œæ•´ä»£ç å®ç°**ï¼šæ•°å­—ç­¾åã€ç­¾åéªŒè¯ã€è¯ä¹¦ç®¡ç†ã€å¯†é’¥å¯¹ç®¡ç†ç®—æ³•
- âœ… **ä¸¥æ ¼å½¢å¼åŒ–è¯æ˜**ï¼šç­¾åæ­£ç¡®æ€§ã€ç­¾åéªŒè¯å¯é æ€§ã€è¯ä¹¦ç®¡ç†å®‰å…¨æ€§
- âœ… **å…¨é¢æ•°å­—ç­¾å**ï¼šæ•°å­—ç­¾åã€ç­¾åéªŒè¯ã€è¯ä¹¦ç®¡ç†ã€å¯†é’¥å¯¹ç®¡ç†ã€ç­¾åé“¾éªŒè¯
- âœ… **å®ç”¨å·¥å…·**ï¼šç­¾åå™¨ã€éªŒè¯å™¨ã€è¯ä¹¦ç®¡ç†å™¨ã€å¯†é’¥å¯¹ç®¡ç†å™¨

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [1. ç†è®ºåŸºç¡€ / Theoretical Foundation](#1-ç†è®ºåŸºç¡€--theoretical-foundation)
- [2. æ•°å­—ç­¾å / Digital Signature](#2-æ•°å­—ç­¾å--digital-signature)
- [3. ç­¾åéªŒè¯ / Signature Verification](#3-ç­¾åéªŒè¯--signature-verification)
- [4. è¯ä¹¦ç®¡ç† / Certificate Management](#4-è¯ä¹¦ç®¡ç†--certificate-management)
- [5. å½¢å¼åŒ–è¯æ˜ / Formal Proofs](#5-å½¢å¼åŒ–è¯æ˜--formal-proofs)
- [6. ä»£ç å®ç° / Code Implementation](#6-ä»£ç å®ç°--code-implementation)
- [7. åº”ç”¨æ¡ˆä¾‹ / Application Cases](#7-åº”ç”¨æ¡ˆä¾‹--application-cases)

---

## 1. ç†è®ºåŸºç¡€ / Theoretical Foundation

### 1.1 æ•°å­—ç­¾åå®šä¹‰ / Digital Signature Definition

**å®šä¹‰ 1.1** (æ•°å­—ç­¾å / Digital Signature)

æ•°å­—ç­¾å $Sign(Data, PrivateKey)$ ä½¿ç”¨ç§é’¥ç­¾åæ•°æ®ï¼š

$$Sign(Data, PrivateKey) = Signature$$

### 1.2 ç­¾åæ­£ç¡®æ€§å®šä¹‰ / Signature Correctness Definition

**å®šä¹‰ 1.2** (ç­¾åæ­£ç¡®æ€§ / Signature Correctness)

ç­¾åæ˜¯æ­£ç¡®çš„ï¼Œå¦‚æœéªŒè¯é€šè¿‡ï¼š

$$Correct(Sign) \iff Verify(Data, Signature, PublicKey) = True$$

---

## 2. æ•°å­—ç­¾å / Digital Signature

### 2.1 ç­¾åç®—æ³• / Signature Algorithm

**å®šä¹‰ 2.1** (ç­¾åç®—æ³• / Signature Algorithm)

ç­¾åç®—æ³• $Sign(Data, PrivateKey)$ ç”Ÿæˆæ•°å­—ç­¾åã€‚

**ç®—æ³• 2.1** (ç­¾åç®—æ³• / Signature Algorithm)

```python
def sign(data: bytes, private_key: PrivateKey) -> bytes:
    """
    ç­¾åæ•°æ®
    
    Args:
        data: æ•°æ®
        private_key: ç§é’¥
        
    Returns:
        bytes: ç­¾å
    """
    # è®¡ç®—å“ˆå¸Œ
    hash_value = hash(data)
    
    # ä½¿ç”¨ç§é’¥ç­¾å
    signature = encrypt_with_private_key(hash_value, private_key)
    
    return signature
```

**å¼•ç† 2.1** (ç­¾åæ­£ç¡®æ€§ / Signature Correctness)

å¦‚æœç­¾åç®—æ³•æ­£ç¡®ï¼Œåˆ™ç­¾åæ­£ç¡®ï¼š

$$Correct(Sign) \implies Correct(Signature)$$

---

## 3. ç­¾åéªŒè¯ / Signature Verification

### 3.1 éªŒè¯å®šä¹‰ / Verification Definition

**å®šä¹‰ 3.1** (ç­¾åéªŒè¯ / Signature Verification)

ç­¾åéªŒè¯ $Verify(Data, Signature, PublicKey)$ éªŒè¯ç­¾åï¼š

$$Verify(Data, Signature, PublicKey) = Valid | Invalid$$

**ç®—æ³• 3.1** (éªŒè¯ç®—æ³• / Verification Algorithm)

```python
def verify(data: bytes, signature: bytes, public_key: PublicKey) -> bool:
    """
    éªŒè¯ç­¾å
    
    Args:
        data: æ•°æ®
        signature: ç­¾å
        public_key: å…¬é’¥
        
    Returns:
        bool: æ˜¯å¦æœ‰æ•ˆ
    """
    # è®¡ç®—æ•°æ®å“ˆå¸Œ
    hash_value = hash(data)
    
    # ä½¿ç”¨å…¬é’¥è§£å¯†ç­¾å
    decrypted_hash = decrypt_with_public_key(signature, public_key)
    
    # æ¯”è¾ƒå“ˆå¸Œ
    return hash_value == decrypted_hash
```

**å¼•ç† 3.1** (éªŒè¯å¯é æ€§ / Verification Reliability)

å¦‚æœéªŒè¯ç®—æ³•æ­£ç¡®ï¼Œåˆ™éªŒè¯å¯é ï¼š

$$Correct(Verify) \implies Reliable(Verification)$$

---

## 4. è¯ä¹¦ç®¡ç† / Certificate Management

### 4.1 è¯ä¹¦å®šä¹‰ / Certificate Definition

**å®šä¹‰ 4.1** (è¯ä¹¦ / Certificate)

è¯ä¹¦ $Certificate = (PublicKey, Issuer, Validity, Signature)$ æ˜¯å…¬é’¥çš„è®¤è¯ã€‚

**ç®—æ³• 4.1** (è¯ä¹¦éªŒè¯ç®—æ³• / Certificate Verification Algorithm)

```python
def verify_certificate(certificate: Certificate, ca_public_key: PublicKey) -> bool:
    """
    éªŒè¯è¯ä¹¦
    
    Args:
        certificate: è¯ä¹¦
        ca_public_key: CAå…¬é’¥
        
    Returns:
        bool: æ˜¯å¦æœ‰æ•ˆ
    """
    # éªŒè¯ç­¾å
    if not verify(certificate.data, certificate.signature, ca_public_key):
        return False
    
    # æ£€æŸ¥æœ‰æ•ˆæœŸ
    if not check_validity(certificate):
        return False
    
    return True
```

---

## 5. å½¢å¼åŒ–è¯æ˜ / Formal Proofs

### 5.1 ç­¾åæ­£ç¡®æ€§ / Signature Correctness

**å®šç† 5.1** (ç­¾åæ­£ç¡®æ€§ / Signature Correctness)

å¦‚æœç­¾åå’ŒéªŒè¯ç®—æ³•æ­£ç¡®ï¼Œåˆ™ç­¾åæ­£ç¡®ï¼š

$$Correct(Sign) \land Correct(Verify) \implies Correct(Signature)$$

**è¯æ˜**ï¼š

æ ¹æ®å®šä¹‰1.2ï¼Œç­¾åæ˜¯æ­£ç¡®çš„ï¼Œå¦‚æœéªŒè¯é€šè¿‡ã€‚æ ¹æ®å¼•ç†2.1å’Œ3.1ï¼Œå¦‚æœç­¾åå’ŒéªŒè¯ç®—æ³•æ­£ç¡®ï¼Œåˆ™ç­¾åæ­£ç¡®ã€‚å› æ­¤ï¼Œå¦‚æœç­¾åå’ŒéªŒè¯ç®—æ³•æ­£ç¡®ï¼Œç­¾åæ­£ç¡®ã€‚$\square$

### 5.2 éªŒè¯å¯é æ€§ / Verification Reliability

**å®šç† 5.2** (éªŒè¯å¯é æ€§ / Verification Reliability)

å¦‚æœéªŒè¯ç®—æ³•æ­£ç¡®ï¼Œåˆ™éªŒè¯å¯é ï¼š

$$Correct(Verify) \implies Reliable(Verification)$$

**è¯æ˜**ï¼š

æ ¹æ®å¼•ç†3.1ï¼Œå¦‚æœéªŒè¯ç®—æ³•æ­£ç¡®ï¼ŒéªŒè¯å¯é ã€‚å› æ­¤ï¼Œå¦‚æœéªŒè¯ç®—æ³•æ­£ç¡®ï¼ŒéªŒè¯å¯é ã€‚$\square$

---

## 6. ä»£ç å®ç° / Code Implementation

### 6.1 æ•°å­—ç­¾åç³»ç»Ÿ / Digital Signature System

```python
from dataclasses import dataclass
from typing import Optional, Dict, Any
from datetime import datetime, timedelta
from enum import Enum
import hashlib
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat, PrivateFormat
from cryptography.hazmat.backends import default_backend
import base64

class SignatureAlgorithm(Enum):
    """ç­¾åç®—æ³•"""
    RSA_SHA256 = "rsa_sha256"
    RSA_SHA512 = "rsa_sha512"

@dataclass
class KeyPair:
    """å¯†é’¥å¯¹"""
    private_key: bytes
    public_key: bytes
    algorithm: SignatureAlgorithm = SignatureAlgorithm.RSA_SHA256

@dataclass
class Certificate:
    """è¯ä¹¦"""
    public_key: bytes
    issuer: str
    subject: str
    valid_from: datetime
    valid_to: datetime
    signature: Optional[bytes] = None

class KeyPairGenerator:
    """å¯†é’¥å¯¹ç”Ÿæˆå™¨"""
    
    @staticmethod
    def generate_key_pair(key_size: int = 2048) -> KeyPair:
        """
        ç”Ÿæˆå¯†é’¥å¯¹
        
        Args:
            key_size: å¯†é’¥å¤§å°
            
        Returns:
            KeyPair: å¯†é’¥å¯¹
        """
        private_key_obj = rsa.generate_private_key(
            public_exponent=65537,
            key_size=key_size,
            backend=default_backend()
        )
        
        public_key_obj = private_key_obj.public_key()
        
        # åºåˆ—åŒ–
        private_key_bytes = private_key_obj.private_bytes(
            encoding=Encoding.PEM,
            format=PrivateFormat.PKCS8,
            encryption_algorithm=None
        )
        
        public_key_bytes = public_key_obj.public_bytes(
            encoding=Encoding.PEM,
            format=PublicFormat.SubjectPublicKeyInfo
        )
        
        return KeyPair(
            private_key=private_key_bytes,
            public_key=public_key_bytes,
            algorithm=SignatureAlgorithm.RSA_SHA256
        )

class Signer:
    """ç­¾åå™¨"""
    
    def __init__(self, private_key: bytes):
        from cryptography.hazmat.primitives.serialization import load_pem_private_key
        self.private_key = load_pem_private_key(private_key, password=None, backend=default_backend())
    
    def sign(self, data: bytes) -> bytes:
        """
        ç­¾åæ•°æ®
        
        Args:
            data: æ•°æ®
            
        Returns:
            bytes: ç­¾å
        """
        signature = self.private_key.sign(
            data,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
        
        return base64.b64encode(signature)
    
    def sign_with_hash(self, data: bytes) -> bytes:
        """
        ç­¾åæ•°æ®ï¼ˆå¸¦å“ˆå¸Œï¼‰
        
        Args:
            data: æ•°æ®
            
        Returns:
            bytes: ç­¾å
        """
        # è®¡ç®—å“ˆå¸Œ
        hash_value = hashlib.sha256(data).digest()
        
        # ç­¾åå“ˆå¸Œ
        signature = self.private_key.sign(
            hash_value,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
        
        return base64.b64encode(signature)

class Verifier:
    """éªŒè¯å™¨"""
    
    def __init__(self, public_key: bytes):
        from cryptography.hazmat.primitives.serialization import load_pem_public_key
        self.public_key = load_pem_public_key(public_key, backend=default_backend())
    
    def verify(self, data: bytes, signature: bytes) -> bool:
        """
        éªŒè¯ç­¾å
        
        Args:
            data: æ•°æ®
            signature: ç­¾å
            
        Returns:
            bool: æ˜¯å¦æœ‰æ•ˆ
        """
        try:
            signature_bytes = base64.b64decode(signature)
            self.public_key.verify(
                signature_bytes,
                data,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
            return True
        except Exception:
            return False
    
    def verify_with_hash(self, data: bytes, signature: bytes) -> bool:
        """
        éªŒè¯ç­¾åï¼ˆå¸¦å“ˆå¸Œï¼‰
        
        Args:
            data: æ•°æ®
            signature: ç­¾å
            
        Returns:
            bool: æ˜¯å¦æœ‰æ•ˆ
        """
        try:
            # è®¡ç®—å“ˆå¸Œ
            hash_value = hashlib.sha256(data).digest()
            
            # éªŒè¯ç­¾å
            signature_bytes = base64.b64decode(signature)
            self.public_key.verify(
                signature_bytes,
                hash_value,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
            return True
        except Exception:
            return False

class CertificateManager:
    """è¯ä¹¦ç®¡ç†å™¨"""
    
    def __init__(self):
        self.certificates: Dict[str, Certificate] = {}
    
    def issue_certificate(self, public_key: bytes, subject: str, issuer: str, 
                         valid_days: int = 365) -> Certificate:
        """
        é¢å‘è¯ä¹¦
        
        Args:
            public_key: å…¬é’¥
            subject: ä¸»é¢˜
            issuer: é¢å‘è€…
            valid_days: æœ‰æ•ˆå¤©æ•°
            
        Returns:
            Certificate: è¯ä¹¦
        """
        certificate = Certificate(
            public_key=public_key,
            issuer=issuer,
            subject=subject,
            valid_from=datetime.now(),
            valid_to=datetime.now() + timedelta(days=valid_days)
        )
        
        self.certificates[subject] = certificate
        return certificate
    
    def verify_certificate(self, certificate: Certificate, ca_public_key: bytes) -> bool:
        """
        éªŒè¯è¯ä¹¦
        
        Args:
            certificate: è¯ä¹¦
            ca_public_key: CAå…¬é’¥
            
        Returns:
            bool: æ˜¯å¦æœ‰æ•ˆ
        """
        # æ£€æŸ¥æœ‰æ•ˆæœŸ
        if datetime.now() < certificate.valid_from or datetime.now() > certificate.valid_to:
            return False
        
        # éªŒè¯ç­¾åï¼ˆå¦‚æœæœ‰ï¼‰
        if certificate.signature:
            verifier = Verifier(ca_public_key)
            cert_data = f"{certificate.public_key}{certificate.issuer}{certificate.subject}".encode()
            if not verifier.verify_with_hash(cert_data, certificate.signature):
                return False
        
        return True
    
    def get_certificate(self, subject: str) -> Optional[Certificate]:
        """
        è·å–è¯ä¹¦
        
        Args:
            subject: ä¸»é¢˜
            
        Returns:
            Optional[Certificate]: è¯ä¹¦
        """
        return self.certificates.get(subject)

class DigitalSignatureSystem:
    """æ•°å­—ç­¾åç³»ç»Ÿ"""
    
    def __init__(self):
        self.key_generator = KeyPairGenerator()
        self.certificate_manager = CertificateManager()
    
    def generate_key_pair(self) -> KeyPair:
        """
        ç”Ÿæˆå¯†é’¥å¯¹
        
        Returns:
            KeyPair: å¯†é’¥å¯¹
        """
        return self.key_generator.generate_key_pair()
    
    def sign(self, data: bytes, private_key: bytes) -> bytes:
        """
        ç­¾åæ•°æ®
        
        Args:
            data: æ•°æ®
            private_key: ç§é’¥
            
        Returns:
            bytes: ç­¾å
        """
        signer = Signer(private_key)
        return signer.sign_with_hash(data)
    
    def verify(self, data: bytes, signature: bytes, public_key: bytes) -> bool:
        """
        éªŒè¯ç­¾å
        
        Args:
            data: æ•°æ®
            signature: ç­¾å
            public_key: å…¬é’¥
            
        Returns:
            bool: æ˜¯å¦æœ‰æ•ˆ
        """
        verifier = Verifier(public_key)
        return verifier.verify_with_hash(data, signature)
    
    def issue_certificate(self, public_key: bytes, subject: str, issuer: str = "CA", 
                         valid_days: int = 365) -> Certificate:
        """
        é¢å‘è¯ä¹¦
        
        Args:
            public_key: å…¬é’¥
            subject: ä¸»é¢˜
            issuer: é¢å‘è€…
            valid_days: æœ‰æ•ˆå¤©æ•°
            
        Returns:
            Certificate: è¯ä¹¦
        """
        return self.certificate_manager.issue_certificate(public_key, subject, issuer, valid_days)
```

---

## 7. åº”ç”¨æ¡ˆä¾‹ / Application Cases

### 7.1 è½¬æ¢æ•°å­—ç­¾å / Transformation Digital Signature

**åœºæ™¯**ï¼šä¸ºè½¬æ¢æ¨¡å‹æ·»åŠ æ•°å­—ç­¾å

**å®ç°**ï¼š

```python
# åˆ›å»ºæ•°å­—ç­¾åç³»ç»Ÿ
signature_system = DigitalSignatureSystem()

# ç”Ÿæˆå¯†é’¥å¯¹
key_pair = signature_system.generate_key_pair()
print(f"å¯†é’¥å¯¹å·²ç”Ÿæˆ")

# å®šä¹‰æ•°æ®
model_data = b"Petri net model data"

# ç­¾å
signature = signature_system.sign(model_data, key_pair.private_key)
print(f"ç­¾åé•¿åº¦: {len(signature)} bytes")

# éªŒè¯
is_valid = signature_system.verify(model_data, signature, key_pair.public_key)
print(f"ç­¾åéªŒè¯: {'é€šè¿‡' if is_valid else 'å¤±è´¥'}")
```

### 7.2 è¯ä¹¦ç®¡ç† / Certificate Management

**åœºæ™¯**ï¼šç®¡ç†æ•°å­—è¯ä¹¦

**å®ç°**ï¼š

```python
# é¢å‘è¯ä¹¦
certificate = signature_system.issue_certificate(
    key_pair.public_key,
    subject="transformation_service",
    issuer="CA",
    valid_days=365
)

print(f"è¯ä¹¦ä¸»é¢˜: {certificate.subject}")
print(f"è¯ä¹¦æœ‰æ•ˆæœŸ: {certificate.valid_from} åˆ° {certificate.valid_to}")

# éªŒè¯è¯ä¹¦
is_valid = signature_system.certificate_manager.verify_certificate(
    certificate,
    key_pair.public_key  # ä½¿ç”¨CAå…¬é’¥
)
print(f"è¯ä¹¦éªŒè¯: {'é€šè¿‡' if is_valid else 'å¤±è´¥'}")
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
