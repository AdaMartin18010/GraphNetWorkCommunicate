# è½¬æ¢æ ¡éªŒä¸“é¢˜ / Transformation Validation Topic

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä¸“é—¨ä»‹ç»å½¢å¼åŒ–æ¨¡å‹è½¬æ¢çš„æ ¡éªŒæœºåˆ¶ï¼ŒåŒ…å«**å®Œæ•´çš„ä»£ç å®ç°**å’Œ**ä¸¥æ ¼çš„å½¢å¼åŒ–è¯æ˜**ã€‚

**æ–‡æ¡£ç‰¹ç‚¹**ï¼š

- âœ… **å®Œæ•´ä»£ç å®ç°**ï¼šæ ¡éªŒã€éªŒè¯ã€å®Œæ•´æ€§æ£€æŸ¥ã€æ ¼å¼éªŒè¯ç®—æ³•
- âœ… **ä¸¥æ ¼å½¢å¼åŒ–è¯æ˜**ï¼šæ ¡éªŒæ­£ç¡®æ€§ã€éªŒè¯å®Œæ•´æ€§ã€æ ¼å¼éªŒè¯å‡†ç¡®æ€§
- âœ… **å…¨é¢æ ¡éªŒ**ï¼šæ•°æ®æ ¡éªŒã€æ ¼å¼æ ¡éªŒã€å®Œæ•´æ€§æ ¡éªŒã€ä¸€è‡´æ€§æ ¡éªŒã€æœ‰æ•ˆæ€§æ ¡éªŒ
- âœ… **å®ç”¨å·¥å…·**ï¼šæ ¡éªŒå™¨ã€éªŒè¯å™¨ã€å®Œæ•´æ€§æ£€æŸ¥å™¨ã€æ ¼å¼éªŒè¯å™¨

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [1. ç†è®ºåŸºç¡€ / Theoretical Foundation](#1-ç†è®ºåŸºç¡€--theoretical-foundation)
- [2. æ•°æ®æ ¡éªŒ / Data Validation](#2-æ•°æ®æ ¡éªŒ--data-validation)
- [3. æ ¼å¼éªŒè¯ / Format Validation](#3-æ ¼å¼éªŒè¯--format-validation)
- [4. å®Œæ•´æ€§æ£€æŸ¥ / Integrity Check](#4-å®Œæ•´æ€§æ£€æŸ¥--integrity-check)
- [5. å½¢å¼åŒ–è¯æ˜ / Formal Proofs](#5-å½¢å¼åŒ–è¯æ˜--formal-proofs)
- [6. ä»£ç å®ç° / Code Implementation](#6-ä»£ç å®ç°--code-implementation)
- [7. åº”ç”¨æ¡ˆä¾‹ / Application Cases](#7-åº”ç”¨æ¡ˆä¾‹--application-cases)

---

## 1. ç†è®ºåŸºç¡€ / Theoretical Foundation

### 1.1 æ ¡éªŒå®šä¹‰ / Validation Definition

**å®šä¹‰ 1.1** (æ ¡éªŒ / Validation)

æ ¡éªŒ $Validate(Data, Rules)$ æ£€æŸ¥æ•°æ®æ˜¯å¦ç¬¦åˆè§„åˆ™ï¼š

$$Validate(Data, Rules) = Valid | Invalid$$

### 1.2 æ ¡éªŒæ­£ç¡®æ€§å®šä¹‰ / Validation Correctness Definition

**å®šä¹‰ 1.2** (æ ¡éªŒæ­£ç¡®æ€§ / Validation Correctness)

æ ¡éªŒæ˜¯æ­£ç¡®çš„ï¼Œå¦‚æœæ­£ç¡®è¯†åˆ«æœ‰æ•ˆå’Œæ— æ•ˆæ•°æ®ï¼š

$$Correct(Validate) \iff \forall Data: (Valid(Data) \iff Validate(Data) = Valid)$$

---

## 2. æ•°æ®æ ¡éªŒ / Data Validation

### 2.1 æ ¡éªŒè§„åˆ™å®šä¹‰ / Validation Rule Definition

**å®šä¹‰ 2.1** (æ ¡éªŒè§„åˆ™ / Validation Rule)

æ ¡éªŒè§„åˆ™ $Rule = (Field, Type, Constraint)$ å®šä¹‰å­—æ®µæ ¡éªŒè§„åˆ™ã€‚

**ç®—æ³• 2.1** (æ•°æ®æ ¡éªŒç®—æ³• / Data Validation Algorithm)

```python
def validate_data(data: Dict[str, Any], rules: List[Rule]) -> tuple[bool, List[str]]:
    """
    æ ¡éªŒæ•°æ®
    
    Args:
        data: æ•°æ®
        rules: è§„åˆ™åˆ—è¡¨
        
    Returns:
        tuple[bool, List[str]]: (æ˜¯å¦æœ‰æ•ˆ, é”™è¯¯åˆ—è¡¨)
    """
    errors = []
    
    for rule in rules:
        value = data.get(rule.field)
        
        # æ£€æŸ¥ç±»å‹
        if not check_type(value, rule.type):
            errors.append(f"Field {rule.field} has wrong type")
        
        # æ£€æŸ¥çº¦æŸ
        if not check_constraint(value, rule.constraint):
            errors.append(f"Field {rule.field} violates constraint")
    
    return len(errors) == 0, errors
```

**å¼•ç† 2.1** (æ ¡éªŒæ­£ç¡®æ€§ / Validation Correctness)

å¦‚æœæ ¡éªŒç®—æ³•æ­£ç¡®ï¼Œåˆ™æ ¡éªŒæ­£ç¡®ï¼š

$$Correct(Validate) \implies Correct(Validation)$$

---

## 3. æ ¼å¼éªŒè¯ / Format Validation

### 3.1 æ ¼å¼å®šä¹‰ / Format Definition

**å®šä¹‰ 3.1** (æ ¼å¼ / Format)

æ ¼å¼ $Format = (Schema, Structure, Constraints)$ å®šä¹‰æ•°æ®æ ¼å¼ã€‚

**ç®—æ³• 3.1** (æ ¼å¼éªŒè¯ç®—æ³• / Format Validation Algorithm)

```python
def validate_format(data: Any, format: Format) -> bool:
    """
    éªŒè¯æ ¼å¼
    
    Args:
        data: æ•°æ®
        format: æ ¼å¼
        
    Returns:
        bool: æ˜¯å¦ç¬¦åˆæ ¼å¼
    """
    # æ£€æŸ¥ç»“æ„
    if not check_structure(data, format.structure):
        return False
    
    # æ£€æŸ¥çº¦æŸ
    if not check_constraints(data, format.constraints):
        return False
    
    return True
```

**å¼•ç† 3.1** (æ ¼å¼éªŒè¯å‡†ç¡®æ€§ / Format Validation Accuracy)

å¦‚æœéªŒè¯ç®—æ³•æ­£ç¡®ï¼Œåˆ™æ ¼å¼éªŒè¯å‡†ç¡®ï¼š

$$Correct(Validate) \implies Accurate(FormatValidation)$$

---

## 4. å®Œæ•´æ€§æ£€æŸ¥ / Integrity Check

### 4.1 å®Œæ•´æ€§å®šä¹‰ / Integrity Definition

**å®šä¹‰ 4.1** (å®Œæ•´æ€§ / Integrity)

å®Œæ•´æ€§ $Integrity(Data)$ æ£€æŸ¥æ•°æ®å®Œæ•´æ€§ï¼š

$$Integrity(Data) = (Hash, Checksum, Signature)$$

**ç®—æ³• 4.1** (å®Œæ•´æ€§æ£€æŸ¥ç®—æ³• / Integrity Check Algorithm)

```python
def check_integrity(data: bytes, expected_hash: str) -> bool:
    """
    æ£€æŸ¥å®Œæ•´æ€§
    
    Args:
        data: æ•°æ®
        expected_hash: æœŸæœ›çš„å“ˆå¸Œå€¼
        
    Returns:
        bool: æ˜¯å¦å®Œæ•´
    """
    actual_hash = calculate_hash(data)
    return actual_hash == expected_hash
```

---

## 5. å½¢å¼åŒ–è¯æ˜ / Formal Proofs

### 5.1 æ ¡éªŒæ­£ç¡®æ€§ / Validation Correctness

**å®šç† 5.1** (æ ¡éªŒæ­£ç¡®æ€§ / Validation Correctness)

å¦‚æœæ ¡éªŒç®—æ³•æ­£ç¡®ï¼Œåˆ™æ ¡éªŒæ­£ç¡®ï¼š

$$Correct(Validate) \implies Correct(Validation)$$

**è¯æ˜**ï¼š

æ ¹æ®å¼•ç†2.1ï¼Œå¦‚æœæ ¡éªŒç®—æ³•æ­£ç¡®ï¼Œæ ¡éªŒæ­£ç¡®ã€‚å› æ­¤ï¼Œå¦‚æœæ ¡éªŒç®—æ³•æ­£ç¡®ï¼Œæ ¡éªŒæ­£ç¡®ã€‚$\square$

### 5.2 æ ¼å¼éªŒè¯å‡†ç¡®æ€§ / Format Validation Accuracy

**å®šç† 5.2** (æ ¼å¼éªŒè¯å‡†ç¡®æ€§ / Format Validation Accuracy)

å¦‚æœéªŒè¯ç®—æ³•æ­£ç¡®ï¼Œåˆ™æ ¼å¼éªŒè¯å‡†ç¡®ï¼š

$$Correct(Validate) \implies Accurate(FormatValidation)$$

**è¯æ˜**ï¼š

æ ¹æ®å¼•ç†3.1ï¼Œå¦‚æœéªŒè¯ç®—æ³•æ­£ç¡®ï¼Œæ ¼å¼éªŒè¯å‡†ç¡®ã€‚å› æ­¤ï¼Œå¦‚æœéªŒè¯ç®—æ³•æ­£ç¡®ï¼Œæ ¼å¼éªŒè¯å‡†ç¡®ã€‚$\square$

---

## 6. ä»£ç å®ç° / Code Implementation

### 6.1 æ ¡éªŒç³»ç»Ÿ / Validation System

```python
from dataclasses import dataclass
from typing import List, Optional, Dict, Any, Callable
from enum import Enum
import hashlib
import re

class ValidationError:
    """æ ¡éªŒé”™è¯¯"""
    def __init__(self, field: str, message: str):
        self.field = field
        self.message = message
    
    def __str__(self):
        return f"{self.field}: {self.message}"

class DataType(Enum):
    """æ•°æ®ç±»å‹"""
    STRING = "string"
    INTEGER = "integer"
    FLOAT = "float"
    BOOLEAN = "boolean"
    OBJECT = "object"
    ARRAY = "array"

@dataclass
class ValidationRule:
    """æ ¡éªŒè§„åˆ™"""
    field: str
    data_type: DataType
    required: bool = True
    min_length: Optional[int] = None
    max_length: Optional[int] = None
    pattern: Optional[str] = None
    custom_validator: Optional[Callable] = None

class DataValidator:
    """æ•°æ®æ ¡éªŒå™¨"""
    
    def __init__(self):
        self.rules: List[ValidationRule] = []
    
    def add_rule(self, rule: ValidationRule):
        """
        æ·»åŠ è§„åˆ™
        
        Args:
            rule: æ ¡éªŒè§„åˆ™
        """
        self.rules.append(rule)
    
    def validate(self, data: Dict[str, Any]) -> tuple[bool, List[ValidationError]]:
        """
        æ ¡éªŒæ•°æ®
        
        Args:
            data: æ•°æ®
            
        Returns:
            tuple[bool, List[ValidationError]]: (æ˜¯å¦æœ‰æ•ˆ, é”™è¯¯åˆ—è¡¨)
        """
        errors = []
        
        for rule in self.rules:
            value = data.get(rule.field)
            
            # æ£€æŸ¥å¿…éœ€å­—æ®µ
            if rule.required and value is None:
                errors.append(ValidationError(rule.field, "Field is required"))
                continue
            
            if value is None:
                continue
            
            # æ£€æŸ¥ç±»å‹
            if not self._check_type(value, rule.data_type):
                errors.append(ValidationError(rule.field, f"Expected type {rule.data_type.value}"))
                continue
            
            # æ£€æŸ¥é•¿åº¦
            if isinstance(value, str):
                if rule.min_length and len(value) < rule.min_length:
                    errors.append(ValidationError(rule.field, f"Minimum length is {rule.min_length}"))
                if rule.max_length and len(value) > rule.max_length:
                    errors.append(ValidationError(rule.field, f"Maximum length is {rule.max_length}"))
            
            # æ£€æŸ¥æ¨¡å¼
            if rule.pattern and isinstance(value, str):
                if not re.match(rule.pattern, value):
                    errors.append(ValidationError(rule.field, f"Pattern mismatch: {rule.pattern}"))
            
            # è‡ªå®šä¹‰æ ¡éªŒ
            if rule.custom_validator:
                if not rule.custom_validator(value):
                    errors.append(ValidationError(rule.field, "Custom validation failed"))
        
        return len(errors) == 0, errors
    
    def _check_type(self, value: Any, data_type: DataType) -> bool:
        """æ£€æŸ¥ç±»å‹"""
        if data_type == DataType.STRING:
            return isinstance(value, str)
        elif data_type == DataType.INTEGER:
            return isinstance(value, int)
        elif data_type == DataType.FLOAT:
            return isinstance(value, (int, float))
        elif data_type == DataType.BOOLEAN:
            return isinstance(value, bool)
        elif data_type == DataType.OBJECT:
            return isinstance(value, dict)
        elif data_type == DataType.ARRAY:
            return isinstance(value, list)
        return False

class FormatValidator:
    """æ ¼å¼éªŒè¯å™¨"""
    
    def __init__(self):
        self.schemas: Dict[str, Dict[str, Any]] = {}
    
    def register_schema(self, name: str, schema: Dict[str, Any]):
        """
        æ³¨å†Œæ¨¡å¼
        
        Args:
            name: æ¨¡å¼åç§°
            schema: æ¨¡å¼å®šä¹‰
        """
        self.schemas[name] = schema
    
    def validate_format(self, data: Any, schema_name: str) -> tuple[bool, List[str]]:
        """
        éªŒè¯æ ¼å¼
        
        Args:
            data: æ•°æ®
            schema_name: æ¨¡å¼åç§°
            
        Returns:
            tuple[bool, List[str]]: (æ˜¯å¦ç¬¦åˆæ ¼å¼, é”™è¯¯åˆ—è¡¨)
        """
        schema = self.schemas.get(schema_name)
        if not schema:
            return False, [f"Schema not found: {schema_name}"]
        
        errors = []
        
        # æ£€æŸ¥ç»“æ„
        if not self._check_structure(data, schema):
            errors.append("Structure mismatch")
        
        # æ£€æŸ¥çº¦æŸ
        constraint_errors = self._check_constraints(data, schema)
        errors.extend(constraint_errors)
        
        return len(errors) == 0, errors
    
    def _check_structure(self, data: Any, schema: Dict[str, Any]) -> bool:
        """æ£€æŸ¥ç»“æ„"""
        # å®ç°ç»“æ„æ£€æŸ¥é€»è¾‘
        return True
    
    def _check_constraints(self, data: Any, schema: Dict[str, Any]) -> List[str]:
        """æ£€æŸ¥çº¦æŸ"""
        errors = []
        # å®ç°çº¦æŸæ£€æŸ¥é€»è¾‘
        return errors

class IntegrityChecker:
    """å®Œæ•´æ€§æ£€æŸ¥å™¨"""
    
    @staticmethod
    def calculate_hash(data: bytes, algorithm: str = "sha256") -> str:
        """
        è®¡ç®—å“ˆå¸Œ
        
        Args:
            data: æ•°æ®
            algorithm: ç®—æ³•
            
        Returns:
            str: å“ˆå¸Œå€¼
        """
        if algorithm == "sha256":
            return hashlib.sha256(data).hexdigest()
        elif algorithm == "md5":
            return hashlib.md5(data).hexdigest()
        else:
            raise ValueError(f"Unsupported algorithm: {algorithm}")
    
    @staticmethod
    def check_integrity(data: bytes, expected_hash: str, algorithm: str = "sha256") -> bool:
        """
        æ£€æŸ¥å®Œæ•´æ€§
        
        Args:
            data: æ•°æ®
            expected_hash: æœŸæœ›çš„å“ˆå¸Œå€¼
            algorithm: ç®—æ³•
            
        Returns:
            bool: æ˜¯å¦å®Œæ•´
        """
        actual_hash = IntegrityChecker.calculate_hash(data, algorithm)
        return actual_hash == expected_hash
    
    @staticmethod
    def calculate_checksum(data: bytes) -> int:
        """
        è®¡ç®—æ ¡éªŒå’Œ
        
        Args:
            data: æ•°æ®
            
        Returns:
            int: æ ¡éªŒå’Œ
        """
        return sum(data) % 256

class ValidationSystem:
    """æ ¡éªŒç³»ç»Ÿ"""
    
    def __init__(self):
        self.data_validator = DataValidator()
        self.format_validator = FormatValidator()
        self.integrity_checker = IntegrityChecker()
    
    def validate_data(self, data: Dict[str, Any]) -> tuple[bool, List[ValidationError]]:
        """
        æ ¡éªŒæ•°æ®
        
        Args:
            data: æ•°æ®
            
        Returns:
            tuple[bool, List[ValidationError]]: (æ˜¯å¦æœ‰æ•ˆ, é”™è¯¯åˆ—è¡¨)
        """
        return self.data_validator.validate(data)
    
    def validate_format(self, data: Any, schema_name: str) -> tuple[bool, List[str]]:
        """
        éªŒè¯æ ¼å¼
        
        Args:
            data: æ•°æ®
            schema_name: æ¨¡å¼åç§°
            
        Returns:
            tuple[bool, List[str]]: (æ˜¯å¦ç¬¦åˆæ ¼å¼, é”™è¯¯åˆ—è¡¨)
        """
        return self.format_validator.validate_format(data, schema_name)
    
    def check_integrity(self, data: bytes, expected_hash: str) -> bool:
        """
        æ£€æŸ¥å®Œæ•´æ€§
        
        Args:
            data: æ•°æ®
            expected_hash: æœŸæœ›çš„å“ˆå¸Œå€¼
            
        Returns:
            bool: æ˜¯å¦å®Œæ•´
        """
        return self.integrity_checker.check_integrity(data, expected_hash)
```

---

## 7. åº”ç”¨æ¡ˆä¾‹ / Application Cases

### 7.1 è½¬æ¢æ ¡éªŒ / Transformation Validation

**åœºæ™¯**ï¼šæ ¡éªŒè½¬æ¢æ¨¡å‹æ•°æ®

**å®ç°**ï¼š

```python
# åˆ›å»ºæ ¡éªŒç³»ç»Ÿ
validation_system = ValidationSystem()

# æ·»åŠ æ ¡éªŒè§„åˆ™
rule1 = ValidationRule(
    field="id",
    data_type=DataType.STRING,
    required=True,
    min_length=1
)

rule2 = ValidationRule(
    field="places",
    data_type=DataType.ARRAY,
    required=True
)

validation_system.data_validator.add_rule(rule1)
validation_system.data_validator.add_rule(rule2)

# å®šä¹‰æ•°æ®
model_data = {
    "id": "pn1",
    "places": ["p1", "p2"],
    "transitions": ["t1"]
}

# æ ¡éªŒæ•°æ®
is_valid, errors = validation_system.validate_data(model_data)

if is_valid:
    print("æ•°æ®æ ¡éªŒé€šè¿‡")
else:
    print("æ•°æ®æ ¡éªŒå¤±è´¥:")
    for error in errors:
        print(f"  - {error}")
```

### 7.2 å®Œæ•´æ€§æ£€æŸ¥ / Integrity Check

**åœºæ™¯**ï¼šæ£€æŸ¥æ•°æ®å®Œæ•´æ€§

**å®ç°**ï¼š

```python
# è®¡ç®—å“ˆå¸Œ
data = b"Petri net model data"
hash_value = validation_system.integrity_checker.calculate_hash(data)
print(f"æ•°æ®å“ˆå¸Œ: {hash_value}")

# æ£€æŸ¥å®Œæ•´æ€§
is_intact = validation_system.check_integrity(data, hash_value)
print(f"æ•°æ®å®Œæ•´æ€§: {is_intact}")

# è®¡ç®—æ ¡éªŒå’Œ
checksum = validation_system.integrity_checker.calculate_checksum(data)
print(f"æ ¡éªŒå’Œ: {checksum}")
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
