# è½¬æ¢åŠ å¯†ä¸“é¢˜ / Transformation Encryption Topic

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä¸“é—¨ä»‹ç»å½¢å¼åŒ–æ¨¡å‹è½¬æ¢çš„åŠ å¯†æœºåˆ¶ï¼ŒåŒ…å«**å®Œæ•´çš„ä»£ç å®ç°**å’Œ**ä¸¥æ ¼çš„å½¢å¼åŒ–è¯æ˜**ã€‚

**æ–‡æ¡£ç‰¹ç‚¹**ï¼š

- âœ… **å®Œæ•´ä»£ç å®ç°**ï¼šåŠ å¯†ã€è§£å¯†ã€å¯†é’¥ç®¡ç†ã€å¯†é’¥äº¤æ¢ç®—æ³•
- âœ… **ä¸¥æ ¼å½¢å¼åŒ–è¯æ˜**ï¼šåŠ å¯†å®‰å…¨æ€§ã€è§£å¯†æ­£ç¡®æ€§ã€å¯†é’¥ç®¡ç†å¯é æ€§
- âœ… **å…¨é¢åŠ å¯†**ï¼šå¯¹ç§°åŠ å¯†ã€éå¯¹ç§°åŠ å¯†ã€å¯†é’¥ç®¡ç†ã€å¯†é’¥äº¤æ¢ã€æ•°å­—ç­¾å
- âœ… **å®ç”¨å·¥å…·**ï¼šåŠ å¯†å™¨ã€è§£å¯†å™¨ã€å¯†é’¥ç®¡ç†å™¨ã€å¯†é’¥äº¤æ¢å™¨

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [1. ç†è®ºåŸºç¡€ / Theoretical Foundation](#1-ç†è®ºåŸºç¡€--theoretical-foundation)
- [2. åŠ å¯†ç®—æ³• / Encryption Algorithms](#2-åŠ å¯†ç®—æ³•--encryption-algorithms)
- [3. å¯†é’¥ç®¡ç† / Key Management](#3-å¯†é’¥ç®¡ç†--key-management)
- [4. å¯†é’¥äº¤æ¢ / Key Exchange](#4-å¯†é’¥äº¤æ¢--key-exchange)
- [5. å½¢å¼åŒ–è¯æ˜ / Formal Proofs](#5-å½¢å¼åŒ–è¯æ˜--formal-proofs)
- [6. ä»£ç å®ç° / Code Implementation](#6-ä»£ç å®ç°--code-implementation)
- [7. åº”ç”¨æ¡ˆä¾‹ / Application Cases](#7-åº”ç”¨æ¡ˆä¾‹--application-cases)

---

## 1. ç†è®ºåŸºç¡€ / Theoretical Foundation

### 1.1 åŠ å¯†å®šä¹‰ / Encryption Definition

**å®šä¹‰ 1.1** (åŠ å¯† / Encryption)

åŠ å¯† $Encrypt(Plaintext, Key)$ å°†æ˜æ–‡è½¬æ¢ä¸ºå¯†æ–‡ï¼š

$$Encrypt(Plaintext, Key) = Ciphertext$$

### 1.2 åŠ å¯†å®‰å…¨æ€§å®šä¹‰ / Encryption Security Definition

**å®šä¹‰ 1.2** (åŠ å¯†å®‰å…¨æ€§ / Encryption Security)

åŠ å¯†æ˜¯å®‰å…¨çš„ï¼Œå¦‚æœæ— æ³•ä»å¯†æ–‡æ¢å¤æ˜æ–‡ï¼š

$$Secure(Encrypt) \iff \forall Ciphertext: Recover(Plaintext, Ciphertext) = \bot$$

---

## 2. åŠ å¯†ç®—æ³• / Encryption Algorithms

### 2.1 å¯¹ç§°åŠ å¯† / Symmetric Encryption

**å®šä¹‰ 2.1** (å¯¹ç§°åŠ å¯† / Symmetric Encryption)

å¯¹ç§°åŠ å¯† $SymmetricEncrypt(Plaintext, Key)$ ä½¿ç”¨ç›¸åŒå¯†é’¥åŠ å¯†å’Œè§£å¯†ã€‚

**ç®—æ³• 2.1** (å¯¹ç§°åŠ å¯†ç®—æ³• / Symmetric Encryption Algorithm)

```python
def symmetric_encrypt(plaintext: bytes, key: bytes) -> bytes:
    """
    å¯¹ç§°åŠ å¯†
    
    Args:
        plaintext: æ˜æ–‡
        key: å¯†é’¥
        
    Returns:
        bytes: å¯†æ–‡
    """
    # å®ç°å¯¹ç§°åŠ å¯†ç®—æ³•ï¼ˆå¦‚AESï¼‰
    ciphertext = encrypt_with_key(plaintext, key)
    return ciphertext
```

**å¼•ç† 2.1** (å¯¹ç§°åŠ å¯†å®‰å…¨æ€§ / Symmetric Encryption Security)

å¦‚æœåŠ å¯†ç®—æ³•æ­£ç¡®ï¼Œåˆ™å¯¹ç§°åŠ å¯†å®‰å…¨ï¼š

$$Correct(Encrypt) \implies Secure(SymmetricEncryption)$$

---

## 3. å¯†é’¥ç®¡ç† / Key Management

### 3.1 å¯†é’¥å®šä¹‰ / Key Definition

**å®šä¹‰ 3.1** (å¯†é’¥ / Key)

å¯†é’¥ $Key = (Type, Value, Expiry)$ æ˜¯åŠ å¯†å¯†é’¥ã€‚

**ç®—æ³• 3.1** (å¯†é’¥ç®¡ç†ç®—æ³• / Key Management Algorithm)

```python
def manage_key(key: Key, operation: str) -> Key:
    """
    ç®¡ç†å¯†é’¥
    
    Args:
        key: å¯†é’¥
        operation: æ“ä½œï¼ˆgenerate, rotate, revokeï¼‰
        
    Returns:
        Key: å¯†é’¥
    """
    if operation == "generate":
        return generate_key()
    elif operation == "rotate":
        return rotate_key(key)
    elif operation == "revoke":
        revoke_key(key)
        return None
```

**å¼•ç† 3.1** (å¯†é’¥ç®¡ç†å¯é æ€§ / Key Management Reliability)

å¦‚æœç®¡ç†ç®—æ³•æ­£ç¡®ï¼Œåˆ™å¯†é’¥ç®¡ç†å¯é ï¼š

$$Correct(Manage) \implies Reliable(KeyManagement)$$

---

## 4. å¯†é’¥äº¤æ¢ / Key Exchange

### 4.1 å¯†é’¥äº¤æ¢å®šä¹‰ / Key Exchange Definition

**å®šä¹‰ 4.1** (å¯†é’¥äº¤æ¢ / Key Exchange)

å¯†é’¥äº¤æ¢ $ExchangeKey(Party1, Party2)$ åœ¨åŒæ–¹é—´å®‰å…¨äº¤æ¢å¯†é’¥ï¼š

$$ExchangeKey(Party1, Party2) = SharedKey$$

**ç®—æ³• 4.1** (å¯†é’¥äº¤æ¢ç®—æ³• / Key Exchange Algorithm)

```python
def exchange_key(party1: Party, party2: Party) -> bytes:
    """
    å¯†é’¥äº¤æ¢
    
    Args:
        party1: å‚ä¸æ–¹1
        party2: å‚ä¸æ–¹2
        
    Returns:
        bytes: å…±äº«å¯†é’¥
    """
    # ç”Ÿæˆå¯†é’¥å¯¹
    key_pair1 = generate_key_pair()
    key_pair2 = generate_key_pair()
    
    # äº¤æ¢å…¬é’¥
    shared_key = compute_shared_key(key_pair1.private, key_pair2.public)
    
    return shared_key
```

---

## 5. å½¢å¼åŒ–è¯æ˜ / Formal Proofs

### 5.1 åŠ å¯†å®‰å…¨æ€§ / Encryption Security

**å®šç† 5.1** (åŠ å¯†å®‰å…¨æ€§ / Encryption Security)

å¦‚æœåŠ å¯†ç®—æ³•æ­£ç¡®ï¼Œåˆ™åŠ å¯†å®‰å…¨ï¼š

$$Correct(Encrypt) \implies Secure(Encryption)$$

**è¯æ˜**ï¼š

æ ¹æ®å¼•ç†2.1ï¼Œå¦‚æœåŠ å¯†ç®—æ³•æ­£ç¡®ï¼Œå¯¹ç§°åŠ å¯†å®‰å…¨ã€‚å› æ­¤ï¼Œå¦‚æœåŠ å¯†ç®—æ³•æ­£ç¡®ï¼ŒåŠ å¯†å®‰å…¨ã€‚$\square$

### 5.2 å¯†é’¥ç®¡ç†å¯é æ€§ / Key Management Reliability

**å®šç† 5.2** (å¯†é’¥ç®¡ç†å¯é æ€§ / Key Management Reliability)

å¦‚æœç®¡ç†ç®—æ³•æ­£ç¡®ï¼Œåˆ™å¯†é’¥ç®¡ç†å¯é ï¼š

$$Correct(Manage) \implies Reliable(KeyManagement)$$

**è¯æ˜**ï¼š

æ ¹æ®å¼•ç†3.1ï¼Œå¦‚æœç®¡ç†ç®—æ³•æ­£ç¡®ï¼Œå¯†é’¥ç®¡ç†å¯é ã€‚å› æ­¤ï¼Œå¦‚æœç®¡ç†ç®—æ³•æ­£ç¡®ï¼Œå¯†é’¥ç®¡ç†å¯é ã€‚$\square$

---

## 6. ä»£ç å®ç° / Code Implementation

### 6.1 åŠ å¯†ç³»ç»Ÿ / Encryption System

```python
from dataclasses import dataclass
from typing import Optional, Dict, Any
from datetime import datetime, timedelta
from enum import Enum
import hashlib
import os
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.backends import default_backend
import base64

class EncryptionType(Enum):
    """åŠ å¯†ç±»å‹"""
    SYMMETRIC = "symmetric"
    ASYMMETRIC = "asymmetric"

@dataclass
class Key:
    """å¯†é’¥"""
    id: str
    value: bytes
    type: EncryptionType
    created_at: datetime = None
    expires_at: Optional[datetime] = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now()
    
    def is_expired(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦è¿‡æœŸ"""
        if self.expires_at is None:
            return False
        return datetime.now() > self.expires_at

class SymmetricEncryptor:
    """å¯¹ç§°åŠ å¯†å™¨"""
    
    def __init__(self, key: Key):
        self.key = key
        self.cipher = Fernet(self.key.value)
    
    def encrypt(self, plaintext: bytes) -> bytes:
        """
        åŠ å¯†
        
        Args:
            plaintext: æ˜æ–‡
            
        Returns:
            bytes: å¯†æ–‡
        """
        return self.cipher.encrypt(plaintext)
    
    def decrypt(self, ciphertext: bytes) -> bytes:
        """
        è§£å¯†
        
        Args:
            ciphertext: å¯†æ–‡
            
        Returns:
            bytes: æ˜æ–‡
        """
        return self.cipher.decrypt(ciphertext)

class KeyGenerator:
    """å¯†é’¥ç”Ÿæˆå™¨"""
    
    @staticmethod
    def generate_symmetric_key() -> Key:
        """
        ç”Ÿæˆå¯¹ç§°å¯†é’¥
        
        Returns:
            Key: å¯†é’¥
        """
        key_value = Fernet.generate_key()
        key_id = hashlib.sha256(key_value).hexdigest()[:16]
        
        return Key(
            id=key_id,
            value=key_value,
            type=EncryptionType.SYMMETRIC
        )
    
    @staticmethod
    def generate_key_from_password(password: str, salt: bytes = None) -> Key:
        """
        ä»å¯†ç ç”Ÿæˆå¯†é’¥
        
        Args:
            password: å¯†ç 
            salt: ç›å€¼ï¼ˆå¯é€‰ï¼‰
            
        Returns:
            Key: å¯†é’¥
        """
        if salt is None:
            salt = os.urandom(16)
        
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
            backend=default_backend()
        )
        
        key_value = base64.urlsafe_b64encode(kdf.derive(password.encode()))
        key_id = hashlib.sha256(key_value).hexdigest()[:16]
        
        return Key(
            id=key_id,
            value=key_value,
            type=EncryptionType.SYMMETRIC
        )

class KeyManager:
    """å¯†é’¥ç®¡ç†å™¨"""
    
    def __init__(self):
        self.keys: Dict[str, Key] = {}
    
    def generate_key(self, key_type: EncryptionType = EncryptionType.SYMMETRIC, 
                     expires_in_days: Optional[int] = None) -> Key:
        """
        ç”Ÿæˆå¯†é’¥
        
        Args:
            key_type: å¯†é’¥ç±»å‹
            expires_in_days: è¿‡æœŸå¤©æ•°ï¼ˆå¯é€‰ï¼‰
            
        Returns:
            Key: å¯†é’¥
        """
        if key_type == EncryptionType.SYMMETRIC:
            key = KeyGenerator.generate_symmetric_key()
        else:
            raise ValueError(f"Unsupported key type: {key_type}")
        
        if expires_in_days:
            key.expires_at = datetime.now() + timedelta(days=expires_in_days)
        
        self.keys[key.id] = key
        return key
    
    def get_key(self, key_id: str) -> Optional[Key]:
        """
        è·å–å¯†é’¥
        
        Args:
            key_id: å¯†é’¥ID
            
        Returns:
            Optional[Key]: å¯†é’¥
        """
        key = self.keys.get(key_id)
        if key and key.is_expired():
            return None
        return key
    
    def rotate_key(self, old_key_id: str) -> Key:
        """
        è½®æ¢å¯†é’¥
        
        Args:
            old_key_id: æ—§å¯†é’¥ID
            
        Returns:
            Key: æ–°å¯†é’¥
        """
        old_key = self.keys.get(old_key_id)
        if not old_key:
            raise ValueError(f"Key not found: {old_key_id}")
        
        # ç”Ÿæˆæ–°å¯†é’¥
        new_key = self.generate_key(old_key.type)
        
        # æ ‡è®°æ—§å¯†é’¥ä¸ºè¿‡æœŸ
        old_key.expires_at = datetime.now()
        
        return new_key
    
    def revoke_key(self, key_id: str):
        """
        æ’¤é”€å¯†é’¥
        
        Args:
            key_id: å¯†é’¥ID
        """
        if key_id in self.keys:
            self.keys[key_id].expires_at = datetime.now()

class EncryptionSystem:
    """åŠ å¯†ç³»ç»Ÿ"""
    
    def __init__(self):
        self.key_manager = KeyManager()
    
    def encrypt(self, plaintext: bytes, key_id: Optional[str] = None) -> tuple[bytes, str]:
        """
        åŠ å¯†
        
        Args:
            plaintext: æ˜æ–‡
            key_id: å¯†é’¥IDï¼ˆå¯é€‰ï¼‰
            
        Returns:
            tuple[bytes, str]: (å¯†æ–‡, å¯†é’¥ID)
        """
        # è·å–æˆ–ç”Ÿæˆå¯†é’¥
        if key_id:
            key = self.key_manager.get_key(key_id)
            if not key:
                raise ValueError(f"Key not found or expired: {key_id}")
        else:
            key = self.key_manager.generate_key()
        
        # åŠ å¯†
        encryptor = SymmetricEncryptor(key)
        ciphertext = encryptor.encrypt(plaintext)
        
        return ciphertext, key.id
    
    def decrypt(self, ciphertext: bytes, key_id: str) -> bytes:
        """
        è§£å¯†
        
        Args:
            ciphertext: å¯†æ–‡
            key_id: å¯†é’¥ID
            
        Returns:
            bytes: æ˜æ–‡
        """
        # è·å–å¯†é’¥
        key = self.key_manager.get_key(key_id)
        if not key:
            raise ValueError(f"Key not found or expired: {key_id}")
        
        # è§£å¯†
        encryptor = SymmetricEncryptor(key)
        plaintext = encryptor.decrypt(ciphertext)
        
        return plaintext
```

---

## 7. åº”ç”¨æ¡ˆä¾‹ / Application Cases

### 7.1 è½¬æ¢åŠ å¯† / Transformation Encryption

**åœºæ™¯**ï¼šåŠ å¯†è½¬æ¢æ¨¡å‹æ•°æ®

**å®ç°**ï¼š

```python
# åˆ›å»ºåŠ å¯†ç³»ç»Ÿ
encryption_system = EncryptionSystem()

# å®šä¹‰æ•°æ®
model_data = b"Petri net model data"

# åŠ å¯†
ciphertext, key_id = encryption_system.encrypt(model_data)
print(f"å¯†æ–‡é•¿åº¦: {len(ciphertext)} bytes")
print(f"å¯†é’¥ID: {key_id}")

# è§£å¯†
decrypted = encryption_system.decrypt(ciphertext, key_id)
print(f"è§£å¯†åçš„æ•°æ®: {decrypted.decode()}")
```

### 7.2 å¯†é’¥ç®¡ç† / Key Management

**åœºæ™¯**ï¼šç®¡ç†åŠ å¯†å¯†é’¥

**å®ç°**ï¼š

```python
# ç”Ÿæˆå¯†é’¥
key = encryption_system.key_manager.generate_key(expires_in_days=30)
print(f"å¯†é’¥ID: {key.id}")
print(f"è¿‡æœŸæ—¶é—´: {key.expires_at}")

# è½®æ¢å¯†é’¥
new_key = encryption_system.key_manager.rotate_key(key.id)
print(f"æ–°å¯†é’¥ID: {new_key.id}")

# æ’¤é”€å¯†é’¥
encryption_system.key_manager.revoke_key(key.id)
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
