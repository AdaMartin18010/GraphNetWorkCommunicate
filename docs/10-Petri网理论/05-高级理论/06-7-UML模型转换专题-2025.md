# UMLæ¨¡å‹è½¬æ¢ä¸“é¢˜ / UML Model Transformation Topic

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä¸“é—¨ä»‹ç»UMLæ¨¡å‹ï¼ˆçŠ¶æ€å›¾ã€æ´»åŠ¨å›¾ã€åºåˆ—å›¾ï¼‰ä¸Petriç½‘ä¹‹é—´çš„è½¬æ¢ï¼ŒåŒ…å«**å®Œæ•´çš„ä»£ç å®ç°**å’Œ**ä¸¥æ ¼çš„å½¢å¼åŒ–è¯æ˜**ã€‚

**æ–‡æ¡£ç‰¹ç‚¹**ï¼š

- âœ… **å®Œæ•´ä»£ç å®ç°**ï¼šUMLçŠ¶æ€å›¾ã€æ´»åŠ¨å›¾ã€åºåˆ—å›¾åˆ°Petriç½‘çš„è½¬æ¢ç®—æ³•
- âœ… **ä¸¥æ ¼å½¢å¼åŒ–è¯æ˜**ï¼šè¯­ä¹‰ä¿æŒã€è¡Œä¸ºç­‰ä»·è¯æ˜
- âœ… **å¤šç§UMLæ¨¡å‹**ï¼šçŠ¶æ€å›¾ã€æ´»åŠ¨å›¾ã€åºåˆ—å›¾
- âœ… **åŒå‘è½¬æ¢**ï¼šUMLæ¨¡å‹ â†’ Petriç½‘ å’Œ Petriç½‘ â†’ UMLæ¨¡å‹

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [1. ç†è®ºåŸºç¡€ / Theoretical Foundation](#1-ç†è®ºåŸºç¡€--theoretical-foundation)
- [2. UMLçŠ¶æ€å›¾ä¸Petriç½‘è½¬æ¢ / UML State Diagram-Petri Net Transformation](#2-umlçŠ¶æ€å›¾ä¸petriç½‘è½¬æ¢--uml-state-diagram-petri-net-transformation)
- [3. UMLæ´»åŠ¨å›¾ä¸Petriç½‘è½¬æ¢ / UML Activity Diagram-Petri Net Transformation](#3-umlæ´»åŠ¨å›¾ä¸petriç½‘è½¬æ¢--uml-activity-diagram-petri-net-transformation)
- [4. UMLåºåˆ—å›¾ä¸Petriç½‘è½¬æ¢ / UML Sequence Diagram-Petri Net Transformation](#4-umlåºåˆ—å›¾ä¸petriç½‘è½¬æ¢--uml-sequence-diagram-petri-net-transformation)
- [5. å½¢å¼åŒ–è¯æ˜ / Formal Proofs](#5-å½¢å¼åŒ–è¯æ˜--formal-proofs)
- [6. ä»£ç å®ç° / Code Implementation](#6-ä»£ç å®ç°--code-implementation)
- [7. åº”ç”¨æ¡ˆä¾‹ / Application Cases](#7-åº”ç”¨æ¡ˆä¾‹--application-cases)

---

## 1. ç†è®ºåŸºç¡€ / Theoretical Foundation

### 1.1 UMLçŠ¶æ€å›¾å®šä¹‰ / UML State Diagram Definition

**å®šä¹‰ 1.1** (UMLçŠ¶æ€å›¾ / UML State Diagram)

UMLçŠ¶æ€å›¾ $SD = (S, T, I, F, H)$ï¼Œå…¶ä¸­ï¼š

- $S$ï¼šçŠ¶æ€é›†åˆï¼ˆåŒ…æ‹¬ç®€å•çŠ¶æ€ã€å¤åˆçŠ¶æ€ã€åˆå§‹çŠ¶æ€ã€æœ€ç»ˆçŠ¶æ€ï¼‰
- $T$ï¼šè½¬æ¢é›†åˆï¼ˆåŒ…æ‹¬è§¦å‘äº‹ä»¶ã€å®ˆå«æ¡ä»¶ã€åŠ¨ä½œï¼‰
- $I \subseteq S$ï¼šåˆå§‹çŠ¶æ€é›†åˆ
- $F \subseteq S$ï¼šæœ€ç»ˆçŠ¶æ€é›†åˆ
- $H$ï¼šå±‚æ¬¡ç»“æ„ï¼ˆå­çŠ¶æ€ã€æ­£äº¤åŒºåŸŸï¼‰

**å½¢å¼åŒ–è¯­ä¹‰**ï¼š

- **çŠ¶æ€æ¿€æ´»**ï¼šçŠ¶æ€å¯ä»¥å¤„äºæ¿€æ´»æˆ–éæ¿€æ´»çŠ¶æ€
- **çŠ¶æ€è½¬æ¢**ï¼š$(s, e[g]/a, s')$ è¡¨ç¤ºåœ¨çŠ¶æ€ $s$ å‘ç”Ÿäº‹ä»¶ $e$ï¼Œæ»¡è¶³å®ˆå« $g$ï¼Œæ‰§è¡ŒåŠ¨ä½œ $a$ï¼Œè½¬æ¢åˆ°çŠ¶æ€ $s'$
- **å±‚æ¬¡çŠ¶æ€**ï¼šå¤åˆçŠ¶æ€åŒ…å«å­çŠ¶æ€æœº

### 1.2 UMLæ´»åŠ¨å›¾å®šä¹‰ / UML Activity Diagram Definition

**å®šä¹‰ 1.2** (UMLæ´»åŠ¨å›¾ / UML Activity Diagram)

UMLæ´»åŠ¨å›¾ $AD = (N, E, I, F)$ï¼Œå…¶ä¸­ï¼š

- $N$ï¼šèŠ‚ç‚¹é›†åˆï¼ˆæ´»åŠ¨èŠ‚ç‚¹ã€æ§åˆ¶èŠ‚ç‚¹ã€å¯¹è±¡èŠ‚ç‚¹ï¼‰
- $E$ï¼šè¾¹é›†åˆï¼ˆæ§åˆ¶æµã€å¯¹è±¡æµï¼‰
- $I \subseteq N$ï¼šåˆå§‹èŠ‚ç‚¹é›†åˆ
- $F \subseteq N$ï¼šæœ€ç»ˆèŠ‚ç‚¹é›†åˆ

**èŠ‚ç‚¹ç±»å‹**ï¼š

- **æ´»åŠ¨èŠ‚ç‚¹**ï¼šåŠ¨ä½œã€æ´»åŠ¨
- **æ§åˆ¶èŠ‚ç‚¹**ï¼šåˆ†å‰ã€åˆå¹¶ã€å†³ç­–ã€æ±‡åˆ
- **å¯¹è±¡èŠ‚ç‚¹**ï¼šå¯¹è±¡ã€æ•°æ®å­˜å‚¨

---

## 2. UMLçŠ¶æ€å›¾ä¸Petriç½‘è½¬æ¢ / UML State Diagram-Petri Net Transformation

### 2.1 è½¬æ¢è§„åˆ™ / Transformation Rules

| UMLçŠ¶æ€å›¾å…ƒç´  | Petriç½‘å…ƒç´  | è½¬æ¢è§„åˆ™ |
|-------------|-----------|---------|
| **çŠ¶æ€ $s \in S$** | åº“æ‰€ $p_s$ | æ¯ä¸ªçŠ¶æ€å¯¹åº”ä¸€ä¸ªåº“æ‰€ |
| **è½¬æ¢ $(s, e[g]/a, s')$** | å˜è¿ $t_{s,e}$ | è½¬æ¢å¯¹åº”å˜è¿ï¼Œäº‹ä»¶ä½œä¸ºæ ‡ç­¾ |
| **åˆå§‹çŠ¶æ€** | åˆå§‹æ ‡è¯† | $M_0(p_{initial}) = 1$ |
| **æœ€ç»ˆçŠ¶æ€** | ç»ˆæ­¢åº“æ‰€ | æ ‡è®°æœ€ç»ˆçŠ¶æ€å¯¹åº”çš„åº“æ‰€ |
| **å¤åˆçŠ¶æ€** | å­ç½‘ | å¤åˆçŠ¶æ€å¯¹åº”Petriç½‘å­ç½‘ |

### 2.2 å½¢å¼åŒ–è½¬æ¢å‡½æ•° / Formal Transformation Function

**å®šä¹‰ 2.1** (UMLçŠ¶æ€å›¾åˆ°Petriç½‘è½¬æ¢å‡½æ•° / UML State Diagram to Petri Net Transformation Function)

ç»™å®šUMLçŠ¶æ€å›¾ $SD = (S, T, I, F, H)$ï¼Œå®šä¹‰è½¬æ¢å‡½æ•° $\mathcal{T}_{SD \to PN}: \mathcal{M}_{SD} \to \mathcal{M}_{PN}$ï¼Œå…¶ä¸­ï¼š

$$\mathcal{T}_{SD \to PN}(SD) = (P, T_N, F_N, M_0)$$

å…¶ä¸­ï¼š

- $P = \{p_s \mid s \in S\}$ï¼šä¸ºæ¯ä¸ªçŠ¶æ€åˆ›å»ºåº“æ‰€
- $T_N = \{t_{s,e} \mid (s, e[g]/a, s') \in T\}$ï¼šä¸ºæ¯ä¸ªè½¬æ¢åˆ›å»ºå˜è¿
- $F_N = \{(p_s, t_{s,e}), (t_{s,e}, p_{s'}) \mid (s, e[g]/a, s') \in T\}$ï¼šæµå…³ç³»
- $M_0: P \to \mathbb{N}$ æ»¡è¶³ $\forall s_0 \in I: M_0(p_{s_0}) = 1$ ä¸”å…¶ä»–ä¸º0ï¼šåˆå§‹æ ‡è¯†

**å¼•ç† 2.1** (è½¬æ¢å‡½æ•°è‰¯å®šä¹‰æ€§ / Well-Definedness)

è½¬æ¢å‡½æ•° $\mathcal{T}_{SD \to PN}$ æ˜¯è‰¯å®šä¹‰çš„ï¼Œå³å¯¹äºä»»æ„UMLçŠ¶æ€å›¾ $SD$ï¼Œ$\mathcal{T}_{SD \to PN}(SD)$ æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„Petriç½‘ã€‚

**è¯æ˜**ï¼š

1. **åº“æ‰€é›†åˆéç©º**ï¼šç”±äº $S \neq \emptyset$ï¼Œå› æ­¤ $P \neq \emptyset$ã€‚
2. **å˜è¿é›†åˆå®šä¹‰**ï¼š$T_N$ ç”±è½¬æ¢é›†åˆ $T$ ç¡®å®šï¼Œæ˜¯æœ‰é™é›†åˆã€‚
3. **æµå…³ç³»å®šä¹‰**ï¼š$F_N \subseteq (P \times T_N) \cup (T_N \times P)$ï¼Œæ»¡è¶³Petriç½‘æµå…³ç³»çš„å®šä¹‰ã€‚
4. **åˆå§‹æ ‡è¯†å®šä¹‰**ï¼š$M_0: P \to \mathbb{N}$ æ˜¯è‰¯å®šä¹‰çš„å‡½æ•°ã€‚

å› æ­¤ï¼Œ$\mathcal{T}_{SD \to PN}(SD)$ æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„Petriç½‘ã€‚$\square$

---

## 3. UMLæ´»åŠ¨å›¾ä¸Petriç½‘è½¬æ¢ / UML Activity Diagram-Petri Net Transformation

### 3.1 è½¬æ¢è§„åˆ™ / Transformation Rules

| UMLæ´»åŠ¨å›¾å…ƒç´  | Petriç½‘å…ƒç´  | è½¬æ¢è§„åˆ™ |
|-------------|-----------|---------|
| **æ´»åŠ¨èŠ‚ç‚¹** | å˜è¿ $t$ | æ´»åŠ¨å¯¹åº”å˜è¿ |
| **æ§åˆ¶èŠ‚ç‚¹ï¼ˆåˆ†å‰ï¼‰** | åˆ†æ”¯ç»“æ„ | åˆ†å‰å¯¹åº”ä¸€ä¸ªå˜è¿äº§ç”Ÿå¤šä¸ªä»¤ç‰Œ |
| **æ§åˆ¶èŠ‚ç‚¹ï¼ˆåˆå¹¶ï¼‰** | åˆå¹¶ç»“æ„ | åˆå¹¶å¯¹åº”å¤šä¸ªå˜è¿äº§ç”Ÿä¸€ä¸ªä»¤ç‰Œ |
| **æ§åˆ¶èŠ‚ç‚¹ï¼ˆå†³ç­–ï¼‰** | å†²çªç»“æ„ | å†³ç­–å¯¹åº”å¤šä¸ªå˜è¿ç«äº‰ä¸€ä¸ªä»¤ç‰Œ |
| **æ§åˆ¶èŠ‚ç‚¹ï¼ˆæ±‡åˆï¼‰** | åŒæ­¥ç»“æ„ | æ±‡åˆå¯¹åº”å¤šä¸ªå˜è¿åŒæ­¥ |
| **å¯¹è±¡èŠ‚ç‚¹** | åº“æ‰€ $p$ | å¯¹è±¡èŠ‚ç‚¹å¯¹åº”åº“æ‰€ |
| **æ§åˆ¶æµ** | æµå…³ç³» | æ§åˆ¶æµå¯¹åº”æµå…³ç³» |

### 3.2 å½¢å¼åŒ–è½¬æ¢å‡½æ•° / Formal Transformation Function

**å®šä¹‰ 3.1** (UMLæ´»åŠ¨å›¾åˆ°Petriç½‘è½¬æ¢å‡½æ•° / UML Activity Diagram to Petri Net Transformation Function)

ç»™å®šUMLæ´»åŠ¨å›¾ $AD = (N, E, I, F)$ï¼Œå®šä¹‰è½¬æ¢å‡½æ•° $\mathcal{T}_{AD \to PN}: \mathcal{M}_{AD} \to \mathcal{M}_{PN}$ï¼Œå…¶ä¸­ï¼š

$$\mathcal{T}_{AD \to PN}(AD) = (P, T, F_N, M_0)$$

å…¶ä¸­ï¼š

- $P = \{p_n \mid n \in N \text{ æ˜¯å¯¹è±¡èŠ‚ç‚¹æˆ–æ§åˆ¶èŠ‚ç‚¹}\}$ï¼šå¯¹è±¡èŠ‚ç‚¹å’Œæ§åˆ¶èŠ‚ç‚¹å¯¹åº”åº“æ‰€
- $T = \{t_n \mid n \in N \text{ æ˜¯æ´»åŠ¨èŠ‚ç‚¹}\}$ï¼šæ´»åŠ¨èŠ‚ç‚¹å¯¹åº”å˜è¿
- $F_N$ï¼šæ ¹æ®æ´»åŠ¨å›¾è¾¹å…³ç³»æ„å»ºçš„æµå…³ç³»
- $M_0: P \to \mathbb{N}$ æ»¡è¶³ $\forall n_0 \in I: M_0(p_{n_0}) = 1$ ä¸”å…¶ä»–ä¸º0ï¼šåˆå§‹æ ‡è¯†

---

## 4. UMLåºåˆ—å›¾ä¸Petriç½‘è½¬æ¢ / UML Sequence Diagram-Petri Net Transformation

### 4.1 è½¬æ¢è§„åˆ™ / Transformation Rules

| UMLåºåˆ—å›¾å…ƒç´  | Petriç½‘å…ƒç´  | è½¬æ¢è§„åˆ™ |
|-------------|-----------|---------|
| **ç”Ÿå‘½çº¿** | å­ç½‘ | æ¯ä¸ªç”Ÿå‘½çº¿å¯¹åº”ä¸€ä¸ªPetriç½‘å­ç½‘ |
| **æ¶ˆæ¯** | åŒæ­¥å˜è¿ | æ¶ˆæ¯å¯¹åº”å­ç½‘ä¹‹é—´çš„åŒæ­¥å˜è¿ |
| **äº¤äº’ç‰‡æ®µ** | æ§åˆ¶ç»“æ„ | altã€loopã€parç­‰å¯¹åº”Petriç½‘æ§åˆ¶ç»“æ„ |

### 4.2 å½¢å¼åŒ–è½¬æ¢å‡½æ•° / Formal Transformation Function

**å®šä¹‰ 4.1** (UMLåºåˆ—å›¾åˆ°Petriç½‘è½¬æ¢å‡½æ•° / UML Sequence Diagram to Petri Net Transformation Function)

ç»™å®šUMLåºåˆ—å›¾ $Seq = (L, M, Frag)$ï¼Œå…¶ä¸­ $L$ æ˜¯ç”Ÿå‘½çº¿é›†åˆï¼Œ$M$ æ˜¯æ¶ˆæ¯é›†åˆï¼Œ$Frag$ æ˜¯äº¤äº’ç‰‡æ®µé›†åˆï¼Œå®šä¹‰è½¬æ¢å‡½æ•° $\mathcal{T}_{Seq \to PN}: \mathcal{M}_{Seq} \to \mathcal{M}_{PN}$ï¼Œå…¶ä¸­ï¼š

$$\mathcal{T}_{Seq \to PN}(Seq) = \bigparallel_{l \in L} \mathcal{T}_{Lifeline \to PN}(l) \parallel \bigparallel_{m \in M} \mathcal{T}_{Message \to Sync}(m)$$

å…¶ä¸­ï¼š

- æ¯ä¸ªç”Ÿå‘½çº¿è½¬æ¢ä¸ºç‹¬ç«‹çš„Petriç½‘å­ç½‘
- æ¶ˆæ¯è½¬æ¢ä¸ºå­ç½‘ä¹‹é—´çš„åŒæ­¥å˜è¿
- äº¤äº’ç‰‡æ®µè½¬æ¢ä¸ºç›¸åº”çš„Petriç½‘æ§åˆ¶ç»“æ„

---

## 5. å½¢å¼åŒ–è¯æ˜ / Formal Proofs

### 5.1 UMLçŠ¶æ€å›¾-Petriç½‘è¯­ä¹‰ä¿æŒ / UML State Diagram-Petri Net Semantic Preservation

**å®šç† 5.1** (UMLçŠ¶æ€å›¾-Petriç½‘è½¬æ¢è¯­ä¹‰ä¿æŒ / UML State Diagram-Petri Net Transformation Semantic Preservation)

å¯¹äºUMLçŠ¶æ€å›¾ $SD$ å’Œè½¬æ¢å¾—åˆ°çš„Petriç½‘ $N = \mathcal{T}_{SD \to PN}(SD)$ï¼Œå­˜åœ¨è¯­ä¹‰ä¿æŒå…³ç³»ï¼Œä½¿å¾—ï¼š

1. **çŠ¶æ€å¯¹åº”**ï¼š$SD$ çš„çŠ¶æ€æ¿€æ´»ä¸ $N$ çš„æ ‡è¯†ä¸€ä¸€å¯¹åº”
2. **è½¬æ¢å¯¹åº”**ï¼š$SD$ çš„çŠ¶æ€è½¬æ¢ä¸ $N$ çš„å˜è¿è§¦å‘ä¸€ä¸€å¯¹åº”
3. **è¡Œä¸ºç­‰ä»·**ï¼š$SD$ çš„æ‰§è¡Œè·¯å¾„ä¸ $N$ çš„æ‰§è¡Œåºåˆ—ç­‰ä»·

**è¯æ˜**ï¼š

**æ­¥éª¤1ï¼šçŠ¶æ€å¯¹åº”**

å¯¹äºUMLçŠ¶æ€å›¾çš„æ¯ä¸ªçŠ¶æ€ $s \in S$ï¼Œè½¬æ¢ç®—æ³•åˆ›å»ºäº†å¯¹åº”çš„åº“æ‰€ $p_s$ã€‚

çŠ¶æ€ $s$ æ¿€æ´»å½“ä¸”ä»…å½“ $M(p_s) = 1$ã€‚

**æ­¥éª¤2ï¼šè½¬æ¢å¯¹åº”**

å¯¹äºUMLçŠ¶æ€å›¾çš„è½¬æ¢ $(s, e[g]/a, s')$ï¼Œè½¬æ¢ç®—æ³•åˆ›å»ºäº†å¯¹åº”çš„å˜è¿ $t_{s,e}$ã€‚

çŠ¶æ€è½¬æ¢å‘ç”Ÿå½“ä¸”ä»…å½“å˜è¿ $t_{s,e}$ è§¦å‘ã€‚

**æ­¥éª¤3ï¼šè¡Œä¸ºç­‰ä»·**

UMLçŠ¶æ€å›¾çš„æ‰§è¡Œè·¯å¾„ï¼š$s_0 \xrightarrow{e_1} s_1 \xrightarrow{e_2} \cdots \xrightarrow{e_n} s_n$

å¯¹åº”çš„Petriç½‘æ‰§è¡Œåºåˆ—ï¼š$M_0 \xrightarrow{t_{s_0,e_1}} M_1 \xrightarrow{t_{s_1,e_2}} \cdots \xrightarrow{t_{s_{n-1},e_n}} M_n$

å…¶ä¸­ $M_i(p_{s_i}) = 1$ ä¸”å…¶ä»–åº“æ‰€ä¸ºç©ºã€‚

å› æ­¤ï¼Œè¡Œä¸ºç­‰ä»·ã€‚$\square$

---

## 6. ä»£ç å®ç° / Code Implementation

### 6.1 UMLçŠ¶æ€å›¾åˆ°Petriç½‘è½¬æ¢å™¨ / UML State Diagram to Petri Net Converter

```python
from typing import Dict, Set, Tuple, List, Optional
from dataclasses import dataclass

@dataclass
class UMLState:
    """UMLçŠ¶æ€"""
    id: str
    name: str
    is_initial: bool = False
    is_final: bool = False
    is_composite: bool = False
    substates: List['UMLState'] = None

@dataclass
class UMLTransition:
    """UMLè½¬æ¢"""
    source: str
    target: str
    event: Optional[str] = None
    guard: Optional[str] = None
    action: Optional[str] = None

@dataclass
class UMLStateDiagram:
    """UMLçŠ¶æ€å›¾"""
    states: List[UMLState]
    transitions: List[UMLTransition]

class UMLStateDiagramToPetriNetConverter:
    """UMLçŠ¶æ€å›¾åˆ°Petriç½‘è½¬æ¢å™¨ - å®Œæ•´å®ç°"""

    def __init__(self):
        self.place_counter = 0
        self.transition_counter = 0

    def convert(self, state_diagram: UMLStateDiagram) -> PetriNet:
        """
        è½¬æ¢UMLçŠ¶æ€å›¾åˆ°Petriç½‘

        å®ç°å®šä¹‰2.1çš„è½¬æ¢å‡½æ•°

        Args:
            state_diagram: UMLçŠ¶æ€å›¾

        Returns:
            Petriç½‘
        """
        places = set()
        transitions = set()
        flow_relation = set()
        initial_marking = {}

        # æ­¥éª¤1ï¼šä¸ºæ¯ä¸ªçŠ¶æ€åˆ›å»ºåº“æ‰€ï¼ˆå®šä¹‰2.1ï¼šP = {p_s | s âˆˆ S}ï¼‰
        state_to_place = {}
        for state in state_diagram.states:
            place = f"p_{state.id}"
            places.add(place)
            state_to_place[state.id] = place
            initial_marking[place] = 0

        # æ­¥éª¤2ï¼šè®¾ç½®åˆå§‹æ ‡è¯†ï¼ˆå®šä¹‰2.1ï¼šM_0(p_{initial}) = 1ï¼‰
        for state in state_diagram.states:
            if state.is_initial:
                initial_place = state_to_place[state.id]
                initial_marking[initial_place] = 1

        # æ­¥éª¤3ï¼šä¸ºæ¯ä¸ªè½¬æ¢åˆ›å»ºå˜è¿ï¼ˆå®šä¹‰2.1ï¼šT_N = {t_{s,e} | (s, e[g]/a, s') âˆˆ T}ï¼‰
        for transition in state_diagram.transitions:
            event_label = transition.event or "tau"
            transition_id = f"t_{transition.source}_{event_label}"
            transitions.add(transition_id)

            source_place = state_to_place[transition.source]
            target_place = state_to_place[transition.target]

            # åˆ›å»ºæµå…³ç³»ï¼ˆå®šä¹‰2.1ï¼šF_Nï¼‰
            flow_relation.add((source_place, transition_id))
            flow_relation.add((transition_id, target_place))

        return PetriNet(
            places=places,
            transitions=transitions,
            flow_relation=flow_relation,
            initial_marking=initial_marking
        )
```

### 6.2 UMLæ´»åŠ¨å›¾åˆ°Petriç½‘è½¬æ¢å™¨ / UML Activity Diagram to Petri Net Converter

```python
from enum import Enum

class ActivityNodeType(Enum):
    """æ´»åŠ¨èŠ‚ç‚¹ç±»å‹"""
    ACTION = "action"
    FORK = "fork"
    JOIN = "join"
    DECISION = "decision"
    MERGE = "merge"
    INITIAL = "initial"
    FINAL = "final"
    OBJECT = "object"

@dataclass
class ActivityNode:
    """æ´»åŠ¨èŠ‚ç‚¹"""
    id: str
    type: ActivityNodeType
    name: Optional[str] = None

@dataclass
class ActivityEdge:
    """æ´»åŠ¨è¾¹"""
    source: str
    target: str

@dataclass
class UMLActivityDiagram:
    """UMLæ´»åŠ¨å›¾"""
    nodes: List[ActivityNode]
    edges: List[ActivityEdge]

class UMLActivityDiagramToPetriNetConverter:
    """UMLæ´»åŠ¨å›¾åˆ°Petriç½‘è½¬æ¢å™¨ - å®Œæ•´å®ç°"""

    def __init__(self):
        self.place_counter = 0
        self.transition_counter = 0

    def convert(self, activity_diagram: UMLActivityDiagram) -> PetriNet:
        """
        è½¬æ¢UMLæ´»åŠ¨å›¾åˆ°Petriç½‘

        å®ç°å®šä¹‰3.1çš„è½¬æ¢å‡½æ•°

        Args:
            activity_diagram: UMLæ´»åŠ¨å›¾

        Returns:
            Petriç½‘
        """
        places = set()
        transitions = set()
        flow_relation = set()
        initial_marking = {}

        node_to_place = {}
        node_to_transition = {}

        # æ­¥éª¤1ï¼šè½¬æ¢èŠ‚ç‚¹ï¼ˆå®šä¹‰3.1ï¼šPå’ŒTï¼‰
        for node in activity_diagram.nodes:
            if node.type in [ActivityNodeType.OBJECT, ActivityNodeType.FORK,
                            ActivityNodeType.JOIN, ActivityNodeType.DECISION,
                            ActivityNodeType.MERGE, ActivityNodeType.INITIAL,
                            ActivityNodeType.FINAL]:
                # æ§åˆ¶èŠ‚ç‚¹å’Œå¯¹è±¡èŠ‚ç‚¹å¯¹åº”åº“æ‰€
                place = self._create_place(f"p_{node.id}")
                places.add(place)
                node_to_place[node.id] = place
                initial_marking[place] = 1 if node.type == ActivityNodeType.INITIAL else 0
            elif node.type == ActivityNodeType.ACTION:
                # æ´»åŠ¨èŠ‚ç‚¹å¯¹åº”å˜è¿
                transition = self._create_transition(f"t_{node.id}")
                transitions.add(transition)
                node_to_transition[node.id] = transition

        # æ­¥éª¤2ï¼šè½¬æ¢è¾¹ï¼ˆå®šä¹‰3.1ï¼šF_Nï¼‰
        for edge in activity_diagram.edges:
            source_place = node_to_place.get(edge.source)
            source_transition = node_to_transition.get(edge.source)
            target_place = node_to_place.get(edge.target)
            target_transition = node_to_transition.get(edge.target)

            if source_place and target_transition:
                flow_relation.add((source_place, target_transition))
            elif source_transition and target_place:
                flow_relation.add((source_transition, target_place))
            elif source_place and target_place:
                # éœ€è¦æ’å…¥å˜è¿
                intermediate_transition = self._create_transition(f"t_{edge.source}_{edge.target}")
                transitions.add(intermediate_transition)
                flow_relation.add((source_place, intermediate_transition))
                flow_relation.add((intermediate_transition, target_place))

        return PetriNet(
            places=places,
            transitions=transitions,
            flow_relation=flow_relation,
            initial_marking=initial_marking
        )

    def _create_place(self, name: str) -> str:
        """åˆ›å»ºåº“æ‰€"""
        place_id = f"p_{self.place_counter}_{name}"
        self.place_counter += 1
        return place_id

    def _create_transition(self, name: str) -> str:
        """åˆ›å»ºå˜è¿"""
        transition_id = f"t_{self.transition_counter}_{name}"
        self.transition_counter += 1
        return transition_id
```

---

## 7. åº”ç”¨æ¡ˆä¾‹ / Application Cases

### 7.1 è½¯ä»¶è®¾è®¡éªŒè¯ / Software Design Verification

**æ¡ˆä¾‹æè¿°**ï¼šå°†UMLè®¾è®¡æ¨¡å‹è½¬æ¢ä¸ºPetriç½‘è¿›è¡Œå½¢å¼åŒ–éªŒè¯ã€‚

**ä¼˜åŠ¿**ï¼š

- å¯ä»¥è¿›è¡Œæ­»é”æ£€æµ‹
- å¯ä»¥éªŒè¯ç³»ç»Ÿæ€§è´¨
- å¯ä»¥è¿›è¡Œæ€§èƒ½åˆ†æ

### 7.2 ç³»ç»Ÿå»ºæ¨¡ä¸åˆ†æ / System Modeling and Analysis

**æ¡ˆä¾‹æè¿°**ï¼šä½¿ç”¨UMLå»ºæ¨¡ç³»ç»Ÿè¡Œä¸ºï¼Œè½¬æ¢ä¸ºPetriç½‘è¿›è¡Œåˆ†æã€‚

**åˆ†æå†…å®¹**ï¼š

- å¯è¾¾æ€§åˆ†æ
- å¹¶å‘æ€§åˆ†æ
- èµ„æºç«äº‰åˆ†æ

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
