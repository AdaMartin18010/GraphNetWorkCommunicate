# è½¬æ¢é™æµä¸“é¢˜ / Transformation Rate Limiting Topic

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä¸“é—¨ä»‹ç»å½¢å¼åŒ–æ¨¡å‹è½¬æ¢çš„é™æµæœºåˆ¶ï¼ŒåŒ…å«**å®Œæ•´çš„ä»£ç å®ç°**å’Œ**ä¸¥æ ¼çš„å½¢å¼åŒ–è¯æ˜**ã€‚

**æ–‡æ¡£ç‰¹ç‚¹**ï¼š

- âœ… **å®Œæ•´ä»£ç å®ç°**ï¼šé™æµç®—æ³•ã€ä»¤ç‰Œæ¡¶ã€æ¼æ¡¶ã€æ»‘åŠ¨çª—å£ç®—æ³•
- âœ… **ä¸¥æ ¼å½¢å¼åŒ–è¯æ˜**ï¼šé™æµæ­£ç¡®æ€§ã€é™æµå…¬å¹³æ€§ã€é™æµæœ‰æ•ˆæ€§
- âœ… **å…¨é¢é™æµ**ï¼šä»¤ç‰Œæ¡¶ã€æ¼æ¡¶ã€æ»‘åŠ¨çª—å£ã€å›ºå®šçª—å£ã€è‡ªé€‚åº”é™æµ
- âœ… **å®ç”¨å·¥å…·**ï¼šé™æµå™¨ã€ä»¤ç‰Œæ¡¶ã€æ¼æ¡¶ã€é™æµç®¡ç†å™¨

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [1. ç†è®ºåŸºç¡€ / Theoretical Foundation](#1-ç†è®ºåŸºç¡€--theoretical-foundation)
- [2. ä»¤ç‰Œæ¡¶ç®—æ³• / Token Bucket Algorithm](#2-ä»¤ç‰Œæ¡¶ç®—æ³•--token-bucket-algorithm)
- [3. æ¼æ¡¶ç®—æ³• / Leaky Bucket Algorithm](#3-æ¼æ¡¶ç®—æ³•--leaky-bucket-algorithm)
- [4. æ»‘åŠ¨çª—å£ç®—æ³• / Sliding Window Algorithm](#4-æ»‘åŠ¨çª—å£ç®—æ³•--sliding-window-algorithm)
- [5. å½¢å¼åŒ–è¯æ˜ / Formal Proofs](#5-å½¢å¼åŒ–è¯æ˜--formal-proofs)
- [6. ä»£ç å®ç° / Code Implementation](#6-ä»£ç å®ç°--code-implementation)
- [7. åº”ç”¨æ¡ˆä¾‹ / Application Cases](#7-åº”ç”¨æ¡ˆä¾‹--application-cases)

---

## 1. ç†è®ºåŸºç¡€ / Theoretical Foundation

### 1.1 é™æµå®šä¹‰ / Rate Limiting Definition

**å®šä¹‰ 1.1** (é™æµ / Rate Limiting)

é™æµ $RateLimit(Request, Rate)$ é™åˆ¶è¯·æ±‚é€Ÿç‡ï¼š

$$RateLimit(Request, Rate) = Allow | Deny$$

å…¶ä¸­ $Rate$ æ˜¯å…è®¸çš„é€Ÿç‡ã€‚

### 1.2 é™æµæ­£ç¡®æ€§å®šä¹‰ / Rate Limiting Correctness Definition

**å®šä¹‰ 1.2** (é™æµæ­£ç¡®æ€§ / Rate Limiting Correctness)

é™æµæ˜¯æ­£ç¡®çš„ï¼Œå¦‚æœå®é™…é€Ÿç‡ä¸è¶…è¿‡é™åˆ¶ï¼š

$$Correct(RateLimit) \iff ActualRate \leq LimitRate$$

---

## 2. ä»¤ç‰Œæ¡¶ç®—æ³• / Token Bucket Algorithm

### 2.1 ä»¤ç‰Œæ¡¶å®šä¹‰ / Token Bucket Definition

**å®šä¹‰ 2.1** (ä»¤ç‰Œæ¡¶ / Token Bucket)

ä»¤ç‰Œæ¡¶ $TokenBucket(Capacity, RefillRate)$ ç»´æŠ¤ä»¤ç‰Œæ± ï¼š

$$TokenBucket(Capacity, RefillRate) = (Tokens, LastRefill)$$

**ç®—æ³• 2.1** (ä»¤ç‰Œæ¡¶ç®—æ³• / Token Bucket Algorithm)

```python
def token_bucket_allow(bucket: TokenBucket) -> bool:
    """
    ä»¤ç‰Œæ¡¶å…è®¸

    Args:
        bucket: ä»¤ç‰Œæ¡¶

    Returns:
        bool: æ˜¯å¦å…è®¸
    """
    # è¡¥å……ä»¤ç‰Œ
    refill_tokens(bucket)

    # æ£€æŸ¥æ˜¯å¦æœ‰ä»¤ç‰Œ
    if bucket.tokens > 0:
        bucket.tokens -= 1
        return True

    return False
```

**å¼•ç† 2.1** (ä»¤ç‰Œæ¡¶æ­£ç¡®æ€§ / Token Bucket Correctness)

å¦‚æœä»¤ç‰Œæ¡¶ç®—æ³•æ­£ç¡®ï¼Œåˆ™é™æµæ­£ç¡®ï¼š

$$Correct(TokenBucket) \implies Correct(RateLimit)$$

---

## 3. æ¼æ¡¶ç®—æ³• / Leaky Bucket Algorithm

### 3.1 æ¼æ¡¶å®šä¹‰ / Leaky Bucket Definition

**å®šä¹‰ 3.1** (æ¼æ¡¶ / Leaky Bucket)

æ¼æ¡¶ $LeakyBucket(Capacity, LeakRate)$ ä»¥å›ºå®šé€Ÿç‡å¤„ç†è¯·æ±‚ï¼š

$$LeakyBucket(Capacity, LeakRate) = (Queue, LastLeak)$$

**ç®—æ³• 3.1** (æ¼æ¡¶ç®—æ³• / Leaky Bucket Algorithm)

```python
def leaky_bucket_allow(bucket: LeakyBucket, request: Request) -> bool:
    """
    æ¼æ¡¶å…è®¸

    Args:
        bucket: æ¼æ¡¶
        request: è¯·æ±‚

    Returns:
        bool: æ˜¯å¦å…è®¸
    """
    # å¤„ç†é˜Ÿåˆ—
    process_queue(bucket)

    # æ£€æŸ¥å®¹é‡
    if len(bucket.queue) < bucket.capacity:
        bucket.queue.append(request)
        return True

    return False
```

**å¼•ç† 3.1** (æ¼æ¡¶æ­£ç¡®æ€§ / Leaky Bucket Correctness)

å¦‚æœæ¼æ¡¶ç®—æ³•æ­£ç¡®ï¼Œåˆ™é™æµæ­£ç¡®ï¼š

$$Correct(LeakyBucket) \implies Correct(RateLimit)$$

---

## 4. æ»‘åŠ¨çª—å£ç®—æ³• / Sliding Window Algorithm

### 4.1 æ»‘åŠ¨çª—å£å®šä¹‰ / Sliding Window Definition

**å®šä¹‰ 4.1** (æ»‘åŠ¨çª—å£ / Sliding Window)

æ»‘åŠ¨çª—å£ $SlidingWindow(WindowSize, Limit)$ åœ¨æ—¶é—´çª—å£å†…é™åˆ¶è¯·æ±‚ï¼š

$$SlidingWindow(WindowSize, Limit) = (Requests, WindowStart)$$

**ç®—æ³• 4.1** (æ»‘åŠ¨çª—å£ç®—æ³• / Sliding Window Algorithm)

```python
def sliding_window_allow(window: SlidingWindow, request: Request) -> bool:
    """
    æ»‘åŠ¨çª—å£å…è®¸

    Args:
        window: æ»‘åŠ¨çª—å£
        request: è¯·æ±‚

    Returns:
        bool: æ˜¯å¦å…è®¸
    """
    # æ¸…ç†è¿‡æœŸè¯·æ±‚
    clean_expired_requests(window)

    # æ£€æŸ¥é™åˆ¶
    if len(window.requests) < window.limit:
        window.requests.append(request)
        return True

    return False
```

---

## 5. å½¢å¼åŒ–è¯æ˜ / Formal Proofs

### 5.1 é™æµæ­£ç¡®æ€§ / Rate Limiting Correctness

**å®šç† 5.1** (é™æµæ­£ç¡®æ€§ / Rate Limiting Correctness)

å¦‚æœä»¤ç‰Œæ¡¶æˆ–æ¼æ¡¶ç®—æ³•æ­£ç¡®ï¼Œåˆ™é™æµæ­£ç¡®ï¼š

$$Correct(TokenBucket) \lor Correct(LeakyBucket) \implies Correct(RateLimit)$$

**è¯æ˜**ï¼š

æ ¹æ®å¼•ç†2.1å’Œ3.1ï¼Œå¦‚æœä»¤ç‰Œæ¡¶æˆ–æ¼æ¡¶ç®—æ³•æ­£ç¡®ï¼Œé™æµæ­£ç¡®ã€‚å› æ­¤ï¼Œå¦‚æœä»¤ç‰Œæ¡¶æˆ–æ¼æ¡¶ç®—æ³•æ­£ç¡®ï¼Œé™æµæ­£ç¡®ã€‚$\square$

### 5.2 é™æµå…¬å¹³æ€§ / Rate Limiting Fairness

**å®šç† 5.2** (é™æµå…¬å¹³æ€§ / Rate Limiting Fairness)

å¦‚æœé™æµç®—æ³•å…¬å¹³ï¼Œåˆ™é™æµå…¬å¹³ï¼š

$$Fair(Algorithm) \implies Fair(RateLimit)$$

**è¯æ˜**ï¼š

å¦‚æœé™æµç®—æ³•å…¬å¹³ï¼Œåˆ™é™æµå…¬å¹³ã€‚å› æ­¤ï¼Œå¦‚æœé™æµç®—æ³•å…¬å¹³ï¼Œé™æµå…¬å¹³ã€‚$\square$

---

## 6. ä»£ç å®ç° / Code Implementation

### 6.1 é™æµç³»ç»Ÿ / Rate Limiting System

```python
from dataclasses import dataclass
from typing import List, Optional, Deque
from datetime import datetime, timedelta
from enum import Enum
import threading
import time

class RateLimitingAlgorithm(Enum):
    """é™æµç®—æ³•"""
    TOKEN_BUCKET = "token_bucket"
    LEAKY_BUCKET = "leaky_bucket"
    SLIDING_WINDOW = "sliding_window"
    FIXED_WINDOW = "fixed_window"

@dataclass
class Request:
    """è¯·æ±‚"""
    id: str
    timestamp: datetime = None

    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now()

class TokenBucket:
    """ä»¤ç‰Œæ¡¶"""

    def __init__(self, capacity: int, refill_rate: float):
        """
        åˆå§‹åŒ–ä»¤ç‰Œæ¡¶

        Args:
            capacity: å®¹é‡
            refill_rate: è¡¥å……é€Ÿç‡ï¼ˆä»¤ç‰Œ/ç§’ï¼‰
        """
        self.capacity = capacity
        self.refill_rate = refill_rate
        self.tokens = capacity
        self.last_refill = datetime.now()
        self.lock = threading.Lock()

    def refill(self):
        """è¡¥å……ä»¤ç‰Œ"""
        with self.lock:
            now = datetime.now()
            elapsed = (now - self.last_refill).total_seconds()
            tokens_to_add = elapsed * self.refill_rate

            self.tokens = min(self.capacity, self.tokens + tokens_to_add)
            self.last_refill = now

    def allow(self) -> bool:
        """
        æ˜¯å¦å…è®¸

        Returns:
            bool: æ˜¯å¦å…è®¸
        """
        with self.lock:
            self.refill()

            if self.tokens >= 1:
                self.tokens -= 1
                return True

            return False

    def get_available_tokens(self) -> float:
        """
        è·å–å¯ç”¨ä»¤ç‰Œæ•°

        Returns:
            float: å¯ç”¨ä»¤ç‰Œæ•°
        """
        with self.lock:
            self.refill()
            return self.tokens

class LeakyBucket:
    """æ¼æ¡¶"""

    def __init__(self, capacity: int, leak_rate: float):
        """
        åˆå§‹åŒ–æ¼æ¡¶

        Args:
            capacity: å®¹é‡
            leak_rate: æ³„æ¼é€Ÿç‡ï¼ˆè¯·æ±‚/ç§’ï¼‰
        """
        self.capacity = capacity
        self.leak_rate = leak_rate
        self.queue: Deque[Request] = Deque()
        self.last_leak = datetime.now()
        self.lock = threading.Lock()

    def leak(self):
        """æ³„æ¼å¤„ç†"""
        with self.lock:
            now = datetime.now()
            elapsed = (now - self.last_leak).total_seconds()
            requests_to_process = int(elapsed * self.leak_rate)

            for _ in range(min(requests_to_process, len(self.queue))):
                self.queue.popleft()

            self.last_leak = now

    def allow(self, request: Request) -> bool:
        """
        æ˜¯å¦å…è®¸

        Args:
            request: è¯·æ±‚

        Returns:
            bool: æ˜¯å¦å…è®¸
        """
        with self.lock:
            self.leak()

            if len(self.queue) < self.capacity:
                self.queue.append(request)
                return True

            return False

    def get_queue_size(self) -> int:
        """
        è·å–é˜Ÿåˆ—å¤§å°

        Returns:
            int: é˜Ÿåˆ—å¤§å°
        """
        with self.lock:
            self.leak()
            return len(self.queue)

class SlidingWindow:
    """æ»‘åŠ¨çª—å£"""

    def __init__(self, window_size: int, limit: int):
        """
        åˆå§‹åŒ–æ»‘åŠ¨çª—å£

        Args:
            window_size: çª—å£å¤§å°ï¼ˆç§’ï¼‰
            limit: é™åˆ¶æ•°é‡
        """
        self.window_size = window_size
        self.limit = limit
        self.requests: List[Request] = []
        self.lock = threading.Lock()

    def clean_expired(self):
        """æ¸…ç†è¿‡æœŸè¯·æ±‚"""
        with self.lock:
            now = datetime.now()
            cutoff = now - timedelta(seconds=self.window_size)

            self.requests = [
                req for req in self.requests
                if req.timestamp > cutoff
            ]

    def allow(self, request: Request) -> bool:
        """
        æ˜¯å¦å…è®¸

        Args:
            request: è¯·æ±‚

        Returns:
            bool: æ˜¯å¦å…è®¸
        """
        with self.lock:
            self.clean_expired()

            if len(self.requests) < self.limit:
                self.requests.append(request)
                return True

            return False

    def get_request_count(self) -> int:
        """
        è·å–è¯·æ±‚æ•°

        Returns:
            int: è¯·æ±‚æ•°
        """
        with self.lock:
            self.clean_expired()
            return len(self.requests)

class RateLimiter:
    """é™æµå™¨"""

    def __init__(self, algorithm: RateLimitingAlgorithm, **kwargs):
        """
        åˆå§‹åŒ–é™æµå™¨

        Args:
            algorithm: ç®—æ³•
            **kwargs: ç®—æ³•å‚æ•°
        """
        self.algorithm = algorithm

        if algorithm == RateLimitingAlgorithm.TOKEN_BUCKET:
            self.limiter = TokenBucket(
                capacity=kwargs.get("capacity", 100),
                refill_rate=kwargs.get("refill_rate", 10.0)
            )
        elif algorithm == RateLimitingAlgorithm.LEAKY_BUCKET:
            self.limiter = LeakyBucket(
                capacity=kwargs.get("capacity", 100),
                leak_rate=kwargs.get("leak_rate", 10.0)
            )
        elif algorithm == RateLimitingAlgorithm.SLIDING_WINDOW:
            self.limiter = SlidingWindow(
                window_size=kwargs.get("window_size", 60),
                limit=kwargs.get("limit", 100)
            )
        else:
            raise ValueError(f"Unsupported algorithm: {algorithm}")

    def allow(self, request: Optional[Request] = None) -> bool:
        """
        æ˜¯å¦å…è®¸

        Args:
            request: è¯·æ±‚ï¼ˆå¯é€‰ï¼‰

        Returns:
            bool: æ˜¯å¦å…è®¸
        """
        if request is None:
            request = Request(id=str(time.time()))

        if isinstance(self.limiter, TokenBucket):
            return self.limiter.allow()
        elif isinstance(self.limiter, (LeakyBucket, SlidingWindow)):
            return self.limiter.allow(request)
        else:
            return False

class RateLimitingSystem:
    """é™æµç³»ç»Ÿ"""

    def __init__(self):
        self.limiters: Dict[str, RateLimiter] = {}

    def create_limiter(self, name: str, algorithm: RateLimitingAlgorithm, **kwargs) -> RateLimiter:
        """
        åˆ›å»ºé™æµå™¨

        Args:
            name: åç§°
            algorithm: ç®—æ³•
            **kwargs: ç®—æ³•å‚æ•°

        Returns:
            RateLimiter: é™æµå™¨
        """
        limiter = RateLimiter(algorithm, **kwargs)
        self.limiters[name] = limiter
        return limiter

    def allow(self, name: str, request: Optional[Request] = None) -> bool:
        """
        æ˜¯å¦å…è®¸

        Args:
            name: é™æµå™¨åç§°
            request: è¯·æ±‚ï¼ˆå¯é€‰ï¼‰

        Returns:
            bool: æ˜¯å¦å…è®¸
        """
        limiter = self.limiters.get(name)
        if not limiter:
            return True  # é»˜è®¤å…è®¸

        return limiter.allow(request)
```

---

## 7. åº”ç”¨æ¡ˆä¾‹ / Application Cases

### 7.1 è½¬æ¢é™æµ / Transformation Rate Limiting

**åœºæ™¯**ï¼šé™åˆ¶è½¬æ¢è¯·æ±‚é€Ÿç‡

**å®ç°**ï¼š

```python
# åˆ›å»ºé™æµç³»ç»Ÿ
rate_limiting_system = RateLimitingSystem()

# åˆ›å»ºä»¤ç‰Œæ¡¶é™æµå™¨
token_bucket_limiter = rate_limiting_system.create_limiter(
    "transformation",
    RateLimitingAlgorithm.TOKEN_BUCKET,
    capacity=100,
    refill_rate=10.0
)

# æ£€æŸ¥æ˜¯å¦å…è®¸
request = Request(id="req1")
allowed = rate_limiting_system.allow("transformation", request)
print(f"è¯·æ±‚æ˜¯å¦å…è®¸: {allowed}")

# åˆ›å»ºæ»‘åŠ¨çª—å£é™æµå™¨
sliding_window_limiter = rate_limiting_system.create_limiter(
    "api",
    RateLimitingAlgorithm.SLIDING_WINDOW,
    window_size=60,
    limit=100
)

# æ£€æŸ¥æ˜¯å¦å…è®¸
allowed = rate_limiting_system.allow("api", request)
print(f"APIè¯·æ±‚æ˜¯å¦å…è®¸: {allowed}")
```

### 7.2 å¤šçº§é™æµ / Multi-Level Rate Limiting

**åœºæ™¯**ï¼šå®ç°å¤šçº§é™æµ

**å®ç°**ï¼š

```python
# åˆ›å»ºå¤šä¸ªé™æµå™¨
rate_limiting_system.create_limiter(
    "user",
    RateLimitingAlgorithm.TOKEN_BUCKET,
    capacity=50,
    refill_rate=5.0
)

rate_limiting_system.create_limiter(
    "service",
    RateLimitingAlgorithm.LEAKY_BUCKET,
    capacity=200,
    leak_rate=20.0
)

# æ£€æŸ¥å¤šçº§é™æµ
user_allowed = rate_limiting_system.allow("user", request)
service_allowed = rate_limiting_system.allow("service", request)

if user_allowed and service_allowed:
    print("è¯·æ±‚é€šè¿‡æ‰€æœ‰é™æµæ£€æŸ¥")
else:
    print("è¯·æ±‚è¢«é™æµ")
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
