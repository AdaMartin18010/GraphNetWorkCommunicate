# æ¦‚ç‡æ¨¡å‹è½¬æ¢ä¸“é¢˜ / Probabilistic Model Transformation Topic

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä¸“é—¨ä»‹ç»æ¦‚ç‡æ¨¡å‹ï¼ˆæ¦‚ç‡è‡ªåŠ¨æœºã€éšæœºPetriç½‘ã€é©¬å°”å¯å¤«é“¾ï¼‰ä¸Petriç½‘ä¹‹é—´çš„è½¬æ¢ï¼ŒåŒ…å«**å®Œæ•´çš„ä»£ç å®ç°**å’Œ**ä¸¥æ ¼çš„å½¢å¼åŒ–è¯æ˜**ã€‚

**æ–‡æ¡£ç‰¹ç‚¹**ï¼š

- âœ… **å®Œæ•´ä»£ç å®ç°**ï¼šæ¦‚ç‡è‡ªåŠ¨æœºã€éšæœºPetriç½‘ã€é©¬å°”å¯å¤«é“¾çš„è½¬æ¢ç®—æ³•
- âœ… **ä¸¥æ ¼å½¢å¼åŒ–è¯æ˜**ï¼šæ¦‚ç‡è¯­ä¹‰ä¿æŒã€è¡Œä¸ºç­‰ä»·è¯æ˜
- âœ… **å¤šç§æ¦‚ç‡æ¨¡å‹**ï¼šæ¦‚ç‡è‡ªåŠ¨æœºã€éšæœºPetriç½‘ã€é©¬å°”å¯å¤«é“¾
- âœ… **åŒå‘è½¬æ¢**ï¼šæ¦‚ç‡æ¨¡å‹ â†’ Petriç½‘ å’Œ Petriç½‘ â†’ æ¦‚ç‡æ¨¡å‹

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [1. ç†è®ºåŸºç¡€ / Theoretical Foundation](#1-ç†è®ºåŸºç¡€--theoretical-foundation)
- [2. æ¦‚ç‡è‡ªåŠ¨æœºä¸éšæœºPetriç½‘è½¬æ¢ / Probabilistic Automaton-Stochastic Petri Net Transformation](#2-æ¦‚ç‡è‡ªåŠ¨æœºä¸éšæœºpetriç½‘è½¬æ¢--probabilistic-automaton-stochastic-petri-net-transformation)
- [3. éšæœºPetriç½‘ä¸é©¬å°”å¯å¤«é“¾è½¬æ¢ / Stochastic Petri Net-Markov Chain Transformation](#3-éšæœºpetriç½‘ä¸é©¬å°”å¯å¤«é“¾è½¬æ¢--stochastic-petri-net-markov-chain-transformation)
- [4. å½¢å¼åŒ–è¯æ˜ / Formal Proofs](#4-å½¢å¼åŒ–è¯æ˜--formal-proofs)
- [5. ä»£ç å®ç° / Code Implementation](#5-ä»£ç å®ç°--code-implementation)
- [6. åº”ç”¨æ¡ˆä¾‹ / Application Cases](#6-åº”ç”¨æ¡ˆä¾‹--application-cases)

---

## 1. ç†è®ºåŸºç¡€ / Theoretical Foundation

### 1.1 æ¦‚ç‡è‡ªåŠ¨æœºå®šä¹‰ / Probabilistic Automaton Definition

**å®šä¹‰ 1.1** (æ¦‚ç‡è‡ªåŠ¨æœº / Probabilistic Automaton)

æ¦‚ç‡è‡ªåŠ¨æœº $PA = (Q, \Sigma, \delta, q_0, F)$ï¼Œå…¶ä¸­ï¼š

- $Q$ï¼šçŠ¶æ€é›†åˆ
- $\Sigma$ï¼šè¾“å…¥å­—æ¯è¡¨
- $\delta: Q \times \Sigma \times Q \to [0,1]$ï¼šæ¦‚ç‡è½¬ç§»å‡½æ•°
  - $\sum_{q' \in Q} \delta(q, a, q') = 1$ï¼ˆæ¦‚ç‡å½’ä¸€åŒ–ï¼‰
- $q_0 \in Q$ï¼šåˆå§‹çŠ¶æ€
- $F \subseteq Q$ï¼šæ¥å—çŠ¶æ€é›†åˆ

**å½¢å¼åŒ–è¯­ä¹‰**ï¼š

- **æ¦‚ç‡è½¬ç§»**ï¼š$\delta(q, a, q')$ è¡¨ç¤ºåœ¨çŠ¶æ€ $q$ è¯»å…¥ç¬¦å· $a$ è½¬ç§»åˆ°çŠ¶æ€ $q'$ çš„æ¦‚ç‡
- **æ‰§è¡Œè·¯å¾„æ¦‚ç‡**ï¼š$P(q_0 \xrightarrow{a_1} q_1 \xrightarrow{a_2} \cdots \xrightarrow{a_n} q_n) = \prod_{i=1}^{n} \delta(q_{i-1}, a_i, q_i)$

### 1.2 éšæœºPetriç½‘å®šä¹‰ / Stochastic Petri Net Definition

**å®šä¹‰ 1.2** (éšæœºPetriç½‘ / Stochastic Petri Net)

éšæœºPetriç½‘ $SPN = (P, T, F, M_0, \Lambda)$ï¼Œå…¶ä¸­ï¼š

- $(P, T, F, M_0)$ï¼šåŸºç¡€Petriç½‘
- $\Lambda: T \to \mathbb{R}^+$ï¼šå˜è¿é€Ÿç‡å‡½æ•°
  - å˜è¿ $t$ çš„è§¦å‘æ—¶é—´æœä»æŒ‡æ•°åˆ†å¸ƒï¼Œå‚æ•°ä¸º $\Lambda(t)$

**å½¢å¼åŒ–è¯­ä¹‰**ï¼š

- **å˜è¿è§¦å‘æ¦‚ç‡**ï¼šå½“å¤šä¸ªå˜è¿å¯è§¦å‘æ—¶ï¼Œå˜è¿ $t$ è¢«é€‰æ‹©çš„æ¦‚ç‡ä¸º $P(t) = \frac{\Lambda(t)}{\sum_{t' \in \text{enabled}} \Lambda(t')}$
- **æ‰§è¡Œè·¯å¾„æ¦‚ç‡**ï¼šè·¯å¾„çš„æ¦‚ç‡ç”±å˜è¿é€‰æ‹©æ¦‚ç‡çš„ä¹˜ç§¯ç»™å‡º

### 1.3 é©¬å°”å¯å¤«é“¾å®šä¹‰ / Markov Chain Definition

**å®šä¹‰ 1.3** (è¿ç»­æ—¶é—´é©¬å°”å¯å¤«é“¾ / Continuous-Time Markov Chain)

è¿ç»­æ—¶é—´é©¬å°”å¯å¤«é“¾ $CTMC = (S, Q, \pi_0)$ï¼Œå…¶ä¸­ï¼š

- $S$ï¼šçŠ¶æ€é›†åˆ
- $Q: S \times S \to \mathbb{R}$ï¼šé€Ÿç‡çŸ©é˜µï¼ˆ$Q(s, s') \geq 0$ å¯¹äº $s \neq s'$ï¼Œ$Q(s, s) = -\sum_{s' \neq s} Q(s, s')$ï¼‰
- $\pi_0: S \to [0,1]$ï¼šåˆå§‹æ¦‚ç‡åˆ†å¸ƒ

**å½¢å¼åŒ–è¯­ä¹‰**ï¼š

- **çŠ¶æ€è½¬ç§»é€Ÿç‡**ï¼š$Q(s, s')$ è¡¨ç¤ºä»çŠ¶æ€ $s$ è½¬ç§»åˆ°çŠ¶æ€ $s'$ çš„é€Ÿç‡
- **åœç•™æ—¶é—´**ï¼šåœ¨çŠ¶æ€ $s$ çš„åœç•™æ—¶é—´æœä»æŒ‡æ•°åˆ†å¸ƒï¼Œå‚æ•°ä¸º $-Q(s, s)$

---

## 2. æ¦‚ç‡è‡ªåŠ¨æœºä¸éšæœºPetriç½‘è½¬æ¢ / Probabilistic Automaton-Stochastic Petri Net Transformation

### 2.1 è½¬æ¢è§„åˆ™ / Transformation Rules

| æ¦‚ç‡è‡ªåŠ¨æœºå…ƒç´  | éšæœºPetriç½‘å…ƒç´  | è½¬æ¢è§„åˆ™ |
|-------------|--------------|---------|
| **çŠ¶æ€ $q \in Q$** | åº“æ‰€ $p_q$ | æ¯ä¸ªçŠ¶æ€å¯¹åº”ä¸€ä¸ªåº“æ‰€ |
| **æ¦‚ç‡è½¬ç§» $\delta(q, a, q')$** | å˜è¿ $t_{q,a,q'}$ | è½¬ç§»å¯¹åº”å˜è¿ï¼Œé€Ÿç‡ç”±æ¦‚ç‡è®¡ç®— |
| **åˆå§‹çŠ¶æ€ $q_0$** | åˆå§‹æ ‡è¯† | $M_0(p_{q_0}) = 1$ |

### 2.2 å½¢å¼åŒ–è½¬æ¢å‡½æ•° / Formal Transformation Function

**å®šä¹‰ 2.1** (æ¦‚ç‡è‡ªåŠ¨æœºåˆ°éšæœºPetriç½‘è½¬æ¢å‡½æ•° / Probabilistic Automaton to Stochastic Petri Net Transformation Function)

ç»™å®šæ¦‚ç‡è‡ªåŠ¨æœº $PA = (Q, \Sigma, \delta, q_0, F)$ï¼Œå®šä¹‰è½¬æ¢å‡½æ•° $\mathcal{T}_{PA \to SPN}: \mathcal{M}_{PA} \to \mathcal{M}_{SPN}$ï¼Œå…¶ä¸­ï¼š

$$\mathcal{T}_{PA \to SPN}(PA) = (P, T, F_N, M_0, \Lambda)$$

å…¶ä¸­ï¼š

- $P = \{p_q \mid q \in Q\}$ï¼šä¸ºæ¯ä¸ªçŠ¶æ€åˆ›å»ºåº“æ‰€
- $T = \{t_{q,a,q'} \mid q, q' \in Q, a \in \Sigma, \delta(q, a, q') > 0\}$ï¼šä¸ºæ¯ä¸ªéé›¶æ¦‚ç‡è½¬ç§»åˆ›å»ºå˜è¿
- $F_N = \{(p_q, t_{q,a,q'}), (t_{q,a,q'}, p_{q'}) \mid \delta(q, a, q') > 0\}$ï¼šæµå…³ç³»
- $M_0(p_{q_0}) = 1$ ä¸” $\forall q \neq q_0: M_0(p_q) = 0$ï¼šåˆå§‹æ ‡è¯†
- $\Lambda(t_{q,a,q'}) = \lambda \cdot \delta(q, a, q')$ï¼šå˜è¿é€Ÿç‡ï¼Œå…¶ä¸­ $\lambda > 0$ æ˜¯æ—¶é—´å°ºåº¦å‚æ•°

**å¼•ç† 2.1** (è½¬æ¢å‡½æ•°è‰¯å®šä¹‰æ€§ / Well-Definedness)

è½¬æ¢å‡½æ•° $\mathcal{T}_{PA \to SPN}$ æ˜¯è‰¯å®šä¹‰çš„ï¼Œå³å¯¹äºä»»æ„æ¦‚ç‡è‡ªåŠ¨æœº $PA$ï¼Œ$\mathcal{T}_{PA \to SPN}(PA)$ æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„éšæœºPetriç½‘ã€‚

**è¯æ˜**ï¼š

1. **åŸºç¡€Petriç½‘æœ‰æ•ˆæ€§**ï¼š$(P, T, F_N, M_0)$ æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„Petriç½‘ã€‚
2. **é€Ÿç‡å‡½æ•°å®šä¹‰**ï¼š$\Lambda: T \to \mathbb{R}^+$ æ˜¯è‰¯å®šä¹‰çš„å‡½æ•°ï¼Œå› ä¸ºå¯¹äºæ¯ä¸ª $t_{q,a,q'} \in T$ï¼Œæœ‰ $\delta(q, a, q') > 0$ï¼Œå› æ­¤ $\Lambda(t_{q,a,q'}) = \lambda \cdot \delta(q, a, q') > 0$ã€‚

å› æ­¤ï¼Œ$\mathcal{T}_{PA \to SPN}(PA)$ æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„éšæœºPetriç½‘ã€‚$\square$

---

## 3. éšæœºPetriç½‘ä¸é©¬å°”å¯å¤«é“¾è½¬æ¢ / Stochastic Petri Net-Markov Chain Transformation

### 3.1 è½¬æ¢æ–¹æ³• / Transformation Method

**è½¬æ¢æ€è·¯**ï¼šé€šè¿‡å¯è¾¾æ€§å›¾æ„é€ è¿ç»­æ—¶é—´é©¬å°”å¯å¤«é“¾ï¼ˆCTMCï¼‰

**å®šä¹‰ 3.1** (éšæœºPetriç½‘å¯è¾¾æ€§å›¾ / Stochastic Petri Net Reachability Graph)

ç»™å®šéšæœºPetriç½‘ $SPN = (P, T, F, M_0, \Lambda)$ï¼Œå…¶**å¯è¾¾æ€§å›¾**æ˜¯ä¸€ä¸ªæ ‡è®°è½¬æ¢ç³»ç»Ÿ $RG(SPN) = (S, s_0, L, \to, \lambda)$ï¼Œå…¶ä¸­ï¼š

- $S = \{M \mid M_0 \to^* M\}$ï¼šæ‰€æœ‰ä»åˆå§‹æ ‡è¯†å¯è¾¾çš„æ ‡è¯†é›†åˆ
- $s_0 = M_0$ï¼šåˆå§‹çŠ¶æ€
- $L = T$ï¼šæ ‡ç­¾é›†åˆï¼ˆå˜è¿é›†åˆï¼‰
- $\to \subseteq S \times L \times S$ï¼šè½¬ç§»å…³ç³»ï¼Œ$(M, t, M') \in \to$ å½“ä¸”ä»…å½“ $M[t\rangle M'$
- $\lambda: \to \to \mathbb{R}^+$ï¼šè½¬ç§»é€Ÿç‡å‡½æ•°ï¼Œ$\lambda(M, t, M') = \Lambda(t)$

### 3.2 å½¢å¼åŒ–è½¬æ¢å‡½æ•° / Formal Transformation Function

**å®šä¹‰ 3.2** (éšæœºPetriç½‘åˆ°é©¬å°”å¯å¤«é“¾è½¬æ¢å‡½æ•° / Stochastic Petri Net to Markov Chain Transformation Function)

ç»™å®šéšæœºPetriç½‘ $SPN = (P, T, F, M_0, \Lambda)$ï¼Œå®šä¹‰è½¬æ¢å‡½æ•° $\mathcal{T}_{SPN \to CTMC}: \mathcal{M}_{SPN} \to \mathcal{M}_{CTMC}$ï¼Œå…¶ä¸­ï¼š

$$\mathcal{T}_{SPN \to CTMC}(SPN) = (S, Q, \pi_0)$$

å…¶ä¸­ï¼š

- $S = \text{Reach}(SPN) = \{M \in \mathbb{N}^P \mid M_0 \to^* M\}$ï¼šå¯è¾¾æ ‡è¯†é›†åˆï¼ˆCTMCçŠ¶æ€é›†åˆï¼‰
- $Q: S \times S \to \mathbb{R}$ï¼šé€Ÿç‡çŸ©é˜µï¼Œ$Q(M, M') = \sum_{t: M[t\rangle M'} \Lambda(t)$
- $\pi_0: S \to [0,1]$ æ»¡è¶³ $\pi_0(M_0) = 1$ ä¸”å…¶ä»–ä¸º0ï¼šåˆå§‹æ¦‚ç‡åˆ†å¸ƒ

**å¼•ç† 3.1** (è½¬æ¢å‡½æ•°è‰¯å®šä¹‰æ€§ / Well-Definedness)

å¯¹äºæœ‰ç•ŒéšæœºPetriç½‘ $SPN$ï¼Œè½¬æ¢å‡½æ•° $\mathcal{T}_{SPN \to CTMC}$ æ˜¯è‰¯å®šä¹‰çš„ï¼Œå³ç»“æœæ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„è¿ç»­æ—¶é—´é©¬å°”å¯å¤«é“¾ã€‚

**è¯æ˜**ï¼š

1. **çŠ¶æ€é›†åˆæœ‰é™**ï¼šç”±äº $SPN$ æ˜¯æœ‰ç•Œçš„ï¼Œå¯è¾¾æ ‡è¯†é›†åˆ $S$ æ˜¯æœ‰é™çš„ã€‚
2. **é€Ÿç‡çŸ©é˜µå®šä¹‰**ï¼š$Q$ æ˜¯è‰¯å®šä¹‰çš„çŸ©é˜µï¼Œæ»¡è¶³ $Q(s, s) = -\sum_{s' \neq s} Q(s, s')$ã€‚
3. **åˆå§‹åˆ†å¸ƒå®šä¹‰**ï¼š$\pi_0$ æ˜¯è‰¯å®šä¹‰çš„æ¦‚ç‡åˆ†å¸ƒã€‚

å› æ­¤ï¼Œ$\mathcal{T}_{SPN \to CTMC}(SPN)$ æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„è¿ç»­æ—¶é—´é©¬å°”å¯å¤«é“¾ã€‚$\square$

---

## 4. å½¢å¼åŒ–è¯æ˜ / Formal Proofs

### 4.1 æ¦‚ç‡è¯­ä¹‰ä¿æŒå®šç† / Probabilistic Semantic Preservation Theorem

**å®šç† 4.1** (æ¦‚ç‡è‡ªåŠ¨æœº-éšæœºPetriç½‘è½¬æ¢æ¦‚ç‡è¯­ä¹‰ä¿æŒ / Probabilistic Automaton-Stochastic Petri Net Transformation Probabilistic Semantic Preservation)

å¯¹äºæ¦‚ç‡è‡ªåŠ¨æœº $PA$ å’Œè½¬æ¢å¾—åˆ°çš„éšæœºPetriç½‘ $SPN = \mathcal{T}_{PA \to SPN}(PA)$ï¼Œå­˜åœ¨æ¦‚ç‡åŒæ¨¡æ‹Ÿå…³ç³»ï¼Œä½¿å¾—ï¼š

1. **çŠ¶æ€å¯¹åº”**ï¼š$PA$ çš„çŠ¶æ€ $q$ å¯¹åº” $SPN$ çš„æ ‡è¯† $M$ï¼Œå…¶ä¸­ $M(p_q) = 1$ ä¸”å…¶ä»–åº“æ‰€ä¸ºç©º
2. **è½¬ç§»æ¦‚ç‡å¯¹åº”**ï¼š$PA$ çš„è½¬ç§»æ¦‚ç‡ $\delta(q, a, q')$ å¯¹åº” $SPN$ çš„å˜è¿é€Ÿç‡æ¯”ä¾‹
3. **è¡Œä¸ºç­‰ä»·**ï¼š$PA$ çš„æ‰§è¡Œè·¯å¾„æ¦‚ç‡åˆ†å¸ƒä¸ $SPN$ çš„æ‰§è¡Œè·¯å¾„æ¦‚ç‡åˆ†å¸ƒä¸€è‡´

**è¯æ˜**ï¼š

**æ­¥éª¤1ï¼šå®šä¹‰æ¦‚ç‡åŒæ¨¡æ‹Ÿå…³ç³»**

å®šä¹‰å…³ç³» $\mathcal{R}_P \subseteq Q \times \mathbb{N}^P$ï¼š

$$(q, M) \in \mathcal{R}_P \iff M(p_q) = 1 \land \forall q' \in Q \setminus \{q\}: M(p_{q'}) = 0$$

**æ­¥éª¤2ï¼šè¯æ˜è½¬ç§»æ¦‚ç‡å¯¹åº”**

å¯¹äº $PA$ çš„è½¬ç§» $\delta(q, a, q')$ï¼Œå¯¹åº” $SPN$ çš„å˜è¿ $t_{q,a,q'}$ï¼Œå…¶é€Ÿç‡ä¸º $\Lambda(t_{q,a,q'}) = \lambda \cdot \delta(q, a, q')$ã€‚

åœ¨éšæœºPetriç½‘ä¸­ï¼Œå½“å¤šä¸ªå˜è¿å¯è§¦å‘æ—¶ï¼Œå˜è¿ $t_{q,a,q'}$ è¢«é€‰æ‹©çš„æ¦‚ç‡ä¸ºï¼š

$$P(t_{q,a,q'} \text{è¢«é€‰æ‹©}) = \frac{\Lambda(t_{q,a,q'})}{\sum_{q'' \in Q} \Lambda(t_{q,a,q''})} = \frac{\lambda \cdot \delta(q, a, q')}{\lambda \sum_{q'' \in Q} \delta(q, a, q'')} = \frac{\delta(q, a, q')}{1} = \delta(q, a, q')$$

å› æ­¤ï¼Œè½¬ç§»æ¦‚ç‡ä¿æŒä¸€è‡´ã€‚

**æ­¥éª¤3ï¼šè¯æ˜è·¯å¾„æ¦‚ç‡åˆ†å¸ƒä¸€è‡´**

å¯¹äº $PA$ çš„æ‰§è¡Œè·¯å¾„ $q_0 \xrightarrow{a_1} q_1 \xrightarrow{a_2} \cdots \xrightarrow{a_n} q_n$ï¼Œå…¶æ¦‚ç‡ä¸ºï¼š

$$P_{PA}(\text{path}) = \prod_{i=1}^{n} \delta(q_{i-1}, a_i, q_i)$$

å¯¹äº $SPN$ çš„å¯¹åº”æ‰§è¡Œè·¯å¾„ $M_0[t_{q_0,a_1,q_1}\rangle M_1[t_{q_1,a_2,q_2}\rangle \cdots [t_{q_{n-1},a_n,q_n}\rangle M_n$ï¼Œå…¶æ¦‚ç‡ä¸ºï¼š

$$P_{SPN}(\text{path}) = \prod_{i=1}^{n} \frac{\Lambda(t_{q_{i-1},a_i,q_i})}{\sum_{q' \in Q} \Lambda(t_{q_{i-1},a_i,q'})} = \prod_{i=1}^{n} \delta(q_{i-1}, a_i, q_i) = P_{PA}(\text{path})$$

å› æ­¤ï¼Œè·¯å¾„æ¦‚ç‡åˆ†å¸ƒä¸€è‡´ã€‚$\square$

---

## 5. ä»£ç å®ç° / Code Implementation

### 5.1 æ¦‚ç‡è‡ªåŠ¨æœºåˆ°éšæœºPetriç½‘è½¬æ¢å™¨ / Probabilistic Automaton to Stochastic Petri Net Converter

```python
from typing import Dict, Set, Tuple
from dataclasses import dataclass

@dataclass
class ProbabilisticAutomaton:
    """æ¦‚ç‡è‡ªåŠ¨æœº"""
    states: Set[str]
    alphabet: Set[str]
    transitions: Dict[Tuple[str, str, str], float]  # (source_state, symbol, target_state) -> probability
    initial_state: str
    accepting_states: Set[str]

@dataclass
class StochasticPetriNet:
    """éšæœºPetriç½‘"""
    places: Set[str]
    transitions: Set[str]
    flow_relation: Set[Tuple[str, str]]
    initial_marking: Dict[str, int]
    transition_rates: Dict[str, float]  # transition -> rate

class ProbabilisticAutomatonToStochasticPetriNetConverter:
    """æ¦‚ç‡è‡ªåŠ¨æœºåˆ°éšæœºPetriç½‘è½¬æ¢å™¨ - å®Œæ•´å®ç°"""

    def __init__(self, time_scale: float = 1.0):
        """
        åˆå§‹åŒ–è½¬æ¢å™¨

        Args:
            time_scale: æ—¶é—´å°ºåº¦å‚æ•° Î»
        """
        self.time_scale = time_scale

    def convert(self, prob_automaton: ProbabilisticAutomaton) -> StochasticPetriNet:
        """
        è½¬æ¢æ¦‚ç‡è‡ªåŠ¨æœºåˆ°éšæœºPetriç½‘

        å®ç°å®šä¹‰2.1çš„è½¬æ¢å‡½æ•°

        Args:
            prob_automaton: æ¦‚ç‡è‡ªåŠ¨æœº

        Returns:
            éšæœºPetriç½‘
        """
        places = set()
        transitions = set()
        flow_relation = set()
        initial_marking = {}
        transition_rates = {}

        # æ­¥éª¤1ï¼šä¸ºæ¯ä¸ªçŠ¶æ€åˆ›å»ºåº“æ‰€ï¼ˆå®šä¹‰2.1ï¼šP = {p_q | q âˆˆ Q}ï¼‰
        state_to_place = {}
        for state in prob_automaton.states:
            place = f"p_{state}"
            places.add(place)
            state_to_place[state] = place
            initial_marking[place] = 0

        # è®¾ç½®åˆå§‹æ ‡è¯†ï¼ˆå®šä¹‰2.1ï¼šM_0(p_{q_0}) = 1ï¼‰
        initial_place = state_to_place[prob_automaton.initial_state]
        initial_marking[initial_place] = 1

        # æ­¥éª¤2ï¼šä¸ºæ¯ä¸ªæ¦‚ç‡è½¬ç§»åˆ›å»ºå˜è¿ï¼ˆå®šä¹‰2.1ï¼šT = {t_{q,a,q'} | Î´(q, a, q') > 0}ï¼‰
        for (source_state, symbol, target_state), prob in prob_automaton.transitions.items():
            if prob > 0:  # åªè€ƒè™‘éé›¶æ¦‚ç‡è½¬ç§»
                transition = f"t_{source_state}_{symbol}_{target_state}"
                transitions.add(transition)

                source_place = state_to_place[source_state]
                target_place = state_to_place[target_state]

                flow_relation.add((source_place, transition))
                flow_relation.add((transition, target_place))

                # æ­¥éª¤3ï¼šå°†æ¦‚ç‡è½¬æ¢ä¸ºé€Ÿç‡ï¼ˆå®šä¹‰2.1ï¼šÎ›(t_{q,a,q'}) = Î» Â· Î´(q, a, q')ï¼‰
                rate = self.time_scale * prob
                transition_rates[transition] = rate

        return StochasticPetriNet(
            places=places,
            transitions=transitions,
            flow_relation=flow_relation,
            initial_marking=initial_marking,
            transition_rates=transition_rates
        )
```

### 5.2 éšæœºPetriç½‘åˆ°é©¬å°”å¯å¤«é“¾è½¬æ¢å™¨ / Stochastic Petri Net to Markov Chain Converter

```python
import numpy as np
from collections import deque

@dataclass
class ContinuousTimeMarkovChain:
    """è¿ç»­æ—¶é—´é©¬å°”å¯å¤«é“¾"""
    states: Set[str]
    rate_matrix: np.ndarray  # é€Ÿç‡çŸ©é˜µ
    initial_distribution: Dict[str, float]  # åˆå§‹æ¦‚ç‡åˆ†å¸ƒ

class StochasticPetriNetToMarkovChainConverter:
    """éšæœºPetriç½‘åˆ°é©¬å°”å¯å¤«é“¾è½¬æ¢å™¨ - å®Œæ•´å®ç°"""

    def convert(self, stochastic_petri_net: StochasticPetriNet) -> ContinuousTimeMarkovChain:
        """
        è½¬æ¢éšæœºPetriç½‘åˆ°è¿ç»­æ—¶é—´é©¬å°”å¯å¤«é“¾

        å®ç°å®šä¹‰3.2çš„è½¬æ¢å‡½æ•°

        Args:
            stochastic_petri_net: éšæœºPetriç½‘

        Returns:
            è¿ç»­æ—¶é—´é©¬å°”å¯å¤«é“¾
        """
        # æ­¥éª¤1ï¼šæ„å»ºå¯è¾¾æ€§å›¾ï¼ˆå®šä¹‰3.1ï¼‰
        reachability_graph = self._build_reachability_graph(stochastic_petri_net)

        # æ­¥éª¤2ï¼šå¯è¾¾æ€§å›¾çš„èŠ‚ç‚¹å¯¹åº”CTMCçš„çŠ¶æ€ï¼ˆå®šä¹‰3.2ï¼šS = Reach(SPN)ï¼‰
        states = set()
        state_list = []
        marking_to_index = {}

        for marking_tuple in reachability_graph['markings']:
            state_id = self._marking_to_state_id(marking_tuple)
            states.add(state_id)
            state_list.append(state_id)
            marking_to_index[marking_tuple] = len(state_list) - 1

        # æ­¥éª¤3ï¼šæ„å»ºé€Ÿç‡çŸ©é˜µï¼ˆå®šä¹‰3.2ï¼šQ(M, M') = Î£_{t: M[tâŸ©M'} Î›(t)ï¼‰
        n = len(states)
        rate_matrix = np.zeros((n, n))

        for (source_marking, target_marking), transition_info in reachability_graph['edges'].items():
            source_index = marking_to_index[source_marking]
            target_index = marking_to_index[target_marking]

            transition_rate = transition_info['rate']
            rate_matrix[source_index, target_index] += transition_rate

        # è®¾ç½®å¯¹è§’çº¿å…ƒç´ ï¼ˆå®šä¹‰3.2ï¼šQ(s, s) = -Î£_{s'â‰ s} Q(s, s')ï¼‰
        for i in range(n):
            rate_matrix[i, i] = -np.sum(rate_matrix[i, :])

        # æ­¥éª¤4ï¼šè®¾ç½®åˆå§‹åˆ†å¸ƒï¼ˆå®šä¹‰3.2ï¼šÏ€_0(M_0) = 1ï¼‰
        initial_marking_id = self._marking_to_state_id(
            self._dict_to_tuple(stochastic_petri_net.initial_marking)
        )
        initial_index = marking_to_index.get(
            self._dict_to_tuple(stochastic_petri_net.initial_marking)
        )
        initial_distribution = {state_list[i]: (1.0 if i == initial_index else 0.0)
                              for i in range(n)}

        return ContinuousTimeMarkovChain(
            states=states,
            rate_matrix=rate_matrix,
            initial_distribution=initial_distribution
        )

    def _build_reachability_graph(self, stochastic_petri_net: StochasticPetriNet) -> Dict:
        """æ„å»ºå¯è¾¾æ€§å›¾"""
        visited = set()
        queue = deque([stochastic_petri_net.initial_marking])
        edges = {}

        marking_tuple = self._dict_to_tuple(stochastic_petri_net.initial_marking)
        visited.add(marking_tuple)

        while queue:
            current_marking = queue.popleft()
            current_tuple = self._dict_to_tuple(current_marking)

            # æŸ¥æ‰¾æ‰€æœ‰å¯è§¦å‘çš„å˜è¿
            for transition in stochastic_petri_net.transitions:
                if self._is_enabled(stochastic_petri_net, transition, current_marking):
                    next_marking = self._fire_transition(stochastic_petri_net, transition, current_marking)
                    next_tuple = self._dict_to_tuple(next_marking)

                    edge_key = (current_tuple, next_tuple)
                    if edge_key not in edges:
                        edges[edge_key] = {'rate': 0.0}
                    edges[edge_key]['rate'] += stochastic_petri_net.transition_rates.get(transition, 0.0)

                    if next_tuple not in visited:
                        visited.add(next_tuple)
                        queue.append(next_marking)

        return {
            'markings': visited,
            'edges': edges
        }

    def _dict_to_tuple(self, marking: Dict[str, int]) -> Tuple:
        """å°†æ ‡è¯†å­—å…¸è½¬æ¢ä¸ºå…ƒç»„"""
        return tuple(sorted(marking.items()))

    def _marking_to_state_id(self, marking_tuple: Tuple) -> str:
        """å°†æ ‡è¯†å…ƒç»„è½¬æ¢ä¸ºçŠ¶æ€ID"""
        return f"state_{hash(marking_tuple)}"

    def _is_enabled(self, petri_net: StochasticPetriNet, transition: str, marking: Dict[str, int]) -> bool:
        """æ£€æŸ¥å˜è¿æ˜¯å¦å¯è§¦å‘"""
        for (source, target) in petri_net.flow_relation:
            if target == transition:
                if marking.get(source, 0) < 1:
                    return False
        return True

    def _fire_transition(self, petri_net: StochasticPetriNet, transition: str, marking: Dict[str, int]) -> Dict[str, int]:
        """è§¦å‘å˜è¿"""
        new_marking = marking.copy()

        for (source, target) in petri_net.flow_relation:
            if target == transition:
                new_marking[source] = new_marking.get(source, 0) - 1
            if source == transition:
                new_marking[target] = new_marking.get(target, 0) + 1

        return new_marking
```

---

## 6. åº”ç”¨æ¡ˆä¾‹ / Application Cases

### 6.1 æ€§èƒ½åˆ†æåº”ç”¨ / Performance Analysis Application

**æ¡ˆä¾‹æè¿°**ï¼šå°†éšæœºPetriç½‘è½¬æ¢ä¸ºé©¬å°”å¯å¤«é“¾ï¼Œä½¿ç”¨é©¬å°”å¯å¤«é“¾åˆ†æå·¥å…·è¿›è¡Œæ€§èƒ½è¯„ä¼°ã€‚

**åˆ†ææŒ‡æ ‡**ï¼š

- ååé‡
- å“åº”æ—¶é—´
- èµ„æºåˆ©ç”¨ç‡
- å¯é æ€§

### 6.2 å¯é æ€§åˆ†æ / Reliability Analysis

**æ¡ˆä¾‹æè¿°**ï¼šä½¿ç”¨æ¦‚ç‡æ¨¡å‹åˆ†æç³»ç»Ÿçš„å¯é æ€§æŒ‡æ ‡ã€‚

**åˆ†æå†…å®¹**ï¼š

- ç³»ç»Ÿå¯ç”¨æ€§
- æ•…éšœç‡
- å¹³å‡æ•…éšœé—´éš”æ—¶é—´ï¼ˆMTBFï¼‰

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
