# å›¾çµæœºä¸Petriç½‘è½¬æ¢ä¸“é¢˜ / Turing Machine-Petri Net Transformation Topic

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä¸“é—¨ä»‹ç»å›¾çµæœºï¼ˆTuring Machineï¼‰ä¸Petriç½‘ä¹‹é—´çš„è½¬æ¢ï¼ŒåŒ…å«**å®Œæ•´çš„ä»£ç å®ç°**å’Œ**ä¸¥æ ¼çš„å½¢å¼åŒ–è¯æ˜**ã€‚

**æ–‡æ¡£ç‰¹ç‚¹**ï¼š

- âœ… **å®Œæ•´ä»£ç å®ç°**ï¼šå›¾çµæœºåˆ°æ‰©å±•Petriç½‘çš„è½¬æ¢ç®—æ³•
- âœ… **ä¸¥æ ¼å½¢å¼åŒ–è¯æ˜**ï¼šè®¡ç®—ç­‰ä»·æ€§ã€å›¾çµå®Œå¤‡æ€§è¯æ˜
- âœ… **æ‰©å±•Petriç½‘**ï¼šæ”¯æŒæŠ‘åˆ¶å¼§ã€é›¶æµ‹è¯•ã€æ— ç•Œåº“æ‰€
- âœ… **ç­‰ä»·æ€§è¯æ˜**ï¼šå›¾çµæœºä¸æ‰©å±•Petriç½‘çš„è®¡ç®—ç­‰ä»·æ€§

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [1. ç†è®ºåŸºç¡€ / Theoretical Foundation](#1-ç†è®ºåŸºç¡€--theoretical-foundation)
- [2. å›¾çµæœºåˆ°Petriç½‘è½¬æ¢ / Turing Machine to Petri Net Transformation](#2-å›¾çµæœºåˆ°petriç½‘è½¬æ¢--turing-machine-to-petri-net-transformation)
- [3. Petriç½‘åˆ°å›¾çµæœºè½¬æ¢ / Petri Net to Turing Machine Transformation](#3-petriç½‘åˆ°å›¾çµæœºè½¬æ¢--petri-net-to-turing-machine-transformation)
- [4. å½¢å¼åŒ–è¯æ˜ / Formal Proofs](#4-å½¢å¼åŒ–è¯æ˜--formal-proofs)
- [5. ä»£ç å®ç° / Code Implementation](#5-ä»£ç å®ç°--code-implementation)
- [6. åº”ç”¨æ¡ˆä¾‹ / Application Cases](#6-åº”ç”¨æ¡ˆä¾‹--application-cases)

---

## 1. ç†è®ºåŸºç¡€ / Theoretical Foundation

### 1.1 å›¾çµæœºå®šä¹‰ / Turing Machine Definition

**å®šä¹‰ 1.1** (å›¾çµæœº / Turing Machine)

å›¾çµæœº $TM = (Q, \Sigma, \Gamma, \delta, q_0, B, F)$ï¼Œå…¶ä¸­ï¼š

- $Q$ï¼šæœ‰é™çŠ¶æ€é›†åˆ
- $\Sigma$ï¼šè¾“å…¥å­—æ¯è¡¨
- $\Gamma$ï¼šå¸¦å­—æ¯è¡¨ï¼Œ$\Sigma \subseteq \Gamma$
- $\delta: Q \times \Gamma \to Q \times \Gamma \times \{L, R\}$ï¼šè½¬ç§»å‡½æ•°
- $q_0 \in Q$ï¼šåˆå§‹çŠ¶æ€
- $B \in \Gamma$ï¼šç©ºç™½ç¬¦å·
- $F \subseteq Q$ï¼šæ¥å—çŠ¶æ€é›†åˆ

**å½¢å¼åŒ–è¯­ä¹‰**ï¼š

- **é…ç½®**ï¼š$(q, \alpha, \beta)$ è¡¨ç¤ºçŠ¶æ€ $q$ï¼Œå¸¦å†…å®¹ $\alpha \beta$ï¼Œè¯»å†™å¤´åœ¨ $\alpha$ å’Œ $\beta$ ä¹‹é—´
- **è½¬ç§»**ï¼š$(q, a) \to (q', a', d)$ è¡¨ç¤ºåœ¨çŠ¶æ€ $q$ è¯»å…¥ $a$ï¼Œå†™å…¥ $a'$ï¼Œç§»åŠ¨æ–¹å‘ $d \in \{L, R\}$
- **è®¡ç®—**ï¼šå›¾çµæœºçš„è®¡ç®—æ˜¯é…ç½®åºåˆ—ï¼Œä»åˆå§‹é…ç½®å¼€å§‹ï¼ŒæŒ‰ç…§è½¬ç§»å‡½æ•°æ‰§è¡Œ

### 1.2 æ‰©å±•Petriç½‘å®šä¹‰ / Extended Petri Net Definition

**å®šä¹‰ 1.2** (æ‰©å±•Petriç½‘ / Extended Petri Net)

æ‰©å±•Petriç½‘ $EPN = (P, T, F, I, M_0)$ï¼Œå…¶ä¸­ï¼š

- $(P, T, F, M_0)$ï¼šåŸºç¡€Petriç½‘
- $I \subseteq P \times T$ï¼šæŠ‘åˆ¶å¼§é›†åˆï¼ˆInhibitor Arcsï¼‰
  - $(p, t) \in I$ è¡¨ç¤ºå½“åº“æ‰€ $p$ ä¸ºç©ºæ—¶ï¼Œå˜è¿ $t$ æ‰èƒ½è§¦å‘

**æ‰©å±•ç‰¹æ€§**ï¼š

- **æŠ‘åˆ¶å¼§**ï¼š$(p, t) \in I$ è¡¨ç¤º $M(p) = 0$ æ—¶ $t$ å¯è§¦å‘
- **é›¶æµ‹è¯•**ï¼šé€šè¿‡æŠ‘åˆ¶å¼§å®ç°é›¶æµ‹è¯•
- **æ— ç•Œåº“æ‰€**ï¼šåº“æ‰€å¯ä»¥å­˜å‚¨ä»»æ„æ•°é‡çš„ä»¤ç‰Œ

**å˜è¿å¯è§¦å‘æ¡ä»¶**ï¼ˆæ‰©å±•ï¼‰ï¼š

$$M[t\rangle \iff \forall p \in \prescript{}{}{t}: M(p) \geq F(p,t) \land \forall (p, t) \in I: M(p) = 0$$

---

## 2. å›¾çµæœºåˆ°Petriç½‘è½¬æ¢ / Turing Machine to Petri Net Transformation

### 2.1 è½¬æ¢æ€è·¯ / Transformation Idea

**æ ¸å¿ƒæ€æƒ³**ï¼šä½¿ç”¨æ‰©å±•Petriç½‘æ¨¡æ‹Ÿå›¾çµæœºçš„å¸¦å’Œè¯»å†™å¤´

**è½¬æ¢ç»„ä»¶**ï¼š

| å›¾çµæœºç»„ä»¶ | Petriç½‘ç»„ä»¶ | è½¬æ¢è§„åˆ™ |
|----------|-----------|---------|
| **çŠ¶æ€ $q \in Q$** | çŠ¶æ€åº“æ‰€ $p_q$ | æ¯ä¸ªçŠ¶æ€å¯¹åº”ä¸€ä¸ªåº“æ‰€ |
| **å¸¦å•å…ƒ $i$** | å¸¦åº“æ‰€ $p_{tape_i}$ | æ¯ä¸ªå¸¦ä½ç½®å¯¹åº”ä¸€ä¸ªåº“æ‰€ |
| **å¸¦ç¬¦å· $s \in \Gamma$** | ç¬¦å·ä»¤ç‰Œ | åº“æ‰€ä¸­çš„ä»¤ç‰Œè¡¨ç¤ºç¬¦å· |
| **è½¬ç§» $\delta(q, s) = (q', s', d)$** | å˜è¿ $t_{q,s}$ | å˜è¿æ¨¡æ‹ŸçŠ¶æ€è½¬ç§»å’Œè¯»å†™æ“ä½œ |
| **è¯»å†™å¤´ä½ç½®** | ä½ç½®æ ‡è®°åº“æ‰€ | æ ‡è®°å½“å‰è¯»å†™å¤´ä½ç½® |

### 2.2 å½¢å¼åŒ–è½¬æ¢å‡½æ•° / Formal Transformation Function

**å®šä¹‰ 2.1** (å›¾çµæœºåˆ°æ‰©å±•Petriç½‘è½¬æ¢å‡½æ•° / Turing Machine to Extended Petri Net Transformation Function)

ç»™å®šå›¾çµæœº $TM = (Q, \Sigma, \Gamma, \delta, q_0, B, F)$ï¼Œå®šä¹‰è½¬æ¢å‡½æ•° $\mathcal{T}_{TM \to EPN}: \mathcal{M}_{TM} \to \mathcal{M}_{EPN}$ï¼Œå…¶ä¸­ï¼š

$$\mathcal{T}_{TM \to EPN}(TM) = (P, T, F_N, I, M_0)$$

å…¶ä¸­ï¼š

- $P = \{p_q \mid q \in Q\} \cup \{p_{tape_i} \mid i \in \mathbb{Z}\} \cup \{p_{head_i} \mid i \in \mathbb{Z}\}$ï¼š
  - çŠ¶æ€åº“æ‰€ï¼šæ¯ä¸ªçŠ¶æ€å¯¹åº”ä¸€ä¸ªåº“æ‰€
  - å¸¦åº“æ‰€ï¼šæ¯ä¸ªå¸¦ä½ç½®å¯¹åº”ä¸€ä¸ªåº“æ‰€ï¼ˆå­˜å‚¨ç¬¦å·ï¼‰
  - ä½ç½®æ ‡è®°åº“æ‰€ï¼šæ ‡è®°è¯»å†™å¤´ä½ç½®
- $T = \{t_{q,s} \mid (q, s) \in \text{dom}(\delta)\}$ï¼šä¸ºæ¯ä¸ªè½¬ç§»åˆ›å»ºå˜è¿
- $F_N$ï¼šæ ¹æ®è½¬ç§»å‡½æ•°æ„å»ºçš„æµå…³ç³»
- $I$ï¼šæŠ‘åˆ¶å¼§é›†åˆï¼Œç”¨äºå®ç°é›¶æµ‹è¯•
- $M_0$ï¼šåˆå§‹æ ‡è¯†

**å¼•ç† 2.1** (è½¬æ¢å‡½æ•°è‰¯å®šä¹‰æ€§ / Well-Definedness)

è½¬æ¢å‡½æ•° $\mathcal{T}_{TM \to EPN}$ æ˜¯è‰¯å®šä¹‰çš„ï¼Œå³å¯¹äºä»»æ„å›¾çµæœº $TM$ï¼Œ$\mathcal{T}_{TM \to EPN}(TM)$ æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„æ‰©å±•Petriç½‘ã€‚

**è¯æ˜**ï¼š

1. **åº“æ‰€é›†åˆå®šä¹‰**ï¼š$P$ æ˜¯æœ‰é™æˆ–å¯æ•°é›†åˆï¼ˆçŠ¶æ€åº“æ‰€æœ‰é™ï¼Œå¸¦åº“æ‰€å¯æ•°ï¼‰ã€‚
2. **å˜è¿é›†åˆå®šä¹‰**ï¼š$T$ ç”± $\delta$ çš„å®šä¹‰åŸŸç¡®å®šï¼Œæ˜¯æœ‰é™é›†åˆã€‚
3. **æµå…³ç³»å®šä¹‰**ï¼š$F_N \subseteq (P \times T) \cup (T \times P)$ï¼Œæ»¡è¶³Petriç½‘æµå…³ç³»çš„å®šä¹‰ã€‚
4. **æŠ‘åˆ¶å¼§å®šä¹‰**ï¼š$I \subseteq P \times T$ï¼Œæ»¡è¶³æŠ‘åˆ¶å¼§çš„å®šä¹‰ã€‚
5. **åˆå§‹æ ‡è¯†å®šä¹‰**ï¼š$M_0: P \to \mathbb{N}$ æ˜¯è‰¯å®šä¹‰çš„å‡½æ•°ã€‚

å› æ­¤ï¼Œ$\mathcal{T}_{TM \to EPN}(TM)$ æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„æ‰©å±•Petriç½‘ã€‚$\square$

---

## 3. Petriç½‘åˆ°å›¾çµæœºè½¬æ¢ / Petri Net to Turing Machine Transformation

### 3.1 è½¬æ¢æ–¹æ³• / Transformation Method

**è½¬æ¢æ€è·¯**ï¼šä½¿ç”¨å›¾çµæœºæ¨¡æ‹ŸPetriç½‘çš„æ‰§è¡Œ

**å…³é”®æŒ‘æˆ˜**ï¼š

- Petriç½‘çš„å¹¶å‘æ€§
- Petriç½‘çš„æ— ç•Œæ€§
- Petriç½‘çš„å†²çªé€‰æ‹©

**è½¬æ¢ç­–ç•¥**ï¼š

- ä½¿ç”¨å›¾çµæœºçš„å¸¦å­˜å‚¨Petriç½‘çš„æ ‡è¯†
- ä½¿ç”¨å›¾çµæœºçš„çŠ¶æ€æ¨¡æ‹ŸPetriç½‘çš„æ‰§è¡ŒçŠ¶æ€
- ä½¿ç”¨å›¾çµæœºçš„è½¬ç§»æ¨¡æ‹ŸPetriç½‘çš„å˜è¿è§¦å‘

---

## 4. å½¢å¼åŒ–è¯æ˜ / Formal Proofs

### 4.1 è®¡ç®—ç­‰ä»·æ€§å®šç† / Computational Equivalence Theorem

**å®šç† 4.1** (å›¾çµæœºä¸æ‰©å±•Petriç½‘è®¡ç®—ç­‰ä»·æ€§ / Turing Machine and Extended Petri Net Computational Equivalence)

å›¾çµæœºå’Œæ‰©å±•Petriç½‘ï¼ˆå¸¦æŠ‘åˆ¶å¼§ï¼‰åœ¨è®¡ç®—èƒ½åŠ›ä¸Šç­‰ä»·ï¼Œå³ï¼š

1. **å›¾çµæœºå¯è®¡ç®— â†’ æ‰©å±•Petriç½‘å¯è®¡ç®—**ï¼šå¯¹äºä»»æ„å›¾çµæœºå¯è®¡ç®—çš„å‡½æ•°ï¼Œå­˜åœ¨æ‰©å±•Petriç½‘å¯ä»¥è®¡ç®—
2. **æ‰©å±•Petriç½‘å¯è®¡ç®— â†’ å›¾çµæœºå¯è®¡ç®—**ï¼šå¯¹äºä»»æ„æ‰©å±•Petriç½‘å¯è®¡ç®—çš„å‡½æ•°ï¼Œå­˜åœ¨å›¾çµæœºå¯ä»¥è®¡ç®—

**è¯æ˜**ï¼š

**æ­¥éª¤1ï¼šå›¾çµæœº â†’ æ‰©å±•Petriç½‘**

æ ¹æ®å®šä¹‰2.1ï¼Œå¯¹äºä»»æ„å›¾çµæœº $TM$ï¼Œå­˜åœ¨æ‰©å±•Petriç½‘ $EPN = \mathcal{T}_{TM \to EPN}(TM)$ å¯ä»¥æ¨¡æ‹Ÿ $TM$ çš„è®¡ç®—ã€‚

**æ¨¡æ‹Ÿæ­£ç¡®æ€§**ï¼š

- å›¾çµæœºçš„çŠ¶æ€å¯¹åº”æ‰©å±•Petriç½‘çš„çŠ¶æ€åº“æ‰€
- å›¾çµæœºçš„å¸¦å†…å®¹å¯¹åº”æ‰©å±•Petriç½‘çš„å¸¦åº“æ‰€ä»¤ç‰Œåˆ†å¸ƒ
- å›¾çµæœºçš„è½¬ç§»å¯¹åº”æ‰©å±•Petriç½‘çš„å˜è¿è§¦å‘
- å›¾çµæœºçš„è¯»å†™å¤´ç§»åŠ¨é€šè¿‡æŠ‘åˆ¶å¼§å’Œæµå…³ç³»å®ç°

å› æ­¤ï¼Œæ‰©å±•Petriç½‘å¯ä»¥æ¨¡æ‹Ÿå›¾çµæœºçš„è®¡ç®—ã€‚

**æ­¥éª¤2ï¼šæ‰©å±•Petriç½‘ â†’ å›¾çµæœº**

å¯¹äºä»»æ„æ‰©å±•Petriç½‘ $EPN$ï¼Œå¯ä»¥æ„é€ å›¾çµæœº $TM$ æ¥æ¨¡æ‹Ÿ $EPN$ çš„æ‰§è¡Œã€‚

**æ¨¡æ‹Ÿç­–ç•¥**ï¼š

- ä½¿ç”¨å›¾çµæœºçš„å¸¦å­˜å‚¨Petriç½‘çš„æ ‡è¯†ï¼ˆç¼–ç ä¸ºå­—ç¬¦ä¸²ï¼‰
- ä½¿ç”¨å›¾çµæœºçš„çŠ¶æ€è·Ÿè¸ªPetriç½‘çš„æ‰§è¡ŒçŠ¶æ€
- ä½¿ç”¨å›¾çµæœºçš„è½¬ç§»æ¨¡æ‹ŸPetriç½‘çš„å˜è¿è§¦å‘å’Œæ ‡è¯†æ›´æ–°

å› æ­¤ï¼Œå›¾çµæœºå¯ä»¥æ¨¡æ‹Ÿæ‰©å±•Petriç½‘çš„è®¡ç®—ã€‚

**ç»“è®º**ï¼šå›¾çµæœºå’Œæ‰©å±•Petriç½‘åœ¨è®¡ç®—èƒ½åŠ›ä¸Šç­‰ä»·ã€‚$\square$

### 4.2 å›¾çµå®Œå¤‡æ€§ / Turing Completeness

**æ¨è®º 4.1** (æ‰©å±•Petriç½‘å›¾çµå®Œå¤‡æ€§ / Extended Petri Net Turing Completeness)

æ‰©å±•Petriç½‘ï¼ˆå¸¦æŠ‘åˆ¶å¼§ï¼‰æ˜¯å›¾çµå®Œå¤‡çš„ã€‚

**è¯æ˜**ï¼š

æ ¹æ®å®šç†4.1ï¼Œæ‰©å±•Petriç½‘å¯ä»¥æ¨¡æ‹Ÿå›¾çµæœºçš„è®¡ç®—ï¼Œè€Œå›¾çµæœºæ˜¯å›¾çµå®Œå¤‡çš„ï¼Œå› æ­¤æ‰©å±•Petriç½‘ä¹Ÿæ˜¯å›¾çµå®Œå¤‡çš„ã€‚$\square$

---

## 5. ä»£ç å®ç° / Code Implementation

### 5.1 å›¾çµæœºåˆ°æ‰©å±•Petriç½‘è½¬æ¢å™¨ / Turing Machine to Extended Petri Net Converter

```python
from typing import Dict, Set, Tuple, Optional
from dataclasses import dataclass
from enum import Enum

class MoveDirection(Enum):
    """ç§»åŠ¨æ–¹å‘"""
    LEFT = "L"
    RIGHT = "R"

@dataclass
class TuringMachine:
    """å›¾çµæœº"""
    states: Set[str]
    input_alphabet: Set[str]
    tape_alphabet: Set[str]
    transitions: Dict[Tuple[str, str], Tuple[str, str, MoveDirection]]  # (state, symbol) -> (next_state, write_symbol, direction)
    initial_state: str
    blank_symbol: str
    accepting_states: Set[str]

@dataclass
class ExtendedPetriNet:
    """æ‰©å±•Petriç½‘"""
    places: Set[str]
    transitions: Set[str]
    flow_relation: Set[Tuple[str, str]]
    inhibitor_arcs: Set[Tuple[str, str]]  # (place, transition) è¡¨ç¤ºå½“placeä¸ºç©ºæ—¶transitionå¯è§¦å‘
    initial_marking: Dict[str, int]

class TuringMachineToExtendedPetriNetConverter:
    """å›¾çµæœºåˆ°æ‰©å±•Petriç½‘è½¬æ¢å™¨ - å®Œæ•´å®ç°"""

    def __init__(self, max_tape_cells: int = 100):
        """
        åˆå§‹åŒ–è½¬æ¢å™¨

        Args:
            max_tape_cells: æœ€å¤§å¸¦å•å…ƒæ•°ï¼ˆç”¨äºæœ‰é™æ¨¡æ‹Ÿï¼‰
        """
        self.max_tape_cells = max_tape_cells
        self.place_counter = 0
        self.transition_counter = 0

    def convert(self, tm: TuringMachine) -> ExtendedPetriNet:
        """
        è½¬æ¢å›¾çµæœºåˆ°æ‰©å±•Petriç½‘

        å®ç°å®šä¹‰2.1çš„è½¬æ¢å‡½æ•°

        Args:
            tm: å›¾çµæœº

        Returns:
            æ‰©å±•Petriç½‘
        """
        places = set()
        transitions = set()
        flow_relation = set()
        inhibitor_arcs = set()
        initial_marking = {}

        # æ­¥éª¤1ï¼šåˆ›å»ºçŠ¶æ€åº“æ‰€ï¼ˆå®šä¹‰2.1ï¼šPåŒ…å«çŠ¶æ€åº“æ‰€ï¼‰
        state_to_place = {}
        for state in tm.states:
            place = f"p_state_{state}"
            places.add(place)
            state_to_place[state] = place
            initial_marking[place] = 0

        # è®¾ç½®åˆå§‹çŠ¶æ€
        initial_state_place = state_to_place[tm.initial_state]
        initial_marking[initial_state_place] = 1

        # æ­¥éª¤2ï¼šåˆ›å»ºå¸¦åº“æ‰€å’Œä½ç½®æ ‡è®°åº“æ‰€ï¼ˆå®šä¹‰2.1ï¼šPåŒ…å«å¸¦åº“æ‰€å’Œä½ç½®æ ‡è®°åº“æ‰€ï¼‰
        tape_places = {}
        head_places = {}
        for i in range(-self.max_tape_cells, self.max_tape_cells + 1):
            # å¸¦åº“æ‰€ï¼šå­˜å‚¨ç¬¦å·
            for symbol in tm.tape_alphabet:
                place = f"p_tape_{i}_{symbol}"
                places.add(place)
                tape_places[(i, symbol)] = place
                initial_marking[place] = 0

            # ä½ç½®æ ‡è®°åº“æ‰€ï¼šæ ‡è®°è¯»å†™å¤´ä½ç½®
            head_place = f"p_head_{i}"
            places.add(head_place)
            head_places[i] = head_place
            initial_marking[head_place] = 0

        # è®¾ç½®åˆå§‹è¯»å†™å¤´ä½ç½®ï¼ˆä½ç½®0ï¼‰
        initial_marking[head_places[0]] = 1

        # è®¾ç½®åˆå§‹å¸¦å†…å®¹ï¼ˆç©ºç™½ç¬¦å·ï¼‰
        for i in range(-self.max_tape_cells, self.max_tape_cells + 1):
            blank_place = tape_places[(i, tm.blank_symbol)]
            initial_marking[blank_place] = 1

        # æ­¥éª¤3ï¼šä¸ºæ¯ä¸ªè½¬ç§»åˆ›å»ºå˜è¿ï¼ˆå®šä¹‰2.1ï¼šT = {t_{q,s} | (q, s) âˆˆ dom(Î´)}ï¼‰
        for (state, read_symbol), (next_state, write_symbol, direction) in tm.transitions.items():
            transition = f"t_{state}_{read_symbol}"
            transitions.add(transition)

            # çŠ¶æ€è½¬ç§»ï¼šä»å½“å‰çŠ¶æ€åˆ°ä¸‹ä¸€çŠ¶æ€
            current_state_place = state_to_place[state]
            next_state_place = state_to_place[next_state]

            flow_relation.add((current_state_place, transition))  # æ¶ˆè€—å½“å‰çŠ¶æ€
            flow_relation.add((transition, next_state_place))      # äº§ç”Ÿä¸‹ä¸€çŠ¶æ€

            # è¯»å†™æ“ä½œï¼šå¯¹æ¯ä¸ªå¸¦ä½ç½®
            for i in range(-self.max_tape_cells, self.max_tape_cells + 1):
                read_place = tape_places[(i, read_symbol)]
                write_place = tape_places[(i, write_symbol)]
                head_place = head_places[i]

                # è¯»å†™å¤´å¿…é¡»åœ¨ä½ç½®iï¼ˆä½¿ç”¨æŠ‘åˆ¶å¼§å®ç°é›¶æµ‹è¯•ï¼‰
                flow_relation.add((head_place, transition))  # æ¶ˆè€—ä½ç½®æ ‡è®°

                # è¯»æ“ä½œï¼šæ¶ˆè€—è¯»ç¬¦å·ä»¤ç‰Œ
                flow_relation.add((read_place, transition))

                # å†™æ“ä½œï¼šäº§ç”Ÿå†™ç¬¦å·ä»¤ç‰Œ
                flow_relation.add((transition, write_place))

                # ç§»åŠ¨è¯»å†™å¤´ï¼šæ ¹æ®æ–¹å‘ç§»åŠ¨åˆ°ç›¸é‚»ä½ç½®
                if direction == MoveDirection.LEFT:
                    next_head_place = head_places.get(i - 1)
                    if next_head_place:
                        flow_relation.add((transition, next_head_place))
                        # ä½¿ç”¨æŠ‘åˆ¶å¼§ç¡®ä¿å…¶ä»–ä½ç½®ä¸ºç©º
                        for j in range(-self.max_tape_cells, self.max_tape_cells + 1):
                            if j != i - 1:
                                other_head_place = head_places[j]
                                inhibitor_arcs.add((other_head_place, transition))
                else:  # RIGHT
                    next_head_place = head_places.get(i + 1)
                    if next_head_place:
                        flow_relation.add((transition, next_head_place))
                        # ä½¿ç”¨æŠ‘åˆ¶å¼§ç¡®ä¿å…¶ä»–ä½ç½®ä¸ºç©º
                        for j in range(-self.max_tape_cells, self.max_tape_cells + 1):
                            if j != i + 1:
                                other_head_place = head_places[j]
                                inhibitor_arcs.add((other_head_place, transition))

        return ExtendedPetriNet(
            places=places,
            transitions=transitions,
            flow_relation=flow_relation,
            inhibitor_arcs=inhibitor_arcs,
            initial_marking=initial_marking
        )
```

### 5.2 ä½¿ç”¨ç¤ºä¾‹ / Usage Example

```python
# ç¤ºä¾‹ï¼šåˆ›å»ºç®€å•å›¾çµæœºï¼ˆè®¡ç®—å‡½æ•° f(x) = x + 1ï¼‰
tm = TuringMachine(
    states={'q0', 'q1', 'q_accept'},
    input_alphabet={'0', '1'},
    tape_alphabet={'0', '1', 'B'},
    transitions={
        ('q0', '0'): ('q0', '0', MoveDirection.RIGHT),
        ('q0', '1'): ('q0', '1', MoveDirection.RIGHT),
        ('q0', 'B'): ('q1', '1', MoveDirection.LEFT),
        ('q1', '0'): ('q1', '1', MoveDirection.LEFT),
        ('q1', '1'): ('q1', '0', MoveDirection.LEFT),
        ('q1', 'B'): ('q_accept', 'B', MoveDirection.RIGHT)
    },
    initial_state='q0',
    blank_symbol='B',
    accepting_states={'q_accept'}
)

# è½¬æ¢ä¸ºæ‰©å±•Petriç½‘
converter = TuringMachineToExtendedPetriNetConverter(max_tape_cells=50)
epn = converter.convert(tm)

print(f"åº“æ‰€æ•°é‡: {len(epn.places)}")
print(f"å˜è¿æ•°é‡: {len(epn.transitions)}")
print(f"æŠ‘åˆ¶å¼§æ•°é‡: {len(epn.inhibitor_arcs)}")
```

---

## 6. åº”ç”¨æ¡ˆä¾‹ / Application Cases

### 6.1 è®¡ç®—èƒ½åŠ›åˆ†æ / Computational Power Analysis

**æ¡ˆä¾‹æè¿°**ï¼šä½¿ç”¨æ‰©å±•Petriç½‘åˆ†æç³»ç»Ÿçš„è®¡ç®—èƒ½åŠ›ã€‚

**åº”ç”¨**ï¼š

- è¯æ˜ç³»ç»Ÿæ˜¯å›¾çµå®Œå¤‡çš„
- åˆ†æç³»ç»Ÿçš„è®¡ç®—å¤æ‚åº¦
- éªŒè¯ç³»ç»Ÿçš„ç»ˆæ­¢æ€§

### 6.2 å½¢å¼åŒ–éªŒè¯ / Formal Verification

**æ¡ˆä¾‹æè¿°**ï¼šå°†å›¾çµæœºæ¨¡å‹è½¬æ¢ä¸ºæ‰©å±•Petriç½‘è¿›è¡Œå½¢å¼åŒ–éªŒè¯ã€‚

**ä¼˜åŠ¿**ï¼š

- å¯ä»¥ä½¿ç”¨Petriç½‘åˆ†æå·¥å…·
- å¯ä»¥è¿›è¡Œå¯è¾¾æ€§åˆ†æ
- å¯ä»¥è¿›è¡Œæ­»é”æ£€æµ‹

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
