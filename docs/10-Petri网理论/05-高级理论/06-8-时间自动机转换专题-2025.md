# æ—¶é—´è‡ªåŠ¨æœºè½¬æ¢ä¸“é¢˜ / Timed Automaton Transformation Topic

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä¸“é—¨ä»‹ç»æ—¶é—´è‡ªåŠ¨æœºï¼ˆTimed Automatonï¼‰å’Œæ··åˆè‡ªåŠ¨æœºï¼ˆHybrid Automatonï¼‰ä¸Petriç½‘ä¹‹é—´çš„è½¬æ¢ï¼ŒåŒ…å«**å®Œæ•´çš„ä»£ç å®ç°**å’Œ**ä¸¥æ ¼çš„å½¢å¼åŒ–è¯æ˜**ã€‚

**æ–‡æ¡£ç‰¹ç‚¹**ï¼š

- âœ… **å®Œæ•´ä»£ç å®ç°**ï¼šæ—¶é—´è‡ªåŠ¨æœºã€æ··åˆè‡ªåŠ¨æœºåˆ°æ—¶é—´Petriç½‘ã€æ··åˆPetriç½‘çš„è½¬æ¢ç®—æ³•
- âœ… **ä¸¥æ ¼å½¢å¼åŒ–è¯æ˜**ï¼šæ—¶é—´è¯­ä¹‰ä¿æŒã€è¡Œä¸ºç­‰ä»·è¯æ˜
- âœ… **å¤šç§æ—¶é—´æ¨¡å‹**ï¼šæ—¶é—´è‡ªåŠ¨æœºã€æ··åˆè‡ªåŠ¨æœºã€æ—¶é—´Petriç½‘ã€æ··åˆPetriç½‘
- âœ… **åŒå‘è½¬æ¢**ï¼šæ—¶é—´æ¨¡å‹ â†’ Petriç½‘ å’Œ Petriç½‘ â†’ æ—¶é—´æ¨¡å‹

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [1. ç†è®ºåŸºç¡€ / Theoretical Foundation](#1-ç†è®ºåŸºç¡€--theoretical-foundation)
- [2. æ—¶é—´è‡ªåŠ¨æœºä¸æ—¶é—´Petriç½‘è½¬æ¢ / Timed Automaton-Timed Petri Net Transformation](#2-æ—¶é—´è‡ªåŠ¨æœºä¸æ—¶é—´petriç½‘è½¬æ¢--timed-automaton-timed-petri-net-transformation)
- [3. æ··åˆè‡ªåŠ¨æœºä¸æ··åˆPetriç½‘è½¬æ¢ / Hybrid Automaton-Hybrid Petri Net Transformation](#3-æ··åˆè‡ªåŠ¨æœºä¸æ··åˆpetriç½‘è½¬æ¢--hybrid-automaton-hybrid-petri-net-transformation)
- [4. å½¢å¼åŒ–è¯æ˜ / Formal Proofs](#4-å½¢å¼åŒ–è¯æ˜--formal-proofs)
- [5. ä»£ç å®ç° / Code Implementation](#5-ä»£ç å®ç°--code-implementation)
- [6. åº”ç”¨æ¡ˆä¾‹ / Application Cases](#6-åº”ç”¨æ¡ˆä¾‹--application-cases)

---

## 1. ç†è®ºåŸºç¡€ / Theoretical Foundation

### 1.1 æ—¶é—´è‡ªåŠ¨æœºå®šä¹‰ / Timed Automaton Definition

**å®šä¹‰ 1.1** (æ—¶é—´è‡ªåŠ¨æœº / Timed Automaton)

æ—¶é—´è‡ªåŠ¨æœº $TA = (L, l_0, C, A, E, I)$ï¼Œå…¶ä¸­ï¼š

- $L$ï¼šä½ç½®é›†åˆï¼ˆLocationsï¼‰
- $l_0 \in L$ï¼šåˆå§‹ä½ç½®
- $C$ï¼šæ—¶é’Ÿé›†åˆï¼ˆClocksï¼‰
- $A$ï¼šåŠ¨ä½œé›†åˆï¼ˆActionsï¼‰
- $E \subseteq L \times G(C) \times A \times 2^C \times L$ï¼šè¾¹é›†åˆï¼ˆEdgesï¼‰
  - $G(C)$ï¼šæ—¶é’Ÿçº¦æŸï¼ˆGuardï¼‰
  - $2^C$ï¼šæ—¶é’Ÿé‡ç½®é›†åˆï¼ˆResetï¼‰
- $I: L \to G(C)$ï¼šä¸å˜å¼ï¼ˆInvariantï¼‰

**å½¢å¼åŒ–è¯­ä¹‰**ï¼š

- **æ—¶é’Ÿèµ‹å€¼**ï¼š$v: C \to \mathbb{R}_{\geq 0}$ è¡¨ç¤ºæ—¶é’Ÿçš„å½“å‰å€¼
- **æ—¶é—´æµé€**ï¼š$(l, v) \xrightarrow{d} (l, v + d)$ å¦‚æœ $v + d \models I(l)$
- **ç¦»æ•£è½¬æ¢**ï¼š$(l, v) \xrightarrow{a} (l', v')$ å¦‚æœå­˜åœ¨è¾¹ $(l, g, a, r, l')$ ä½¿å¾— $v \models g$ ä¸” $v' = v[r := 0]$

### 1.2 æ—¶é—´Petriç½‘å®šä¹‰ / Timed Petri Net Definition

**å®šä¹‰ 1.2** (æ—¶é—´Petriç½‘ / Timed Petri Net)

æ—¶é—´Petriç½‘ $TPN = (P, T, F, M_0, I)$ï¼Œå…¶ä¸­ï¼š

- $(P, T, F, M_0)$ï¼šåŸºç¡€Petriç½‘
- $I: T \to \mathbb{Q}^+ \times (\mathbb{Q}^+ \cup \{\infty\})$ï¼šæ—¶é—´åŒºé—´å‡½æ•°
  - $I(t) = [a, b]$ è¡¨ç¤ºå˜è¿ $t$ çš„è§¦å‘æ—¶é—´åŒºé—´

**å½¢å¼åŒ–è¯­ä¹‰**ï¼š

- **æ—¶é—´çŠ¶æ€**ï¼š$(M, \tau)$ å…¶ä¸­ $M$ æ˜¯æ ‡è¯†ï¼Œ$\tau: T \to \mathbb{R}_{\geq 0}$ æ˜¯æ—¶é—´æˆ³
- **æ—¶é—´æµé€**ï¼š$(M, \tau) \xrightarrow{d} (M, \tau + d)$ å¦‚æœæ»¡è¶³æ—¶é—´çº¦æŸ
- **å˜è¿è§¦å‘**ï¼š$(M, \tau) \xrightarrow{t} (M', \tau')$ å¦‚æœ $M[t\rangle M'$ ä¸” $\tau(t) \in I(t)$

---

## 2. æ—¶é—´è‡ªåŠ¨æœºä¸æ—¶é—´Petriç½‘è½¬æ¢ / Timed Automaton-Timed Petri Net Transformation

### 2.1 è½¬æ¢è§„åˆ™ / Transformation Rules

| æ—¶é—´è‡ªåŠ¨æœºå…ƒç´  | æ—¶é—´Petriç½‘å…ƒç´  | è½¬æ¢è§„åˆ™ |
|-------------|--------------|---------|
| **ä½ç½® $l \in L$** | åº“æ‰€ $p_l$ | æ¯ä¸ªä½ç½®å¯¹åº”ä¸€ä¸ªåº“æ‰€ |
| **è¾¹ $e \in E$** | å˜è¿ $t_e$ | è¾¹å¯¹åº”å˜è¿ |
| **æ—¶é’Ÿçº¦æŸ $g \in G(C)$** | æ—¶é—´åŒºé—´ | è½¬æ¢ä¸ºå˜è¿çš„æ—¶é—´åŒºé—´ |
| **æ—¶é’Ÿé‡ç½® $r \subseteq C$** | æ—¶é—´é‡ç½® | é€šè¿‡ç‰¹æ®Šå˜è¿å®ç° |
| **ä¸å˜å¼ $I(l)$** | æ—¶é—´çº¦æŸ | è½¬æ¢ä¸ºåº“æ‰€çš„æ—¶é—´çº¦æŸ |

### 2.2 å½¢å¼åŒ–è½¬æ¢å‡½æ•° / Formal Transformation Function

**å®šä¹‰ 2.1** (æ—¶é—´è‡ªåŠ¨æœºåˆ°æ—¶é—´Petriç½‘è½¬æ¢å‡½æ•° / Timed Automaton to Timed Petri Net Transformation Function)

ç»™å®šæ—¶é—´è‡ªåŠ¨æœº $TA = (L, l_0, C, A, E, I)$ï¼Œå®šä¹‰è½¬æ¢å‡½æ•° $\mathcal{T}_{TA \to TPN}: \mathcal{M}_{TA} \to \mathcal{M}_{TPN}$ï¼Œå…¶ä¸­ï¼š

$$\mathcal{T}_{TA \to TPN}(TA) = (P, T, F, M_0, I_{TPN})$$

å…¶ä¸­ï¼š

- $P = \{p_l \mid l \in L\}$ï¼šä¸ºæ¯ä¸ªä½ç½®åˆ›å»ºåº“æ‰€
- $T = \{t_e \mid e \in E\}$ï¼šä¸ºæ¯æ¡è¾¹åˆ›å»ºå˜è¿
- $F = \{(p_l, t_e), (t_e, p_{l'}) \mid e = (l, g, a, r, l') \in E\}$ï¼šæµå…³ç³»
- $M_0: P \to \mathbb{N}$ æ»¡è¶³ $M_0(p_{l_0}) = 1$ ä¸”å…¶ä»–ä¸º0ï¼šåˆå§‹æ ‡è¯†
- $I_{TPN}(t_e) = \text{extract\_interval}(g)$ï¼šä»æ—¶é’Ÿçº¦æŸ $g$ æå–æ—¶é—´åŒºé—´

**å¼•ç† 2.1** (è½¬æ¢å‡½æ•°è‰¯å®šä¹‰æ€§ / Well-Definedness)

è½¬æ¢å‡½æ•° $\mathcal{T}_{TA \to TPN}$ æ˜¯è‰¯å®šä¹‰çš„ï¼Œå³å¯¹äºä»»æ„æ—¶é—´è‡ªåŠ¨æœº $TA$ï¼Œ$\mathcal{T}_{TA \to TPN}(TA)$ æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„æ—¶é—´Petriç½‘ã€‚

**è¯æ˜**ï¼š

1. **åŸºç¡€Petriç½‘æœ‰æ•ˆæ€§**ï¼š$(P, T, F, M_0)$ æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„Petriç½‘ï¼ˆç±»ä¼¼å¼•ç†2.1ï¼‰ã€‚
2. **æ—¶é—´åŒºé—´å‡½æ•°å®šä¹‰**ï¼š$I_{TPN}: T \to \mathbb{Q}^+ \times (\mathbb{Q}^+ \cup \{\infty\})$ æ˜¯è‰¯å®šä¹‰çš„å‡½æ•°ã€‚

å› æ­¤ï¼Œ$\mathcal{T}_{TA \to TPN}(TA)$ æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„æ—¶é—´Petriç½‘ã€‚$\square$

---

## 3. æ··åˆè‡ªåŠ¨æœºä¸æ··åˆPetriç½‘è½¬æ¢ / Hybrid Automaton-Hybrid Petri Net Transformation

### 3.1 æ··åˆè‡ªåŠ¨æœºå®šä¹‰ / Hybrid Automaton Definition

**å®šä¹‰ 3.1** (æ··åˆè‡ªåŠ¨æœº / Hybrid Automaton)

æ··åˆè‡ªåŠ¨æœº $HA = (L, l_0, X, Init, Inv, Flow, Jump)$ï¼Œå…¶ä¸­ï¼š

- $L$ï¼šç¦»æ•£ä½ç½®é›†åˆ
- $l_0 \in L$ï¼šåˆå§‹ä½ç½®
- $X$ï¼šè¿ç»­å˜é‡é›†åˆ
- $Init \subseteq L \times \mathbb{R}^X$ï¼šåˆå§‹æ¡ä»¶
- $Inv: L \to \Phi(X)$ï¼šä½ç½®ä¸å˜å¼
- $Flow: L \to \dot{X} = f(X)$ï¼šè¿ç»­åŠ¨æ€ï¼ˆå¾®åˆ†æ–¹ç¨‹ï¼‰
- $Jump \subseteq L \times G(X) \times L \times R(X)$ï¼šè·³è½¬å…³ç³»

### 3.2 æ··åˆPetriç½‘å®šä¹‰ / Hybrid Petri Net Definition

**å®šä¹‰ 3.2** (æ··åˆPetriç½‘ / Hybrid Petri Net)

æ··åˆPetriç½‘ $HPN = (P_d, P_c, T_d, T_c, F, M_0, Flow)$ï¼Œå…¶ä¸­ï¼š

- $P_d$ï¼šç¦»æ•£åº“æ‰€é›†åˆ
- $P_c$ï¼šè¿ç»­åº“æ‰€é›†åˆ
- $T_d$ï¼šç¦»æ•£å˜è¿é›†åˆ
- $T_c$ï¼šè¿ç»­å˜è¿é›†åˆ
- $F$ï¼šæµå…³ç³»
- $M_0$ï¼šåˆå§‹æ ‡è¯†
- $Flow: P_c \to \dot{x} = f(x)$ï¼šè¿ç»­åŠ¨æ€

### 3.3 å½¢å¼åŒ–è½¬æ¢å‡½æ•° / Formal Transformation Function

**å®šä¹‰ 3.3** (æ··åˆè‡ªåŠ¨æœºåˆ°æ··åˆPetriç½‘è½¬æ¢å‡½æ•° / Hybrid Automaton to Hybrid Petri Net Transformation Function)

ç»™å®šæ··åˆè‡ªåŠ¨æœº $HA = (L, l_0, X, Init, Inv, Flow, Jump)$ï¼Œå®šä¹‰è½¬æ¢å‡½æ•° $\mathcal{T}_{HA \to HPN}: \mathcal{M}_{HA} \to \mathcal{M}_{HPN}$ï¼Œå…¶ä¸­ï¼š

$$\mathcal{T}_{HA \to HPN}(HA) = (P_d, P_c, T_d, T_c, F, M_0, Flow_{HPN})$$

å…¶ä¸­ï¼š

- $P_d = \{p_l \mid l \in L\}$ï¼šç¦»æ•£åº“æ‰€ï¼ˆå¯¹åº”ä½ç½®ï¼‰
- $P_c = \{p_x \mid x \in X\}$ï¼šè¿ç»­åº“æ‰€ï¼ˆå¯¹åº”è¿ç»­å˜é‡ï¼‰
- $T_d = \{t_j \mid j \in Jump\}$ï¼šç¦»æ•£å˜è¿ï¼ˆå¯¹åº”è·³è½¬ï¼‰
- $T_c$ï¼šè¿ç»­å˜è¿ï¼ˆå¯¹åº”è¿ç»­åŠ¨æ€ï¼‰
- $Flow_{HPN}(p_x) = Flow(l)$ å¯¹äºä½ç½® $l$ ä¸­çš„å˜é‡ $x$

---

## 4. å½¢å¼åŒ–è¯æ˜ / Formal Proofs

### 4.1 æ—¶é—´è¯­ä¹‰ä¿æŒå®šç† / Timed Semantic Preservation Theorem

**å®šç† 4.1** (æ—¶é—´è‡ªåŠ¨æœº-æ—¶é—´Petriç½‘è½¬æ¢æ—¶é—´è¯­ä¹‰ä¿æŒ / Timed Automaton-Timed Petri Net Transformation Timed Semantic Preservation)

å¯¹äºæ—¶é—´è‡ªåŠ¨æœº $TA$ å’Œè½¬æ¢å¾—åˆ°çš„æ—¶é—´Petriç½‘ $TPN = \mathcal{T}_{TA \to TPN}(TA)$ï¼Œå­˜åœ¨æ—¶é—´åŒæ¨¡æ‹Ÿå…³ç³»ï¼Œä½¿å¾—ï¼š

1. **ä½ç½®å¯¹åº”**ï¼š$TA$ çš„ä½ç½®å¯¹åº” $TPN$ çš„æ ‡è¯†
2. **æ—¶é—´å¯¹åº”**ï¼š$TA$ çš„æ—¶é’Ÿèµ‹å€¼å¯¹åº” $TPN$ çš„æ—¶é—´æˆ³
3. **è¡Œä¸ºç­‰ä»·**ï¼š$TA$ çš„æ‰§è¡Œè·¯å¾„ä¸ $TPN$ çš„æ‰§è¡Œåºåˆ—æ—¶é—´ç­‰ä»·

**è¯æ˜**ï¼š

**æ­¥éª¤1ï¼šå®šä¹‰æ—¶é—´åŒæ¨¡æ‹Ÿå…³ç³»**

å®šä¹‰å…³ç³» $\mathcal{R}_T \subseteq (L \times \mathbb{R}^C) \times (\mathbb{N}^P \times \mathbb{R}^T)$ï¼š

$$((l, v), (M, \tau)) \in \mathcal{R}_T \iff M(p_l) = 1 \land \forall l' \neq l: M(p_{l'}) = 0 \land \text{time\_correspondence}(v, \tau)$$

**æ­¥éª¤2ï¼šè¯æ˜æ—¶é—´å¯¹åº”**

æ—¶é—´è‡ªåŠ¨æœºçš„æ—¶é’Ÿçº¦æŸ $g$ å¯¹åº”æ—¶é—´Petriç½‘çš„æ—¶é—´åŒºé—´ $I(t)$ã€‚

å¦‚æœ $v \models g$ï¼Œåˆ™ $\tau(t) \in I(t)$ã€‚

**æ­¥éª¤3ï¼šè¯æ˜è¡Œä¸ºç­‰ä»·**

æ—¶é—´è‡ªåŠ¨æœºçš„æ‰§è¡Œï¼š$(l_0, v_0) \xrightarrow{d_1} (l_0, v_0 + d_1) \xrightarrow{a_1} (l_1, v_1) \xrightarrow{d_2} \cdots$

å¯¹åº”æ—¶é—´Petriç½‘çš„æ‰§è¡Œï¼š$(M_0, \tau_0) \xrightarrow{d_1} (M_0, \tau_0 + d_1) \xrightarrow{t_1} (M_1, \tau_1) \xrightarrow{d_2} \cdots$

å› æ­¤ï¼Œæ—¶é—´è¯­ä¹‰ä¿æŒã€‚$\square$

---

## 5. ä»£ç å®ç° / Code Implementation

### 5.1 æ—¶é—´è‡ªåŠ¨æœºåˆ°æ—¶é—´Petriç½‘è½¬æ¢å™¨ / Timed Automaton to Timed Petri Net Converter

```python
from typing import Dict, Set, Tuple, Optional
from dataclasses import dataclass

@dataclass
class ClockConstraint:
    """æ—¶é’Ÿçº¦æŸ"""
    clock: str
    operator: str  # '<=', '>=', '<', '>', '=='
    value: float

@dataclass
class TimedAutomatonEdge:
    """æ—¶é—´è‡ªåŠ¨æœºè¾¹"""
    source_location: str
    guard: Set[ClockConstraint]  # æ—¶é’Ÿçº¦æŸé›†åˆ
    action: str
    reset_clocks: Set[str]  # é‡ç½®çš„æ—¶é’Ÿé›†åˆ
    target_location: str

@dataclass
class TimedAutomaton:
    """æ—¶é—´è‡ªåŠ¨æœº"""
    locations: Set[str]
    initial_location: str
    clocks: Set[str]
    actions: Set[str]
    edges: Set[TimedAutomatonEdge]
    invariants: Dict[str, Set[ClockConstraint]]  # location -> invariants

@dataclass
class TimedPetriNet:
    """æ—¶é—´Petriç½‘"""
    places: Set[str]
    transitions: Set[str]
    flow_relation: Set[Tuple[str, str]]
    initial_marking: Dict[str, int]
    time_intervals: Dict[str, Tuple[float, float]]  # transition -> (min, max)

class TimedAutomatonToTimedPetriNetConverter:
    """æ—¶é—´è‡ªåŠ¨æœºåˆ°æ—¶é—´Petriç½‘è½¬æ¢å™¨ - å®Œæ•´å®ç°"""

    def convert(self, timed_automaton: TimedAutomaton) -> TimedPetriNet:
        """
        è½¬æ¢æ—¶é—´è‡ªåŠ¨æœºåˆ°æ—¶é—´Petriç½‘

        å®ç°å®šä¹‰2.1çš„è½¬æ¢å‡½æ•°

        Args:
            timed_automaton: æ—¶é—´è‡ªåŠ¨æœº

        Returns:
            æ—¶é—´Petriç½‘
        """
        places = set()
        transitions = set()
        flow_relation = set()
        initial_marking = {}
        time_intervals = {}

        # æ­¥éª¤1ï¼šä¸ºæ¯ä¸ªä½ç½®åˆ›å»ºåº“æ‰€ï¼ˆå®šä¹‰2.1ï¼šP = {p_l | l âˆˆ L}ï¼‰
        location_to_place = {}
        for location in timed_automaton.locations:
            place = f"p_{location}"
            places.add(place)
            location_to_place[location] = place
            initial_marking[place] = 0

        # è®¾ç½®åˆå§‹æ ‡è¯†ï¼ˆå®šä¹‰2.1ï¼šM_0(p_{l_0}) = 1ï¼‰
        initial_place = location_to_place[timed_automaton.initial_location]
        initial_marking[initial_place] = 1

        # æ­¥éª¤2ï¼šä¸ºæ¯æ¡è¾¹åˆ›å»ºå˜è¿ï¼ˆå®šä¹‰2.1ï¼šT = {t_e | e âˆˆ E}ï¼‰
        for edge in timed_automaton.edges:
            transition = f"t_{edge.source_location}_{edge.action}_{edge.target_location}"
            transitions.add(transition)

            source_place = location_to_place[edge.source_location]
            target_place = location_to_place[edge.target_location]

            flow_relation.add((source_place, transition))
            flow_relation.add((transition, target_place))

            # æ­¥éª¤3ï¼šè½¬æ¢æ—¶é’Ÿçº¦æŸä¸ºæ—¶é—´åŒºé—´ï¼ˆå®šä¹‰2.1ï¼šI_{TPN}(t_e) = extract_interval(g)ï¼‰
            time_interval = self._guard_to_time_interval(edge.guard)
            time_intervals[transition] = time_interval

        return TimedPetriNet(
            places=places,
            transitions=transitions,
            flow_relation=flow_relation,
            initial_marking=initial_marking,
            time_intervals=time_intervals
        )

    def _guard_to_time_interval(self, guard: Set[ClockConstraint]) -> Tuple[float, float]:
        """
        å°†æ—¶é’Ÿçº¦æŸè½¬æ¢ä¸ºæ—¶é—´åŒºé—´

        å®ç°å®šä¹‰2.1çš„æ—¶é—´åŒºé—´æå–

        Args:
            guard: æ—¶é’Ÿçº¦æŸé›†åˆ

        Returns:
            æ—¶é—´åŒºé—´ (min, max)
        """
        min_time = 0.0
        max_time = float('inf')

        for constraint in guard:
            if constraint.operator == '<=':
                max_time = min(max_time, constraint.value)
            elif constraint.operator == '>=':
                min_time = max(min_time, constraint.value)
            elif constraint.operator == '<':
                max_time = min(max_time, constraint.value)
            elif constraint.operator == '>':
                min_time = max(min_time, constraint.value)
            elif constraint.operator == '==':
                min_time = max(min_time, constraint.value)
                max_time = min(max_time, constraint.value)

        return (min_time, max_time)
```

---

## 6. åº”ç”¨æ¡ˆä¾‹ / Application Cases

### 6.1 å®æ—¶ç³»ç»ŸéªŒè¯ / Real-Time System Verification

**æ¡ˆä¾‹æè¿°**ï¼šå°†å®æ—¶ç³»ç»Ÿçš„æ—¶é—´è‡ªåŠ¨æœºæ¨¡å‹è½¬æ¢ä¸ºæ—¶é—´Petriç½‘è¿›è¡Œå½¢å¼åŒ–éªŒè¯ã€‚

**éªŒè¯æ€§è´¨**ï¼š

- æ—¶é—´çº¦æŸæ»¡è¶³æ€§
- æ— æ­»é”
- å®æ—¶æ€§ä¿è¯

### 6.2 æ··æˆç³»ç»Ÿå»ºæ¨¡ / Hybrid System Modeling

**æ¡ˆä¾‹æè¿°**ï¼šä½¿ç”¨æ··åˆè‡ªåŠ¨æœºå»ºæ¨¡æ··æˆç³»ç»Ÿï¼Œè½¬æ¢ä¸ºæ··åˆPetriç½‘è¿›è¡Œåˆ†æã€‚

**åˆ†æå†…å®¹**ï¼š

- è¿ç»­åŠ¨æ€åˆ†æ
- ç¦»æ•£äº‹ä»¶åˆ†æ
- æ··æˆè¡Œä¸ºåˆ†æ

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
