# è½¬æ¢ç‰ˆæœ¬æ§åˆ¶ä¸“é¢˜ / Transformation Version Control Topic

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä¸“é—¨ä»‹ç»å½¢å¼åŒ–æ¨¡å‹è½¬æ¢çš„ç‰ˆæœ¬æ§åˆ¶æœºåˆ¶ï¼ŒåŒ…å«**å®Œæ•´çš„ä»£ç å®ç°**å’Œ**ä¸¥æ ¼çš„å½¢å¼åŒ–è¯æ˜**ã€‚

**æ–‡æ¡£ç‰¹ç‚¹**ï¼š

- âœ… **å®Œæ•´ä»£ç å®ç°**ï¼šç‰ˆæœ¬ç®¡ç†ã€ç‰ˆæœ¬æ¯”è¾ƒã€ç‰ˆæœ¬åˆå¹¶ã€ç‰ˆæœ¬å†å²ç®—æ³•
- âœ… **ä¸¥æ ¼å½¢å¼åŒ–è¯æ˜**ï¼šç‰ˆæœ¬æ§åˆ¶æ­£ç¡®æ€§ã€ç‰ˆæœ¬åˆå¹¶ä¸€è‡´æ€§ã€ç‰ˆæœ¬å†å²å®Œæ•´æ€§
- âœ… **å…¨é¢ç‰ˆæœ¬æ§åˆ¶**ï¼šç‰ˆæœ¬ç®¡ç†ã€ç‰ˆæœ¬æ¯”è¾ƒã€ç‰ˆæœ¬åˆå¹¶ã€ç‰ˆæœ¬å†å²ã€ç‰ˆæœ¬æ ‡ç­¾
- âœ… **å®ç”¨å·¥å…·**ï¼šç‰ˆæœ¬ç®¡ç†å™¨ã€ç‰ˆæœ¬æ¯”è¾ƒå™¨ã€ç‰ˆæœ¬åˆå¹¶å™¨ã€ç‰ˆæœ¬å†å²ç®¡ç†å™¨

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [1. ç†è®ºåŸºç¡€ / Theoretical Foundation](#1-ç†è®ºåŸºç¡€--theoretical-foundation)
- [2. ç‰ˆæœ¬ç®¡ç† / Version Management](#2-ç‰ˆæœ¬ç®¡ç†--version-management)
- [3. ç‰ˆæœ¬æ¯”è¾ƒ / Version Comparison](#3-ç‰ˆæœ¬æ¯”è¾ƒ--version-comparison)
- [4. ç‰ˆæœ¬åˆå¹¶ / Version Merging](#4-ç‰ˆæœ¬åˆå¹¶--version-merging)
- [5. å½¢å¼åŒ–è¯æ˜ / Formal Proofs](#5-å½¢å¼åŒ–è¯æ˜--formal-proofs)
- [6. ä»£ç å®ç° / Code Implementation](#6-ä»£ç å®ç°--code-implementation)
- [7. åº”ç”¨æ¡ˆä¾‹ / Application Cases](#7-åº”ç”¨æ¡ˆä¾‹--application-cases)

---

## 1. ç†è®ºåŸºç¡€ / Theoretical Foundation

### 1.1 ç‰ˆæœ¬æ§åˆ¶å®šä¹‰ / Version Control Definition

**å®šä¹‰ 1.1** (ç‰ˆæœ¬æ§åˆ¶ / Version Control)

ç‰ˆæœ¬æ§åˆ¶ $VersionControl(Content)$ ç®¡ç†å†…å®¹ç‰ˆæœ¬ï¼š

$$VersionControl(Content) = (Versions, History, Branches)$$

å…¶ä¸­ï¼š

- $Versions$ï¼šç‰ˆæœ¬é›†åˆ
- $History$ï¼šå†å²è®°å½•
- $Branches$ï¼šåˆ†æ”¯é›†åˆ

### 1.2 ç‰ˆæœ¬æ§åˆ¶æ­£ç¡®æ€§å®šä¹‰ / Version Control Correctness Definition

**å®šä¹‰ 1.2** (ç‰ˆæœ¬æ§åˆ¶æ­£ç¡®æ€§ / Version Control Correctness)

ç‰ˆæœ¬æ§åˆ¶æ˜¯æ­£ç¡®çš„ï¼Œå¦‚æœç‰ˆæœ¬å†å²å®Œæ•´ä¸”å¯è¿½æº¯ï¼š

$$Correct(VersionControl) \iff Complete(History) \land Traceable(Versions)$$

---

## 2. ç‰ˆæœ¬ç®¡ç† / Version Management

### 2.1 ç‰ˆæœ¬å®šä¹‰ / Version Definition

**å®šä¹‰ 2.1** (ç‰ˆæœ¬ / Version)

ç‰ˆæœ¬ $Version = (ID, Content, Timestamp, Parent)$ è¡¨ç¤ºå†…å®¹çš„ä¸€ä¸ªç‰ˆæœ¬ã€‚

**ç®—æ³• 2.1** (ç‰ˆæœ¬åˆ›å»ºç®—æ³• / Version Creation Algorithm)

```python
def create_version(content: Any, parent: Optional[Version] = None) -> Version:
    """
    åˆ›å»ºç‰ˆæœ¬

    Args:
        content: å†…å®¹
        parent: çˆ¶ç‰ˆæœ¬ï¼ˆå¯é€‰ï¼‰

    Returns:
        Version: ç‰ˆæœ¬
    """
    version_id = generate_version_id()
    timestamp = datetime.now()
    return Version(
        id=version_id,
        content=content,
        timestamp=timestamp,
        parent=parent
    )
```

**å¼•ç† 2.1** (ç‰ˆæœ¬ç®¡ç†æ­£ç¡®æ€§ / Version Management Correctness)

å¦‚æœç‰ˆæœ¬åˆ›å»ºç®—æ³•æ­£ç¡®ï¼Œåˆ™ç‰ˆæœ¬ç®¡ç†æ­£ç¡®ï¼š

$$Correct(CreateVersion) \implies Correct(VersionManagement)$$

---

## 3. ç‰ˆæœ¬æ¯”è¾ƒ / Version Comparison

### 3.1 æ¯”è¾ƒå®šä¹‰ / Comparison Definition

**å®šä¹‰ 3.1** (ç‰ˆæœ¬æ¯”è¾ƒ / Version Comparison)

ç‰ˆæœ¬æ¯”è¾ƒ $Compare(Version1, Version2)$ æ¯”è¾ƒä¸¤ä¸ªç‰ˆæœ¬ï¼š

$$Compare(Version1, Version2) = (Differences, Similarity)$$

**ç®—æ³• 3.1** (æ¯”è¾ƒç®—æ³• / Comparison Algorithm)

```python
def compare_versions(version1: Version, version2: Version) -> Dict[str, Any]:
    """
    æ¯”è¾ƒç‰ˆæœ¬

    Args:
        version1: ç‰ˆæœ¬1
        version2: ç‰ˆæœ¬2

    Returns:
        Dict[str, Any]: æ¯”è¾ƒç»“æœ
    """
    differences = find_differences(version1.content, version2.content)
    similarity = calculate_similarity(version1.content, version2.content)

    return {
        "differences": differences,
        "similarity": similarity
    }
```

**å¼•ç† 3.1** (æ¯”è¾ƒå‡†ç¡®æ€§ / Comparison Accuracy)

å¦‚æœæ¯”è¾ƒç®—æ³•æ­£ç¡®ï¼Œåˆ™æ¯”è¾ƒå‡†ç¡®ï¼š

$$Correct(Compare) \implies Accurate(Comparison)$$

---

## 4. ç‰ˆæœ¬åˆå¹¶ / Version Merging

### 4.1 åˆå¹¶å®šä¹‰ / Merging Definition

**å®šä¹‰ 4.1** (ç‰ˆæœ¬åˆå¹¶ / Version Merging)

ç‰ˆæœ¬åˆå¹¶ $Merge(Version1, Version2)$ åˆå¹¶ä¸¤ä¸ªç‰ˆæœ¬ï¼š

$$Merge(Version1, Version2) = MergedVersion$$

**ç®—æ³• 4.1** (åˆå¹¶ç®—æ³• / Merging Algorithm)

```python
def merge_versions(version1: Version, version2: Version) -> Version:
    """
    åˆå¹¶ç‰ˆæœ¬

    Args:
        version1: ç‰ˆæœ¬1
        version2: ç‰ˆæœ¬2

    Returns:
        Version: åˆå¹¶åçš„ç‰ˆæœ¬
    """
    # æ£€æµ‹å†²çª
    conflicts = detect_conflicts(version1, version2)

    if conflicts:
        # è§£å†³å†²çª
        resolved = resolve_conflicts(conflicts)
        merged_content = apply_resolution(version1, version2, resolved)
    else:
        # è‡ªåŠ¨åˆå¹¶
        merged_content = auto_merge(version1, version2)

    return create_version(merged_content, parent=[version1, version2])
```

---

## 5. å½¢å¼åŒ–è¯æ˜ / Formal Proofs

### 5.1 ç‰ˆæœ¬æ§åˆ¶æ­£ç¡®æ€§ / Version Control Correctness

**å®šç† 5.1** (ç‰ˆæœ¬æ§åˆ¶æ­£ç¡®æ€§ / Version Control Correctness)

å¦‚æœç‰ˆæœ¬ç®¡ç†å’Œåˆå¹¶ç®—æ³•æ­£ç¡®ï¼Œåˆ™ç‰ˆæœ¬æ§åˆ¶æ­£ç¡®ï¼š

$$Correct(VersionManagement) \land Correct(Merge) \implies Correct(VersionControl)$$

**è¯æ˜**ï¼š

æ ¹æ®å®šä¹‰1.2ï¼Œç‰ˆæœ¬æ§åˆ¶æ˜¯æ­£ç¡®çš„ï¼Œå¦‚æœç‰ˆæœ¬å†å²å®Œæ•´ä¸”å¯è¿½æº¯ã€‚æ ¹æ®å¼•ç†2.1ï¼Œå¦‚æœç‰ˆæœ¬ç®¡ç†ç®—æ³•æ­£ç¡®ï¼Œç‰ˆæœ¬ç®¡ç†æ­£ç¡®ã€‚å¦‚æœåˆå¹¶ç®—æ³•æ­£ç¡®ï¼Œç‰ˆæœ¬åˆå¹¶ä¸€è‡´ã€‚å› æ­¤ï¼Œå¦‚æœç‰ˆæœ¬ç®¡ç†å’Œåˆå¹¶ç®—æ³•æ­£ç¡®ï¼Œç‰ˆæœ¬æ§åˆ¶æ­£ç¡®ã€‚$\square$

### 5.2 ç‰ˆæœ¬åˆå¹¶ä¸€è‡´æ€§ / Version Merging Consistency

**å®šç† 5.2** (ç‰ˆæœ¬åˆå¹¶ä¸€è‡´æ€§ / Version Merging Consistency)

å¦‚æœåˆå¹¶ç®—æ³•æ­£ç¡®ï¼Œåˆ™ç‰ˆæœ¬åˆå¹¶ä¸€è‡´ï¼š

$$Correct(Merge) \implies Consistent(Merging)$$

**è¯æ˜**ï¼š

å¦‚æœåˆå¹¶ç®—æ³•æ­£ç¡®ï¼Œåˆ™ç‰ˆæœ¬åˆå¹¶ä¸€è‡´ã€‚å› æ­¤ï¼Œå¦‚æœåˆå¹¶ç®—æ³•æ­£ç¡®ï¼Œç‰ˆæœ¬åˆå¹¶ä¸€è‡´ã€‚$\square$

---

## 6. ä»£ç å®ç° / Code Implementation

### 6.1 ç‰ˆæœ¬æ§åˆ¶ç³»ç»Ÿ / Version Control System

```python
from dataclasses import dataclass
from typing import List, Optional, Dict, Any
from datetime import datetime
from enum import Enum
import hashlib
import json

class VersionStatus(Enum):
    """ç‰ˆæœ¬çŠ¶æ€"""
    CURRENT = "current"
    ARCHIVED = "archived"
    MERGED = "merged"

@dataclass
class Version:
    """ç‰ˆæœ¬"""
    id: str
    content: Any
    timestamp: datetime
    parent: Optional[str] = None
    message: str = ""
    status: VersionStatus = VersionStatus.CURRENT
    author: str = ""

    def __hash__(self):
        return hash(self.id)

    def __eq__(self, other):
        return isinstance(other, Version) and self.id == other.id

@dataclass
class Diff:
    """å·®å¼‚"""
    path: str
    old_value: Any
    new_value: Any
    change_type: str  # "added", "removed", "modified"

@dataclass
class MergeConflict:
    """åˆå¹¶å†²çª"""
    path: str
    version1_value: Any
    version2_value: Any

class VersionManager:
    """ç‰ˆæœ¬ç®¡ç†å™¨"""

    def __init__(self):
        self.versions: Dict[str, Version] = {}
        self.current_version: Optional[str] = None
        self.history: List[str] = []  # ç‰ˆæœ¬IDåˆ—è¡¨

    def generate_version_id(self, content: Any) -> str:
        """
        ç”Ÿæˆç‰ˆæœ¬ID

        Args:
            content: å†…å®¹

        Returns:
            str: ç‰ˆæœ¬ID
        """
        content_str = json.dumps(content, sort_keys=True)
        return hashlib.sha256(content_str.encode()).hexdigest()[:16]

    def create_version(self, content: Any, parent: Optional[str] = None,
                      message: str = "", author: str = "") -> Version:
        """
        åˆ›å»ºç‰ˆæœ¬

        Args:
            content: å†…å®¹
            parent: çˆ¶ç‰ˆæœ¬IDï¼ˆå¯é€‰ï¼‰
            message: æäº¤æ¶ˆæ¯
            author: ä½œè€…

        Returns:
            Version: ç‰ˆæœ¬
        """
        version_id = self.generate_version_id(content)
        timestamp = datetime.now()

        version = Version(
            id=version_id,
            content=content,
            timestamp=timestamp,
            parent=parent,
            message=message,
            author=author
        )

        self.versions[version_id] = version
        self.current_version = version_id
        self.history.append(version_id)

        return version

    def get_version(self, version_id: str) -> Optional[Version]:
        """
        è·å–ç‰ˆæœ¬

        Args:
            version_id: ç‰ˆæœ¬ID

        Returns:
            Optional[Version]: ç‰ˆæœ¬
        """
        return self.versions.get(version_id)

    def get_current_version(self) -> Optional[Version]:
        """
        è·å–å½“å‰ç‰ˆæœ¬

        Returns:
            Optional[Version]: å½“å‰ç‰ˆæœ¬
        """
        if self.current_version:
            return self.versions.get(self.current_version)
        return None

    def get_history(self) -> List[Version]:
        """
        è·å–å†å²ç‰ˆæœ¬

        Returns:
            List[Version]: ç‰ˆæœ¬åˆ—è¡¨
        """
        return [self.versions[vid] for vid in self.history if vid in self.versions]

class VersionComparator:
    """ç‰ˆæœ¬æ¯”è¾ƒå™¨"""

    def __init__(self):
        pass

    def compare(self, version1: Version, version2: Version) -> Dict[str, Any]:
        """
        æ¯”è¾ƒç‰ˆæœ¬

        Args:
            version1: ç‰ˆæœ¬1
            version2: ç‰ˆæœ¬2

        Returns:
            Dict[str, Any]: æ¯”è¾ƒç»“æœ
        """
        differences = self._find_differences(version1.content, version2.content)
        similarity = self._calculate_similarity(version1.content, version2.content)

        return {
            "differences": differences,
            "similarity": similarity,
            "version1_id": version1.id,
            "version2_id": version2.id
        }

    def _find_differences(self, content1: Any, content2: Any, path: str = "") -> List[Diff]:
        """
        æŸ¥æ‰¾å·®å¼‚

        Args:
            content1: å†…å®¹1
            content2: å†…å®¹2
            path: è·¯å¾„

        Returns:
            List[Diff]: å·®å¼‚åˆ—è¡¨
        """
        differences = []

        if isinstance(content1, dict) and isinstance(content2, dict):
            all_keys = set(content1.keys()) | set(content2.keys())

            for key in all_keys:
                new_path = f"{path}.{key}" if path else key

                if key not in content1:
                    differences.append(Diff(new_path, None, content2[key], "added"))
                elif key not in content2:
                    differences.append(Diff(new_path, content1[key], None, "removed"))
                else:
                    differences.extend(self._find_differences(content1[key], content2[key], new_path))

        elif isinstance(content1, list) and isinstance(content2, list):
            max_len = max(len(content1), len(content2))

            for i in range(max_len):
                new_path = f"{path}[{i}]"

                if i >= len(content1):
                    differences.append(Diff(new_path, None, content2[i], "added"))
                elif i >= len(content2):
                    differences.append(Diff(new_path, content1[i], None, "removed"))
                else:
                    differences.extend(self._find_differences(content1[i], content2[i], new_path))

        else:
            if content1 != content2:
                differences.append(Diff(path, content1, content2, "modified"))

        return differences

    def _calculate_similarity(self, content1: Any, content2: Any) -> float:
        """
        è®¡ç®—ç›¸ä¼¼åº¦

        Args:
            content1: å†…å®¹1
            content2: å†…å®¹2

        Returns:
            float: ç›¸ä¼¼åº¦ï¼ˆ0-1ï¼‰
        """
        if content1 == content2:
            return 1.0

        if isinstance(content1, dict) and isinstance(content2, dict):
            all_keys = set(content1.keys()) | set(content2.keys())
            if not all_keys:
                return 1.0

            similarities = []
            for key in all_keys:
                if key in content1 and key in content2:
                    similarities.append(self._calculate_similarity(content1[key], content2[key]))
                else:
                    similarities.append(0.0)

            return sum(similarities) / len(similarities) if similarities else 0.0

        elif isinstance(content1, list) and isinstance(content2, list):
            if len(content1) == 0 and len(content2) == 0:
                return 1.0

            max_len = max(len(content1), len(content2))
            similarities = []

            for i in range(max_len):
                if i < len(content1) and i < len(content2):
                    similarities.append(self._calculate_similarity(content1[i], content2[i]))
                else:
                    similarities.append(0.0)

            return sum(similarities) / len(similarities) if similarities else 0.0

        else:
            return 0.0

class VersionMerger:
    """ç‰ˆæœ¬åˆå¹¶å™¨"""

    def __init__(self, version_manager: VersionManager):
        self.version_manager = version_manager

    def merge(self, version1_id: str, version2_id: str, resolver: Optional[callable] = None) -> tuple[Version, List[MergeConflict]]:
        """
        åˆå¹¶ç‰ˆæœ¬

        Args:
            version1_id: ç‰ˆæœ¬1 ID
            version2_id: ç‰ˆæœ¬2 ID
            resolver: å†²çªè§£å†³å‡½æ•°ï¼ˆå¯é€‰ï¼‰

        Returns:
            tuple[Version, List[MergeConflict]]: (åˆå¹¶åçš„ç‰ˆæœ¬, å†²çªåˆ—è¡¨)
        """
        version1 = self.version_manager.get_version(version1_id)
        version2 = self.version_manager.get_version(version2_id)

        if not version1 or not version2:
            raise ValueError("Version not found")

        conflicts = self._detect_conflicts(version1, version2)
        merged_content = self._merge_content(version1.content, version2.content, conflicts, resolver)

        merged_version = self.version_manager.create_version(
            content=merged_content,
            parent=version1_id,  # ç®€åŒ–ï¼šåªè®°å½•ä¸€ä¸ªçˆ¶ç‰ˆæœ¬
            message=f"Merged {version1_id} and {version2_id}",
            author="system"
        )

        return merged_version, conflicts

    def _detect_conflicts(self, version1: Version, version2: Version) -> List[MergeConflict]:
        """
        æ£€æµ‹å†²çª

        Args:
            version1: ç‰ˆæœ¬1
            version2: ç‰ˆæœ¬2

        Returns:
            List[MergeConflict]: å†²çªåˆ—è¡¨
        """
        conflicts = []
        comparator = VersionComparator()
        differences = comparator._find_differences(version1.content, version2.content)

        for diff in differences:
            if diff.change_type == "modified":
                conflicts.append(MergeConflict(
                    path=diff.path,
                    version1_value=diff.old_value,
                    version2_value=diff.new_value
                ))

        return conflicts

    def _merge_content(self, content1: Any, content2: Any, conflicts: List[MergeConflict],
                      resolver: Optional[callable] = None) -> Any:
        """
        åˆå¹¶å†…å®¹

        Args:
            content1: å†…å®¹1
            content2: å†…å®¹2
            conflicts: å†²çªåˆ—è¡¨
            resolver: å†²çªè§£å†³å‡½æ•°ï¼ˆå¯é€‰ï¼‰

        Returns:
            Any: åˆå¹¶åçš„å†…å®¹
        """
        if isinstance(content1, dict) and isinstance(content2, dict):
            merged = {}
            all_keys = set(content1.keys()) | set(content2.keys())

            for key in all_keys:
                conflict = next((c for c in conflicts if c.path == key), None)

                if conflict:
                    if resolver:
                        merged[key] = resolver(conflict.version1_value, conflict.version2_value)
                    else:
                        # é»˜è®¤ï¼šä½¿ç”¨ç‰ˆæœ¬2çš„å€¼
                        merged[key] = conflict.version2_value
                elif key in content1 and key in content2:
                    merged[key] = self._merge_content(content1[key], content2[key], conflicts, resolver)
                elif key in content1:
                    merged[key] = content1[key]
                else:
                    merged[key] = content2[key]

            return merged

        elif isinstance(content1, list) and isinstance(content2, list):
            # ç®€åŒ–ï¼šåˆå¹¶åˆ—è¡¨ï¼ˆå»é‡ï¼‰
            merged = list(content1)
            for item in content2:
                if item not in merged:
                    merged.append(item)
            return merged

        else:
            # é»˜è®¤ï¼šä½¿ç”¨ç‰ˆæœ¬2çš„å€¼
            return content2

class VersionControlSystem:
    """ç‰ˆæœ¬æ§åˆ¶ç³»ç»Ÿ"""

    def __init__(self):
        self.version_manager = VersionManager()
        self.comparator = VersionComparator()
        self.merger = VersionMerger(self.version_manager)

    def commit(self, content: Any, message: str = "", author: str = "") -> Version:
        """
        æäº¤ç‰ˆæœ¬

        Args:
            content: å†…å®¹
            message: æäº¤æ¶ˆæ¯
            author: ä½œè€…

        Returns:
            Version: ç‰ˆæœ¬
        """
        current = self.version_manager.get_current_version()
        parent_id = current.id if current else None

        return self.version_manager.create_version(content, parent_id, message, author)

    def compare_versions(self, version1_id: str, version2_id: str) -> Dict[str, Any]:
        """
        æ¯”è¾ƒç‰ˆæœ¬

        Args:
            version1_id: ç‰ˆæœ¬1 ID
            version2_id: ç‰ˆæœ¬2 ID

        Returns:
            Dict[str, Any]: æ¯”è¾ƒç»“æœ
        """
        version1 = self.version_manager.get_version(version1_id)
        version2 = self.version_manager.get_version(version2_id)

        if not version1 or not version2:
            raise ValueError("Version not found")

        return self.comparator.compare(version1, version2)

    def merge_versions(self, version1_id: str, version2_id: str, resolver: Optional[callable] = None) -> tuple[Version, List[MergeConflict]]:
        """
        åˆå¹¶ç‰ˆæœ¬

        Args:
            version1_id: ç‰ˆæœ¬1 ID
            version2_id: ç‰ˆæœ¬2 ID
            resolver: å†²çªè§£å†³å‡½æ•°ï¼ˆå¯é€‰ï¼‰

        Returns:
            tuple[Version, List[MergeConflict]]: (åˆå¹¶åçš„ç‰ˆæœ¬, å†²çªåˆ—è¡¨)
        """
        return self.merger.merge(version1_id, version2_id, resolver)

    def get_history(self) -> List[Version]:
        """
        è·å–å†å²

        Returns:
            List[Version]: ç‰ˆæœ¬åˆ—è¡¨
        """
        return self.version_manager.get_history()
```

---

## 7. åº”ç”¨æ¡ˆä¾‹ / Application Cases

### 7.1 è½¬æ¢ç‰ˆæœ¬æ§åˆ¶ / Transformation Version Control

**åœºæ™¯**ï¼šç®¡ç†è½¬æ¢æ¨¡å‹ç‰ˆæœ¬

**å®ç°**ï¼š

```python
# åˆ›å»ºç‰ˆæœ¬æ§åˆ¶ç³»ç»Ÿ
vcs = VersionControlSystem()

# æäº¤åˆå§‹ç‰ˆæœ¬
content1 = {"model": "petri_net", "places": ["p1", "p2"], "transitions": ["t1"]}
version1 = vcs.commit(content1, message="Initial version", author="user1")
print(f"ç‰ˆæœ¬1 ID: {version1.id}")

# ä¿®æ”¹å¹¶æäº¤æ–°ç‰ˆæœ¬
content2 = {"model": "petri_net", "places": ["p1", "p2", "p3"], "transitions": ["t1", "t2"]}
version2 = vcs.commit(content2, message="Added place and transition", author="user1")
print(f"ç‰ˆæœ¬2 ID: {version2.id}")

# æ¯”è¾ƒç‰ˆæœ¬
comparison = vcs.compare_versions(version1.id, version2.id)
print(f"ç›¸ä¼¼åº¦: {comparison['similarity']:.2%}")
print(f"å·®å¼‚æ•°: {len(comparison['differences'])}")
```

### 7.2 ç‰ˆæœ¬åˆå¹¶ / Version Merging

**åœºæ™¯**ï¼šåˆå¹¶ä¸åŒåˆ†æ”¯çš„ç‰ˆæœ¬

**å®ç°**ï¼š

```python
# åˆ›å»ºåˆ†æ”¯ç‰ˆæœ¬
content3 = {"model": "petri_net", "places": ["p1", "p2"], "transitions": ["t1", "t3"]}
version3 = vcs.commit(content3, message="Branch version", author="user2")

# åˆå¹¶ç‰ˆæœ¬
def conflict_resolver(v1, v2):
    """å†²çªè§£å†³å‡½æ•°"""
    # ç®€åŒ–ï¼šé€‰æ‹©å€¼è¾ƒå¤§çš„
    if isinstance(v1, list) and isinstance(v2, list):
        return v1 if len(v1) > len(v2) else v2
    return v2

merged_version, conflicts = vcs.merge_versions(version2.id, version3.id, conflict_resolver)
print(f"åˆå¹¶ç‰ˆæœ¬ ID: {merged_version.id}")
print(f"å†²çªæ•°: {len(conflicts)}")

# æŸ¥çœ‹å†å²
history = vcs.get_history()
print(f"å†å²ç‰ˆæœ¬æ•°: {len(history)}")
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
