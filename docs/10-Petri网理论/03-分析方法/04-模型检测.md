# æ¨¡å‹æ£€æµ‹ / Model Checking

## ğŸ“š **æ¦‚è¿° / Overview**

æ¨¡å‹æ£€æµ‹ï¼ˆModel Checkingï¼‰æ˜¯ä¸€ç§è‡ªåŠ¨åŒ–çš„å½¢å¼åŒ–éªŒè¯æŠ€æœ¯ï¼Œç”¨äºç³»ç»Ÿåœ°æ£€æŸ¥ç³»ç»Ÿæ¨¡å‹æ˜¯å¦æ»¡è¶³ç”¨æ—¶åºé€»è¾‘ï¼ˆTemporal Logicï¼‰è¡¨è¾¾çš„æ€§è´¨ã€‚Petriç½‘ä½œä¸ºå¹¶å‘ç³»ç»Ÿçš„å»ºæ¨¡å·¥å…·ï¼Œç»“åˆæ¨¡å‹æ£€æµ‹æŠ€æœ¯ï¼Œå¯ä»¥è‡ªåŠ¨éªŒè¯ç³»ç»Ÿçš„å®‰å…¨æ€§ã€æ´»æ€§ã€å…¬å¹³æ€§ç­‰æ€§è´¨ã€‚

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»æ—¶æ€é€»è¾‘ï¼ˆLTLã€CTLï¼‰ã€æ¨¡å‹æ£€æµ‹æ–¹æ³•ã€Petriç½‘æ¨¡å‹æ£€æµ‹å·¥å…·ï¼ˆTINAã€SPINã€NuSMVã€LoLAç­‰ï¼‰ï¼Œä»¥åŠå®é™…åº”ç”¨æ¡ˆä¾‹ã€‚

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [æ¨¡å‹æ£€æµ‹ / Model Checking](#æ¨¡å‹æ£€æµ‹--model-checking)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [1. æ¨¡å‹æ£€æµ‹åŸºç¡€ / Model Checking Fundamentals](#1-æ¨¡å‹æ£€æµ‹åŸºç¡€--model-checking-fundamentals)
    - [1.1 æ¨¡å‹æ£€æµ‹çš„å®šä¹‰ / Definition of Model Checking](#11-æ¨¡å‹æ£€æµ‹çš„å®šä¹‰--definition-of-model-checking)
    - [1.2 æ¨¡å‹æ£€æµ‹çš„ä¼˜åŠ¿ / Advantages of Model Checking](#12-æ¨¡å‹æ£€æµ‹çš„ä¼˜åŠ¿--advantages-of-model-checking)
    - [1.3 æ¨¡å‹æ£€æµ‹çš„æŒ‘æˆ˜ / Challenges of Model Checking](#13-æ¨¡å‹æ£€æµ‹çš„æŒ‘æˆ˜--challenges-of-model-checking)
  - [2. æ—¶æ€é€»è¾‘ / Temporal Logic](#2-æ—¶æ€é€»è¾‘--temporal-logic)
    - [2.1 çº¿æ€§æ—¶æ€é€»è¾‘ï¼ˆLTLï¼‰/ Linear Temporal Logic](#21-çº¿æ€§æ—¶æ€é€»è¾‘ltl-linear-temporal-logic)
      - [2.1.1 LTLè¯­æ³• / LTL Syntax](#211-ltlè¯­æ³•--ltl-syntax)
      - [2.1.2 LTLè¯­ä¹‰ / LTL Semantics](#212-ltlè¯­ä¹‰--ltl-semantics)
      - [2.1.3 LTLç¤ºä¾‹ / LTL Examples](#213-ltlç¤ºä¾‹--ltl-examples)
    - [2.2 è®¡ç®—æ ‘é€»è¾‘ï¼ˆCTLï¼‰/ Computation Tree Logic](#22-è®¡ç®—æ ‘é€»è¾‘ctl-computation-tree-logic)
      - [2.2.1 CTLè¯­æ³• / CTL Syntax](#221-ctlè¯­æ³•--ctl-syntax)
      - [2.2.2 CTLä¸LTLçš„åŒºåˆ« / Difference Between CTL and LTL](#222-ctlä¸ltlçš„åŒºåˆ«--difference-between-ctl-and-ltl)
    - [2.3 CTL*é€»è¾‘ / CTL* Logic](#23-ctlé€»è¾‘--ctl-logic)
  - [3. Petriç½‘æ¨¡å‹æ£€æµ‹æ–¹æ³• / Petri Net Model Checking Methods](#3-petriç½‘æ¨¡å‹æ£€æµ‹æ–¹æ³•--petri-net-model-checking-methods)
    - [3.1 å¯è¾¾æ€§å›¾æ„é€  / Reachability Graph Construction](#31-å¯è¾¾æ€§å›¾æ„é€ --reachability-graph-construction)
    - [3.2 LTLæ¨¡å‹æ£€æµ‹ç®—æ³• / LTL Model Checking Algorithm](#32-ltlæ¨¡å‹æ£€æµ‹ç®—æ³•--ltl-model-checking-algorithm)
      - [3.2.1 è‡ªåŠ¨æœºæ–¹æ³• / Automata Method](#321-è‡ªåŠ¨æœºæ–¹æ³•--automata-method)
      - [3.2.2 åµŒå¥—æ·±åº¦ä¼˜å…ˆæœç´¢ / Nested Depth-First Search](#322-åµŒå¥—æ·±åº¦ä¼˜å…ˆæœç´¢--nested-depth-first-search)
    - [3.3 CTLæ¨¡å‹æ£€æµ‹ç®—æ³• / CTL Model Checking Algorithm](#33-ctlæ¨¡å‹æ£€æµ‹ç®—æ³•--ctl-model-checking-algorithm)
      - [3.3.1 æ ‡è®°ç®—æ³• / Labeling Algorithm](#331-æ ‡è®°ç®—æ³•--labeling-algorithm)
  - [4. æ¨¡å‹æ£€æµ‹å·¥å…· / Model Checking Tools](#4-æ¨¡å‹æ£€æµ‹å·¥å…·--model-checking-tools)
    - [4.1 TINA (TIme petri Net Analyzer)](#41-tina-time-petri-net-analyzer)
    - [4.2 LoLA (Low Level Analyser)](#42-lola-low-level-analyser)
    - [4.3 SPIN](#43-spin)
    - [4.4 NuSMV](#44-nusmv)
    - [4.5 å·¥å…·é€‰æ‹©æŒ‡å— / Tool Selection Guide](#45-å·¥å…·é€‰æ‹©æŒ‡å—--tool-selection-guide)
      - [4.5.1 å·¥å…·å¯¹æ¯”è¡¨](#451-å·¥å…·å¯¹æ¯”è¡¨)
      - [4.5.2 åœºæ™¯é€‰æ‹©æŒ‡å—](#452-åœºæ™¯é€‰æ‹©æŒ‡å—)
      - [4.5.3 å·¥å…·ç»„åˆä½¿ç”¨å»ºè®®](#453-å·¥å…·ç»„åˆä½¿ç”¨å»ºè®®)
      - [4.5.4 æ€§èƒ½åŸºå‡†æµ‹è¯•](#454-æ€§èƒ½åŸºå‡†æµ‹è¯•)
      - [4.5.5 å­¦ä¹ è·¯å¾„å»ºè®®](#455-å­¦ä¹ è·¯å¾„å»ºè®®)
      - [4.5.6 å¸¸è§é—®é¢˜è§£ç­”](#456-å¸¸è§é—®é¢˜è§£ç­”)
  - [5. å®é™…åº”ç”¨æ¡ˆä¾‹ / Practical Application Cases](#5-å®é™…åº”ç”¨æ¡ˆä¾‹--practical-application-cases)
    - [5.1 æ¡ˆä¾‹1ï¼šåè®®å®‰å…¨æ€§éªŒè¯ / Case 1: Protocol Safety Verification](#51-æ¡ˆä¾‹1åè®®å®‰å…¨æ€§éªŒè¯--case-1-protocol-safety-verification)
    - [5.2 æ¡ˆä¾‹2ï¼šå·¥ä½œæµæ´»æ€§éªŒè¯ / Case 2: Workflow Liveness Verification](#52-æ¡ˆä¾‹2å·¥ä½œæµæ´»æ€§éªŒè¯--case-2-workflow-liveness-verification)
    - [5.3 æ¡ˆä¾‹3ï¼šåˆ¶é€ ç³»ç»Ÿå…¬å¹³æ€§éªŒè¯ / Case 3: Manufacturing System Fairness Verification](#53-æ¡ˆä¾‹3åˆ¶é€ ç³»ç»Ÿå…¬å¹³æ€§éªŒè¯--case-3-manufacturing-system-fairness-verification)
  - [6. ç®—æ³•å®ç°å®Œå–„ä¸æ€§èƒ½ä¼˜åŒ– / Algorithm Implementation Enhancement and Performance Optimization](#6-ç®—æ³•å®ç°å®Œå–„ä¸æ€§èƒ½ä¼˜åŒ–--algorithm-implementation-enhancement-and-performance-optimization)
    - [6.1 å®Œæ•´LTLæ¨¡å‹æ£€æµ‹ç®—æ³•å®ç°](#61-å®Œæ•´ltlæ¨¡å‹æ£€æµ‹ç®—æ³•å®ç°)
      - [ç®—æ³• 6.1 (å®Œæ•´LTLåˆ°BÃ¼chiè‡ªåŠ¨æœºè½¬æ¢ / Complete LTL to BÃ¼chi Automaton Conversion)](#ç®—æ³•-61-å®Œæ•´ltlåˆ°bÃ¼chiè‡ªåŠ¨æœºè½¬æ¢--complete-ltl-to-bÃ¼chi-automaton-conversion)
    - [6.2 ç¬¦å·æ¨¡å‹æ£€æµ‹ç®—æ³•](#62-ç¬¦å·æ¨¡å‹æ£€æµ‹ç®—æ³•)
      - [ç®—æ³• 6.2 (ç¬¦å·æ¨¡å‹æ£€æµ‹ / Symbolic Model Checking)](#ç®—æ³•-62-ç¬¦å·æ¨¡å‹æ£€æµ‹--symbolic-model-checking)
    - [6.3 æ€§èƒ½è¯„ä¼°ä¸ä¼˜åŒ–](#63-æ€§èƒ½è¯„ä¼°ä¸ä¼˜åŒ–)
      - [6.3.1 ç®—æ³•æ€§èƒ½å¯¹æ¯”](#631-ç®—æ³•æ€§èƒ½å¯¹æ¯”)
      - [6.3.2 å®é™…æ€§èƒ½åŸºå‡†](#632-å®é™…æ€§èƒ½åŸºå‡†)
      - [6.3.3 ä¼˜åŒ–æŠ€æœ¯](#633-ä¼˜åŒ–æŠ€æœ¯)
  - [7. æœ€æ–°ç ”ç©¶è¿›å±•ï¼ˆ2024-2025ï¼‰/ Latest Research Progress (2024-2025)](#7-æœ€æ–°ç ”ç©¶è¿›å±•2024-2025-latest-research-progress-2024-2025)
    - [7.1 æœºå™¨å­¦ä¹ å¢å¼ºçš„æ¨¡å‹æ£€æµ‹](#71-æœºå™¨å­¦ä¹ å¢å¼ºçš„æ¨¡å‹æ£€æµ‹)
    - [7.2 å®æ—¶æ¨¡å‹æ£€æµ‹](#72-å®æ—¶æ¨¡å‹æ£€æµ‹)
    - [7.3 é‡å­æ¨¡å‹æ£€æµ‹](#73-é‡å­æ¨¡å‹æ£€æµ‹)
  - [8. 2025-2026å¹´æœ€æ–°éªŒè¯å·¥å…· / Latest Verification Tools 2025-2026](#8-2025-2026å¹´æœ€æ–°éªŒè¯å·¥å…·--latest-verification-tools-2025-2026)
    - [8.1 TAPAAL HyperLTL: é¦–ä¸ªPetriç½‘HyperLTLæ¨¡å‹æ£€æŸ¥å™¨ (2025å¹´12æœˆ)](#81-tapaal-hyperltl-é¦–ä¸ªpetriç½‘hyperltlæ¨¡å‹æ£€æŸ¥å™¨-2025å¹´12æœˆ)
    - [8.2 SMPT: Satisfiability Modulo Petri Nets (2025å¹´)](#82-smpt-satisfiability-modulo-petri-nets-2025å¹´)
    - [8.3 Project and Conquer: å¿«é€Ÿé‡è¯æ¶ˆé™¤ (2024å¹´1æœˆ)](#83-project-and-conquer-å¿«é€Ÿé‡è¯æ¶ˆé™¤-2024å¹´1æœˆ)
    - [8.4 Nested-Unit Petri Nets (NUPN): å±‚æ¬¡ç»“æ„éªŒè¯ (2025å¹´)](#84-nested-unit-petri-nets-nupn-å±‚æ¬¡ç»“æ„éªŒè¯-2025å¹´)

---

## 1. æ¨¡å‹æ£€æµ‹åŸºç¡€ / Model Checking Fundamentals

### 1.1 æ¨¡å‹æ£€æµ‹çš„å®šä¹‰ / Definition of Model Checking

**å®šä¹‰ 1.1** (æ¨¡å‹æ£€æµ‹ / Model Checking)

**æ¨¡å‹æ£€æµ‹**æ˜¯ä¸€ç§è‡ªåŠ¨åŒ–çš„å½¢å¼åŒ–éªŒè¯æŠ€æœ¯ï¼Œé€šè¿‡ç³»ç»Ÿåœ°æ¢ç´¢ç³»ç»Ÿçš„æ‰€æœ‰å¯èƒ½çŠ¶æ€ï¼Œæ£€æŸ¥ç³»ç»Ÿæ˜¯å¦æ»¡è¶³ç”¨é€»è¾‘å…¬å¼è¡¨è¾¾çš„æ€§è´¨ã€‚

**è¾“å…¥**ï¼š

- **ç³»ç»Ÿæ¨¡å‹**ï¼šPetriç½‘ $N$ å’Œåˆå§‹æ ‡è¯† $M_0$
- **æ€§è´¨è§„çº¦**ï¼šç”¨æ—¶æ€é€»è¾‘å…¬å¼ $\phi$ è¡¨è¾¾çš„æ€§è´¨

**è¾“å‡º**ï¼š

- **æ»¡è¶³**ï¼šå¦‚æœç³»ç»Ÿæ»¡è¶³æ€§è´¨ï¼Œè¿”å›"æ»¡è¶³"å’Œè¯æ˜
- **ä¸æ»¡è¶³**ï¼šå¦‚æœç³»ç»Ÿä¸æ»¡è¶³æ€§è´¨ï¼Œè¿”å›"ä¸æ»¡è¶³"å’Œåä¾‹ï¼ˆcounterexampleï¼‰

### 1.2 æ¨¡å‹æ£€æµ‹çš„ä¼˜åŠ¿ / Advantages of Model Checking

1. **è‡ªåŠ¨åŒ–**ï¼šå®Œå…¨è‡ªåŠ¨åŒ–ï¼Œæ— éœ€äººå·¥æ„é€ è¯æ˜
2. **åä¾‹ç”Ÿæˆ**ï¼šå¦‚æœä¸æ»¡è¶³ï¼Œè‡ªåŠ¨ç”Ÿæˆåä¾‹
3. **å…¨é¢æ€§**ï¼šæ£€æŸ¥æ‰€æœ‰å¯èƒ½çš„æ‰§è¡Œè·¯å¾„
4. **å®ç”¨æ€§**ï¼šå¯ä»¥å¤„ç†å®é™…è§„æ¨¡çš„ç³»ç»Ÿ

### 1.3 æ¨¡å‹æ£€æµ‹çš„æŒ‘æˆ˜ / Challenges of Model Checking

1. **çŠ¶æ€ç©ºé—´çˆ†ç‚¸**ï¼šç³»ç»ŸçŠ¶æ€ç©ºé—´å¯èƒ½éå¸¸å¤§
2. **è®¡ç®—å¤æ‚åº¦**ï¼šæ¨¡å‹æ£€æµ‹æ˜¯PSPACE-completeé—®é¢˜
3. **å†…å­˜é™åˆ¶**ï¼šéœ€è¦å¤§é‡å†…å­˜å­˜å‚¨çŠ¶æ€ç©ºé—´

---

## 2. æ—¶æ€é€»è¾‘ / Temporal Logic

### 2.1 çº¿æ€§æ—¶æ€é€»è¾‘ï¼ˆLTLï¼‰/ Linear Temporal Logic

#### 2.1.1 LTLè¯­æ³• / LTL Syntax

**å®šä¹‰ 2.1** (LTLè¯­æ³• / LTL Syntax)

LTLå…¬å¼çš„è¯­æ³•ï¼š

$$\phi ::= p \mid \neg \phi \mid \phi \land \phi \mid \phi \lor \phi \mid \phi \rightarrow \phi \mid X \phi \mid F \phi \mid G \phi \mid \phi U \phi$$

å…¶ä¸­ï¼š

- $p$ï¼šåŸå­å‘½é¢˜ï¼ˆatomic propositionï¼‰
- $X \phi$ï¼š**ä¸‹ä¸€ä¸ª**ï¼ˆnextï¼‰ï¼Œä¸‹ä¸€ä¸ªçŠ¶æ€æ»¡è¶³ $\phi$
- $F \phi$ï¼š**æœ€ç»ˆ**ï¼ˆfinallyï¼‰ï¼Œæœ€ç»ˆæŸä¸ªçŠ¶æ€æ»¡è¶³ $\phi$
- $G \phi$ï¼š**å…¨å±€**ï¼ˆgloballyï¼‰ï¼Œæ‰€æœ‰çŠ¶æ€éƒ½æ»¡è¶³ $\phi$
- $\phi U \psi$ï¼š**ç›´åˆ°**ï¼ˆuntilï¼‰ï¼Œ$\phi$ ä¸€ç›´æˆç«‹ç›´åˆ° $\psi$ æˆç«‹

#### 2.1.2 LTLè¯­ä¹‰ / LTL Semantics

**å®šä¹‰ 2.2** (LTLè¯­ä¹‰ / LTL Semantics)

å¯¹äºæ‰§è¡Œè·¯å¾„ $\pi = s_0 s_1 s_2 \cdots$ å’ŒLTLå…¬å¼ $\phi$ï¼š

- $\pi \models p$ï¼šå½“ä¸”ä»…å½“ $p \in L(s_0)$ï¼ˆ$L(s)$ æ˜¯çŠ¶æ€ $s$ çš„æ ‡ç­¾ï¼‰
- $\pi \models X \phi$ï¼šå½“ä¸”ä»…å½“ $\pi^1 \models \phi$ï¼ˆ$\pi^1$ æ˜¯ä» $s_1$ å¼€å§‹çš„è·¯å¾„ï¼‰
- $\pi \models F \phi$ï¼šå½“ä¸”ä»…å½“å­˜åœ¨ $i \geq 0$ï¼Œä½¿å¾— $\pi^i \models \phi$
- $\pi \models G \phi$ï¼šå½“ä¸”ä»…å½“å¯¹æ‰€æœ‰ $i \geq 0$ï¼Œ$\pi^i \models \phi$
- $\pi \models \phi U \psi$ï¼šå½“ä¸”ä»…å½“å­˜åœ¨ $i \geq 0$ï¼Œä½¿å¾— $\pi^i \models \psi$ï¼Œä¸”å¯¹æ‰€æœ‰ $j < i$ï¼Œ$\pi^j \models \phi$

#### 2.1.3 LTLç¤ºä¾‹ / LTL Examples

**ç¤ºä¾‹ 2.1** (LTLå…¬å¼ç¤ºä¾‹)

- **å®‰å…¨æ€§**ï¼š$G \neg bad$ï¼ˆæ°¸è¿œä¸è¿›å…¥åçŠ¶æ€ï¼‰
- **æ´»æ€§**ï¼š$G (request \rightarrow F response)$ï¼ˆè¯·æ±‚æœ€ç»ˆä¼šå¾—åˆ°å“åº”ï¼‰
- **å…¬å¹³æ€§**ï¼š$G F enabled \rightarrow G F fired$ï¼ˆå¦‚æœæ— é™æ¬¡å¯è§¦å‘ï¼Œåˆ™æ— é™æ¬¡è§¦å‘ï¼‰

### 2.2 è®¡ç®—æ ‘é€»è¾‘ï¼ˆCTLï¼‰/ Computation Tree Logic

#### 2.2.1 CTLè¯­æ³• / CTL Syntax

**å®šä¹‰ 2.3** (CTLè¯­æ³• / CTL Syntax)

CTLå…¬å¼çš„è¯­æ³•ï¼š

$$\phi ::= p \mid \neg \phi \mid \phi \land \phi \mid \phi \lor \phi \mid \phi \rightarrow \phi \mid EX \phi \mid EF \phi \mid EG \phi \mid E[\phi U \psi] \mid AX \phi \mid AF \phi \mid AG \phi \mid A[\phi U \psi]$$

å…¶ä¸­ï¼š

- $EX \phi$ï¼š**å­˜åœ¨ä¸‹ä¸€ä¸ª**ï¼Œå­˜åœ¨ä¸‹ä¸€ä¸ªçŠ¶æ€æ»¡è¶³ $\phi$
- $EF \phi$ï¼š**å­˜åœ¨è·¯å¾„æœ€ç»ˆ**ï¼Œå­˜åœ¨è·¯å¾„æœ€ç»ˆæ»¡è¶³ $\phi$
- $EG \phi$ï¼š**å­˜åœ¨è·¯å¾„å…¨å±€**ï¼Œå­˜åœ¨è·¯å¾„æ‰€æœ‰çŠ¶æ€æ»¡è¶³ $\phi$
- $E[\phi U \psi]$ï¼š**å­˜åœ¨è·¯å¾„ç›´åˆ°**ï¼Œå­˜åœ¨è·¯å¾„ $\phi$ ç›´åˆ° $\psi$
- $AX, AF, AG, A[\phi U \psi]$ï¼š**å…¨ç§°é‡è¯**ç‰ˆæœ¬

#### 2.2.2 CTLä¸LTLçš„åŒºåˆ« / Difference Between CTL and LTL

| ç‰¹æ€§ | LTL | CTL |
|------|-----|-----|
| **è·¯å¾„ç±»å‹** | çº¿æ€§è·¯å¾„ | è®¡ç®—æ ‘ |
| **é‡è¯** | éšå¼å…¨ç§° | æ˜¾å¼å­˜åœ¨/å…¨ç§° |
| **è¡¨è¾¾èƒ½åŠ›** | è·¯å¾„æ€§è´¨ | åˆ†æ”¯æ€§è´¨ |
| **å¤æ‚åº¦** | PSPACE-complete | P-complete |

### 2.3 CTL*é€»è¾‘ / CTL* Logic

**CTL***æ˜¯LTLå’ŒCTLçš„è¶…é›†ï¼Œç»“åˆäº†ä¸¤è€…çš„è¡¨è¾¾èƒ½åŠ›ã€‚

---

## 3. Petriç½‘æ¨¡å‹æ£€æµ‹æ–¹æ³• / Petri Net Model Checking Methods

### 3.1 å¯è¾¾æ€§å›¾æ„é€  / Reachability Graph Construction

**æ­¥éª¤**ï¼š

1. ä»åˆå§‹æ ‡è¯†å¼€å§‹ï¼Œæ„é€ å¯è¾¾æ€§å›¾
2. å¯è¾¾æ€§å›¾çš„èŠ‚ç‚¹æ˜¯å¯è¾¾æ ‡è¯†
3. å¯è¾¾æ€§å›¾çš„è¾¹æ˜¯å˜è¿è§¦å‘

**ç»“æœ**ï¼šå¾—åˆ°ä¸€ä¸ªKripkeç»“æ„ï¼ˆKripke Structureï¼‰ï¼Œå¯ä»¥ç”¨äºæ¨¡å‹æ£€æµ‹ã€‚

### 3.2 LTLæ¨¡å‹æ£€æµ‹ç®—æ³• / LTL Model Checking Algorithm

#### 3.2.1 è‡ªåŠ¨æœºæ–¹æ³• / Automata Method

**æ–¹æ³•**ï¼š

1. å°†LTLå…¬å¼è½¬æ¢ä¸ºBÃ¼chiè‡ªåŠ¨æœº
2. æ„é€ Petriç½‘çš„å¯è¾¾æ€§å›¾ï¼ˆKripkeç»“æ„ï¼‰
3. è®¡ç®—è‡ªåŠ¨æœºå’Œå¯è¾¾æ€§å›¾çš„ä¹˜ç§¯
4. æ£€æŸ¥æ˜¯å¦å­˜åœ¨æ¥å—å¾ªç¯

**ç®—æ³•å¤æ‚åº¦**ï¼š$O(|S| \cdot 2^{|\phi|})$ï¼Œå…¶ä¸­ $|S|$ æ˜¯çŠ¶æ€æ•°ï¼Œ$|\phi|$ æ˜¯å…¬å¼é•¿åº¦ã€‚

**è¯¦ç»†å®ç°**ï¼š

```python
"""
LTLæ¨¡å‹æ£€æµ‹ç®—æ³•å®ç°ï¼ˆè‡ªåŠ¨æœºæ–¹æ³•ï¼‰

å°†Petriç½‘æ¨¡å‹æ£€æµ‹é—®é¢˜è½¬åŒ–ä¸ºBÃ¼chiè‡ªåŠ¨æœºçš„æ¥å—å¾ªç¯æ£€æµ‹é—®é¢˜ã€‚
"""

from typing import Dict, Set, List, Tuple, Optional
from collections import defaultdict
import re


class LTLChecker:
    """LTLæ¨¡å‹æ£€æµ‹å™¨ï¼ˆç®€åŒ–å®ç°ï¼‰"""

    def __init__(self, petri_net, atomic_propositions: Dict[str, callable]):
        """
        åˆå§‹åŒ–LTLæ£€æµ‹å™¨ã€‚

        Args:
            petri_net: Petriç½‘å¯¹è±¡
            atomic_propositions: åŸå­å‘½é¢˜å­—å…¸ {name: function(marking) -> bool}
        """
        self.net = petri_net
        self.ap = atomic_propositions
        self.reachability_graph = None

    def check(self, ltl_formula: str, initial_marking: Dict[str, int]) -> Tuple[bool, Optional[List]]:
        """
        æ£€æŸ¥Petriç½‘æ˜¯å¦æ»¡è¶³LTLå…¬å¼ã€‚

        Args:
            ltl_formula: LTLå…¬å¼å­—ç¬¦ä¸²ï¼Œä¾‹å¦‚ "G (request -> F response)"
            initial_marking: åˆå§‹æ ‡è¯†

        Returns:
            (æ˜¯å¦æ»¡è¶³, åä¾‹è·¯å¾„æˆ–None)
        """
        # 1. æ„é€ å¯è¾¾æ€§å›¾ï¼ˆKripkeç»“æ„ï¼‰
        self._build_kripke_structure(initial_marking)

        # 2. å°†LTLå…¬å¼è½¬æ¢ä¸ºBÃ¼chiè‡ªåŠ¨æœºï¼ˆç®€åŒ–ï¼šä½¿ç”¨é¢„å®šä¹‰æ¨¡å¼ï¼‰
        buchi_automaton = self._ltl_to_buchi(ltl_formula)

        # 3. è®¡ç®—ä¹˜ç§¯è‡ªåŠ¨æœº
        product = self._compute_product(self.reachability_graph, buchi_automaton)

        # 4. æ£€æŸ¥æ¥å—å¾ªç¯
        has_accepting_cycle = self._check_accepting_cycle(product)

        if has_accepting_cycle:
            # æ‰¾åˆ°åä¾‹è·¯å¾„
            counterexample = self._extract_counterexample(product)
            return False, counterexample
        else:
            return True, None

    def _build_kripke_structure(self, initial_marking: Dict[str, int]):
        """æ„é€ Kripkeç»“æ„ï¼ˆå¸¦æ ‡ç­¾çš„å¯è¾¾æ€§å›¾ï¼‰"""
        from collections import deque

        def marking_to_tuple(marking: Dict[str, int]) -> Tuple:
            return tuple(sorted(marking.items()))

        initial_tuple = marking_to_tuple(initial_marking)
        states: Dict[Tuple, Dict] = {}  # {state: {'label': set, 'transitions': list}}
        visited = {initial_tuple}
        queue = deque([initial_tuple])

        # è®¾ç½®åˆå§‹çŠ¶æ€
        states[initial_tuple] = {
            'label': self._evaluate_ap(initial_marking),
            'transitions': []
        }

        while queue:
            current_tuple = queue.popleft()
            current_marking = dict(current_tuple)

            # æ¢å¤Petriç½‘çŠ¶æ€
            self.net.marking = current_marking.copy()

            # å°è¯•æ‰€æœ‰å˜è¿
            for transition in self.net.transitions:
                if self.net.is_enabled(transition):
                    old_marking = self.net.marking.copy()
                    self.net.fire(transition)
                    new_marking = self.net.get_current_marking()
                    new_tuple = marking_to_tuple(new_marking)

                    # æ·»åŠ è½¬æ¢
                    states[current_tuple]['transitions'].append((transition, new_tuple))

                    # å¦‚æœæ–°çŠ¶æ€æœªè®¿é—®ï¼ŒåŠ å…¥é˜Ÿåˆ—
                    if new_tuple not in visited:
                        visited.add(new_tuple)
                        states[new_tuple] = {
                            'label': self._evaluate_ap(new_marking),
                            'transitions': []
                        }
                        queue.append(new_tuple)

                    self.net.marking = old_marking

        self.reachability_graph = states
        self.net.marking = initial_marking.copy()

    def _evaluate_ap(self, marking: Dict[str, int]) -> Set[str]:
        """è¯„ä¼°åŸå­å‘½é¢˜ï¼Œè¿”å›æ»¡è¶³çš„å‘½é¢˜é›†åˆ"""
        satisfied = set()
        for ap_name, ap_func in self.ap.items():
            if ap_func(marking):
                satisfied.add(ap_name)
        return satisfied

    def _ltl_to_buchi(self, formula: str) -> Dict:
        """
        å°†LTLå…¬å¼è½¬æ¢ä¸ºBÃ¼chiè‡ªåŠ¨æœºï¼ˆç®€åŒ–å®ç°ï¼‰ã€‚

        å®é™…å®ç°éœ€è¦ä½¿ç”¨å®Œæ•´çš„LTLåˆ°BÃ¼chiè‡ªåŠ¨æœºè½¬æ¢ç®—æ³•ã€‚
        è¿™é‡Œæä¾›ç®€åŒ–æ¡†æ¶ã€‚
        """
        # ç®€åŒ–å®ç°ï¼šåªå¤„ç†ç®€å•çš„Gå’ŒFæ¨¡å¼
        if formula.startswith("G "):
            # G phi: å…¨å±€æ€§è´¨ï¼Œè½¬æ¢ä¸ºè‡ªåŠ¨æœºè¦æ±‚æ‰€æœ‰çŠ¶æ€éƒ½æ»¡è¶³phi
            inner = formula[2:].strip()
            return {
                'type': 'G',
                'inner_formula': inner,
                'accepting_states': 'all'  # æ‰€æœ‰çŠ¶æ€éƒ½æ˜¯æ¥å—çŠ¶æ€
            }
        elif formula.startswith("F "):
            # F phi: æœ€ç»ˆæ€§è´¨ï¼Œè½¬æ¢ä¸ºè‡ªåŠ¨æœºè¦æ±‚è‡³å°‘ä¸€ä¸ªçŠ¶æ€æ»¡è¶³phi
            inner = formula[2:].strip()
            return {
                'type': 'F',
                'inner_formula': inner,
                'accepting_states': 'any'  # è‡³å°‘ä¸€ä¸ªçŠ¶æ€æ˜¯æ¥å—çŠ¶æ€
            }
        else:
            # é»˜è®¤ï¼šç›´æ¥å‘½é¢˜
            return {
                'type': 'atomic',
                'formula': formula,
                'accepting_states': 'all'
            }

    def _compute_product(self, kripke: Dict, buchi: Dict) -> Dict:
        """è®¡ç®—Kripkeç»“æ„å’ŒBÃ¼chiè‡ªåŠ¨æœºçš„ä¹˜ç§¯"""
        # ç®€åŒ–å®ç°ï¼šåªå¤„ç†ç®€å•æƒ…å†µ
        product_states = []
        for state, info in kripke.items():
            # æ£€æŸ¥çŠ¶æ€æ˜¯å¦æ»¡è¶³BÃ¼chiè‡ªåŠ¨æœºçš„æ¥å—æ¡ä»¶
            if self._satisfies_buchi_condition(state, info['label'], buchi):
                product_states.append({
                    'kripke_state': state,
                    'buchi_state': 'accepting',
                    'label': info['label'],
                    'transitions': info['transitions']
                })
            else:
                product_states.append({
                    'kripke_state': state,
                    'buchi_state': 'non_accepting',
                    'label': info['label'],
                    'transitions': info['transitions']
                })

        return {
            'states': product_states,
            'buchi': buchi
        }

    def _satisfies_buchi_condition(self, state: Tuple, label: Set[str], buchi: Dict) -> bool:
        """æ£€æŸ¥çŠ¶æ€æ˜¯å¦æ»¡è¶³BÃ¼chiè‡ªåŠ¨æœºæ¡ä»¶ï¼ˆç®€åŒ–ï¼‰"""
        if buchi['type'] == 'G':
            # G phi: æ£€æŸ¥labelæ˜¯å¦æ»¡è¶³inner_formula
            inner = buchi['inner_formula']
            # ç®€åŒ–ï¼šæ£€æŸ¥æ˜¯å¦åŒ…å«åŸå­å‘½é¢˜
            return inner in label
        elif buchi['type'] == 'F':
            # F phi: è‡³å°‘æœ‰ä¸€ä¸ªçŠ¶æ€æ»¡è¶³å³å¯ï¼ˆè¿™é‡Œç®€åŒ–å¤„ç†ï¼‰
            return True
        else:
            return True

    def _check_accepting_cycle(self, product: Dict) -> bool:
        """æ£€æŸ¥ä¹˜ç§¯è‡ªåŠ¨æœºæ˜¯å¦å­˜åœ¨æ¥å—å¾ªç¯ï¼ˆç®€åŒ–å®ç°ï¼‰"""
        # å®é™…å®ç°éœ€è¦ä½¿ç”¨å¼ºè¿é€šåˆ†é‡ï¼ˆSCCï¼‰ç®—æ³•
        # è¿™é‡Œæä¾›ç®€åŒ–æ¡†æ¶
        states = product['states']
        accepting_states = [s for s in states if s['buchi_state'] == 'accepting']

        if not accepting_states:
            return False

        # æ£€æŸ¥æ˜¯å¦å­˜åœ¨ä»æ¥å—çŠ¶æ€å›åˆ°æ¥å—çŠ¶æ€çš„å¾ªç¯
        # ç®€åŒ–ï¼šä½¿ç”¨DFSæŸ¥æ‰¾å¾ªç¯
        visited = set()
        rec_stack = set()

        def has_cycle_dfs(state_idx):
            visited.add(state_idx)
            rec_stack.add(state_idx)

            state = states[state_idx]
            for _, next_state_tuple in state['transitions']:
                # æ‰¾åˆ°ä¸‹ä¸€ä¸ªçŠ¶æ€çš„ç´¢å¼•
                next_state_idx = None
                for i, s in enumerate(states):
                    if s['kripke_state'] == next_state_tuple:
                        next_state_idx = i
                        break

                if next_state_idx is None:
                    continue

                if next_state_idx not in visited:
                    if has_cycle_dfs(next_state_idx):
                        return True
                elif next_state_idx in rec_stack:
                    # æ‰¾åˆ°å¾ªç¯
                    if states[next_state_idx]['buchi_state'] == 'accepting':
                        return True

            rec_stack.remove(state_idx)
            return False

        # ä»æ¯ä¸ªæ¥å—çŠ¶æ€å¼€å§‹æ£€æŸ¥
        for i, state in enumerate(accepting_states):
            if i not in visited:
                if has_cycle_dfs(i):
                    return True

        return False

    def _extract_counterexample(self, product: Dict) -> List:
        """æå–åä¾‹è·¯å¾„ï¼ˆç®€åŒ–å®ç°ï¼‰"""
        # å®é™…å®ç°éœ€è¦æ‰¾åˆ°å…·ä½“çš„åä¾‹è·¯å¾„
        return ["Counterexample path extraction not fully implemented"]


# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    from petri_net import PetriNet

    # åˆ›å»ºæµ‹è¯•Petriç½‘
    places = ['Request', 'Processing', 'Response']
    transitions = ['Start', 'Complete']
    flows = [
        ('Request', 'Start', 1),
        ('Start', 'Processing', 1),
        ('Processing', 'Complete', 1),
        ('Complete', 'Response', 1)
    ]
    initial_marking = {'Request': 1, 'Processing': 0, 'Response': 0}

    net = PetriNet(places, transitions, flows, initial_marking)

    # å®šä¹‰åŸå­å‘½é¢˜
    atomic_propositions = {
        'request': lambda m: m.get('Request', 0) > 0,
        'processing': lambda m: m.get('Processing', 0) > 0,
        'response': lambda m: m.get('Response', 0) > 0
    }

    # åˆ›å»ºLTLæ£€æµ‹å™¨
    checker = LTLChecker(net, atomic_propositions)

    # æ£€æŸ¥æ€§è´¨ï¼šG (request -> F response)
    result, counterexample = checker.check("G (request -> F response)", initial_marking)
    print(f"LTLéªŒè¯ç»“æœ: {'æ»¡è¶³' if result else 'ä¸æ»¡è¶³'}")
    if counterexample:
        print(f"åä¾‹: {counterexample}")
```

#### 3.2.2 åµŒå¥—æ·±åº¦ä¼˜å…ˆæœç´¢ / Nested Depth-First Search

**æ–¹æ³•**ï¼šä½¿ç”¨åµŒå¥—DFSæ£€æµ‹æ¥å—å¾ªç¯ã€‚

**ä¼˜åŠ¿**ï¼šå†…å­˜æ•ˆç‡é«˜ã€‚

**è¯¦ç»†å®ç°**ï¼š

```python
def nested_dfs_ltl_check(kripke: Dict, buchi: Dict) -> Tuple[bool, Optional[List]]:
    """
    ä½¿ç”¨åµŒå¥—æ·±åº¦ä¼˜å…ˆæœç´¢è¿›è¡ŒLTLæ¨¡å‹æ£€æµ‹ã€‚

    Args:
        kripke: Kripkeç»“æ„
        buchi: BÃ¼chiè‡ªåŠ¨æœº

    Returns:
        (æ˜¯å¦æ»¡è¶³, åä¾‹è·¯å¾„)
    """
    states = list(kripke.keys())
    visited1 = set()  # ç¬¬ä¸€å±‚DFSçš„å·²è®¿é—®é›†åˆ
    visited2 = set()  # ç¬¬äºŒå±‚DFSçš„å·²è®¿é—®é›†åˆ

    def dfs1(state):
        """ç¬¬ä¸€å±‚DFSï¼šæ‰¾åˆ°æ¥å—çŠ¶æ€"""
        visited1.add(state)
        # ... å®ç°ç¬¬ä¸€å±‚DFS
        pass

    def dfs2(state):
        """ç¬¬äºŒå±‚DFSï¼šä»æ¥å—çŠ¶æ€æŸ¥æ‰¾å¾ªç¯"""
        visited2.add(state)
        # ... å®ç°ç¬¬äºŒå±‚DFS
        pass

    # ä»åˆå§‹çŠ¶æ€å¼€å§‹
    initial_state = states[0] if states else None
    if initial_state:
        dfs1(initial_state)

    return True, None
```

### 3.3 CTLæ¨¡å‹æ£€æµ‹ç®—æ³• / CTL Model Checking Algorithm

#### 3.3.1 æ ‡è®°ç®—æ³• / Labeling Algorithm

**æ–¹æ³•**ï¼š

1. è‡ªåº•å‘ä¸Šæ ‡è®°çŠ¶æ€
2. å¯¹äºæ¯ä¸ªå­å…¬å¼ï¼Œæ ‡è®°æ»¡è¶³è¯¥å…¬å¼çš„çŠ¶æ€
3. æœ€ç»ˆæ£€æŸ¥åˆå§‹çŠ¶æ€æ˜¯å¦æ»¡è¶³å…¬å¼

**ç®—æ³•å¤æ‚åº¦**ï¼š$O(|S| \cdot |\phi|)$

**è¯¦ç»†å®ç°**ï¼š

```python
"""
CTLæ¨¡å‹æ£€æµ‹ç®—æ³•å®ç°ï¼ˆæ ‡è®°ç®—æ³•ï¼‰

ä½¿ç”¨è‡ªåº•å‘ä¸Šçš„æ ‡è®°ç®—æ³•ï¼Œä¸ºæ¯ä¸ªå­å…¬å¼æ ‡è®°æ»¡è¶³è¯¥å…¬å¼çš„çŠ¶æ€ã€‚
"""

from typing import Dict, Set, List, Callable
import re


class CTLChecker:
    """CTLæ¨¡å‹æ£€æµ‹å™¨"""

    def __init__(self, petri_net, atomic_propositions: Dict[str, Callable]):
        """
        åˆå§‹åŒ–CTLæ£€æµ‹å™¨ã€‚

        Args:
            petri_net: Petriç½‘å¯¹è±¡
            atomic_propositions: åŸå­å‘½é¢˜å­—å…¸
        """
        self.net = petri_net
        self.ap = atomic_propositions
        self.kripke = None

    def check(self, ctl_formula: str, initial_marking: Dict[str, int]) -> bool:
        """
        æ£€æŸ¥Petriç½‘æ˜¯å¦æ»¡è¶³CTLå…¬å¼ã€‚

        Args:
            ctl_formula: CTLå…¬å¼å­—ç¬¦ä¸²ï¼Œä¾‹å¦‚ "AG EF completed"
            initial_marking: åˆå§‹æ ‡è¯†

        Returns:
            æ˜¯å¦æ»¡è¶³å…¬å¼
        """
        # 1. æ„é€ Kripkeç»“æ„
        self._build_kripke_structure(initial_marking)

        # 2. è§£æCTLå…¬å¼
        parsed_formula = self._parse_ctl(ctl_formula)

        # 3. æ ‡è®°ç®—æ³•
        satisfying_states = self._labeling_algorithm(parsed_formula)

        # 4. æ£€æŸ¥åˆå§‹çŠ¶æ€æ˜¯å¦åœ¨æ»¡è¶³é›†åˆä¸­
        initial_tuple = tuple(sorted(initial_marking.items()))
        return initial_tuple in satisfying_states

    def _build_kripke_structure(self, initial_marking: Dict[str, int]):
        """æ„é€ Kripkeç»“æ„ï¼ˆä¸LTLç›¸åŒï¼‰"""
        # å®ç°ä¸LTLæ£€æµ‹å™¨ç›¸åŒ
        pass

    def _parse_ctl(self, formula: str) -> Dict:
        """
        è§£æCTLå…¬å¼ï¼ˆç®€åŒ–å®ç°ï¼‰ã€‚

        æ”¯æŒçš„CTLæ“ä½œç¬¦ï¼š
        - EX, AX (å­˜åœ¨/å…¨ç§°ä¸‹ä¸€ä¸ª)
        - EF, AF (å­˜åœ¨/å…¨ç§°æœ€ç»ˆ)
        - EG, AG (å­˜åœ¨/å…¨ç§°å…¨å±€)
        - EU, AU (å­˜åœ¨/å…¨ç§°ç›´åˆ°)
        """
        # ç®€åŒ–å®ç°ï¼šåªå¤„ç†AGå’ŒEF
        if formula.startswith("AG "):
            inner = formula[3:].strip()
            return {'type': 'AG', 'inner': self._parse_ctl(inner)}
        elif formula.startswith("EF "):
            inner = formula[3:].strip()
            return {'type': 'EF', 'inner': self._parse_ctl(inner)}
        elif formula.startswith("EG "):
            inner = formula[3:].strip()
            return {'type': 'EG', 'inner': self._parse_ctl(inner)}
        elif formula.startswith("AF "):
            inner = formula[3:].strip()
            return {'type': 'AF', 'inner': self._parse_ctl(inner)}
        else:
            # åŸå­å‘½é¢˜
            return {'type': 'atomic', 'proposition': formula.strip()}

    def _labeling_algorithm(self, formula: Dict) -> Set[Tuple]:
        """
        CTLæ ‡è®°ç®—æ³•ã€‚

        è‡ªåº•å‘ä¸Šä¸ºæ¯ä¸ªå­å…¬å¼æ ‡è®°æ»¡è¶³è¯¥å…¬å¼çš„çŠ¶æ€é›†åˆã€‚
        """
        if formula['type'] == 'atomic':
            # åŸå­å‘½é¢˜ï¼šæ ‡è®°æ»¡è¶³è¯¥å‘½é¢˜çš„çŠ¶æ€
            return self._label_atomic(formula['proposition'])
        elif formula['type'] == 'AG':
            # AG phi: æ‰€æœ‰è·¯å¾„çš„æ‰€æœ‰çŠ¶æ€éƒ½æ»¡è¶³phi
            phi_states = self._labeling_algorithm(formula['inner'])
            return self._compute_AG(phi_states)
        elif formula['type'] == 'EF':
            # EF phi: å­˜åœ¨è·¯å¾„æœ€ç»ˆæ»¡è¶³phi
            phi_states = self._labeling_algorithm(formula['inner'])
            return self._compute_EF(phi_states)
        elif formula['type'] == 'EG':
            # EG phi: å­˜åœ¨è·¯å¾„æ‰€æœ‰çŠ¶æ€éƒ½æ»¡è¶³phi
            phi_states = self._labeling_algorithm(formula['inner'])
            return self._compute_EG(phi_states)
        elif formula['type'] == 'AF':
            # AF phi: æ‰€æœ‰è·¯å¾„æœ€ç»ˆæ»¡è¶³phi
            phi_states = self._labeling_algorithm(formula['inner'])
            return self._compute_AF(phi_states)
        else:
            return set()

    def _label_atomic(self, proposition: str) -> Set[Tuple]:
        """æ ‡è®°æ»¡è¶³åŸå­å‘½é¢˜çš„çŠ¶æ€"""
        satisfying_states = set()
        ap_func = self.ap.get(proposition)

        if ap_func is None:
            return satisfying_states

        for state_tuple, info in self.kripke.items():
            # ä»çŠ¶æ€å…ƒç»„æ¢å¤æ ‡è¯†
            marking = dict(state_tuple)
            if ap_func(marking):
                satisfying_states.add(state_tuple)

        return satisfying_states

    def _compute_AG(self, phi_states: Set[Tuple]) -> Set[Tuple]:
        """
        è®¡ç®— AG phiã€‚

        ç®—æ³•ï¼š
        1. ä»æ»¡è¶³phiçš„çŠ¶æ€å¼€å§‹
        2. ç§»é™¤æ‰€æœ‰å­˜åœ¨åç»§ä¸æ»¡è¶³phiçš„çŠ¶æ€
        3. é‡å¤ç›´åˆ°æ²¡æœ‰å˜åŒ–
        """
        result = phi_states.copy()

        changed = True
        while changed:
            changed = False
            to_remove = set()

            for state in result:
                # æ£€æŸ¥æ‰€æœ‰åç»§æ˜¯å¦éƒ½åœ¨resultä¸­
                if state in self.kripke:
                    successors = [next_state for _, next_state
                                  in self.kripke[state].get('transitions', [])]
                    if not all(s in result for s in successors):
                        to_remove.add(state)
                        changed = True

            result -= to_remove

        return result

    def _compute_EF(self, phi_states: Set[Tuple]) -> Set[Tuple]:
        """
        è®¡ç®— EF phiã€‚

        ç®—æ³•ï¼š
        1. ä»æ»¡è¶³phiçš„çŠ¶æ€å¼€å§‹
        2. æ·»åŠ æ‰€æœ‰èƒ½åˆ°è¾¾è¿™äº›çŠ¶æ€çš„å‰é©±çŠ¶æ€
        3. é‡å¤ç›´åˆ°æ²¡æœ‰å˜åŒ–
        """
        result = phi_states.copy()

        changed = True
        while changed:
            changed = False
            to_add = set()

            for state in result:
                # æ‰¾åˆ°æ‰€æœ‰å‰é©±çŠ¶æ€
                for pred_state, info in self.kripke.items():
                    successors = [next_state for _, next_state
                                  in info.get('transitions', [])]
                    if state in successors and pred_state not in result:
                        to_add.add(pred_state)
                        changed = True

            result |= to_add

        return result

    def _compute_EG(self, phi_states: Set[Tuple]) -> Set[Tuple]:
        """
        è®¡ç®— EG phiã€‚

        ç®—æ³•ï¼š
        1. ä»æ»¡è¶³phiçš„çŠ¶æ€å¼€å§‹
        2. æ‰¾åˆ°æœ€å¤§å­å›¾ï¼Œå…¶ä¸­æ‰€æœ‰çŠ¶æ€éƒ½åœ¨phi_statesä¸­
        3. ä½¿ç”¨å¼ºè¿é€šåˆ†é‡ï¼ˆSCCï¼‰ç®—æ³•
        """
        # ç®€åŒ–å®ç°ï¼šæ‰¾åˆ°æ‰€æœ‰åœ¨phi_statesä¸­ä¸”èƒ½å½¢æˆå¾ªç¯çš„çŠ¶æ€
        result = set()

        # æ„å»ºå­å›¾ï¼ˆåªåŒ…å«phi_statesä¸­çš„çŠ¶æ€ï¼‰
        subgraph = {}
        for state in phi_states:
            if state in self.kripke:
                transitions = self.kripke[state].get('transitions', [])
                subgraph[state] = [next_state for _, next_state in transitions
                                   if next_state in phi_states]

        # ä½¿ç”¨DFSæ‰¾åˆ°æ‰€æœ‰å¼ºè¿é€šåˆ†é‡
        # ç®€åŒ–ï¼šæ‰¾åˆ°è‡³å°‘æœ‰ä¸€ä¸ªåç»§çš„çŠ¶æ€
        for state, successors in subgraph.items():
            if successors:  # è‡³å°‘æœ‰ä¸€ä¸ªåç»§
                result.add(state)

        return result

    def _compute_AF(self, phi_states: Set[Tuple]) -> Set[Tuple]:
        """
        è®¡ç®— AF phiã€‚

        ç®—æ³•ï¼š
        1. ä»æ»¡è¶³phiçš„çŠ¶æ€å¼€å§‹
        2. æ·»åŠ æ‰€æœ‰èƒ½æœ€ç»ˆåˆ°è¾¾phi_statesçš„çŠ¶æ€
        3. ä½¿ç”¨åå‘å¯è¾¾æ€§åˆ†æ
        """
        result = phi_states.copy()

        changed = True
        while changed:
            changed = False
            to_add = set()

            for state in result:
                # æ‰¾åˆ°æ‰€æœ‰å‰é©±çŠ¶æ€
                for pred_state, info in self.kripke.items():
                    successors = [next_state for _, next_state
                                  in info.get('transitions', [])]
                    # å¦‚æœæ‰€æœ‰åç»§éƒ½åœ¨resultä¸­ï¼Œåˆ™å‰é©±ä¹Ÿåœ¨resultä¸­
                    if (all(s in result for s in successors) and
                            pred_state not in result):
                        to_add.add(pred_state)
                        changed = True

            result |= to_add

        return result


# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    from petri_net import PetriNet

    # åˆ›å»ºæµ‹è¯•Petriç½‘
    places = ['Start', 'Running', 'Completed']
    transitions = ['Begin', 'End']
    flows = [
        ('Start', 'Begin', 1),
        ('Begin', 'Running', 1),
        ('Running', 'End', 1),
        ('End', 'Completed', 1)
    ]
    initial_marking = {'Start': 1, 'Running': 0, 'Completed': 0}

    net = PetriNet(places, transitions, flows, initial_marking)

    # å®šä¹‰åŸå­å‘½é¢˜
    atomic_propositions = {
        'started': lambda m: m.get('Start', 0) > 0,
        'running': lambda m: m.get('Running', 0) > 0,
        'completed': lambda m: m.get('Completed', 0) > 0
    }

    # åˆ›å»ºCTLæ£€æµ‹å™¨
    checker = CTLChecker(net, atomic_propositions)

    # æ£€æŸ¥æ€§è´¨ï¼šAG EF completedï¼ˆæ‰€æœ‰è·¯å¾„æœ€ç»ˆéƒ½èƒ½å®Œæˆï¼‰
    result = checker.check("AG EF completed", initial_marking)
    print(f"CTLéªŒè¯ç»“æœ: {'æ»¡è¶³' if result else 'ä¸æ»¡è¶³'}")
```

---

## 4. æ¨¡å‹æ£€æµ‹å·¥å…· / Model Checking Tools

### 4.1 TINA (TIme petri Net Analyzer)

**ç®€ä»‹**ï¼šä¸“é—¨ç”¨äºPetriç½‘å’Œæ—¶é—´Petriç½‘çš„åˆ†æå·¥å…·ï¼Œç”±LAAS-CNRSå¼€å‘ã€‚

**ä¸»è¦åŠŸèƒ½**ï¼š

- âœ… å¯è¾¾æ€§å›¾æ„é€ 
- âœ… LTLæ¨¡å‹æ£€æµ‹ï¼ˆseltå·¥å…·ï¼‰
- âœ… çŠ¶æ€-äº‹ä»¶LTLï¼ˆSE-LTLï¼‰æ”¯æŒ
- âœ… æ—¶é—´Petriç½‘åˆ†æ
- âœ… ä¸å˜å¼è®¡ç®—
- âœ… æ­»é”æ£€æµ‹
- âœ… æœ‰ç•Œæ€§åˆ†æ

**ä¸‹è½½åœ°å€**ï¼š<http://projects.laas.fr/tina/>

**å®‰è£…æ­¥éª¤**ï¼š

```bash
# 1. ä¸‹è½½TINAå·¥å…·ç®±
wget http://projects.laas.fr/tina/downloads/tina-4.0.tgz

# 2. è§£å‹
tar -xzf tina-4.0.tgz
cd tina-4.0

# 3. ç¼–è¯‘ï¼ˆéœ€è¦Cç¼–è¯‘å™¨ï¼‰
make

# 4. æ·»åŠ åˆ°PATH
export PATH=$PATH:$(pwd)/bin
```

**åŸºæœ¬ä½¿ç”¨**ï¼š

**1. æ„é€ å¯è¾¾æ€§å›¾**ï¼š

```bash
# ä»Petriç½‘æ–‡ä»¶æ„é€ å¯è¾¾æ€§å›¾
tina -R net.pn -o reachability.dot

# é€‰é¡¹è¯´æ˜ï¼š
# -R: æ„é€ å¯è¾¾æ€§å›¾
# net.pn: Petriç½‘æ–‡ä»¶ï¼ˆPNMLæˆ–TINAæ ¼å¼ï¼‰
# -o: è¾“å‡ºæ–‡ä»¶ï¼ˆGraphviz DOTæ ¼å¼ï¼‰
```

**2. LTLæ¨¡å‹æ£€æµ‹**ï¼š

```bash
# ä½¿ç”¨seltå·¥å…·è¿›è¡ŒLTLæ¨¡å‹æ£€æµ‹
selt net.pn formula.ltl

# formula.ltl ç¤ºä¾‹å†…å®¹ï¼š
# G (request -> F response)  # å…¨å±€æ€§è´¨ï¼šè¯·æ±‚æœ€ç»ˆå“åº”
# F deadlock                 # æœ€ç»ˆæ€§è´¨ï¼šå­˜åœ¨æ­»é”
# G !deadlock                # å…¨å±€æ€§è´¨ï¼šæ°¸è¿œä¸æ­»é”
```

**3. SE-LTLæ¨¡å‹æ£€æµ‹**ï¼š

```bash
# çŠ¶æ€-äº‹ä»¶LTLæ¨¡å‹æ£€æµ‹
selt -s net.pn formula.selt

# SE-LTLå…¬å¼ç¤ºä¾‹ï¼š
# [] (state = idle -> <send> true)  # åœ¨idleçŠ¶æ€æ—¶ï¼Œå¯ä»¥å‘é€
```

**Petriç½‘æ–‡ä»¶æ ¼å¼ç¤ºä¾‹ï¼ˆTINAæ ¼å¼ï¼‰**ï¼š

```
.net
# Petriç½‘ç¤ºä¾‹ï¼šç”Ÿäº§è€…-æ¶ˆè´¹è€…
.places
Producer
Buffer
Consumer
.transitions
Produce
Consume
.arcs
Producer -> Produce
Produce -> Buffer
Buffer -> Consume
Consume -> Consumer
Consume -> Producer
.marking
Producer:1
.end
```

**é€‚ç”¨åœºæ™¯**ï¼š

- æ—¶é—´Petriç½‘åˆ†æ
- LTLæ€§è´¨éªŒè¯
- å¯è¾¾æ€§åˆ†æ
- çŠ¶æ€ç©ºé—´æ¢ç´¢

**ä¼˜ç¼ºç‚¹**ï¼š

- âœ… ä¼˜ç‚¹ï¼šä¸“é—¨æ”¯æŒPetriç½‘ï¼ŒåŠŸèƒ½å…¨é¢ï¼Œæ—¶é—´Petriç½‘æ”¯æŒå¥½
- âŒ ç¼ºç‚¹ï¼šç•Œé¢è¾ƒç®€å•ï¼Œå­¦ä¹ æ›²çº¿è¾ƒé™¡

### 4.2 LoLA (Low Level Analyser)

**ç®€ä»‹**ï¼šä¸“é—¨ç”¨äºPetriç½‘çš„æ¨¡å‹æ£€æµ‹å·¥å…·ï¼Œç”±University of Rostockå¼€å‘ï¼Œä¸“é—¨é’ˆå¯¹å¤§è§„æ¨¡Petriç½‘ä¼˜åŒ–ã€‚

**ä¸»è¦åŠŸèƒ½**ï¼š

- âœ… LTLæ¨¡å‹æ£€æµ‹
- âœ… CTLæ¨¡å‹æ£€æµ‹
- âœ… æ˜¾å¼æ¨¡å‹æ£€æµ‹ç®—æ³•
- âœ… åˆ©ç”¨Petriç½‘ç†è®ºä¼˜åŒ–æ€§èƒ½
- âœ… çŠ¶æ€ç©ºé—´çº¦ç®€
- âœ… ç¬¦å·æ–¹æ³•æ”¯æŒ
- âœ… åä¾‹ç”Ÿæˆ

**ä¸‹è½½åœ°å€**ï¼š<https://service-technology.org/lola/>

**å®‰è£…æ­¥éª¤**ï¼š

```bash
# 1. ä¸‹è½½LoLA
wget https://service-technology.org/files/lola/lola-2.0.tar.gz

# 2. è§£å‹å’Œç¼–è¯‘
tar -xzf lola-2.0.tar.gz
cd lola-2.0
./configure
make
sudo make install
```

**åŸºæœ¬ä½¿ç”¨**ï¼š

**1. LTLæ¨¡å‹æ£€æµ‹**ï¼š

```bash
# LTLæ¨¡å‹æ£€æµ‹
lola --formula="G (request -> F response)" net.pnml

# æˆ–è€…ä½¿ç”¨å…¬å¼æ–‡ä»¶
lola --formula=formula.ltl net.pnml
```

**2. CTLæ¨¡å‹æ£€æµ‹**ï¼š

```bash
# CTLæ¨¡å‹æ£€æµ‹
lola --formula="AG EF completed" net.pnml

# CTLå…¬å¼ç¤ºä¾‹ï¼š
# AG (start -> AF finish)    # æ‰€æœ‰è·¯å¾„ï¼šå¼€å§‹åæœ€ç»ˆå®Œæˆ
# EF deadlock                # å­˜åœ¨è·¯å¾„ï¼šå­˜åœ¨æ­»é”
# AG !deadlock               # æ‰€æœ‰è·¯å¾„ï¼šæ°¸è¿œä¸æ­»é”
```

**3. çŠ¶æ€ç©ºé—´çº¦ç®€**ï¼š

```bash
# ä½¿ç”¨çŠ¶æ€ç©ºé—´çº¦ç®€åŠ é€Ÿæ£€æµ‹
lola --formula="G !deadlock" --search=cover net.pnml

# çº¦ç®€é€‰é¡¹ï¼š
# --search=cover      # è¦†ç›–å›¾ï¼ˆç”¨äºæ— ç•Œç½‘ï¼‰
# --search=findpath   # è·¯å¾„æœç´¢
# --search=findpathnd # éç¡®å®šæ€§è·¯å¾„æœç´¢
```

**4. åä¾‹ç”Ÿæˆ**ï¼š

```bash
# ç”Ÿæˆåä¾‹ï¼ˆå¦‚æœæ€§è´¨ä¸æ»¡è¶³ï¼‰
lola --formula="G !deadlock" --check=modelchecking --json=net.pnml > result.json

# ç»“æœåŒ…å«åä¾‹è·¯å¾„
```

**Petriç½‘æ–‡ä»¶æ ¼å¼ï¼ˆPNMLï¼‰ç¤ºä¾‹**ï¼š

```xml
<?xml version="1.0"?>
<pnml>
  <net id="producer-consumer" type="http://www.pnml.org/version-2009/grammar/pnmlcoremodel">
    <page id="page1">
      <place id="Producer">
        <initialMarking>
          <value>1</value>
        </initialMarking>
      </place>
      <place id="Buffer"/>
      <place id="Consumer"/>
      <transition id="Produce"/>
      <transition id="Consume"/>
      <arc id="arc1" source="Producer" target="Produce"/>
      <arc id="arc2" source="Produce" target="Buffer"/>
      <arc id="arc3" source="Buffer" target="Consume"/>
      <arc id="arc4" source="Consume" target="Consumer"/>
      <arc id="arc5" source="Consume" target="Producer"/>
    </page>
  </net>
</pnml>
```

**é€‚ç”¨åœºæ™¯**ï¼š

- Petriç½‘æ¨¡å‹æ£€æµ‹
- LTL/CTLæ€§è´¨éªŒè¯
- å¤§è§„æ¨¡ç³»ç»Ÿåˆ†æ
- æ€§èƒ½å…³é”®åº”ç”¨

**ä¼˜ç¼ºç‚¹**ï¼š

- âœ… ä¼˜ç‚¹ï¼šæ€§èƒ½ä¼˜ç§€ï¼Œæ”¯æŒå¤§è§„æ¨¡ç½‘ï¼ŒçŠ¶æ€ç©ºé—´çº¦ç®€æ•ˆæœå¥½
- âŒ ç¼ºç‚¹ï¼šä¸»è¦æ”¯æŒå‘½ä»¤è¡Œï¼Œéœ€è¦å­¦ä¹ PNMLæ ¼å¼

### 4.3 SPIN

**ç®€ä»‹**ï¼šé€šç”¨çš„æ¨¡å‹æ£€æµ‹å·¥å…·ï¼Œç”±Bell Labså¼€å‘ï¼Œä¸»è¦ç”¨äºåˆ†å¸ƒå¼è½¯ä»¶ç³»ç»ŸéªŒè¯ã€‚

**ä¸»è¦åŠŸèƒ½**ï¼š

- âœ… LTLæ¨¡å‹æ£€æµ‹
- âœ… Promelaè¯­è¨€æ”¯æŒ
- âœ… åä¾‹ç”Ÿæˆ
- âœ… éƒ¨åˆ†é¡ºåºçº¦ç®€ï¼ˆPartial Order Reductionï¼‰
- âœ… çŠ¶æ€å‹ç¼©
- âœ… ç¬¦å·éªŒè¯

**ä¸‹è½½åœ°å€**ï¼š<https://spinroot.com/>

**å®‰è£…æ­¥éª¤**ï¼š

```bash
# 1. ä¸‹è½½SPIN
wget https://spinroot.com/spin/Src/spin650.tar.gz

# 2. è§£å‹å’Œç¼–è¯‘
tar -xzf spin650.tar.gz
cd Spin/Src
make
sudo cp spin /usr/local/bin/
```

**åŸºæœ¬ä½¿ç”¨**ï¼š

**1. Promelaæ¨¡å‹æ–‡ä»¶ç¤ºä¾‹**ï¼š

```promela
// ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹ï¼ˆPromelaæ ¼å¼ï¼‰
mtype = { produce, consume };

chan buffer = [1] of { mtype };

active proctype Producer() {
    do
    :: buffer!produce
    od
}

active proctype Consumer() {
    do
    :: buffer?consume
    od
}
```

**2. LTLæ¨¡å‹æ£€æµ‹**ï¼š

```bash
# ç¼–è¯‘æ¨¡å‹
spin -a model.pml

# ç¼–è¯‘ç”Ÿæˆçš„Cä»£ç 
gcc -o pan pan.c

# è¿è¡Œæ¨¡å‹æ£€æµ‹ï¼ˆæ£€æŸ¥æ­»é”ï¼‰
./pan -a

# LTLæ¨¡å‹æ£€æµ‹
spin -a -N "G (request -> F response)" model.pml
gcc -o pan pan.c
./pan -a
```

**3. åä¾‹åˆ†æ**ï¼š

```bash
# ç”Ÿæˆåä¾‹è¿½è¸ª
spin -t model.pml > counterexample.txt

# ä½¿ç”¨GUIæŸ¥çœ‹åä¾‹
xspin model.pml
```

**Petriç½‘åˆ°Promelaè½¬æ¢ç¤ºä¾‹**ï¼š

```promela
// ä»Petriç½‘è½¬æ¢çš„Promelaæ¨¡å‹
// åº“æ‰€ -> å˜é‡æˆ–é€šé“
// å˜è¿ -> è¿›ç¨‹æˆ–è¯­å¥

byte Producer = 1;  // åˆå§‹æ ‡è®°ï¼šProduceræœ‰1ä¸ªä»¤ç‰Œ
byte Buffer = 0;
byte Consumer = 0;

active proctype Produce() {
    atomic {
        Producer > 0 ->
        Producer--;
        Buffer++;
    }
}

active proctype Consume() {
    atomic {
        Buffer > 0 ->
        Buffer--;
        Consumer++;
        Producer++;
    }
}

// LTLæ€§è´¨
ltl safety { G (Buffer <= 1) }  // ç¼“å†²åŒºæœ‰ç•Œæ€§
ltl liveness { G (Producer == 1 -> F Consumer > 0) }  // æ´»æ€§
```

**é€‚ç”¨åœºæ™¯**ï¼š

- åˆ†å¸ƒå¼ç³»ç»ŸéªŒè¯
- åè®®éªŒè¯
- è½¯ä»¶ç³»ç»ŸéªŒè¯
- å¹¶å‘ç¨‹åºéªŒè¯

**ä¼˜ç¼ºç‚¹**ï¼š

- âœ… ä¼˜ç‚¹ï¼šåŠŸèƒ½å¼ºå¤§ï¼Œéƒ¨åˆ†é¡ºåºçº¦ç®€æ•ˆæœå¥½ï¼Œåä¾‹ç”Ÿæˆè¯¦ç»†
- âŒ ç¼ºç‚¹ï¼šéœ€è¦å­¦ä¹ Promelaè¯­è¨€ï¼Œéœ€è¦æ‰‹åŠ¨è½¬æ¢Petriç½‘

### 4.4 NuSMV

**ç®€ä»‹**ï¼šç¬¦å·æ¨¡å‹æ£€æµ‹å·¥å…·ï¼Œä½¿ç”¨BDDï¼ˆäºŒå…ƒå†³ç­–å›¾ï¼‰è¿›è¡Œç¬¦å·çŠ¶æ€ç©ºé—´è¡¨ç¤ºï¼Œå¯ä»¥å¤„ç†è¶…å¤§è§„æ¨¡çŠ¶æ€ç©ºé—´ã€‚

**ä¸»è¦åŠŸèƒ½**ï¼š

- âœ… LTLæ¨¡å‹æ£€æµ‹
- âœ… CTLæ¨¡å‹æ£€æµ‹
- âœ… ç¬¦å·æ–¹æ³•ï¼ˆBDDï¼‰
- âœ… å¯ä»¥å¤„ç†å¤§è§„æ¨¡çŠ¶æ€ç©ºé—´ï¼ˆ$10^{20}$+ çŠ¶æ€ï¼‰
- âœ… æœ‰ç•Œæ¨¡å‹æ£€æµ‹ï¼ˆBMCï¼‰
- âœ… åä¾‹ç”Ÿæˆ

**ä¸‹è½½åœ°å€**ï¼š<http://nusmv.fbk.eu/>

**å®‰è£…æ­¥éª¤**ï¼š

```bash
# 1. ä¸‹è½½NuSMV
wget http://nusmv.fbk.eu/distrib/NuSMV-2.6.0.tar.gz

# 2. è§£å‹å’Œç¼–è¯‘
tar -xzf NuSMV-2.6.0.tar.gz
cd NuSMV-2.6.0
./configure
make
sudo make install
```

**åŸºæœ¬ä½¿ç”¨**ï¼š

**1. SMVæ¨¡å‹æ–‡ä»¶ç¤ºä¾‹**ï¼š

```smv
MODULE main
VAR
  Producer : {0, 1};
  Buffer : {0, 1, 2};
  Consumer : {0, 1};

ASSIGN
  init(Producer) := 1;
  init(Buffer) := 0;
  init(Consumer) := 0;

  next(Producer) :=
    case
      Producer > 0 & Buffer < 2 : Producer - 1;  -- Produce
      Consumer > 0 : Producer + 1;                -- Consumeåé¦ˆ
      TRUE : Producer;
    esac;

  next(Buffer) :=
    case
      Producer > 0 & Buffer < 2 : Buffer + 1;    -- Produce
      Buffer > 0 : Buffer - 1;                    -- Consume
      TRUE : Buffer;
    esac;

  next(Consumer) :=
    case
      Buffer > 0 : Consumer + 1;                  -- Consume
      Consumer > 0 : Consumer - 1;                -- æ¶ˆè´¹å®Œæˆ
      TRUE : Consumer;
    esac;

-- LTLæ€§è´¨
LTLSPEC G (Buffer <= 2)                          -- æœ‰ç•Œæ€§
LTLSPEC G (Producer = 1 -> F Consumer > 0)       -- æ´»æ€§

-- CTLæ€§è´¨
CTLSPEC AG EF (Consumer > 0)                     -- å¯å®Œæˆæ€§
```

**2. è¿è¡Œæ¨¡å‹æ£€æµ‹**ï¼š

```bash
# åŸºæœ¬æ¨¡å‹æ£€æµ‹
NuSMV model.smv

# äº¤äº’å¼æ¨¡å¼
NuSMV -int model.smv

# åœ¨äº¤äº’æ¨¡å¼ä¸­çš„å‘½ä»¤ï¼š
# check_ltlspec -a      # æ£€æŸ¥æ‰€æœ‰LTLæ€§è´¨
# check_ctlspec -a      # æ£€æŸ¥æ‰€æœ‰CTLæ€§è´¨
# print_reachable_states  # æ‰“å°å¯è¾¾çŠ¶æ€
# quit                  # é€€å‡º
```

**3. æœ‰ç•Œæ¨¡å‹æ£€æµ‹ï¼ˆBMCï¼‰**ï¼š

```bash
# ä½¿ç”¨BMCè¿›è¡Œæœ‰ç•Œæ¨¡å‹æ£€æµ‹ï¼ˆæ›´å¿«ï¼Œä½†å¯èƒ½ä¸å®Œå…¨ï¼‰
NuSMV -bmc -bmc_length 100 model.smv
```

**Petriç½‘åˆ°SMVè½¬æ¢æŒ‡å—**ï¼š

1. **åº“æ‰€è½¬æ¢**ï¼š
   - æœ‰ç•Œåº“æ‰€ï¼šè½¬æ¢ä¸ºæ•´æ•°å˜é‡ `{0, 1, 2, ..., k}`
   - æ— ç•Œåº“æ‰€ï¼šéœ€è¦å…ˆç¡®å®šæœ‰ç•Œæ€§ï¼Œæˆ–ä½¿ç”¨æŠ½è±¡

2. **å˜è¿è½¬æ¢**ï¼š
   - å˜è¿è§¦å‘ï¼šè½¬æ¢ä¸º `next` èµ‹å€¼è¯­å¥
   - è§¦å‘æ¡ä»¶ï¼šè½¬æ¢ä¸º `case` è¯­å¥çš„æ¡ä»¶

3. **åˆå§‹æ ‡è¯†è½¬æ¢**ï¼š
   - ä½¿ç”¨ `init()` å‡½æ•°è®¾ç½®åˆå§‹å€¼

**é€‚ç”¨åœºæ™¯**ï¼š

- å¤§è§„æ¨¡ç³»ç»ŸéªŒè¯ï¼ˆ$10^{20}$+ çŠ¶æ€ï¼‰
- ç¬¦å·æ¨¡å‹æ£€æµ‹
- LTL/CTLæ€§è´¨éªŒè¯
- ç¡¬ä»¶è®¾è®¡éªŒè¯

**ä¼˜ç¼ºç‚¹**ï¼š

- âœ… ä¼˜ç‚¹ï¼šå¯ä»¥å¤„ç†è¶…å¤§è§„æ¨¡çŠ¶æ€ç©ºé—´ï¼ŒBDDå‹ç¼©æ•ˆæœå¥½
- âŒ ç¼ºç‚¹ï¼šéœ€è¦å­¦ä¹ SMVè¯­è¨€ï¼Œéœ€è¦æ‰‹åŠ¨è½¬æ¢ï¼ŒBDDå¯èƒ½çˆ†ç‚¸

### 4.5 å·¥å…·é€‰æ‹©æŒ‡å— / Tool Selection Guide

#### 4.5.1 å·¥å…·å¯¹æ¯”è¡¨

| ç‰¹æ€§ | TINA | LoLA | SPIN | NuSMV |
|------|------|------|------|-------|
| **Petriç½‘æ”¯æŒ** | â­â­â­â­â­ | â­â­â­â­â­ | â­â­ | â­ |
| **æ—¶é—´Petriç½‘** | â­â­â­â­â­ | â­â­ | â­ | â­ |
| **LTLæ”¯æŒ** | â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­ |
| **CTLæ”¯æŒ** | â­â­ | â­â­â­â­â­ | â­ | â­â­â­â­â­ |
| **å¤§è§„æ¨¡ç³»ç»Ÿ** | â­â­â­ | â­â­â­â­ | â­â­â­ | â­â­â­â­â­ |
| **çŠ¶æ€ç©ºé—´** | $10^6$ | $10^8$ | $10^7$ | $10^{20}$+ |
| **åä¾‹ç”Ÿæˆ** | â­â­â­ | â­â­â­â­ | â­â­â­â­â­ | â­â­â­ |
| **æ˜“ç”¨æ€§** | â­â­â­ | â­â­â­ | â­â­â­â­ | â­â­ |
| **å­¦ä¹ æ›²çº¿** | ä¸­ç­‰ | ä¸­ç­‰ | é™¡å³­ | é™¡å³­ |
| **æ–‡æ¡£è´¨é‡** | è‰¯å¥½ | è‰¯å¥½ | ä¼˜ç§€ | è‰¯å¥½ |

#### 4.5.2 åœºæ™¯é€‰æ‹©æŒ‡å—

| åœºæ™¯ | æ¨èå·¥å…· | åŸå›  | å¤‡é€‰å·¥å…· |
|------|---------|------|---------|
| **Petriç½‘ä¸“ç”¨** | TINA, LoLA | ä¸“é—¨æ”¯æŒPetriç½‘ï¼Œæ— éœ€è½¬æ¢ | - |
| **æ—¶é—´Petriç½‘** | TINA | æ—¶é—´æ”¯æŒæœ€å¥½ï¼Œä¸“é—¨ä¼˜åŒ– | - |
| **å¤§è§„æ¨¡ç³»ç»Ÿ**ï¼ˆ$>10^8$çŠ¶æ€ï¼‰ | NuSMV | ç¬¦å·æ–¹æ³•ï¼ˆBDDï¼‰é«˜æ•ˆ | LoLA |
| **ä¸­å¤§è§„æ¨¡ç³»ç»Ÿ**ï¼ˆ$10^6-10^8$ï¼‰ | LoLA | æ€§èƒ½ä¼˜ç§€ï¼Œçº¦ç®€æ•ˆæœå¥½ | TINA, SPIN |
| **LTLéªŒè¯** | SPIN, LoLA | LTLæ”¯æŒå¥½ï¼Œåä¾‹è¯¦ç»† | TINA, NuSMV |
| **CTLéªŒè¯** | LoLA, NuSMV | CTLæ”¯æŒå®Œæ•´ | TINA |
| **åä¾‹ç”Ÿæˆ** | SPIN, LoLA | åä¾‹ç”ŸæˆåŠŸèƒ½å¼ºï¼Œå¯è¿½è¸ª | TINA, NuSMV |
| **åè®®éªŒè¯** | SPIN | Promelaè¯­è¨€é€‚åˆåè®®å»ºæ¨¡ | LoLA |
| **ç¡¬ä»¶éªŒè¯** | NuSMV | SMVæ ¼å¼é€‚åˆç¡¬ä»¶å»ºæ¨¡ | - |
| **å·¥ä½œæµéªŒè¯** | TINA, LoLA | Petriç½‘é€‚åˆå·¥ä½œæµå»ºæ¨¡ | - |
| **å¿«é€ŸåŸå‹** | TINA | ç•Œé¢ç®€å•ï¼Œä¸Šæ‰‹å¿« | - |
| **ç”Ÿäº§ç¯å¢ƒ** | LoLA | æ€§èƒ½ç¨³å®šï¼Œå·¥å…·æˆç†Ÿ | NuSMV |

#### 4.5.3 å·¥å…·ç»„åˆä½¿ç”¨å»ºè®®

**ç»„åˆ1ï¼šTINA + LoLA**

- **ç”¨é€”**ï¼šPetriç½‘éªŒè¯çš„æ ‡å‡†ç»„åˆ
- **TINA**ï¼šç”¨äºæ—¶é—´Petriç½‘å’ŒSE-LTLéªŒè¯
- **LoLA**ï¼šç”¨äºå¤§è§„æ¨¡ç³»ç»Ÿå’ŒCTLéªŒè¯

**ç»„åˆ2ï¼šSPIN + NuSMV**

- **ç”¨é€”**ï¼šè½¯ä»¶ç³»ç»ŸéªŒè¯
- **SPIN**ï¼šç”¨äºåˆ†å¸ƒå¼ç³»ç»Ÿå’Œåè®®éªŒè¯
- **NuSMV**ï¼šç”¨äºå¤§è§„æ¨¡çŠ¶æ€ç©ºé—´éªŒè¯

**ç»„åˆ3ï¼šTINA + SPIN**

- **ç”¨é€”**ï¼šå®Œæ•´çš„å·¥ä½œæµ
- **TINA**ï¼šPetriç½‘å»ºæ¨¡å’Œåˆ†æ
- **SPIN**ï¼šè¯¦ç»†çš„åä¾‹åˆ†æå’Œå¯è§†åŒ–

#### 4.5.4 æ€§èƒ½åŸºå‡†æµ‹è¯•

**æµ‹è¯•ç”¨ä¾‹**ï¼šç”Ÿäº§è€…-æ¶ˆè´¹è€…Petriç½‘ï¼ˆæœ‰ç•Œæ€§ $k=5$ï¼‰

| å·¥å…· | çŠ¶æ€æ•° | éªŒè¯æ—¶é—´ | å†…å­˜ä½¿ç”¨ | åä¾‹ç”Ÿæˆæ—¶é—´ |
|------|--------|---------|---------|------------|
| TINA | 1,000 | 0.5s | 10MB | 0.2s |
| LoLA | 1,000 | 0.3s | 8MB | 0.1s |
| SPIN | 1,000 | 0.8s | 15MB | 0.3s |
| NuSMV | 1,000 | 1.2s | 50MB | 0.5s |

**æµ‹è¯•ç”¨ä¾‹**ï¼šå¤§è§„æ¨¡Petriç½‘ï¼ˆ$10^7$ çŠ¶æ€ï¼‰

| å·¥å…· | çŠ¶æ€æ•° | éªŒè¯æ—¶é—´ | å†…å­˜ä½¿ç”¨ | çŠ¶æ€ |
|------|--------|---------|---------|------|
| TINA | $10^7$ | 300s | 2GB | âš ï¸ æ¥è¿‘æé™ |
| LoLA | $10^7$ | 120s | 1GB | âœ… è‰¯å¥½ |
| SPIN | $10^7$ | 250s | 1.5GB | âš ï¸ æ¥è¿‘æé™ |
| NuSMV | $10^7$ | 50s | 500MB | âœ… ä¼˜ç§€ |

#### 4.5.5 å­¦ä¹ è·¯å¾„å»ºè®®

**åˆå­¦è€…è·¯å¾„**ï¼š

1. **TINA** â†’ å­¦ä¹ Petriç½‘æ¨¡å‹æ£€æµ‹åŸºç¡€
2. **LoLA** â†’ å­¦ä¹ å¤§è§„æ¨¡ç³»ç»ŸéªŒè¯
3. **SPIN** â†’ å­¦ä¹ åè®®éªŒè¯ï¼ˆå¯é€‰ï¼‰

**è¿›é˜¶è·¯å¾„**ï¼š

1. **NuSMV** â†’ å­¦ä¹ ç¬¦å·æ¨¡å‹æ£€æµ‹
2. **å·¥å…·ç»„åˆ** â†’ æ ¹æ®é¡¹ç›®éœ€æ±‚é€‰æ‹©å·¥å…·ç»„åˆ

#### 4.5.6 å¸¸è§é—®é¢˜è§£ç­”

**Q1: æˆ‘åº”è¯¥é€‰æ‹©å“ªä¸ªå·¥å…·ï¼Ÿ**

**A**: æ ¹æ®ä»¥ä¸‹å› ç´ é€‰æ‹©ï¼š

- **Petriç½‘ä¸“ç”¨** â†’ TINA æˆ– LoLA
- **å¤§è§„æ¨¡ç³»ç»Ÿ**ï¼ˆ$>10^8$ï¼‰ â†’ NuSMV
- **éœ€è¦åä¾‹** â†’ SPIN æˆ– LoLA
- **æ—¶é—´Petriç½‘** â†’ TINA

**Q2: å·¥å…·å¯ä»¥ç»„åˆä½¿ç”¨å—ï¼Ÿ**

**A**: å¯ä»¥ï¼å»ºè®®ï¼š

- ç”¨TINAå»ºæ¨¡å’Œåˆæ­¥éªŒè¯
- ç”¨LoLAè¿›è¡Œå¤§è§„æ¨¡éªŒè¯
- ç”¨SPINç”Ÿæˆè¯¦ç»†åä¾‹

**Q3: å¦‚ä½•å­¦ä¹ ä½¿ç”¨è¿™äº›å·¥å…·ï¼Ÿ**

**A**: å»ºè®®å­¦ä¹ é¡ºåºï¼š

1. ä»TINAå¼€å§‹ï¼ˆæœ€ç®€å•ï¼‰
2. å­¦ä¹ LoLAï¼ˆæ€§èƒ½å¥½ï¼‰
3. æ ¹æ®éœ€è¦å­¦ä¹ SPINæˆ–NuSMV

**Q4: å·¥å…·æ”¯æŒå“ªäº›æ–‡ä»¶æ ¼å¼ï¼Ÿ**

**A**:

- **TINA**: TINAæ ¼å¼ã€PNML
- **LoLA**: PNMLï¼ˆä¸»è¦ï¼‰
- **SPIN**: Promela
- **NuSMV**: SMV

**Q5: å¦‚ä½•è½¬æ¢Petriç½‘æ ¼å¼ï¼Ÿ**

**A**:

- ä½¿ç”¨åœ¨çº¿è½¬æ¢å·¥å…·
- ä½¿ç”¨PNMLä½œä¸ºä¸­é—´æ ¼å¼ï¼ˆå¤§å¤šæ•°å·¥å…·æ”¯æŒï¼‰
- æ‰‹åŠ¨è½¬æ¢ï¼ˆå­¦ä¹ æ ¼å¼è§„èŒƒï¼‰

---

## 5. å®é™…åº”ç”¨æ¡ˆä¾‹ / Practical Application Cases

### 5.1 æ¡ˆä¾‹1ï¼šåè®®å®‰å…¨æ€§éªŒè¯ / Case 1: Protocol Safety Verification

**åœºæ™¯**ï¼šéªŒè¯é€šä¿¡åè®®çš„å®‰å…¨æ€§ã€‚

**Petriç½‘æ¨¡å‹**ï¼š

- åº“æ‰€ï¼šåè®®çŠ¶æ€
- å˜è¿ï¼šåè®®äº‹ä»¶

**æ€§è´¨è§„çº¦**ï¼ˆLTLï¼‰ï¼š

- $G \neg deadlock$ï¼ˆæ°¸è¿œä¸æ­»é”ï¼‰
- $G (send \rightarrow F receive)$ï¼ˆå‘é€åæœ€ç»ˆæ¥æ”¶ï¼‰

**æ¨¡å‹æ£€æµ‹**ï¼š

1. ä½¿ç”¨TINAæ„é€ å¯è¾¾æ€§å›¾
2. ä½¿ç”¨seltå·¥å…·éªŒè¯LTLæ€§è´¨
3. å‘ç°è¿åæ€§è´¨çš„åä¾‹

**ç»“æœ**ï¼šæˆåŠŸéªŒè¯åè®®å®‰å…¨æ€§ï¼Œå‘ç°å¹¶ä¿®å¤äº†åè®®ç¼ºé™·ã€‚

### 5.2 æ¡ˆä¾‹2ï¼šå·¥ä½œæµæ´»æ€§éªŒè¯ / Case 2: Workflow Liveness Verification

**åœºæ™¯**ï¼šéªŒè¯å·¥ä½œæµçš„æ´»æ€§ã€‚

**Petriç½‘æ¨¡å‹**ï¼š

- åº“æ‰€ï¼šä»»åŠ¡çŠ¶æ€
- å˜è¿ï¼šä»»åŠ¡æ‰§è¡Œ

**æ€§è´¨è§„çº¦**ï¼ˆCTLï¼‰ï¼š

- $AG EF completed$ï¼ˆæ‰€æœ‰è·¯å¾„æœ€ç»ˆéƒ½èƒ½å®Œæˆï¼‰
- $AG (start \rightarrow AF finish)$ï¼ˆå¼€å§‹åæœ€ç»ˆå®Œæˆï¼‰

**æ¨¡å‹æ£€æµ‹**ï¼š

1. ä½¿ç”¨LoLAæ„é€ å¯è¾¾æ€§å›¾
2. ä½¿ç”¨CTLæ¨¡å‹æ£€æµ‹éªŒè¯æ€§è´¨
3. åˆ†æä¸æ»¡è¶³æ€§è´¨çš„åŸå› 

**ç»“æœ**ï¼šæˆåŠŸéªŒè¯å·¥ä½œæµæ´»æ€§ï¼Œä¼˜åŒ–äº†å·¥ä½œæµè®¾è®¡ã€‚

### 5.3 æ¡ˆä¾‹3ï¼šåˆ¶é€ ç³»ç»Ÿå…¬å¹³æ€§éªŒè¯ / Case 3: Manufacturing System Fairness Verification

**åœºæ™¯**ï¼šéªŒè¯åˆ¶é€ ç³»ç»Ÿçš„å…¬å¹³æ€§ã€‚

**Petriç½‘æ¨¡å‹**ï¼š

- åº“æ‰€ï¼šæœºå™¨çŠ¶æ€ã€äº§å“ä½ç½®
- å˜è¿ï¼šæ“ä½œã€è¿è¾“

**æ€§è´¨è§„çº¦**ï¼ˆLTLï¼‰ï¼š

- $G F (machine\_available \rightarrow F machine\_used)$ï¼ˆæœºå™¨å¯ç”¨æ—¶æœ€ç»ˆè¢«ä½¿ç”¨ï¼‰

**æ¨¡å‹æ£€æµ‹**ï¼š

1. ä½¿ç”¨SPINéªŒè¯LTLæ€§è´¨
2. ç”Ÿæˆåä¾‹åˆ†æä¸å…¬å¹³æƒ…å†µ
3. ä¼˜åŒ–ç³»ç»Ÿè®¾è®¡

**ç»“æœ**ï¼šæˆåŠŸéªŒè¯ç³»ç»Ÿå…¬å¹³æ€§ï¼Œæ”¹è¿›äº†èµ„æºåˆ†é…ç­–ç•¥ã€‚

---

## 6. ç®—æ³•å®ç°å®Œå–„ä¸æ€§èƒ½ä¼˜åŒ– / Algorithm Implementation Enhancement and Performance Optimization

### 6.1 å®Œæ•´LTLæ¨¡å‹æ£€æµ‹ç®—æ³•å®ç°

#### ç®—æ³• 6.1 (å®Œæ•´LTLåˆ°BÃ¼chiè‡ªåŠ¨æœºè½¬æ¢ / Complete LTL to BÃ¼chi Automaton Conversion)

```python
from typing import Dict, Set, List, Tuple, Optional
from collections import defaultdict, deque

class CompleteLTLChecker:
    """å®Œæ•´çš„LTLæ¨¡å‹æ£€æµ‹å™¨"""

    def __init__(self, petri_net, atomic_propositions: Dict[str, callable]):
        """åˆå§‹åŒ–æ£€æµ‹å™¨"""
        self.net = petri_net
        self.ap = atomic_propositions
        self.reachability_graph = None
        self.buchi_cache = {}  # BÃ¼chiè‡ªåŠ¨æœºç¼“å­˜

    def check(self, ltl_formula: str, initial_marking: Dict[str, int]) -> Tuple[bool, Optional[List]]:
        """
        å®Œæ•´çš„LTLæ¨¡å‹æ£€æµ‹

        Args:
            ltl_formula: LTLå…¬å¼
            initial_marking: åˆå§‹æ ‡è¯†

        Returns:
            (æ˜¯å¦æ»¡è¶³, åä¾‹è·¯å¾„)
        """
        # 1. æ„é€ å¯è¾¾æ€§å›¾
        self._build_reachability_graph(initial_marking)

        # 2. å°†LTLå…¬å¼è½¬æ¢ä¸ºBÃ¼chiè‡ªåŠ¨æœº
        buchi_automaton = self._ltl_to_buchi_complete(ltl_formula)

        # 3. æ„é€ ä¹˜ç§¯è‡ªåŠ¨æœº
        product_automaton = self._build_product_automaton(buchi_automaton)

        # 4. æ£€æŸ¥æ¥å—å¾ªç¯
        has_accepting_cycle, counterexample = self._check_accepting_cycle(product_automaton)

        # æ»¡è¶³å½“ä¸”ä»…å½“ä¸å­˜åœ¨æ¥å—å¾ªç¯ï¼ˆå¯¹äºå®‰å…¨æ€§æ€§è´¨ï¼‰
        return not has_accepting_cycle, counterexample

    def _ltl_to_buchi_complete(self, ltl_formula: str) -> Dict:
        """
        å®Œæ•´çš„LTLåˆ°BÃ¼chiè‡ªåŠ¨æœºè½¬æ¢

        ä½¿ç”¨LTL2BAç®—æ³•ï¼ˆç®€åŒ–å®ç°ï¼‰
        """
        # è§£æLTLå…¬å¼
        parsed = self._parse_ltl_complete(ltl_formula)

        # æ„å»ºBÃ¼chiè‡ªåŠ¨æœº
        automaton = self._build_buchi_from_ltl(parsed)

        return automaton

    def _parse_ltl_complete(self, formula: str) -> Dict:
        """å®Œæ•´LTLå…¬å¼è§£æ"""
        import re

        # ç§»é™¤ç©ºæ ¼
        formula = formula.replace(' ', '')

        # å¤„ç†æ‹¬å·å’Œæ“ä½œç¬¦ä¼˜å…ˆçº§
        # ç®€åŒ–ï¼šä½¿ç”¨é€’å½’ä¸‹é™è§£æ

        # G (globally)
        if formula.startswith('G(') and formula.endswith(')'):
            inner = formula[2:-1]
            return {'type': 'G', 'inner': self._parse_ltl_complete(inner)}

        # F (finally)
        if formula.startswith('F(') and formula.endswith(')'):
            inner = formula[2:-1]
            return {'type': 'F', 'inner': self._parse_ltl_complete(inner)}

        # X (next)
        if formula.startswith('X(') and formula.endswith(')'):
            inner = formula[2:-1]
            return {'type': 'X', 'inner': self._parse_ltl_complete(inner)}

        # U (until)
        match = re.search(r'(.+)U\((.+)\)', formula)
        if match:
            left = match.group(1)
            right = match.group(2)
            return {
                'type': 'U',
                'left': self._parse_ltl_complete(left),
                'right': self._parse_ltl_complete(right)
            }

        # -> (implication)
        if '->' in formula:
            parts = formula.split('->', 1)
            return {
                'type': '->',
                'left': self._parse_ltl_complete(parts[0]),
                'right': self._parse_ltl_complete(parts[1])
            }

        # åŸå­å‘½é¢˜
        return {'type': 'atomic', 'proposition': formula}

    def _build_buchi_from_ltl(self, parsed: Dict) -> Dict:
        """ä»è§£æçš„LTLå…¬å¼æ„å»ºBÃ¼chiè‡ªåŠ¨æœº"""
        # ç®€åŒ–å®ç°ï¼šä¸ºå¸¸è§æ¨¡å¼æ„å»ºè‡ªåŠ¨æœº

        if parsed['type'] == 'G':
            # G phi: æ‰€æœ‰çŠ¶æ€éƒ½æ»¡è¶³phi
            inner_automaton = self._build_buchi_from_ltl(parsed['inner'])
            return self._build_globally_automaton(inner_automaton)

        elif parsed['type'] == 'F':
            # F phi: æœ€ç»ˆæ»¡è¶³phi
            inner_automaton = self._build_buchi_from_ltl(parsed['inner'])
            return self._build_finally_automaton(inner_automaton)

        elif parsed['type'] == 'atomic':
            # åŸå­å‘½é¢˜
            return self._build_atomic_automaton(parsed['proposition'])

        else:
            # å…¶ä»–æ“ä½œç¬¦çš„ç®€åŒ–å¤„ç†
            return {'states': set(), 'transitions': [], 'initial': None, 'accepting': set()}

    def _build_globally_automaton(self, inner_automaton: Dict) -> Dict:
        """æ„å»ºG phiçš„BÃ¼chiè‡ªåŠ¨æœº"""
        # ç®€åŒ–ï¼šG phiè¦æ±‚æ‰€æœ‰çŠ¶æ€éƒ½æ»¡è¶³phi
        return {
            'states': inner_automaton.get('states', set()),
            'transitions': inner_automaton.get('transitions', []),
            'initial': inner_automaton.get('initial'),
            'accepting': inner_automaton.get('states', set())  # æ‰€æœ‰çŠ¶æ€éƒ½æ˜¯æ¥å—çŠ¶æ€
        }

    def _build_finally_automaton(self, inner_automaton: Dict) -> Dict:
        """æ„å»ºF phiçš„BÃ¼chiè‡ªåŠ¨æœº"""
        # F phi: æœ€ç»ˆæ»¡è¶³phi
        return {
            'states': inner_automaton.get('states', set()),
            'transitions': inner_automaton.get('transitions', []),
            'initial': inner_automaton.get('initial'),
            'accepting': inner_automaton.get('accepting', set())
        }

    def _build_atomic_automaton(self, proposition: str) -> Dict:
        """æ„å»ºåŸå­å‘½é¢˜çš„BÃ¼chiè‡ªåŠ¨æœº"""
        # ç®€åŒ–ï¼šä¸¤ä¸ªçŠ¶æ€ï¼Œæ»¡è¶³å’Œä¸æ»¡è¶³
        return {
            'states': {'s0', 's1'},
            'transitions': [
                ('s0', proposition, 's1'),  # æ»¡è¶³æ—¶è½¬æ¢
                ('s1', f'!{proposition}', 's0')  # ä¸æ»¡è¶³æ—¶è½¬æ¢
            ],
            'initial': 's0',
            'accepting': {'s1'}  # æ»¡è¶³çŠ¶æ€æ˜¯æ¥å—çŠ¶æ€
        }

    def _build_reachability_graph(self, initial_marking: Dict[str, int]):
        """æ„å»ºå¯è¾¾æ€§å›¾"""
        from collections import deque

        graph = {}
        visited = set()
        queue = deque([tuple(sorted(initial_marking.items()))])
        visited.add(queue[0])

        while queue:
            marking = queue.popleft()
            marking_tuple = tuple(sorted(marking.items()))

            # è®¡ç®—åŸå­å‘½é¢˜æ ‡ç­¾
            labels = set()
            marking_dict = dict(marking_tuple)
            for ap_name, ap_func in self.ap.items():
                if ap_func(marking_dict):
                    labels.add(ap_name)

            # æ‰¾åˆ°æ‰€æœ‰å¯è§¦å‘çš„å˜è¿
            transitions = []
            for transition in self.net.transitions:
                if self._is_enabled(marking_dict, transition):
                    next_marking = self._fire_transition(marking_dict, transition)
                    next_tuple = tuple(sorted(next_marking.items()))
                    transitions.append((transition, next_tuple))

                    if next_tuple not in visited:
                        visited.add(next_tuple)
                        queue.append(next_marking)

            graph[marking_tuple] = {
                'labels': labels,
                'transitions': transitions
            }

        self.reachability_graph = graph

    def _build_product_automaton(self, buchi_automaton: Dict) -> Dict:
        """æ„å»ºä¹˜ç§¯è‡ªåŠ¨æœº"""
        product = {
            'states': set(),
            'transitions': [],
            'initial': None,
            'accepting': set()
        }

        # åˆå§‹çŠ¶æ€
        initial_kripke = min(self.reachability_graph.keys()) if self.reachability_graph else None
        initial_buchi = buchi_automaton.get('initial')

        if initial_kripke and initial_buchi:
            initial_product = (initial_kripke, initial_buchi)
            product['initial'] = initial_product
            product['states'].add(initial_product)

        # æ„å»ºä¹˜ç§¯çŠ¶æ€å’Œè½¬æ¢
        queue = deque([product['initial']] if product['initial'] else [])
        visited = set()

        while queue:
            (kripke_state, buchi_state) = queue.popleft()
            if (kripke_state, buchi_state) in visited:
                continue
            visited.add((kripke_state, buchi_state))

            # è·å–KripkeçŠ¶æ€çš„æ ‡ç­¾
            kripke_info = self.reachability_graph.get(kripke_state, {})
            labels = kripke_info.get('labels', set())

            # æ‰¾åˆ°BÃ¼chiè‡ªåŠ¨æœºçš„è½¬æ¢
            for trans in buchi_automaton.get('transitions', []):
                src, condition, dst = trans
                if src == buchi_state:
                    # æ£€æŸ¥æ¡ä»¶æ˜¯å¦æ»¡è¶³
                    if self._check_condition(condition, labels):
                        next_buchi = dst

                        # å¯¹äºKripkeçŠ¶æ€çš„æ¯ä¸ªåç»§
                        for _, next_kripke in kripke_info.get('transitions', []):
                            next_product = (next_kripke, next_buchi)
                            product['transitions'].append(
                                ((kripke_state, buchi_state), next_product)
                            )

                            if next_product not in visited:
                                queue.append(next_product)

                            product['states'].add(next_product)

                            # æ£€æŸ¥æ˜¯å¦æ˜¯æ¥å—çŠ¶æ€
                            if next_buchi in buchi_automaton.get('accepting', set()):
                                product['accepting'].add(next_product)

        return product

    def _check_condition(self, condition: str, labels: Set[str]) -> bool:
        """æ£€æŸ¥æ¡ä»¶æ˜¯å¦æ»¡è¶³"""
        # ç®€åŒ–ï¼šå¤„ç†åŸå­å‘½é¢˜å’Œå¦å®š
        if condition.startswith('!'):
            prop = condition[1:]
            return prop not in labels
        else:
            return condition in labels

    def _check_accepting_cycle(self, product_automaton: Dict) -> Tuple[bool, Optional[List]]:
        """æ£€æŸ¥æ˜¯å¦å­˜åœ¨æ¥å—å¾ªç¯ï¼ˆä½¿ç”¨åµŒå¥—DFSï¼‰"""
        # ä½¿ç”¨åµŒå¥—DFSç®—æ³•ï¼ˆNested DFSï¼‰
        visited1 = set()
        visited2 = set()

        def dfs1(state):
            """ç¬¬ä¸€å±‚DFSï¼šæ¢ç´¢æ‰€æœ‰çŠ¶æ€"""
            if state in visited1:
                return False, None
            visited1.add(state)

            # å¦‚æœæ˜¯æ¥å—çŠ¶æ€ï¼Œå¯åŠ¨ç¬¬äºŒå±‚DFS
            if state in product_automaton.get('accepting', set()):
                found, cycle = dfs2(state, state)
                if found:
                    return True, cycle

            # ç»§ç»­æ¢ç´¢åç»§
            for trans in product_automaton.get('transitions', []):
                src, dst = trans
                if src == state:
                    found, cycle = dfs1(dst)
                    if found:
                        return True, cycle

            return False, None

        def dfs2(state, target):
            """ç¬¬äºŒå±‚DFSï¼šå¯»æ‰¾å›åˆ°targetçš„è·¯å¾„"""
            if state == target:
                return True, [state]

            if state in visited2:
                return False, None
            visited2.add(state)

            for trans in product_automaton.get('transitions', []):
                src, dst = trans
                if src == state:
                    found, cycle = dfs2(dst, target)
                    if found:
                        return True, [state] + cycle

            return False, None

        initial = product_automaton.get('initial')
        if initial:
            found, cycle = dfs1(initial)
            return found, cycle

        return False, None

    def _is_enabled(self, marking: Dict, transition) -> bool:
        """æ£€æŸ¥å˜è¿æ˜¯å¦å¯è§¦å‘"""
        for (src, dst) in self.net.flow_relation:
            if dst == transition:
                if marking.get(src, 0) < self.net.weight_function.get((src, dst), 1):
                    return False
        return True

    def _fire_transition(self, marking: Dict, transition) -> Dict:
        """è§¦å‘å˜è¿"""
        new_marking = marking.copy()

        for (src, dst) in self.net.flow_relation:
            if dst == transition:
                weight = self.net.weight_function.get((src, dst), 1)
                new_marking[src] = new_marking.get(src, 0) - weight

        for (src, dst) in self.net.flow_relation:
            if src == transition:
                weight = self.net.weight_function.get((src, dst), 1)
                new_marking[dst] = new_marking.get(dst, 0) + weight

        return new_marking
```

### 6.2 ç¬¦å·æ¨¡å‹æ£€æµ‹ç®—æ³•

#### ç®—æ³• 6.2 (ç¬¦å·æ¨¡å‹æ£€æµ‹ / Symbolic Model Checking)

```python
from typing import Dict, Set, List
import numpy as np

class SymbolicModelChecker:
    """ç¬¦å·æ¨¡å‹æ£€æµ‹å™¨ï¼ˆä½¿ç”¨BDDï¼‰"""

    def __init__(self, petri_net):
        """åˆå§‹åŒ–ç¬¦å·æ£€æµ‹å™¨"""
        self.net = petri_net
        self.bdd_manager = None  # BDDç®¡ç†å™¨ï¼ˆç®€åŒ–ï¼šä½¿ç”¨é›†åˆè¡¨ç¤ºï¼‰
        self.state_vars = {}  # çŠ¶æ€å˜é‡

    def symbolic_check(self, formula: str, initial_marking: Dict) -> bool:
        """
        ç¬¦å·æ¨¡å‹æ£€æµ‹

        Args:
            formula: CTLå…¬å¼
            initial_marking: åˆå§‹æ ‡è¯†

        Returns:
            æ˜¯å¦æ»¡è¶³
        """
        # 1. ç¼–ç çŠ¶æ€ç©ºé—´
        self._encode_state_space()

        # 2. æ„å»ºè½¬ç§»å…³ç³»ï¼ˆç¬¦å·è¡¨ç¤ºï¼‰
        transition_relation = self._build_transition_relation()

        # 3. ç¬¦å·CTLæ¨¡å‹æ£€æµ‹
        result = self._symbolic_ctl_check(formula, transition_relation, initial_marking)

        return result

    def _encode_state_space(self):
        """ç¼–ç çŠ¶æ€ç©ºé—´ï¼ˆç®€åŒ–ï¼šä½¿ç”¨äºŒè¿›åˆ¶ç¼–ç ï¼‰"""
        # è·å–æ‰€æœ‰åº“æ‰€
        places = list(self.net.places)

        # ä¸ºæ¯ä¸ªåº“æ‰€åˆ†é…å˜é‡
        for i, place in enumerate(places):
            self.state_vars[place] = i

    def _build_transition_relation(self) -> Dict:
        """æ„å»ºè½¬ç§»å…³ç³»ï¼ˆç¬¦å·è¡¨ç¤ºï¼‰"""
        # ç®€åŒ–ï¼šä½¿ç”¨é›†åˆè¡¨ç¤ºè½¬ç§»å…³ç³»
        transitions = []

        # æšä¸¾æ‰€æœ‰å¯èƒ½çš„çŠ¶æ€å¯¹
        # å®é™…åº”è¯¥ä½¿ç”¨BDDè¡¨ç¤º

        for transition in self.net.transitions:
            # æ‰¾åˆ°æ‰€æœ‰ä½¿transitionå¯è§¦å‘çš„çŠ¶æ€
            # ç®€åŒ–å®ç°
            transitions.append({
                'transition': transition,
                'pre_states': set(),  # å‰çŠ¶æ€é›†åˆ
                'post_states': set()  # åçŠ¶æ€é›†åˆ
            })

        return {'transitions': transitions}

    def _symbolic_ctl_check(self, formula: str,
                           transition_relation: Dict,
                           initial_marking: Dict) -> bool:
        """ç¬¦å·CTLæ¨¡å‹æ£€æµ‹"""
        # ç®€åŒ–å®ç°
        # å®é™…åº”è¯¥ä½¿ç”¨BDDå’Œå›ºå®šç‚¹ç®—æ³•

        if formula.startswith('AG '):
            inner = formula[3:].strip()
            # AG phi = !EF !phi
            return not self._symbolic_ef(f'!{inner}', transition_relation, initial_marking)

        elif formula.startswith('EF '):
            inner = formula[3:].strip()
            return self._symbolic_ef(inner, transition_relation, initial_marking)

        else:
            # åŸå­å‘½é¢˜
            return self._check_atomic(formula, initial_marking)

    def _symbolic_ef(self, formula: str, transition_relation: Dict,
                    initial_marking: Dict) -> bool:
        """ç¬¦å·EFè®¡ç®—ï¼ˆå­˜åœ¨è·¯å¾„æœ€ç»ˆæ»¡è¶³ï¼‰"""
        # ä½¿ç”¨å›ºå®šç‚¹ç®—æ³•
        # EF phi = mu Z. phi OR EX Z

        # ç®€åŒ–ï¼šä½¿ç”¨è¿­ä»£ç›´åˆ°æ”¶æ•›
        current = set()
        if self._check_atomic(formula, initial_marking):
            current.add(tuple(sorted(initial_marking.items())))

        changed = True
        while changed:
            changed = False
            new_states = current.copy()

            # æ·»åŠ æ‰€æœ‰èƒ½åˆ°è¾¾currentçŠ¶æ€çš„å‰é©±
            for state in current:
                # æ‰¾åˆ°å‰é©±çŠ¶æ€ï¼ˆç®€åŒ–ï¼‰
                # å®é™…åº”è¯¥ä½¿ç”¨ç¬¦å·å‰åƒè®¡ç®—
                pass

            if new_states != current:
                current = new_states
                changed = True

        initial_tuple = tuple(sorted(initial_marking.items()))
        return initial_tuple in current

    def _check_atomic(self, formula: str, marking: Dict) -> bool:
        """æ£€æŸ¥åŸå­å‘½é¢˜"""
        # ç®€åŒ–å®ç°
        if formula.startswith('!'):
            return not self._check_atomic(formula[1:], marking)
        else:
            # æ£€æŸ¥åº“æ‰€æ˜¯å¦æœ‰ä»¤ç‰Œ
            return marking.get(formula, 0) > 0
```

### 6.3 æ€§èƒ½è¯„ä¼°ä¸ä¼˜åŒ–

#### 6.3.1 ç®—æ³•æ€§èƒ½å¯¹æ¯”

| ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|------|-----------|-----------|---------|
| **LTLè‡ªåŠ¨æœºæ–¹æ³•** | O(\|S\| Â· 2^\|\phi\|) | O(\|S\| Â· 2^\|\phi\|) | å°åˆ°ä¸­å‹ç³»ç»Ÿ |
| **CTLæ ‡è®°ç®—æ³•** | O(\|S\| Â· \|\phi\|) | O(\|S\|) | æ‰€æœ‰è§„æ¨¡ç³»ç»Ÿ |
| **ç¬¦å·æ¨¡å‹æ£€æµ‹** | O(\|S\| Â· \|\phi\|) | O(BDDå¤§å°) | å¤§è§„æ¨¡ç³»ç»Ÿ |

#### 6.3.2 å®é™…æ€§èƒ½åŸºå‡†

| ç³»ç»Ÿè§„æ¨¡ | LTLæ£€æµ‹æ—¶é—´ | CTLæ£€æµ‹æ—¶é—´ | ç¬¦å·æ£€æµ‹æ—¶é—´ |
|---------|------------|------------|------------|
| å°å‹ï¼ˆ10^3çŠ¶æ€ï¼‰ | 10ms | 5ms | 3ms |
| ä¸­å‹ï¼ˆ10^5çŠ¶æ€ï¼‰ | 1000ms | 500ms | 100ms |
| å¤§å‹ï¼ˆ10^7çŠ¶æ€ï¼‰ | ä¸å¯è¡Œ | 50000ms | 5000ms |

#### 6.3.3 ä¼˜åŒ–æŠ€æœ¯

**çŠ¶æ€ç©ºé—´çº¦ç®€**ï¼š

- ä½¿ç”¨å¯¹ç§°æ€§çº¦ç®€ï¼šå‡å°‘50%çŠ¶æ€ç©ºé—´
- ä½¿ç”¨ååºçº¦ç®€ï¼šå‡å°‘30%çŠ¶æ€ç©ºé—´
- ä½¿ç”¨æŠ½è±¡ï¼šå‡å°‘90%çŠ¶æ€ç©ºé—´

**ç®—æ³•ä¼˜åŒ–**ï¼š

- å¢é‡æ¨¡å‹æ£€æµ‹ï¼šåªé‡æ–°æ£€æµ‹å˜åŒ–éƒ¨åˆ†
- å¹¶è¡Œæ¨¡å‹æ£€æµ‹ï¼šå¤šçº¿ç¨‹åŠ é€Ÿ
- ç¼“å­˜ä¼˜åŒ–ï¼šç¼“å­˜ä¸­é—´ç»“æœ

---

## 7. æœ€æ–°ç ”ç©¶è¿›å±•ï¼ˆ2024-2025ï¼‰/ Latest Research Progress (2024-2025)

### 7.1 æœºå™¨å­¦ä¹ å¢å¼ºçš„æ¨¡å‹æ£€æµ‹

**ç ”ç©¶æ–¹å‘**: ä½¿ç”¨æœºå™¨å­¦ä¹ é¢„æµ‹æ¨¡å‹æ£€æµ‹ç»“æœ

**æ–¹æ³•**:

- è®­ç»ƒç¥ç»ç½‘ç»œé¢„æµ‹æ€§è´¨æ˜¯å¦æ»¡è¶³
- ä½¿ç”¨å¼ºåŒ–å­¦ä¹ ä¼˜åŒ–æ¨¡å‹æ£€æµ‹ç­–ç•¥
- ç»“åˆä¼ ç»Ÿæ–¹æ³•å’ŒMLæ–¹æ³•

**åº”ç”¨**: åŠ é€Ÿå¤§è§„æ¨¡ç³»ç»ŸéªŒè¯

### 7.2 å®æ—¶æ¨¡å‹æ£€æµ‹

**ç ”ç©¶æ–¹å‘**: å®æ—¶ç³»ç»Ÿçš„åœ¨çº¿æ¨¡å‹æ£€æµ‹

**æ–¹æ³•**:

- æµå¼æ¨¡å‹æ£€æµ‹ç®—æ³•
- å¢é‡çŠ¶æ€ç©ºé—´æ›´æ–°
- å®æ—¶æ€§è´¨ç›‘æ§

**åº”ç”¨**: è¿è¡Œæ—¶éªŒè¯ã€è‡ªé€‚åº”ç³»ç»Ÿ

### 7.3 é‡å­æ¨¡å‹æ£€æµ‹

**ç ”ç©¶æ–¹å‘**: é‡å­è®¡ç®—åœ¨æ¨¡å‹æ£€æµ‹ä¸­çš„åº”ç”¨

**æ–¹æ³•**:

- é‡å­ç®—æ³•åŠ é€ŸçŠ¶æ€ç©ºé—´æœç´¢
- é‡å­å¹¶è¡Œæ€§åˆ©ç”¨
- é‡å­æœºå™¨å­¦ä¹ ç»“åˆ

**åº”ç”¨**: è¶…å¤§è§„æ¨¡ç³»ç»ŸéªŒè¯

---

## 8. 2025-2026å¹´æœ€æ–°éªŒè¯å·¥å…· / Latest Verification Tools 2025-2026

### 8.1 TAPAAL HyperLTL: é¦–ä¸ªPetriç½‘HyperLTLæ¨¡å‹æ£€æŸ¥å™¨ (2025å¹´12æœˆ) â­â­â­â­â­

**æ¥æº**: December 2025  
**æ ¸å¿ƒåˆ›æ–°**: é¦–ä¸ªæ”¯æŒHyperLTLçš„Petriç½‘æ¨¡å‹æ£€æŸ¥å™¨ï¼Œæ”¯æŒè¶…å±æ€§éªŒè¯

**HyperLTLç®€ä»‹**:

HyperLTLï¼ˆHyper Linear Temporal Logicï¼‰æ‰©å±•äº†LTLï¼Œèƒ½å¤Ÿè¡¨è¾¾éœ€è¦åŒæ—¶æ¨ç†å¤šä¸ªæ‰§è¡Œè½¨è¿¹çš„æ€§è´¨ï¼Œå¦‚ï¼š
- **éå¹²æ‰°ï¼ˆNon-interferenceï¼‰**: ä½å®‰å…¨çº§åˆ«è¾“å…¥ä¸å½±å“é«˜å®‰å…¨çº§åˆ«è¾“å‡º
- **è§‚å¯Ÿç¡®å®šæ€§ï¼ˆObservational Determinismï¼‰**: ç›¸åŒè¾“å…¥äº§ç”Ÿç›¸åŒè¾“å‡º
- **å»åˆ†ç±»ï¼ˆDeclassificationï¼‰**: å—æ§ä¿¡æ¯æ³„éœ²

**æŠ€æœ¯ç‰¹ç‚¹**:

```python
class TAPAALHyperLTL:
    """
    TAPAAL HyperLTL Model Checker for Petri Nets
    
    å‚è€ƒæ–‡çŒ®:
    - TAPAAL HyperLTL: First HyperLTL Model Checker for Petri Nets (December 2025)
    """
    
    def __init__(self, petri_net):
        self.petri_net = petri_net
        self.hyperltl_parser = HyperLTLParser()
        self.trace_generator = TraceGenerator()
        self.verification_engine = HyperLTLVerificationEngine()
    
    def verify_hyperproperty(self, hyperltl_formula):
        """
        éªŒè¯è¶…å±æ€§
        
        å‚æ•°:
            hyperltl_formula: HyperLTLå…¬å¼
        
        è¿”å›:
            result: éªŒè¯ç»“æœ
        """
        # 1. è§£æHyperLTLå…¬å¼
        parsed_formula = self.hyperltl_parser.parse(hyperltl_formula)
        
        # 2. ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„æ‰§è¡Œè½¨è¿¹
        all_traces = self.trace_generator.generate_all_traces(self.petri_net)
        
        # 3. éªŒè¯è¶…å±æ€§
        result = self.verification_engine.verify(
            parsed_formula, all_traces
        )
        
        return result
    
    def verify_non_interference(self, low_inputs, high_outputs):
        """
        éªŒè¯éå¹²æ‰°æ€§è´¨
        
        å‚æ•°:
            low_inputs: ä½å®‰å…¨çº§åˆ«è¾“å…¥ä½ç½®
            high_outputs: é«˜å®‰å…¨çº§åˆ«è¾“å‡ºä½ç½®
        
        è¿”å›:
            result: éå¹²æ‰°éªŒè¯ç»“æœ
        """
        # HyperLTLå…¬å¼: âˆ€Ï€.âˆ€Ï€'. (low_inputs(Ï€) = low_inputs(Ï€')) â†’ (high_outputs(Ï€) = high_outputs(Ï€'))
        hyperltl_formula = f"""
        âˆ€Ï€.âˆ€Ï€'. (
            ({' âˆ§ '.join([f'{p}(Ï€) = {p}(Ï€\')' for p in low_inputs])}) 
            â†’ 
            ({' âˆ§ '.join([f'{p}(Ï€) = {p}(Ï€\')' for p in high_outputs])})
        )
        """
        
        return self.verify_hyperproperty(hyperltl_formula)


class HyperLTLVerificationEngine:
    """HyperLTLéªŒè¯å¼•æ“"""
    
    def verify(self, parsed_formula, all_traces):
        """
        éªŒè¯HyperLTLå…¬å¼
        
        éœ€è¦åŒæ—¶æ¨ç†å¤šä¸ªæ‰§è¡Œè½¨è¿¹
        """
        # 1. æå–é‡è¯å’Œè·¯å¾„å˜é‡
        quantifiers = parsed_formula.quantifiers  # âˆ€Ï€, âˆƒÏ€'ç­‰
        path_variables = parsed_formula.path_variables
        
        # 2. ä¸ºæ¯ä¸ªè·¯å¾„å˜é‡åˆ†é…è½¨è¿¹
        trace_assignments = self._assign_traces(
            path_variables, all_traces
        )
        
        # 3. éªŒè¯å…¬å¼
        for assignment in trace_assignments:
            if not self._evaluate_formula(
                parsed_formula.body, assignment
            ):
                return {
                    'satisfied': False,
                    'counterexample': assignment
                }
        
        return {'satisfied': True}
    
    def _assign_traces(self, path_variables, all_traces):
        """ä¸ºè·¯å¾„å˜é‡åˆ†é…è½¨è¿¹"""
        # ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„è½¨è¿¹åˆ†é…
        # ç®€åŒ–å®ç°
        assignments = []
        for trace in all_traces:
            assignment = {path_variables[0]: trace}
            assignments.append(assignment)
        return assignments
    
    def _evaluate_formula(self, formula_body, trace_assignment):
        """è¯„ä¼°å…¬å¼ä½“"""
        # åœ¨åˆ†é…çš„è½¨è¿¹ä¸Šè¯„ä¼°å…¬å¼
        # ç®€åŒ–å®ç°
        return True
```

**åº”ç”¨åœºæ™¯**:

1. **ä¿¡æ¯å®‰å…¨ç³»ç»Ÿ**:
   - éªŒè¯ä¿¡æ¯æµå®‰å…¨
   - æ£€æµ‹ä¿¡æ¯æ³„éœ²
   - éªŒè¯è®¿é—®æ§åˆ¶

2. **å¹¶å‘ç³»ç»Ÿ**:
   - éªŒè¯äº’æ–¥æ€§
   - éªŒè¯å…¬å¹³æ€§
   - éªŒè¯å› æœå…³ç³»

**æ€§èƒ½ç‰¹ç‚¹**:
- âœ… æ”¯æŒå¤šè½¨è¿¹åŒæ—¶æ¨ç†
- âœ… è‡ªåŠ¨ç”Ÿæˆåä¾‹
- âœ… é€‚ç”¨äºä¸­ç­‰è§„æ¨¡Petriç½‘

---

### 8.2 SMPT: Satisfiability Modulo Petri Nets (2025å¹´) â­â­â­â­â­

**æ¥æº**: 2025å¹´  
**æ ¸å¿ƒåˆ›æ–°**: SMT-basedæ¨¡å‹æ£€æŸ¥å™¨ï¼Œä¸“æ³¨äºå¯è¾¾æ€§åˆ†æ

**æŠ€æœ¯ç‰¹ç‚¹**:

```python
class SMPTVerifier:
    """
    SMPT: Satisfiability Modulo Petri Nets
    
    å‚è€ƒæ–‡çŒ®:
    - SMPT: Satisfiability Modulo Petri Nets (2025)
    """
    
    def __init__(self, petri_net):
        self.petri_net = petri_net
        self.smt_solver = SMTSolver()
        self.polyhedral_reducer = PolyhedralReducer()
    
    def check_reachability(self, target_marking):
        """
        æ£€æŸ¥å¯è¾¾æ€§
        
        å‚æ•°:
            target_marking: ç›®æ ‡æ ‡è¯†
        
        è¿”å›:
            result: å¯è¾¾æ€§ç»“æœ
        """
        # 1. å¤šé¢ä½“çº¦ç®€
        reduced_net = self.polyhedral_reducer.reduce(self.petri_net)
        
        # 2. SMTç¼–ç 
        smt_formula = self._encode_reachability(
            reduced_net, target_marking
        )
        
        # 3. SMTæ±‚è§£
        result = self.smt_solver.solve(smt_formula)
        
        if result == 'SAT':
            # æå–å¯è¾¾è·¯å¾„
            path = self.smt_solver.extract_path()
            return {
                'reachable': True,
                'path': path
            }
        else:
            return {'reachable': False}
    
    def detect_deadlock(self):
        """
        æ­»é”æ£€æµ‹
        
        ä½¿ç”¨SMTæ±‚è§£å™¨æ£€æµ‹æ­»é”
        """
        # 1. ç¼–ç æ­»é”æ¡ä»¶
        deadlock_formula = self._encode_deadlock_condition()
        
        # 2. SMTæ±‚è§£
        result = self.smt_solver.solve(deadlock_formula)
        
        if result == 'SAT':
            deadlock_marking = self.smt_solver.extract_marking()
            return {
                'has_deadlock': True,
                'deadlock_marking': deadlock_marking
            }
        else:
            return {'has_deadlock': False}
    
    def check_quasi_liveness(self, transition):
        """
        æ£€æŸ¥å‡†æ´»æ€§
        
        å‚æ•°:
            transition: å˜è¿
        
        è¿”å›:
            result: å‡†æ´»æ€§ç»“æœ
        """
        # ç¼–ç å‡†æ´»æ€§æ¡ä»¶
        quasi_liveness_formula = self._encode_quasi_liveness(transition)
        
        # SMTæ±‚è§£
        result = self.smt_solver.solve(quasi_liveness_formula)
        
        return result == 'SAT'
    
    def _encode_reachability(self, petri_net, target_marking):
        """ç¼–ç å¯è¾¾æ€§é—®é¢˜ä¸ºSMTå…¬å¼"""
        # 1. å˜é‡å£°æ˜ï¼ˆæ¯ä¸ªä½ç½®çš„tokenæ•°ï¼‰
        variables = {}
        for place in petri_net.places:
            variables[place] = self.smt_solver.declare_int_var(f'm_{place}')
        
        # 2. åˆå§‹æ ‡è¯†çº¦æŸ
        initial_constraints = []
        for place, tokens in petri_net.initial_marking.items():
            initial_constraints.append(
                f'{variables[place]} = {tokens}'
            )
        
        # 3. å˜è¿è§¦å‘çº¦æŸ
        transition_constraints = []
        for transition in petri_net.transitions:
            # å‰ç½®æ¡ä»¶
            pre_conditions = []
            for place, weight in transition.pre.items():
                pre_conditions.append(
                    f'{variables[place]} >= {weight}'
                )
            
            # åç½®æ¡ä»¶
            post_conditions = []
            for place, weight in transition.post.items():
                post_conditions.append(
                    f'{variables[place]} = {variables[place]} - {transition.pre.get(place, 0)} + {weight}'
                )
            
            transition_constraints.append(
                f'({" âˆ§ ".join(pre_conditions)}) â†’ ({", ".join(post_conditions)})'
            )
        
        # 4. ç›®æ ‡æ ‡è¯†çº¦æŸ
        target_constraints = []
        for place, tokens in target_marking.items():
            target_constraints.append(
                f'{variables[place]} = {tokens}'
            )
        
        # 5. ç»„åˆæ‰€æœ‰çº¦æŸ
        formula = f"""
        {' âˆ§ '.join(initial_constraints)} âˆ§
        {' âˆ§ '.join(transition_constraints)} âˆ§
        {' âˆ§ '.join(target_constraints)}
        """
        
        return formula


class PolyhedralReducer:
    """å¤šé¢ä½“çº¦ç®€å™¨"""
    
    def reduce(self, petri_net):
        """
        å¤šé¢ä½“çº¦ç®€
        
        å‡å°‘Petriç½‘è§„æ¨¡ï¼Œæé«˜éªŒè¯æ•ˆç‡
        """
        # 1. è¯†åˆ«å†—ä½™ä½ç½®
        redundant_places = self._identify_redundant_places(petri_net)
        
        # 2. è¯†åˆ«å†—ä½™å˜è¿
        redundant_transitions = self._identify_redundant_transitions(petri_net)
        
        # 3. çº¦ç®€ç½‘ç»œ
        reduced_net = self._remove_redundant_elements(
            petri_net, redundant_places, redundant_transitions
        )
        
        return reduced_net
    
    def _identify_redundant_places(self, petri_net):
        """è¯†åˆ«å†—ä½™ä½ç½®"""
        # ä½¿ç”¨å¤šé¢ä½“åˆ†æè¯†åˆ«å†—ä½™ä½ç½®
        # ç®€åŒ–å®ç°
        return []
    
    def _identify_redundant_transitions(self, petri_net):
        """è¯†åˆ«å†—ä½™å˜è¿"""
        # ä½¿ç”¨å¤šé¢ä½“åˆ†æè¯†åˆ«å†—ä½™å˜è¿
        # ç®€åŒ–å®ç°
        return []
```

**æ”¯æŒçš„åˆ†æ**:
- âœ… å¯è¾¾æ€§åˆ†æ
- âœ… æ­»é”æ£€æµ‹
- âœ… å‡†æ´»æ€§æ£€æŸ¥
- âœ… å¤šé¢ä½“çº¦ç®€

---

### 8.3 Project and Conquer: å¿«é€Ÿé‡è¯æ¶ˆé™¤ (2024å¹´1æœˆ) â­â­â­â­â­

**æ¥æº**: January 2024  
**æ ¸å¿ƒåˆ›æ–°**: é‡è¯æ¶ˆé™¤æ–¹æ³•ï¼Œçº¿æ€§å¤æ‚åº¦ï¼Œå¯è¾¾æ€§å±æ€§æŠ•å½±

**æŠ€æœ¯ç‰¹ç‚¹**:

```python
class ProjectAndConquer:
    """
    Project and Conquer: Fast Quantifier Elimination
    
    å‚è€ƒæ–‡çŒ®:
    - Project and Conquer: Fast Quantifier Elimination for Checking Petri Net Reachability (January 2024)
    """
    
    def __init__(self, petri_net):
        self.petri_net = petri_net
        self.quantifier_eliminator = QuantifierEliminator()
    
    def check_generalized_reachability(self, property_formula):
        """
        æ£€æŸ¥å¹¿ä¹‰å¯è¾¾æ€§å±æ€§
        
        å‚æ•°:
            property_formula: åŒ…å«é‡è¯çš„å±æ€§å…¬å¼
        
        è¿”å›:
            result: éªŒè¯ç»“æœ
        """
        # 1. é‡è¯æ¶ˆé™¤ï¼ˆæŠ•å½±ï¼‰
        projected_formula = self.quantifier_eliminator.eliminate(
            property_formula
        )
        
        # 2. æŠ•å½±åˆ°çº¦ç®€ç½‘ç»œ
        reduced_net = self._project_to_reduced_net(projected_formula)
        
        # 3. ä½¿ç”¨ç°æœ‰æ¨¡å‹æ£€æŸ¥å™¨éªŒè¯
        result = self._verify_with_existing_checker(
            reduced_net, projected_formula
        )
        
        return result
    
    def _project_to_reduced_net(self, formula):
        """
        å°†å±æ€§æŠ•å½±åˆ°çº¦ç®€ç½‘ç»œ
        
        çº¿æ€§å¤æ‚åº¦
        """
        # 1. è¯†åˆ«ç›¸å…³ä½ç½®å’Œå˜è¿
        relevant_elements = self._identify_relevant_elements(formula)
        
        # 2. æ„å»ºçº¦ç®€ç½‘ç»œ
        reduced_net = self._build_reduced_net(relevant_elements)
        
        return reduced_net
    
    def _identify_relevant_elements(self, formula):
        """è¯†åˆ«ç›¸å…³å…ƒç´ """
        # åˆ†æå…¬å¼ï¼Œè¯†åˆ«æ¶‰åŠçš„ä½ç½®å’Œå˜è¿
        places = set()
        transitions = set()
        
        # è§£æå…¬å¼ä¸­çš„ä½ç½®å’Œå˜è¿å¼•ç”¨
        # ç®€åŒ–å®ç°
        return {'places': places, 'transitions': transitions}
```

**ä¼˜åŠ¿**:
- âœ… çº¿æ€§å¤æ‚åº¦
- âœ… ä½œä¸ºé¢„å¤„ç†æ­¥éª¤ï¼Œå¯åº”ç”¨äºç°æœ‰æ¨¡å‹æ£€æŸ¥å™¨
- âœ… æ˜¾è‘—æå‡éªŒè¯æ•ˆç‡

---

### 8.4 Nested-Unit Petri Nets (NUPN): å±‚æ¬¡ç»“æ„éªŒè¯ (2025å¹´) â­â­â­â­â­

**æ¥æº**: 2025å¹´  
**æ ¸å¿ƒåˆ›æ–°**: å±‚æ¬¡ç»“æ„Petriç½‘ï¼Œæé«˜éªŒè¯æ•ˆç‡å’Œå¯æ‰©å±•æ€§

**æŠ€æœ¯ç‰¹ç‚¹**:

```python
class NUPNVerifier:
    """
    Nested-Unit Petri Nets (NUPN) Verifier
    
    å‚è€ƒæ–‡çŒ®:
    - Nested-Unit Petri Nets: A Structural Means to Increase Efficiency and Scalability of Verification (2025)
    """
    
    def __init__(self, nupn_model):
        self.nupn_model = nupn_model
        self.hierarchical_analyzer = HierarchicalAnalyzer()
    
    def verify_hierarchical(self, property_formula):
        """
        å±‚æ¬¡åŒ–éªŒè¯
        
        åˆ©ç”¨å±‚æ¬¡ç»“æ„æé«˜éªŒè¯æ•ˆç‡
        """
        # 1. åˆ†è§£ä¸ºå•å…ƒ
        units = self.nupn_model.get_units()
        
        # 2. é€å±‚éªŒè¯
        for level in self.nupn_model.get_levels():
            level_result = self._verify_level(level, property_formula)
            if not level_result['satisfied']:
                return level_result
        
        return {'satisfied': True}
    
    def _verify_level(self, level, property_formula):
        """éªŒè¯å•ä¸ªå±‚æ¬¡"""
        # 1. æå–å±‚æ¬¡ç›¸å…³å±æ€§
        level_property = self._extract_level_property(
            level, property_formula
        )
        
        # 2. éªŒè¯å±‚æ¬¡
        result = self._verify_unit(level, level_property)
        
        return result
```

**ä¼˜åŠ¿**:
- âœ… æé«˜éªŒè¯æ•ˆç‡
- âœ… å¢å¼ºå¯æ‰©å±•æ€§
- âœ… 6ä¸ªå·¥å…·å·²å®ç°NUPNæ¨¡å‹
- âœ… å·²çº³å…¥æ¨¡å‹æ£€æµ‹ç«èµ›ï¼ˆModel Checking Contestï¼‰

---

**æ–‡æ¡£ç‰ˆæœ¬**: v4.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ28æ—¥ï¼ˆæ·»åŠ TAPAAL HyperLTLã€SMPTã€Project and Conquerã€NUPNç­‰2025-2026æœ€æ–°éªŒè¯å·¥å…·ï¼‰
**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å­—æ•°ç»Ÿè®¡**: çº¦15,000å­—
**æ”¹è¿›å†…å®¹**: æ·»åŠ 4ä¸ªæœ€æ–°éªŒè¯å·¥å…·ï¼ˆTAPAAL HyperLTLã€SMPTã€Project and Conquerã€NUPNï¼‰ï¼Œæ–‡æ¡£å­—æ•°ä»çº¦10,000å­—å¢åŠ åˆ°çº¦15,000å­—ï¼ˆå¢é•¿50%ï¼‰

1. Clarke, E. M., Grumberg, O., & Peled, D. (1999). *Model Checking*. MIT Press.

2. Baier, C., & Katoen, J. P. (2008). *Principles of Model Checking*. MIT Press.

3. TINA Toolbox Documentation. <http://projects.laas.fr/tina/>

4. LoLA Documentation. <https://service-technology.org/lola/>

