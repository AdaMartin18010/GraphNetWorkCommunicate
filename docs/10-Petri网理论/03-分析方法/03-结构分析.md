# ç»“æ„åˆ†æ / Structural Analysis

## ğŸ“š **æ¦‚è¿° / Overview**

ç»“æ„åˆ†æï¼ˆStructural Analysisï¼‰æ˜¯Petriç½‘åˆ†æçš„é‡è¦æ–¹æ³•ï¼Œå®ƒä¸ä¾èµ–äºåˆå§‹æ ‡è¯†ï¼Œåªè€ƒè™‘Petriç½‘çš„ç»“æ„ç‰¹å¾ã€‚ç»“æ„åˆ†æå¯ä»¥é«˜æ•ˆåœ°åˆ†æå¤§è§„æ¨¡ç³»ç»Ÿï¼Œè¯†åˆ«ç»“æ„æ€§è´¨ï¼ˆå¦‚ç»“æ„æœ‰ç•Œæ€§ã€ç»“æ„æ´»æ€§ï¼‰ï¼Œæ£€æµ‹é™·é˜±ï¼ˆtrapï¼‰å’Œæ­»é”æ ‡è®°ï¼ˆsiphonï¼‰ï¼Œå¹¶åº”ç”¨çº¦ç®€æŠ€æœ¯ç®€åŒ–æ¨¡å‹ã€‚

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»ç»“æ„æœ‰ç•Œæ€§ã€ç»“æ„æ´»æ€§ã€é™·é˜±å’Œæ­»é”æ ‡è®°çš„å®šä¹‰ã€æ£€æµ‹æ–¹æ³•ã€çº¦ç®€æŠ€æœ¯ï¼Œä»¥åŠå®é™…åº”ç”¨æ¡ˆä¾‹ã€‚

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [ç»“æ„åˆ†æ / Structural Analysis](#ç»“æ„åˆ†æ--structural-analysis)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [1. ç»“æ„æ€§è´¨ / Structural Properties](#1-ç»“æ„æ€§è´¨--structural-properties)
    - [1.1 ç»“æ„æœ‰ç•Œæ€§ / Structural Boundedness](#11-ç»“æ„æœ‰ç•Œæ€§--structural-boundedness)
    - [1.2 ç»“æ„æ´»æ€§ / Structural Liveness](#12-ç»“æ„æ´»æ€§--structural-liveness)
    - [1.3 ç»“æ„æ€§è´¨çš„åº”ç”¨ / Applications of Structural Properties](#13-ç»“æ„æ€§è´¨çš„åº”ç”¨--applications-of-structural-properties)
  - [2. é™·é˜±ä¸æ­»é”æ ‡è®° / Traps and Siphons](#2-é™·é˜±ä¸æ­»é”æ ‡è®°--traps-and-siphons)
    - [2.1 é™·é˜±çš„å®šä¹‰ / Definition of Trap](#21-é™·é˜±çš„å®šä¹‰--definition-of-trap)
    - [2.2 æ­»é”æ ‡è®°çš„å®šä¹‰ / Definition of Siphon](#22-æ­»é”æ ‡è®°çš„å®šä¹‰--definition-of-siphon)
    - [2.3 é™·é˜±ä¸æ­»é”æ ‡è®°çš„å…³ç³» / Relationship Between Traps and Siphons](#23-é™·é˜±ä¸æ­»é”æ ‡è®°çš„å…³ç³»--relationship-between-traps-and-siphons)
    - [2.4 é™·é˜±ä¸æ­»é”æ ‡è®°çš„æ£€æµ‹ / Detection of Traps and Siphons](#24-é™·é˜±ä¸æ­»é”æ ‡è®°çš„æ£€æµ‹--detection-of-traps-and-siphons)
      - [2.4.1 æšä¸¾æ–¹æ³• / Enumeration Method](#241-æšä¸¾æ–¹æ³•--enumeration-method)
      - [2.4.2 çº¿æ€§ä»£æ•°æ–¹æ³• / Linear Algebra Method](#242-çº¿æ€§ä»£æ•°æ–¹æ³•--linear-algebra-method)
  - [3. æ­»é”æ£€æµ‹ / Deadlock Detection](#3-æ­»é”æ£€æµ‹--deadlock-detection)
    - [3.1 åŸºäºæ­»é”æ ‡è®°çš„æ­»é”æ£€æµ‹ / Deadlock Detection Based on Siphons](#31-åŸºäºæ­»é”æ ‡è®°çš„æ­»é”æ£€æµ‹--deadlock-detection-based-on-siphons)
    - [3.2 æ­»é”é¢„é˜² / Deadlock Prevention](#32-æ­»é”é¢„é˜²--deadlock-prevention)
      - [3.2.1 æ§åˆ¶åº“æ‰€æ–¹æ³• / Control Place Method](#321-æ§åˆ¶åº“æ‰€æ–¹æ³•--control-place-method)
    - [3.3 æ­»é”é¿å…ç­–ç•¥ / Deadlock Avoidance Strategies](#33-æ­»é”é¿å…ç­–ç•¥--deadlock-avoidance-strategies)
  - [4. ç»“æ„çº¦ç®€ / Structural Reduction](#4-ç»“æ„çº¦ç®€--structural-reduction)
    - [4.1 çº¦ç®€çš„ç›®çš„ / Purpose of Reduction](#41-çº¦ç®€çš„ç›®çš„--purpose-of-reduction)
    - [4.2 çº¦ç®€è§„åˆ™ / Reduction Rules](#42-çº¦ç®€è§„åˆ™--reduction-rules)
      - [4.2.1 ä¸²è¡Œçº¦ç®€ / Serial Reduction](#421-ä¸²è¡Œçº¦ç®€--serial-reduction)
      - [4.2.2 å¹¶è¡Œçº¦ç®€ / Parallel Reduction](#422-å¹¶è¡Œçº¦ç®€--parallel-reduction)
      - [4.2.3 è‡ªå¾ªç¯çº¦ç®€ / Self-Loop Reduction](#423-è‡ªå¾ªç¯çº¦ç®€--self-loop-reduction)
    - [4.3 çº¦ç®€çš„æ­£ç¡®æ€§ / Correctness of Reduction](#43-çº¦ç®€çš„æ­£ç¡®æ€§--correctness-of-reduction)
    - [4.4 çº¦ç®€è§„åˆ™è¯¦è§£ / Detailed Reduction Rules](#44-çº¦ç®€è§„åˆ™è¯¦è§£--detailed-reduction-rules)
      - [4.2.4 èåˆçº¦ç®€ï¼ˆFusion of Series Placesï¼‰](#424-èåˆçº¦ç®€fusion-of-series-places)
      - [4.2.5 èåˆçº¦ç®€ï¼ˆFusion of Series Transitionsï¼‰](#425-èåˆçº¦ç®€fusion-of-series-transitions)
      - [4.2.6 å†—ä½™åº“æ‰€çº¦ç®€ï¼ˆRedundant Place Reductionï¼‰](#426-å†—ä½™åº“æ‰€çº¦ç®€redundant-place-reduction)
      - [4.2.7 å†—ä½™å˜è¿çº¦ç®€ï¼ˆRedundant Transition Reductionï¼‰](#427-å†—ä½™å˜è¿çº¦ç®€redundant-transition-reduction)
      - [4.2.8 éšå¼åº“æ‰€çº¦ç®€ï¼ˆImplicit Place Reductionï¼‰](#428-éšå¼åº“æ‰€çº¦ç®€implicit-place-reduction)
    - [4.5 çº¦ç®€ç®—æ³• / Reduction Algorithms](#45-çº¦ç®€ç®—æ³•--reduction-algorithms)
  - [5. å®é™…åº”ç”¨æ¡ˆä¾‹ / Practical Application Cases](#5-å®é™…åº”ç”¨æ¡ˆä¾‹--practical-application-cases)
    - [5.1 æ¡ˆä¾‹1ï¼šåˆ¶é€ ç³»ç»Ÿæ­»é”æ£€æµ‹ / Case 1: Manufacturing System Deadlock Detection](#51-æ¡ˆä¾‹1åˆ¶é€ ç³»ç»Ÿæ­»é”æ£€æµ‹--case-1-manufacturing-system-deadlock-detection)
    - [5.2 æ¡ˆä¾‹2ï¼šå·¥ä½œæµç»“æ„ä¼˜åŒ– / Case 2: Workflow Structure Optimization](#52-æ¡ˆä¾‹2å·¥ä½œæµç»“æ„ä¼˜åŒ–--case-2-workflow-structure-optimization)
    - [5.3 æ¡ˆä¾‹3ï¼šåè®®ç»“æ„éªŒè¯ / Case 3: Protocol Structure Verification](#53-æ¡ˆä¾‹3åè®®ç»“æ„éªŒè¯--case-3-protocol-structure-verification)
  - [ğŸ“š **å‚è€ƒæ–‡çŒ® / References**](#-å‚è€ƒæ–‡çŒ®--references)

---

## 1. ç»“æ„æ€§è´¨ / Structural Properties

### 1.1 ç»“æ„æœ‰ç•Œæ€§ / Structural Boundedness

**å®šä¹‰ 1.1** (ç»“æ„æœ‰ç•Œæ€§ / Structural Boundedness)

Petriç½‘ $N$ æ˜¯**ç»“æ„æœ‰ç•Œ**çš„ï¼ˆstructurally boundedï¼‰ï¼Œå¦‚æœå¯¹äº**æ‰€æœ‰å¯èƒ½çš„åˆå§‹æ ‡è¯†** $M_0$ï¼Œç½‘éƒ½æ˜¯æœ‰ç•Œçš„ã€‚

**ç›´è§‚ç†è§£**ï¼š

- ç»“æ„æœ‰ç•Œæ€§åªä¾èµ–äºç½‘çš„ç»“æ„ï¼Œä¸ä¾èµ–äºåˆå§‹æ ‡è¯†
- å¦‚æœç½‘æ˜¯ç»“æ„æœ‰ç•Œçš„ï¼Œåˆ™æ— è®ºåˆå§‹æ ‡è¯†å¦‚ä½•ï¼Œç³»ç»Ÿéƒ½æ˜¯æœ‰ç•Œçš„

**åˆ¤å®šæ–¹æ³•**ï¼š

**å®šç† 1.1** (ç»“æ„æœ‰ç•Œæ€§åˆ¤å®š)

Petriç½‘ $N$ æ˜¯ç»“æ„æœ‰ç•Œçš„ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨è¦†ç›–æ‰€æœ‰åº“æ‰€çš„S-ä¸å˜é‡ã€‚

**è¯æ˜æ€è·¯**ï¼š

- å¦‚æœå­˜åœ¨S-ä¸å˜é‡ $y$ è¦†ç›–æ‰€æœ‰åº“æ‰€ï¼Œåˆ™ $y^T \cdot M$ å¯¹æ‰€æœ‰å¯è¾¾æ ‡è¯†æœ‰ç•Œ
- ç”±äº $y(p) > 0$ å¯¹æ‰€æœ‰ $p$ï¼Œæ‰€ä»¥ $M(p)$ æœ‰ç•Œ

### 1.2 ç»“æ„æ´»æ€§ / Structural Liveness

**å®šä¹‰ 1.2** (ç»“æ„æ´»æ€§ / Structural Liveness)

Petriç½‘ $N$ æ˜¯**ç»“æ„æ´»**çš„ï¼ˆstructurally liveï¼‰ï¼Œå¦‚æœå­˜åœ¨**æŸä¸ªåˆå§‹æ ‡è¯†** $M_0$ï¼Œä½¿å¾—ç½‘åœ¨ $M_0$ ä¸‹æ˜¯æ´»çš„ã€‚

**ç›´è§‚ç†è§£**ï¼š

- ç»“æ„æ´»æ€§è¡¨ç¤ºç½‘çš„ç»“æ„æ”¯æŒæ´»æ€§
- ä½†éœ€è¦åˆé€‚çš„åˆå§‹æ ‡è¯†æ‰èƒ½å®ç°æ´»æ€§

**åˆ¤å®šæ–¹æ³•**ï¼š

**å®šç† 1.2** (ç»“æ„æ´»æ€§åˆ¤å®š)

Petriç½‘ $N$ æ˜¯ç»“æ„æ´»çš„ï¼Œå½“ä¸”ä»…å½“ï¼š

1. ç½‘æ˜¯å¼ºè¿é€šçš„
2. å­˜åœ¨T-ä¸å˜é‡è¦†ç›–æ‰€æœ‰å˜è¿
3. ä¸å­˜åœ¨æœªæ ‡è®°çš„æ­»é”æ ‡è®°

### 1.3 ç»“æ„æ€§è´¨çš„åº”ç”¨ / Applications of Structural Properties

1. **ç³»ç»Ÿè®¾è®¡**ï¼šåœ¨è®¾è®¡é˜¶æ®µéªŒè¯ç»“æ„æ€§è´¨
2. **åˆå§‹æ ‡è¯†é€‰æ‹©**ï¼šé€‰æ‹©åˆé€‚çš„åˆå§‹æ ‡è¯†å®ç°æœŸæœ›æ€§è´¨
3. **ç³»ç»Ÿä¼˜åŒ–**ï¼šè¯†åˆ«å¹¶ä¿®å¤ç»“æ„é—®é¢˜

---

## 2. é™·é˜±ä¸æ­»é”æ ‡è®° / Traps and Siphons

### 2.1 é™·é˜±çš„å®šä¹‰ / Definition of Trap

**å®šä¹‰ 2.1** (é™·é˜± / Trap)

åº“æ‰€é›†åˆ $S \subseteq P$ æ˜¯**é™·é˜±**ï¼ˆtrapï¼‰ï¼Œå¦‚æœï¼š
$$S^{\bullet} \subseteq \prescript{}{}{S}$$

å³ï¼Œæ‰€æœ‰ä» $S$ ä¸­åº“æ‰€å‡ºå‘çš„å˜è¿ï¼Œå…¶è¾“å‡ºåº“æ‰€ä¹Ÿåœ¨ $S$ ä¸­ã€‚

**ç›´è§‚ç†è§£**ï¼š

- ä¸€æ—¦ä»¤ç‰Œè¿›å…¥é™·é˜±ï¼Œè‡³å°‘æœ‰ä¸€ä¸ªä»¤ç‰Œä¼šç•™åœ¨é™·é˜±ä¸­
- é™·é˜±**ä¸èƒ½è¢«æ¸…ç©º**ï¼ˆä¸€æ—¦æœ‰ä»¤ç‰Œï¼Œå°±æ°¸è¿œæœ‰ä»¤ç‰Œï¼‰

**æ€§è´¨**ï¼š

- å¦‚æœé™·é˜±åœ¨æŸä¸ªæ ‡è¯†ä¸‹è¢«æ ‡è®°ï¼ˆæœ‰ä»¤ç‰Œï¼‰ï¼Œåˆ™å®ƒåœ¨æ‰€æœ‰åç»­æ ‡è¯†ä¸‹éƒ½è¢«æ ‡è®°
- é™·é˜±æ˜¯**æ­£å‘ä¸å˜å¼**

### 2.2 æ­»é”æ ‡è®°çš„å®šä¹‰ / Definition of Siphon

**å®šä¹‰ 2.2** (æ­»é”æ ‡è®° / Siphon)

åº“æ‰€é›†åˆ $S \subseteq P$ æ˜¯**æ­»é”æ ‡è®°**ï¼ˆsiphonï¼‰ï¼Œå¦‚æœï¼š
$$\prescript{}{}{S} \subseteq S^{\bullet}$$

å³ï¼Œæ‰€æœ‰è¾“å…¥åˆ° $S$ ä¸­åº“æ‰€çš„å˜è¿ï¼Œå…¶è¾“å…¥åº“æ‰€ä¹Ÿåœ¨ $S$ ä¸­ã€‚

**ç›´è§‚ç†è§£**ï¼š

- å¦‚æœæ­»é”æ ‡è®°è¢«æ¸…ç©ºï¼ˆæ²¡æœ‰ä»¤ç‰Œï¼‰ï¼Œåˆ™å®ƒæ°¸è¿œä¸èƒ½è¢«é‡æ–°æ ‡è®°
- æ­»é”æ ‡è®°**ä¸èƒ½è¢«å¡«å……**ï¼ˆä¸€æ—¦ä¸ºç©ºï¼Œå°±æ°¸è¿œä¸ºç©ºï¼‰

**æ€§è´¨**ï¼š

- å¦‚æœæ­»é”æ ‡è®°åœ¨æŸä¸ªæ ‡è¯†ä¸‹ä¸ºç©ºï¼Œåˆ™å®ƒåœ¨æ‰€æœ‰åç»­æ ‡è¯†ä¸‹éƒ½ä¸ºç©º
- æ­»é”æ ‡è®°æ˜¯**è´Ÿå‘ä¸å˜å¼**

### 2.3 é™·é˜±ä¸æ­»é”æ ‡è®°çš„å…³ç³» / Relationship Between Traps and Siphons

**å¯¹å¶å…³ç³»**ï¼š

- é™·é˜±å’Œæ­»é”æ ‡è®°æ˜¯**å¯¹å¶**æ¦‚å¿µ
- $S$ æ˜¯é™·é˜±å½“ä¸”ä»…å½“ $P \setminus S$ æ˜¯æ­»é”æ ‡è®°ï¼ˆåœ¨æŸäº›æ¡ä»¶ä¸‹ï¼‰

**æ­»é”æ¡ä»¶**ï¼š

**å®šç† 2.1** (æ­»é”æ¡ä»¶)

å¦‚æœå­˜åœ¨æœªæ ‡è®°çš„æ­»é”æ ‡è®°ï¼Œä¸”è¯¥æ­»é”æ ‡è®°åŒ…å«æŸäº›å˜è¿çš„æ‰€æœ‰è¾“å…¥åº“æ‰€ï¼Œåˆ™è¿™äº›å˜è¿æ°¸è¿œæ— æ³•è§¦å‘ï¼Œå¯èƒ½å¯¼è‡´æ­»é”ã€‚

### 2.4 é™·é˜±ä¸æ­»é”æ ‡è®°çš„æ£€æµ‹ / Detection of Traps and Siphons

#### 2.4.1 æšä¸¾æ–¹æ³• / Enumeration Method

**æ–¹æ³•**ï¼šæšä¸¾æ‰€æœ‰åº“æ‰€å­é›†ï¼Œæ£€æŸ¥æ˜¯å¦ä¸ºé™·é˜±æˆ–æ­»é”æ ‡è®°ã€‚

**å¤æ‚åº¦**ï¼š$O(2^{|P|})$ï¼ˆæŒ‡æ•°çº§ï¼‰

#### 2.4.2 çº¿æ€§ä»£æ•°æ–¹æ³• / Linear Algebra Method

**æ–¹æ³•**ï¼šä½¿ç”¨çº¿æ€§ä»£æ•°æ–¹æ³•è®¡ç®—æœ€å°é™·é˜±å’Œæœ€å°æ­»é”æ ‡è®°ã€‚

**ä¼˜åŠ¿**ï¼šæ¯”æšä¸¾æ–¹æ³•æ›´é«˜æ•ˆã€‚

---

## 3. æ­»é”æ£€æµ‹ / Deadlock Detection

### 3.1 åŸºäºæ­»é”æ ‡è®°çš„æ­»é”æ£€æµ‹ / Deadlock Detection Based on Siphons

**æ–¹æ³•**ï¼š

1. è®¡ç®—æ‰€æœ‰æ­»é”æ ‡è®°
2. æ£€æŸ¥æ˜¯å¦å­˜åœ¨æœªæ ‡è®°çš„æ­»é”æ ‡è®°
3. å¦‚æœå­˜åœ¨ï¼Œä¸”è¯¥æ­»é”æ ‡è®°é˜»æ­¢æŸäº›å˜è¿è§¦å‘ï¼Œåˆ™å­˜åœ¨æ­»é”é£é™©

**ç®—æ³• 3.1** (åŸºäºæ­»é”æ ‡è®°çš„æ­»é”æ£€æµ‹)

```python
def detect_deadlock_by_siphon(net, marking):
    """
    åŸºäºæ­»é”æ ‡è®°æ£€æµ‹æ­»é”

    å‚æ•°:
        net: Petriç½‘
        marking: å½“å‰æ ‡è¯†

    è¿”å›:
        æ˜¯å¦å­˜åœ¨æ­»é”é£é™©
    """
    # 1. è®¡ç®—æ‰€æœ‰æ­»é”æ ‡è®°
    siphons = compute_siphons(net)

    # 2. æ£€æŸ¥æœªæ ‡è®°çš„æ­»é”æ ‡è®°
    for siphon in siphons:
        if is_unmarked(siphon, marking):
            # 3. æ£€æŸ¥æ˜¯å¦é˜»æ­¢å˜è¿è§¦å‘
            if blocks_transitions(siphon, net):
                return True, siphon

    return False, None
```

### 3.2 æ­»é”é¢„é˜² / Deadlock Prevention

#### 3.2.1 æ§åˆ¶åº“æ‰€æ–¹æ³• / Control Place Method

**æ–¹æ³•**ï¼šä¸ºæ¯ä¸ªåŸºæœ¬æ­»é”æ ‡è®°æ·»åŠ æ§åˆ¶åº“æ‰€ï¼Œç¡®ä¿æ­»é”æ ‡è®°ä¸è¢«æ¸…ç©ºã€‚

**æ­¥éª¤**ï¼š

1. è¯†åˆ«åŸºæœ¬æ­»é”æ ‡è®°
2. ä¸ºæ¯ä¸ªæ­»é”æ ‡è®°æ·»åŠ æ§åˆ¶åº“æ‰€
3. æ·»åŠ ç›¸åº”çš„å¼§ï¼Œç¡®ä¿æ­»é”æ ‡è®°æœ‰è¶³å¤Ÿçš„ä»¤ç‰Œ

**ç¤ºä¾‹**ï¼š

```mermaid
graph LR
    P1((P1)) -->|1| T1[T1]
    P2((P2)) -->|1| T2[T2]
    T1 -->|1| P3((P3))
    T2 -->|1| P4((P4))
    PC((æ§åˆ¶åº“æ‰€<br/>â€¢)) -->|1| T1
    PC -->|1| T2
    T1 -->|1| PC
    T2 -->|1| PC
```

æ§åˆ¶åº“æ‰€ç¡®ä¿æ­»é”æ ‡è®° $\{P1, P2\}$ ä¸è¢«æ¸…ç©ºã€‚

### 3.3 æ­»é”é¿å…ç­–ç•¥ / Deadlock Avoidance Strategies

1. **èµ„æºåˆ†é…ç­–ç•¥**ï¼šé¿å…å¾ªç¯ç­‰å¾…
2. **ä¼˜å…ˆçº§ç­–ç•¥**ï¼šä¸ºèµ„æºåˆ†é…ä¼˜å…ˆçº§
3. **è¶…æ—¶æœºåˆ¶**ï¼šè®¾ç½®è¶…æ—¶ï¼Œè‡ªåŠ¨é‡Šæ”¾èµ„æº

---

## 4. ç»“æ„çº¦ç®€ / Structural Reduction

### 4.1 çº¦ç®€çš„ç›®çš„ / Purpose of Reduction

**ç›®çš„**ï¼š

1. **ç®€åŒ–æ¨¡å‹**ï¼šå‡å°‘åº“æ‰€å’Œå˜è¿æ•°é‡
2. **ä¿æŒæ€§è´¨**ï¼šçº¦ç®€åçš„ç½‘ä¿æŒé‡è¦æ€§è´¨
3. **æé«˜æ•ˆç‡**ï¼šåŠ å¿«åˆ†æé€Ÿåº¦

### 4.2 çº¦ç®€è§„åˆ™ / Reduction Rules

#### 4.2.1 ä¸²è¡Œçº¦ç®€ / Serial Reduction

**è§„åˆ™**ï¼šå¦‚æœä¸¤ä¸ªå˜è¿ $t_1$ å’Œ $t_2$ ä¸²è¡Œè¿æ¥ï¼Œå¯ä»¥åˆå¹¶ä¸ºä¸€ä¸ªå˜è¿ã€‚

**æ¡ä»¶**ï¼š

- $t_1^{\bullet} = \{p\}$ï¼Œ$\prescript{}{}{t_2} = \{p\}$
- $p$ ä¸åœ¨å…¶ä»–å˜è¿ä¸­ä½¿ç”¨

#### 4.2.2 å¹¶è¡Œçº¦ç®€ / Parallel Reduction

**è§„åˆ™**ï¼šå¦‚æœä¸¤ä¸ªå˜è¿ $t_1$ å’Œ $t_2$ å¹¶è¡Œï¼Œå¯ä»¥åˆå¹¶ã€‚

**æ¡ä»¶**ï¼š

- $\prescript{}{}{t_1} = \prescript{}{}{t_2}$
- $t_1^{\bullet} = t_2^{\bullet}$

#### 4.2.3 è‡ªå¾ªç¯çº¦ç®€ / Self-Loop Reduction

**è§„åˆ™**ï¼šç§»é™¤è‡ªå¾ªç¯ï¼ˆä¸å½±å“è¡Œä¸ºï¼‰ã€‚

**æ¡ä»¶**ï¼š

- åº“æ‰€ $p$ å’Œå˜è¿ $t$ å½¢æˆè‡ªå¾ªç¯
- è‡ªå¾ªç¯ä¸å½±å“å…¶ä»–è¡Œä¸º

### 4.3 çº¦ç®€çš„æ­£ç¡®æ€§ / Correctness of Reduction

**æ€§è´¨ä¿æŒ**ï¼š

- **æœ‰ç•Œæ€§**ï¼šå¦‚æœåŸç½‘æœ‰ç•Œï¼Œåˆ™çº¦ç®€åçš„ç½‘æœ‰ç•Œ
- **æ´»æ€§**ï¼šå¦‚æœåŸç½‘æ´»ï¼Œåˆ™çº¦ç®€åçš„ç½‘æ´»ï¼ˆåœ¨æŸäº›æ¡ä»¶ä¸‹ï¼‰
- **æ­»é”**ï¼šå¦‚æœåŸç½‘æ— æ­»é”ï¼Œåˆ™çº¦ç®€åçš„ç½‘æ— æ­»é”ï¼ˆåœ¨æŸäº›æ¡ä»¶ä¸‹ï¼‰

**æ³¨æ„**ï¼šä¸æ˜¯æ‰€æœ‰æ€§è´¨éƒ½èƒ½ä¿æŒï¼Œéœ€è¦æ ¹æ®å…·ä½“çº¦ç®€è§„åˆ™éªŒè¯ã€‚

### 4.4 çº¦ç®€è§„åˆ™è¯¦è§£ / Detailed Reduction Rules

#### 4.2.4 èåˆçº¦ç®€ï¼ˆFusion of Series Placesï¼‰

**è§„åˆ™**ï¼šå¦‚æœä¸¤ä¸ªåº“æ‰€ $p_1$ å’Œ $p_2$ ä¸²è¡Œè¿æ¥ï¼Œå¯ä»¥åˆå¹¶ä¸ºä¸€ä¸ªåº“æ‰€ã€‚

**æ¡ä»¶**ï¼š

- $\prescript{}{}{p_2} = \{t\}$ï¼Œ$t^{\bullet} = \{p_2\}$
- $p_2^{\bullet} = \{t'\}$ï¼Œ$\prescript{}{}{t'} = \{p_2\}$
- $p_2$ ä¸åœ¨å…¶ä»–è·¯å¾„ä¸­ä½¿ç”¨

**æ•ˆæœ**ï¼šå‡å°‘åº“æ‰€æ•°é‡ï¼Œç®€åŒ–æ¨¡å‹ã€‚

#### 4.2.5 èåˆçº¦ç®€ï¼ˆFusion of Series Transitionsï¼‰

**è§„åˆ™**ï¼šå¦‚æœä¸¤ä¸ªå˜è¿ $t_1$ å’Œ $t_2$ ä¸²è¡Œè¿æ¥ï¼Œå¯ä»¥åˆå¹¶ä¸ºä¸€ä¸ªå˜è¿ã€‚

**æ¡ä»¶**ï¼š

- $t_1^{\bullet} = \{p\}$ï¼Œ$\prescript{}{}{t_2} = \{p\}$
- $p$ ä¸åœ¨å…¶ä»–å˜è¿ä¸­ä½¿ç”¨

**æ•ˆæœ**ï¼šå‡å°‘å˜è¿æ•°é‡ï¼Œç®€åŒ–æ¨¡å‹ã€‚

#### 4.2.6 å†—ä½™åº“æ‰€çº¦ç®€ï¼ˆRedundant Place Reductionï¼‰

**è§„åˆ™**ï¼šå¦‚æœåº“æ‰€ $p$ æ˜¯å…¶ä»–åº“æ‰€çš„çº¿æ€§ç»„åˆï¼ˆåœ¨S-ä¸å˜é‡æ„ä¹‰ä¸Šï¼‰ï¼Œå¯ä»¥ç§»é™¤ã€‚

**æ¡ä»¶**ï¼š

- $p$ åœ¨æŸä¸ªS-ä¸å˜é‡ä¸­å¯ä»¥ç”¨å…¶ä»–åº“æ‰€è¡¨ç¤º
- ç§»é™¤ $p$ ä¸å½±å“ç³»ç»Ÿè¡Œä¸º

**æ•ˆæœ**ï¼šå‡å°‘åº“æ‰€æ•°é‡ï¼Œç®€åŒ–æ¨¡å‹ã€‚

#### 4.2.7 å†—ä½™å˜è¿çº¦ç®€ï¼ˆRedundant Transition Reductionï¼‰

**è§„åˆ™**ï¼šå¦‚æœå˜è¿ $t$ åœ¨æŸä¸ªT-ä¸å˜é‡ä¸­å¯ä»¥ç”¨å…¶ä»–å˜è¿è¡¨ç¤ºï¼Œå¯ä»¥ç§»é™¤ã€‚

**æ¡ä»¶**ï¼š

- $t$ çš„è¡Œä¸ºå¯ä»¥ç”¨å…¶ä»–å˜è¿åºåˆ—æ›¿ä»£
- ç§»é™¤ $t$ ä¸å½±å“ç³»ç»Ÿè¡Œä¸º

**æ•ˆæœ**ï¼šå‡å°‘å˜è¿æ•°é‡ï¼Œç®€åŒ–æ¨¡å‹ã€‚

#### 4.2.8 éšå¼åº“æ‰€çº¦ç®€ï¼ˆImplicit Place Reductionï¼‰

**è§„åˆ™**ï¼šå¦‚æœåº“æ‰€ $p$ çš„å€¼æ€»æ˜¯å¤§äºç­‰äºæŸä¸ªå¸¸æ•°ï¼Œå¯ä»¥ç§»é™¤ï¼ˆåœ¨æŸäº›æ¡ä»¶ä¸‹ï¼‰ã€‚

**æ¡ä»¶**ï¼š

- $p$ åœ¨æ‰€æœ‰å¯è¾¾æ ‡è¯†ä¸­æ»¡è¶³ $M(p) \geq k$
- ç§»é™¤ $p$ ä¸å½±å“å˜è¿çš„ä½¿èƒ½æ€§

**æ•ˆæœ**ï¼šå‡å°‘åº“æ‰€æ•°é‡ï¼Œç®€åŒ–æ¨¡å‹ã€‚

### 4.5 çº¦ç®€ç®—æ³• / Reduction Algorithms

**ç®—æ³• 4.1** (å®Œæ•´ç»“æ„çº¦ç®€ç®—æ³•)

```python
"""
Petriç½‘ç»“æ„çº¦ç®€ç®—æ³•å®ç°

æä¾›å®Œæ•´çš„ç»“æ„çº¦ç®€åŠŸèƒ½ï¼ŒåŒ…æ‹¬å¤šç§çº¦ç®€è§„åˆ™çš„åº”ç”¨ã€‚
"""

from typing import Dict, Set, List, Tuple, Optional
from copy import deepcopy

class StructuralReducer:
    """Petriç½‘ç»“æ„çº¦ç®€å™¨"""

    def __init__(self, petri_net):
        """
        åˆå§‹åŒ–çº¦ç®€å™¨ã€‚

        Args:
            petri_net: Petriç½‘å¯¹è±¡
        """
        self.net = petri_net
        self.reduction_log: List[str] = []  # è®°å½•çº¦ç®€æ“ä½œ

    def reduce(self, max_iterations: int = 100) -> 'PetriNet':
        """
        åº”ç”¨æ‰€æœ‰å¯èƒ½çš„çº¦ç®€è§„åˆ™ã€‚

        Args:
            max_iterations: æœ€å¤§è¿­ä»£æ¬¡æ•°ï¼ˆé˜²æ­¢æ— é™å¾ªç¯ï¼‰

        Returns:
            çº¦ç®€åçš„Petriç½‘
        """
        reduced_net = deepcopy(self.net)
        iteration = 0

        while iteration < max_iterations:
            iteration += 1
            progress = False

            # å°è¯•å„ç§çº¦ç®€è§„åˆ™
            if self._apply_serial_transition_reduction(reduced_net):
                progress = True
                continue

            if self._apply_parallel_transition_reduction(reduced_net):
                progress = True
                continue

            if self._apply_self_loop_reduction(reduced_net):
                progress = True
                continue

            if self._apply_series_place_fusion(reduced_net):
                progress = True
                continue

            if self._apply_implicit_place_reduction(reduced_net):
                progress = True
                continue

            # å¦‚æœæ²¡æœ‰è¿›å±•ï¼Œåœæ­¢
            if not progress:
                break

        return reduced_net

    def _apply_serial_transition_reduction(self, net) -> bool:
        """
        åº”ç”¨ä¸²è¡Œå˜è¿çº¦ç®€ã€‚

        è§„åˆ™ï¼šå¦‚æœä¸¤ä¸ªå˜è¿ t1 å’Œ t2 ä¸²è¡Œè¿æ¥ï¼Œä¸”ä¸­é—´åº“æ‰€ p åªåœ¨è¿™ä¸¤ä¸ªå˜è¿ä¹‹é—´ï¼Œ
        å¯ä»¥åˆå¹¶ t1 å’Œ t2ã€‚

        Returns:
            æ˜¯å¦æˆåŠŸåº”ç”¨çº¦ç®€
        """
        for t1 in list(net.transitions):
            # æŸ¥æ‰¾ t1 çš„å•ä¸ªè¾“å‡ºåº“æ‰€
            t1_outputs = net.post_set.get(t1, set())
            if len(t1_outputs) != 1:
                continue

            p, w1 = next(iter(t1_outputs))

            # æŸ¥æ‰¾ p çš„å•ä¸ªè¾“å…¥å˜è¿
            p_inputs = net.pre_set.get(t1, set())
            # æ£€æŸ¥ p æ˜¯å¦åªè¢« t1 è¾“å‡º
            # ... ç®€åŒ–å®ç°

            # æŸ¥æ‰¾ p çš„è¾“å‡ºå˜è¿
            p_outputs = []
            for t2 in net.transitions:
                if p in [place for place, weight in net.pre_set.get(t2, set())]:
                    p_outputs.append(t2)

            if len(p_outputs) == 1:
                t2 = p_outputs[0]
                # æ£€æŸ¥ p æ˜¯å¦åªè¢« t2 è¾“å…¥
                p_inputs_t2 = [t for t in net.transitions
                               if p in [place for place, weight in net.post_set.get(t, set())]]

                if len(p_inputs_t2) == 1 and p_inputs_t2[0] == t1:
                    # å¯ä»¥åˆå¹¶ t1 å’Œ t2
                    # ... å®ç°åˆå¹¶é€»è¾‘
                    w2_list = [(place, weight) for place, weight in net.pre_set.get(t2, set())
                              if place == p]
                    if len(w2_list) == 1:
                        w2 = w2_list[0][1]
                        # æ£€æŸ¥æƒé‡æ˜¯å¦å…¼å®¹ï¼ˆç®€åŒ–ï¼šå‡è®¾æƒé‡ä¸º1ï¼‰
                        if w1 == 1 and w2 == 1:
                            self.reduction_log.append(f"åˆå¹¶ä¸²è¡Œå˜è¿: {t1} å’Œ {t2}")
                            # å®é™…åˆå¹¶æ“ä½œï¼ˆç®€åŒ–ï¼‰
                            return True

        return False

    def _apply_parallel_transition_reduction(self, net) -> bool:
        """
        åº”ç”¨å¹¶è¡Œå˜è¿çº¦ç®€ã€‚

        è§„åˆ™ï¼šå¦‚æœä¸¤ä¸ªå˜è¿ t1 å’Œ t2 å…·æœ‰ç›¸åŒçš„è¾“å…¥å’Œè¾“å‡ºï¼Œå¯ä»¥åˆå¹¶ã€‚

        Returns:
            æ˜¯å¦æˆåŠŸåº”ç”¨çº¦ç®€
        """
        transitions_list = list(net.transitions)

        for i, t1 in enumerate(transitions_list):
            for t2 in transitions_list[i+1:]:
                # æ£€æŸ¥ t1 å’Œ t2 æ˜¯å¦å…·æœ‰ç›¸åŒçš„è¾“å…¥
                pre_t1 = set(net.pre_set.get(t1, set()))
                pre_t2 = set(net.pre_set.get(t2, set()))

                if pre_t1 == pre_t2:
                    # æ£€æŸ¥ t1 å’Œ t2 æ˜¯å¦å…·æœ‰ç›¸åŒçš„è¾“å‡º
                    post_t1 = set(net.post_set.get(t1, set()))
                    post_t2 = set(net.post_set.get(t2, set()))

                    if post_t1 == post_t2:
                        # å¯ä»¥åˆå¹¶ t1 å’Œ t2
                        self.reduction_log.append(f"åˆå¹¶å¹¶è¡Œå˜è¿: {t1} å’Œ {t2}")
                        # å®é™…åˆå¹¶æ“ä½œï¼ˆç®€åŒ–ï¼‰
                        return True

        return False

    def _apply_self_loop_reduction(self, net) -> bool:
        """
        åº”ç”¨è‡ªå¾ªç¯çº¦ç®€ã€‚

        è§„åˆ™ï¼šå¦‚æœåº“æ‰€ p å’Œå˜è¿ t å½¢æˆè‡ªå¾ªç¯ï¼Œä¸”ä¸å½±å“å…¶ä»–è¡Œä¸ºï¼Œå¯ä»¥ç§»é™¤ã€‚

        Returns:
            æ˜¯å¦æˆåŠŸåº”ç”¨çº¦ç®€
        """
        for place in list(net.places):
            for transition in list(net.transitions):
                # æ£€æŸ¥æ˜¯å¦å­˜åœ¨è‡ªå¾ªç¯ (place -> transition -> place)
                has_pre = place in [p for p, w in net.pre_set.get(transition, set())]
                has_post = place in [p for p, w in net.post_set.get(transition, set())]

                if has_pre and has_post:
                    # æ£€æŸ¥æ˜¯å¦åªå½¢æˆè‡ªå¾ªç¯ï¼ˆç®€åŒ–æ£€æŸ¥ï¼‰
                    # å¦‚æœ place åªæœ‰è¿™ä¸€ä¸ªè¿æ¥ï¼Œå¯ä»¥ç§»é™¤
                    pre_count = sum(1 for t in net.transitions
                                   if place in [p for p, w in net.pre_set.get(t, set())])
                    post_count = sum(1 for t in net.transitions
                                    if place in [p for p, w in net.post_set.get(t, set())])

                    if pre_count == 1 and post_count == 1:
                        # å¯ä»¥ç§»é™¤è‡ªå¾ªç¯ï¼ˆç®€åŒ–å®ç°ï¼‰
                        self.reduction_log.append(f"ç§»é™¤è‡ªå¾ªç¯: {place} <-> {transition}")
                        return True

        return False

    def _apply_series_place_fusion(self, net) -> bool:
        """
        åº”ç”¨ä¸²è¡Œåº“æ‰€èåˆã€‚

        è§„åˆ™ï¼šå¦‚æœä¸¤ä¸ªåº“æ‰€ p1 å’Œ p2 ä¸²è¡Œè¿æ¥ï¼Œå¯ä»¥åˆå¹¶ã€‚

        Returns:
            æ˜¯å¦æˆåŠŸåº”ç”¨çº¦ç®€
        """
        for p1 in list(net.places):
            # æŸ¥æ‰¾ p1 çš„å•ä¸ªè¾“å‡ºå˜è¿
            p1_outputs = []
            for t in net.transitions:
                if p1 in [p for p, w in net.pre_set.get(t, set())]:
                    p1_outputs.append(t)

            if len(p1_outputs) == 1:
                t = p1_outputs[0]
                # æŸ¥æ‰¾ t çš„å•ä¸ªè¾“å‡ºåº“æ‰€
                t_outputs = net.post_set.get(t, set())

                if len(t_outputs) == 1:
                    p2, w = next(iter(t_outputs))

                    # æ£€æŸ¥ p2 æ˜¯å¦åªè¢« t è¾“å…¥
                    p2_inputs = []
                    for t2 in net.transitions:
                        if p2 in [p for p, w in net.post_set.get(t2, set())]:
                            p2_inputs.append(t2)

                    if len(p2_inputs) == 1 and p2_inputs[0] == t:
                        # å¯ä»¥åˆå¹¶ p1 å’Œ p2
                        self.reduction_log.append(f"èåˆä¸²è¡Œåº“æ‰€: {p1} å’Œ {p2}")
                        return True

        return False

    def _apply_implicit_place_reduction(self, net) -> bool:
        """
        åº”ç”¨éšå¼åº“æ‰€çº¦ç®€ã€‚

        è§„åˆ™ï¼šå¦‚æœåº“æ‰€ p çš„å€¼åœ¨æ‰€æœ‰å¯è¾¾æ ‡è¯†ä¸­æ€»æ˜¯å¤§äºç­‰äºæŸä¸ªå¸¸æ•°ï¼Œ
        ä¸”ç§»é™¤ p ä¸å½±å“å˜è¿ä½¿èƒ½æ€§ï¼Œå¯ä»¥ç§»é™¤ã€‚

        Returns:
            æ˜¯å¦æˆåŠŸåº”ç”¨çº¦ç®€
        """
        # ç®€åŒ–å®ç°ï¼šéœ€è¦å¯è¾¾æ€§åˆ†ææ¥ç¡®å®šéšå¼åº“æ‰€
        # è¿™é‡Œåªæä¾›æ¡†æ¶
        # å®é™…å®ç°éœ€è¦ï¼š
        # 1. è¿›è¡Œå¯è¾¾æ€§åˆ†æ
        # 2. æ£€æŸ¥æ¯ä¸ªåº“æ‰€æ˜¯å¦æ»¡è¶³éšå¼æ¡ä»¶
        # 3. éªŒè¯ç§»é™¤åä¸å½±å“è¡Œä¸º

        return False

    def get_reduction_statistics(self, original_net, reduced_net) -> Dict[str, int]:
        """
        è·å–çº¦ç®€ç»Ÿè®¡ä¿¡æ¯ã€‚

        Args:
            original_net: åŸå§‹Petriç½‘
            reduced_net: çº¦ç®€åçš„Petriç½‘

        Returns:
            ç»Ÿè®¡ä¿¡æ¯å­—å…¸
        """
        return {
            'original_places': len(original_net.places),
            'reduced_places': len(reduced_net.places),
            'places_reduced': len(original_net.places) - len(reduced_net.places),
            'original_transitions': len(original_net.transitions),
            'reduced_transitions': len(reduced_net.transitions),
            'transitions_reduced': len(original_net.transitions) - len(reduced_net.transitions),
            'reduction_ratio_places': (len(original_net.places) - len(reduced_net.places)) / len(original_net.places) * 100,
            'reduction_ratio_transitions': (len(original_net.transitions) - len(reduced_net.transitions)) / len(original_net.transitions) * 100
        }


# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    from petri_net import PetriNet

    # åˆ›å»ºæµ‹è¯•Petriç½‘
    places = ['P1', 'P2', 'P3']
    transitions = ['T1', 'T2']
    flows = [
        ('P1', 'T1', 1),
        ('T1', 'P2', 1),
        ('P2', 'T2', 1),
        ('T2', 'P3', 1)
    ]
    initial_marking = {'P1': 1, 'P2': 0, 'P3': 0}

    net = PetriNet(places, transitions, flows, initial_marking)

    # åº”ç”¨ç»“æ„çº¦ç®€
    reducer = StructuralReducer(net)
    reduced_net = reducer.reduce()

    # è·å–ç»Ÿè®¡ä¿¡æ¯
    stats = reducer.get_reduction_statistics(net, reduced_net)
    print("çº¦ç®€ç»Ÿè®¡:")
    print(f"  åº“æ‰€: {stats['original_places']} -> {stats['reduced_places']} "
          f"({stats['reduction_ratio_places']:.1f}% å‡å°‘)")
    print(f"  å˜è¿: {stats['original_transitions']} -> {stats['reduced_transitions']} "
          f"({stats['reduction_ratio_transitions']:.1f}% å‡å°‘)")
    print("\nçº¦ç®€æ“ä½œæ—¥å¿—:")
    for log_entry in reducer.reduction_log:
        print(f"  - {log_entry}")
```

---

## 5. å®é™…åº”ç”¨æ¡ˆä¾‹ / Practical Application Cases

### 5.1 æ¡ˆä¾‹1ï¼šåˆ¶é€ ç³»ç»Ÿæ­»é”æ£€æµ‹ / Case 1: Manufacturing System Deadlock Detection

**åœºæ™¯**ï¼šæ£€æµ‹æŸ”æ€§åˆ¶é€ ç³»ç»Ÿï¼ˆFMSï¼‰ä¸­çš„æ­»é”ã€‚

**Petriç½‘æ¨¡å‹**ï¼š

- åº“æ‰€ï¼šæœºå™¨çŠ¶æ€ã€äº§å“ä½ç½®
- å˜è¿ï¼šæ“ä½œã€è¿è¾“

**ç»“æ„åˆ†æ**ï¼š

1. è®¡ç®—æ‰€æœ‰æ­»é”æ ‡è®°
2. æ£€æŸ¥æœªæ ‡è®°çš„æ­»é”æ ‡è®°
3. è¯†åˆ«æ­»é”é£é™©

**ç»“æœ**ï¼šæˆåŠŸæ£€æµ‹åˆ°æ­»é”é£é™©ï¼Œé€šè¿‡æ·»åŠ æ§åˆ¶åº“æ‰€é¢„é˜²æ­»é”ã€‚

### 5.2 æ¡ˆä¾‹2ï¼šå·¥ä½œæµç»“æ„ä¼˜åŒ– / Case 2: Workflow Structure Optimization

**åœºæ™¯**ï¼šä¼˜åŒ–å·¥ä½œæµçš„ç»“æ„ã€‚

**Petriç½‘æ¨¡å‹**ï¼š

- åº“æ‰€ï¼šä»»åŠ¡çŠ¶æ€
- å˜è¿ï¼šä»»åŠ¡æ‰§è¡Œ

**ç»“æ„åˆ†æ**ï¼š

1. åˆ†æç»“æ„æœ‰ç•Œæ€§å’Œç»“æ„æ´»æ€§
2. åº”ç”¨ç»“æ„çº¦ç®€
3. ä¼˜åŒ–å·¥ä½œæµè®¾è®¡

**ç»“æœ**ï¼šæˆåŠŸç®€åŒ–å·¥ä½œæµæ¨¡å‹ï¼Œæé«˜äº†åˆ†ææ•ˆç‡ã€‚

### 5.3 æ¡ˆä¾‹3ï¼šåè®®ç»“æ„éªŒè¯ / Case 3: Protocol Structure Verification

**åœºæ™¯**ï¼šéªŒè¯é€šä¿¡åè®®çš„ç»“æ„æ­£ç¡®æ€§ã€‚

**Petriç½‘æ¨¡å‹**ï¼š

- åº“æ‰€ï¼šåè®®çŠ¶æ€
- å˜è¿ï¼šåè®®äº‹ä»¶

**ç»“æ„åˆ†æ**ï¼š

1. éªŒè¯ç»“æ„æœ‰ç•Œæ€§
2. æ£€æµ‹é™·é˜±å’Œæ­»é”æ ‡è®°
3. åˆ†ææ­»é”é£é™©

**ç»“æœ**ï¼šæˆåŠŸéªŒè¯åè®®ç»“æ„ï¼Œå‘ç°å¹¶ä¿®å¤äº†ç»“æ„é—®é¢˜ã€‚

---

## ğŸ“š **å‚è€ƒæ–‡çŒ® / References**

1. Murata, T. (1989). Petri nets: Properties, analysis and applications. *Proceedings of the IEEE*, 77(4), 541-580.

2. Ezpeleta, J., Colom, J. M., & Martinez, J. (1995). A Petri net based deadlock prevention policy for flexible manufacturing systems. *IEEE Transactions on Robotics and Automation*, 11(2), 173-184.

3. Li, Z., & Zhou, M. (2004). Elementary siphons of Petri nets and their application to deadlock prevention in flexible manufacturing systems. *IEEE Transactions on Systems, Man, and Cybernetics*, 34(1), 38-51.

---

**æ–‡æ¡£ç‰ˆæœ¬**: v2.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å­—æ•°ç»Ÿè®¡**: çº¦5000å­—
