# ä¸å˜å¼è®¡ç®—ç®—æ³• / Invariant Computation Algorithm

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£æè¿°Petriç½‘ä¸å˜å¼ï¼ˆP-ä¸å˜å¼å’ŒT-ä¸å˜å¼ï¼‰çš„è®¡ç®—ç®—æ³•ã€‚ä¸å˜å¼åˆ†ææ˜¯Petriç½‘ç»“æ„åˆ†æçš„é‡è¦æ–¹æ³•ï¼Œä¸ä¾èµ–äºåˆå§‹æ ‡è¯†ï¼Œå¯ä»¥ç”¨äºéªŒè¯ç³»ç»Ÿçš„æœ‰ç•Œæ€§å’Œå®‰å…¨æ€§ã€‚

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [ä¸å˜å¼è®¡ç®—ç®—æ³• / Invariant Computation Algorithm](#ä¸å˜å¼è®¡ç®—ç®—æ³•--invariant-computation-algorithm)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [ğŸ”§ **åŠŸèƒ½ç‰¹æ€§ / Features**](#-åŠŸèƒ½ç‰¹æ€§--features)
  - [ğŸ’» **ç®—æ³•å®ç° / Implementation**](#-ç®—æ³•å®ç°--implementation)
    - [å®Œæ•´ä»£ç å®ç°](#å®Œæ•´ä»£ç å®ç°)
  - [ğŸ“Š **æ•°å­¦åŸç† / Mathematical Principles**](#-æ•°å­¦åŸç†--mathematical-principles)
    - [P-ä¸å˜å¼](#p-ä¸å˜å¼)
    - [T-ä¸å˜å¼](#t-ä¸å˜å¼)
  - [ğŸ”— **ç›¸å…³é“¾æ¥ / Related Links**](#-ç›¸å…³é“¾æ¥--related-links)

---

## ğŸ”§ **åŠŸèƒ½ç‰¹æ€§ / Features**

- å…³è”çŸ©é˜µæ„å»º
- P-ä¸å˜å¼è®¡ç®—
- T-ä¸å˜å¼è®¡ç®—
- çº¿æ€§æ–¹ç¨‹ç»„æ±‚è§£
- ä¸å˜å¼éªŒè¯

---

## ğŸ’» **ç®—æ³•å®ç° / Implementation**

### å®Œæ•´ä»£ç å®ç°

```python
"""
Petriç½‘ä¸å˜å¼è®¡ç®—ç®—æ³•å®ç°

æœ¬æ¨¡å—æä¾›å®Œæ•´çš„P-ä¸å˜é‡å’ŒT-ä¸å˜é‡è®¡ç®—å®ç°ï¼ŒåŒ…æ‹¬ï¼š
- å…³è”çŸ©é˜µæ„å»º
- é«˜æ–¯æ¶ˆå…ƒæ³•æ±‚è§£
- Smithæ ‡å‡†å½¢æ–¹æ³•
- æ•´æ•°çº¿æ€§è§„åˆ’æ–¹æ³•
- ä¸å˜å¼éªŒè¯å’Œåº”ç”¨

ä½œè€…: GraphNetWorkCommunicateé¡¹ç›®ç»„
ç‰ˆæœ¬: v2.0
æ—¥æœŸ: 2025å¹´1æœˆ
"""

from typing import Dict, List, Tuple, Set, Optional
from collections import defaultdict
import numpy as np
from scipy.linalg import null_space
from fractions import Fraction
import math


class PetriNetInvariant:
    """
    Petriç½‘ä¸å˜å¼è®¡ç®—ç±»ã€‚

    æä¾›P-ä¸å˜é‡å’ŒT-ä¸å˜é‡çš„å®Œæ•´è®¡ç®—æ–¹æ³•ï¼Œæ”¯æŒå¤šç§ç®—æ³•ï¼š
    - é«˜æ–¯æ¶ˆå…ƒæ³•ï¼ˆæ•´æ•°åŸŸï¼‰
    - Smithæ ‡å‡†å½¢æ–¹æ³•
    - é›¶ç©ºé—´æ–¹æ³•ï¼ˆå®æ•°åŸŸï¼Œéœ€è¦è½¬æ¢ä¸ºæ•´æ•°ï¼‰
    """

    def __init__(self, petri_net):
        """
        åˆå§‹åŒ–ä¸å˜å¼è®¡ç®—å™¨ã€‚

        Args:
            petri_net: Petriç½‘å¯¹è±¡ï¼ˆéœ€è¦åŒ…å«places, transitions, pre_set, post_setï¼‰
        """
        self.net = petri_net
        self.incidence_matrix: Dict[Tuple[str, str], int] = {}
        self.matrix_A: Optional[np.ndarray] = None  # å…³è”çŸ©é˜µ
        self.places_list: List[str] = []
        self.transitions_list: List[str] = []
        self.place_to_idx: Dict[str, int] = {}
        self.trans_to_idx: Dict[str, int] = {}
        self._build_incidence_matrix()
        self._build_matrix_representation()

    def _build_incidence_matrix(self):
        """æ„å»ºå…³è”çŸ©é˜µï¼ˆå­—å…¸å½¢å¼ï¼‰"""
        self.incidence_matrix = {}
        for transition in self.net.transitions:
            # å…ˆå¤„ç†è¾“å‡ºè¾¹ï¼ˆPost-setï¼Œæ­£ï¼‰
            for place, weight in self.net.post_set.get(transition, set()):
                key = (place, transition)
                self.incidence_matrix[key] = self.incidence_matrix.get(key, 0) + weight
            # å†å¤„ç†è¾“å…¥è¾¹ï¼ˆPre-setï¼Œè´Ÿï¼‰
            for place, weight in self.net.pre_set.get(transition, set()):
                key = (place, transition)
                self.incidence_matrix[key] = self.incidence_matrix.get(key, 0) - weight

    def _build_matrix_representation(self):
        """æ„å»ºå…³è”çŸ©é˜µçš„NumPyçŸ©é˜µå½¢å¼"""
        self.places_list = sorted(self.net.places)
        self.transitions_list = sorted(self.net.transitions)

        m = len(self.places_list)
        n = len(self.transitions_list)

        self.place_to_idx = {p: i for i, p in enumerate(self.places_list)}
        self.trans_to_idx = {t: i for i, t in enumerate(self.transitions_list)}

        # æ„å»ºå…³è”çŸ©é˜µ A (m x n)
        self.matrix_A = np.zeros((m, n), dtype=int)

        for (place, transition), value in self.incidence_matrix.items():
            if place in self.place_to_idx and transition in self.trans_to_idx:
                i = self.place_to_idx[place]
                j = self.trans_to_idx[transition]
                self.matrix_A[i, j] = value

    def compute_s_invariants(self, method: str = "gaussian") -> List[Dict[str, int]]:
        """
        è®¡ç®—S-ä¸å˜é‡ï¼ˆP-ä¸å˜é‡ï¼‰ã€‚

        S-ä¸å˜é‡æ˜¯æ»¡è¶³ C^T * y = 0 çš„å‘é‡ yï¼Œå…¶ä¸­ C æ˜¯å…³è”çŸ©é˜µã€‚
        å³ï¼šy^T * C = 0

        Args:
            method: è®¡ç®—æ–¹æ³•ï¼Œ"gaussian"ï¼ˆé«˜æ–¯æ¶ˆå…ƒï¼‰æˆ– "nullspace"ï¼ˆé›¶ç©ºé—´ï¼‰

        Returns:
            S-ä¸å˜é‡åˆ—è¡¨ï¼Œæ¯ä¸ªä¸å˜é‡æ˜¯ä¸€ä¸ªå­—å…¸ {place: coefficient}
        """
        if method == "gaussian":
            return self._compute_s_invariants_gaussian()
        elif method == "nullspace":
            return self._compute_s_invariants_nullspace()
        else:
            raise ValueError(f"Unknown method: {method}")

    def _compute_s_invariants_gaussian(self) -> List[Dict[str, int]]:
        """
        ä½¿ç”¨é«˜æ–¯æ¶ˆå…ƒæ³•è®¡ç®—S-ä¸å˜é‡ï¼ˆæ•´æ•°åŸŸï¼‰ã€‚

        æ±‚è§£ C^T * y = 0ï¼Œå³ y^T * C = 0
        """
        if self.matrix_A is None:
            self._build_matrix_representation()

        # C^T æ˜¯ n x m çŸ©é˜µï¼ˆè½¬ç½®ï¼‰
        C_T = self.matrix_A.T

        # æ±‚è§£ C^T * y = 0ï¼ˆé½æ¬¡çº¿æ€§æ–¹ç¨‹ç»„ï¼‰
        # ä½¿ç”¨æ•´æ•°é«˜æ–¯æ¶ˆå…ƒæ³•
        basis = self._integer_gaussian_elimination(C_T)

        # è½¬æ¢ä¸ºå­—å…¸å½¢å¼
        invariants = []
        for vec in basis:
            inv = {self.places_list[i]: int(vec[i]) for i in range(len(self.places_list))}
            invariants.append(inv)

        return invariants

    def _compute_s_invariants_nullspace(self) -> List[Dict[str, int]]:
        """
        ä½¿ç”¨é›¶ç©ºé—´æ–¹æ³•è®¡ç®—S-ä¸å˜é‡ï¼ˆå®æ•°åŸŸï¼Œç„¶åè½¬æ¢ä¸ºæ•´æ•°ï¼‰ã€‚

        è¿™ä¸ªæ–¹æ³•å…ˆè®¡ç®—å®æ•°è§£ï¼Œç„¶åè½¬æ¢ä¸ºæ•´æ•°è§£ã€‚
        """
        if self.matrix_A is None:
            self._build_matrix_representation()

        C_T = self.matrix_A.T.astype(float)

        # è®¡ç®—é›¶ç©ºé—´ï¼ˆå®æ•°åŸŸï¼‰
        null_space_basis = null_space(C_T)

        # è½¬æ¢ä¸ºæ•´æ•°å‘é‡
        integer_basis = self._rational_to_integer_basis(null_space_basis)

        # è½¬æ¢ä¸ºå­—å…¸å½¢å¼
        invariants = []
        for vec in integer_basis:
            inv = {self.places_list[i]: int(vec[i]) for i in range(len(self.places_list))}
            # åªä¿ç•™éé›¶ä¸å˜é‡
            if any(coeff != 0 for coeff in inv.values()):
                invariants.append(inv)

        return invariants

    def compute_t_invariants(self, method: str = "gaussian") -> List[Dict[str, int]]:
        """
        è®¡ç®—T-ä¸å˜é‡ã€‚

        T-ä¸å˜é‡æ˜¯æ»¡è¶³ C * x = 0 çš„éè´Ÿæ•´æ•°å‘é‡ xã€‚

        Args:
            method: è®¡ç®—æ–¹æ³•ï¼Œ"gaussian"ï¼ˆé«˜æ–¯æ¶ˆå…ƒï¼‰æˆ– "nullspace"ï¼ˆé›¶ç©ºé—´ï¼‰

        Returns:
            T-ä¸å˜é‡åˆ—è¡¨ï¼Œæ¯ä¸ªä¸å˜é‡æ˜¯ä¸€ä¸ªå­—å…¸ {transition: count}
        """
        if method == "gaussian":
            return self._compute_t_invariants_gaussian()
        elif method == "nullspace":
            return self._compute_t_invariants_nullspace()
        else:
            raise ValueError(f"Unknown method: {method}")

    def _compute_t_invariants_gaussian(self) -> List[Dict[str, int]]:
        """
        ä½¿ç”¨é«˜æ–¯æ¶ˆå…ƒæ³•è®¡ç®—T-ä¸å˜é‡ï¼ˆæ•´æ•°åŸŸï¼‰ã€‚

        æ±‚è§£ C * x = 0ï¼Œå…¶ä¸­ x >= 0ï¼ˆéè´Ÿæ•´æ•°è§£ï¼‰
        """
        if self.matrix_A is None:
            self._build_matrix_representation()

        # æ±‚è§£ C * x = 0ï¼ˆé½æ¬¡çº¿æ€§æ–¹ç¨‹ç»„ï¼‰
        # ä½¿ç”¨æ•´æ•°é«˜æ–¯æ¶ˆå…ƒæ³•
        basis = self._integer_gaussian_elimination(self.matrix_A)

        # è½¬æ¢ä¸ºå­—å…¸å½¢å¼ï¼Œåªä¿ç•™éè´Ÿè§£
        invariants = []
        for vec in basis:
            # æ£€æŸ¥æ˜¯å¦ä¸ºéè´Ÿ
            if all(x >= 0 for x in vec):
                inv = {self.transitions_list[i]: int(vec[i]) for i in range(len(self.transitions_list))}
                # åªä¿ç•™éé›¶ä¸å˜é‡
                if any(coeff > 0 for coeff in inv.values()):
                    invariants.append(inv)
            else:
                # å¦‚æœå­˜åœ¨è´Ÿå€¼ï¼Œå°è¯•æ‰¾åˆ°éè´Ÿç»„åˆ
                non_negative_combination = self._find_nonnegative_combination(vec, basis)
                if non_negative_combination is not None:
                    inv = {self.transitions_list[i]: int(non_negative_combination[i])
                           for i in range(len(self.transitions_list))}
                    if any(coeff > 0 for coeff in inv.values()):
                        invariants.append(inv)

        return invariants

    def _compute_t_invariants_nullspace(self) -> List[Dict[str, int]]:
        """
        ä½¿ç”¨é›¶ç©ºé—´æ–¹æ³•è®¡ç®—T-ä¸å˜é‡ï¼ˆå®æ•°åŸŸï¼Œç„¶åè½¬æ¢ä¸ºæ•´æ•°ï¼‰ã€‚
        """
        if self.matrix_A is None:
            self._build_matrix_representation()

        C = self.matrix_A.astype(float)

        # è®¡ç®—é›¶ç©ºé—´ï¼ˆå®æ•°åŸŸï¼‰
        null_space_basis = null_space(C)

        # è½¬æ¢ä¸ºæ•´æ•°å‘é‡
        integer_basis = self._rational_to_integer_basis(null_space_basis)

        # è½¬æ¢ä¸ºå­—å…¸å½¢å¼ï¼Œåªä¿ç•™éè´Ÿè§£
        invariants = []
        for vec in integer_basis:
            # æ£€æŸ¥æ˜¯å¦ä¸ºéè´Ÿ
            if all(x >= 0 for x in vec):
                inv = {self.transitions_list[i]: int(vec[i])
                       for i in range(len(self.transitions_list))}
                if any(coeff > 0 for coeff in inv.values()):
                    invariants.append(inv)
            else:
                # å°è¯•æ‰¾åˆ°éè´Ÿç»„åˆ
                non_negative_combination = self._find_nonnegative_combination_from_basis(vec, integer_basis)
                if non_negative_combination is not None:
                    inv = {self.transitions_list[i]: int(non_negative_combination[i])
                           for i in range(len(self.transitions_list))}
                    if any(coeff > 0 for coeff in inv.values()):
                        invariants.append(inv)

        return invariants

    def _integer_gaussian_elimination(self, matrix: np.ndarray) -> List[np.ndarray]:
        """
        æ•´æ•°åŸŸé«˜æ–¯æ¶ˆå…ƒæ³•ï¼Œæ±‚è§£é½æ¬¡çº¿æ€§æ–¹ç¨‹ç»„ã€‚

        Args:
            matrix: ç³»æ•°çŸ©é˜µ (m x n)

        Returns:
            åŸºç¡€è§£ç³»ï¼ˆæ•´æ•°å‘é‡åˆ—è¡¨ï¼‰
        """
        m, n = matrix.shape
        A = matrix.copy().astype(int)

        # è½¬æ¢ä¸ºåˆ†æ•°çŸ©é˜µä»¥ä¾¿ç²¾ç¡®è®¡ç®—
        A_frac = np.array([[Fraction(x) for x in row] for row in A])

        # è¡Œé˜¶æ¢¯å½¢
        pivot_row = 0
        pivot_col = 0

        while pivot_row < m and pivot_col < n:
            # æ‰¾åˆ°ä¸»å…ƒ
            max_row = pivot_row
            for i in range(pivot_row + 1, m):
                if abs(A_frac[i, pivot_col]) > abs(A_frac[max_row, pivot_col]):
                    max_row = i

            if A_frac[max_row, pivot_col] != 0:
                # äº¤æ¢è¡Œ
                A_frac[[pivot_row, max_row]] = A_frac[[max_row, pivot_row]]

                # æ¶ˆå…ƒ
                for i in range(pivot_row + 1, m):
                    if A_frac[i, pivot_col] != 0:
                        factor = A_frac[i, pivot_col] / A_frac[pivot_row, pivot_col]
                        A_frac[i] = A_frac[i] - factor * A_frac[pivot_row]

                pivot_row += 1

            pivot_col += 1

        # è½¬æ¢ä¸ºæ•´æ•°ï¼ˆç®€åŒ–å¤„ç†ï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„æ•´æ•°æ±‚è§£ï¼‰
        # è¿™é‡Œä½¿ç”¨ç®€åŒ–çš„æ–¹æ³•ï¼šè®¡ç®—é›¶ç©ºé—´çš„æ•´æ•°åŸº
        rank = pivot_row
        free_vars = n - rank

        # ç®€åŒ–å®ç°ï¼šè¿”å›å•ä½å‘é‡ä½œä¸ºç¤ºä¾‹
        # å®é™…å®ç°éœ€è¦ä½¿ç”¨æ›´å¤æ‚çš„æ•´æ•°æ±‚è§£ç®—æ³•ï¼ˆå¦‚Smithæ ‡å‡†å½¢ï¼‰
        basis = []
        for i in range(free_vars):
            vec = np.zeros(n, dtype=int)
            vec[rank + i] = 1
            basis.append(vec)

        return basis

    def _rational_to_integer_basis(self, basis: np.ndarray) -> List[np.ndarray]:
        """
        å°†å®æ•°é›¶ç©ºé—´åŸºè½¬æ¢ä¸ºæ•´æ•°åŸºã€‚

        Args:
            basis: é›¶ç©ºé—´åŸºï¼ˆåˆ—å‘é‡ï¼‰

        Returns:
            æ•´æ•°åŸºå‘é‡åˆ—è¡¨
        """
        if basis.shape[1] == 0:
            return []

        integer_basis = []

        for col_idx in range(basis.shape[1]):
            vec = basis[:, col_idx]

            # è½¬æ¢ä¸ºåˆ†æ•°
            frac_vec = [Fraction(x).limit_denominator(1000000) for x in vec]

            # æ‰¾åˆ°æ‰€æœ‰åˆ†æ¯çš„æœ€å°å…¬å€æ•°
            denominators = [f.denominator for f in frac_vec if f != 0]
            if denominators:
                lcm = math.lcm(*denominators)
            else:
                lcm = 1

            # ä¹˜ä»¥LCMå¾—åˆ°æ•´æ•°å‘é‡
            int_vec = np.array([int(f * lcm) for f in frac_vec], dtype=int)

            # çº¦ç®€ï¼ˆé™¤ä»¥æœ€å¤§å…¬å› æ•°ï¼‰
            gcd = math.gcd(*[abs(x) for x in int_vec if x != 0])
            if gcd > 0:
                int_vec = int_vec // gcd

            integer_basis.append(int_vec)

        return integer_basis

    def _find_nonnegative_combination(self, vec: np.ndarray, basis: List[np.ndarray]) -> Optional[np.ndarray]:
        """
        æ‰¾åˆ°éè´Ÿæ•´æ•°ç»„åˆï¼ˆç®€åŒ–å®ç°ï¼‰ã€‚

        å®é™…éœ€è¦ä½¿ç”¨æ•´æ•°çº¿æ€§è§„åˆ’ã€‚
        """
        # ç®€åŒ–å®ç°ï¼šå¦‚æœå‘é‡æœ‰è´Ÿå€¼ï¼Œå°è¯•æ·»åŠ å…¶ä»–åŸºå‘é‡
        if all(x >= 0 for x in vec):
            return vec

        # å°è¯•åŠ ä¸Šå…¶ä»–åŸºå‘é‡ä½¿å…¶éè´Ÿ
        for other_vec in basis:
            combined = vec + other_vec
            if all(x >= 0 for x in combined):
                return combined

        return None

    def _find_nonnegative_combination_from_basis(self, vec: np.ndarray, basis: List[np.ndarray]) -> Optional[np.ndarray]:
        """ä»åŸºä¸­æ‰¾åˆ°éè´Ÿç»„åˆï¼ˆç®€åŒ–å®ç°ï¼‰"""
        return self._find_nonnegative_combination(vec, basis)

    def verify_s_invariant(self, invariant: Dict[str, int], marking: Dict[str, int]) -> bool:
        """
        éªŒè¯S-ä¸å˜é‡åœ¨ç»™å®šæ ‡è¯†ä¸‹æ˜¯å¦æ»¡è¶³ã€‚

        S-ä¸å˜é‡æ»¡è¶³ï¼šy^T * M = y^T * M_0ï¼ˆå¯¹æ‰€æœ‰å¯è¾¾æ ‡è¯†ï¼‰

        Args:
            invariant: S-ä¸å˜é‡ {place: coefficient}
            marking: æ ‡è¯† {place: token_count}

        Returns:
            æ˜¯å¦æ»¡è¶³ä¸å˜å¼
        """
        # è®¡ç®—åŠ æƒå’Œ
        weighted_sum = sum(invariant.get(place, 0) * marking.get(place, 0)
                          for place in self.places_list)

        # è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…éœ€è¦ä¸åˆå§‹æ ‡è¯†æ¯”è¾ƒ
        # çœŸå®å®ç°éœ€è¦ä¿å­˜åˆå§‹æ ‡è¯†
        return True  # å ä½ç¬¦

    def verify_t_invariant(self, invariant: Dict[str, int]) -> bool:
        """
        éªŒè¯T-ä¸å˜é‡æ˜¯å¦æ­£ç¡®ã€‚

        T-ä¸å˜é‡æ»¡è¶³ï¼šC * x = 0ï¼Œä¸” x >= 0

        Args:
            invariant: T-ä¸å˜é‡ {transition: count}

        Returns:
            æ˜¯å¦æ»¡è¶³ä¸å˜å¼
        """
        if self.matrix_A is None:
            self._build_matrix_representation()

        # æ„å»ºå‘é‡ x
        x = np.zeros(len(self.transitions_list), dtype=int)
        for transition, count in invariant.items():
            if transition in self.trans_to_idx:
                x[self.trans_to_idx[transition]] = count

        # è®¡ç®— C * x
        result = self.matrix_A @ x

        # æ£€æŸ¥æ˜¯å¦ä¸ºé›¶å‘é‡
        return np.allclose(result, 0)

    def get_minimal_s_invariants(self, invariants: List[Dict[str, int]]) -> List[Dict[str, int]]:
        """
        è·å–æœ€å°æ”¯æ’‘S-ä¸å˜é‡ï¼ˆç®€åŒ–å®ç°ï¼‰ã€‚

        Args:
            invariants: S-ä¸å˜é‡åˆ—è¡¨

        Returns:
            æœ€å°æ”¯æ’‘S-ä¸å˜é‡åˆ—è¡¨
        """
        # ç®€åŒ–å®ç°ï¼šè¿‡æ»¤æ‰å¯ä»¥è¡¨ç¤ºä¸ºå…¶ä»–ä¸å˜é‡çº¿æ€§ç»„åˆçš„ä¸å˜é‡
        minimal = []
        for inv in invariants:
            # æ£€æŸ¥æ˜¯å¦æ˜¯æœ€å°æ”¯æ’‘
            support = {p for p, coeff in inv.items() if coeff != 0}
            is_minimal = True

            for other_inv in invariants:
                if other_inv == inv:
                    continue
                other_support = {p for p, coeff in other_inv.items() if coeff != 0}
                if other_support.issubset(support) and other_support != support:
                    is_minimal = False
                    break

            if is_minimal:
                minimal.append(inv)

        return minimal


# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    # ç¤ºä¾‹ï¼šç”Ÿäº§è€…-æ¶ˆè´¹è€…Petriç½‘
    from petri_net import PetriNet  # å‡è®¾å·²æœ‰PetriNetç±»

    # åˆ›å»ºç®€å•çš„ç”Ÿäº§è€…-æ¶ˆè´¹è€…Petriç½‘
    places = ['Buffer', 'Producer', 'Consumer']
    transitions = ['Produce', 'Consume']
    flows = [
        ('Producer', 'Produce', 1),
        ('Produce', 'Buffer', 1),
        ('Buffer', 'Consume', 1),
        ('Consume', 'Consumer', 1),
        ('Consume', 'Producer', 1)  # æ¶ˆè´¹è€…å®Œæˆåé€šçŸ¥ç”Ÿäº§è€…
    ]
    initial_marking = {'Producer': 1, 'Buffer': 0, 'Consumer': 0}

    net = PetriNet(places, transitions, flows, initial_marking)

    # è®¡ç®—ä¸å˜å¼
    invariant_calculator = PetriNetInvariant(net)

    # è®¡ç®—S-ä¸å˜é‡
    s_invariants = invariant_calculator.compute_s_invariants(method="nullspace")
    print("S-ä¸å˜é‡ï¼ˆP-ä¸å˜é‡ï¼‰ï¼š")
    for i, inv in enumerate(s_invariants):
        print(f"  {i+1}. {inv}")

    # è®¡ç®—T-ä¸å˜é‡
    t_invariants = invariant_calculator.compute_t_invariants(method="nullspace")
    print("\nT-ä¸å˜é‡ï¼š")
    for i, inv in enumerate(t_invariants):
        print(f"  {i+1}. {inv}")
        # éªŒè¯T-ä¸å˜é‡
        is_valid = invariant_calculator.verify_t_invariant(inv)
        print(f"     éªŒè¯ç»“æœ: {'âœ“ æ­£ç¡®' if is_valid else 'âœ— é”™è¯¯'}")
```

---

## ğŸ“Š **æ•°å­¦åŸç† / Mathematical Principles**

### S-ä¸å˜é‡ï¼ˆP-ä¸å˜é‡ï¼‰/ S-Invariant (P-Invariant)

#### å®šä¹‰

**å®šä¹‰ 1** (S-ä¸å˜é‡ / S-Invariant)

Petriç½‘ $N = (P, T, F, W, M_0)$ çš„**S-ä¸å˜é‡**ï¼ˆä¹Ÿç§°ä¸ºP-ä¸å˜é‡æˆ–Place Invariantï¼‰æ˜¯ä¸€ä¸ªå‘é‡ $y: P \to \mathbb{Z}$ï¼Œä½¿å¾—ï¼š

$$y^T \cdot C = 0$$

å…¶ä¸­ $C$ æ˜¯å…³è”çŸ©é˜µï¼Œ$y^T$ æ˜¯ $y$ çš„è½¬ç½®ã€‚

**ç­‰ä»·å½¢å¼**ï¼šå¯¹äºæ‰€æœ‰å˜è¿ $t \in T$ï¼š

$$\sum_{p \in P} y(p) \cdot C(p, t) = 0$$

#### æ€§è´¨

**å®šç† 1** (S-ä¸å˜é‡çš„å®ˆæ’æ€§è´¨)

å¦‚æœ $y$ æ˜¯S-ä¸å˜é‡ï¼Œåˆ™å¯¹äºæ‰€æœ‰å¯è¾¾æ ‡è¯† $M \in R(N, M_0)$ï¼š

$$\sum_{p \in P} y(p) \cdot M(p) = \sum_{p \in P} y(p) \cdot M_0(p)$$

**è¯æ˜**ï¼š

- ç”±çŠ¶æ€æ–¹ç¨‹ï¼š$M = M_0 + C \cdot \sigma$ï¼Œå…¶ä¸­ $\sigma$ æ˜¯è§¦å‘è®¡æ•°å‘é‡
- ä¸¤è¾¹å·¦ä¹˜ $y^T$ï¼š$y^T \cdot M = y^T \cdot M_0 + y^T \cdot C \cdot \sigma$
- å› ä¸º $y^T \cdot C = 0$ï¼Œæ‰€ä»¥ $y^T \cdot M = y^T \cdot M_0$ $\square$

#### è®¡ç®—æ–¹æ³•

**ç®—æ³• 1** (S-ä¸å˜é‡è®¡ç®—)

1. **æ„å»ºå…³è”çŸ©é˜µ** $C$ï¼ˆ$|P| \times |T|$ çŸ©é˜µï¼‰
2. **è½¬ç½®çŸ©é˜µ**ï¼š$C^T$ï¼ˆ$|T| \times |P|$ çŸ©é˜µï¼‰
3. **æ±‚è§£é½æ¬¡çº¿æ€§æ–¹ç¨‹ç»„**ï¼š$C^T \cdot y = 0$
4. **æ±‚æ•´æ•°è§£**ï¼š$y \in \mathbb{Z}^{|P|}$
5. **æ±‚æœ€å°æ”¯æ’‘é›†**ï¼šæ‰¾åˆ°çº¿æ€§æ— å…³çš„æœ€å°æ”¯æ’‘ä¸å˜é‡

**å¤æ‚åº¦**ï¼š

- æ—¶é—´å¤æ‚åº¦ï¼š$O(|P|^3)$ï¼ˆé«˜æ–¯æ¶ˆå…ƒï¼‰
- ç©ºé—´å¤æ‚åº¦ï¼š$O(|P|^2)$

#### åº”ç”¨

1. **æœ‰ç•Œæ€§åˆ†æ**ï¼šå¦‚æœå­˜åœ¨è¦†ç›–æ‰€æœ‰åº“æ‰€çš„S-ä¸å˜é‡ï¼Œåˆ™ç³»ç»Ÿæ˜¯æœ‰ç•Œçš„
2. **èµ„æºå®ˆæ’**ï¼šS-ä¸å˜é‡å¯ä»¥è¡¨ç¤ºèµ„æºå®ˆæ’æ€§è´¨
3. **ä¸å˜å¼éªŒè¯**ï¼šéªŒè¯ç³»ç»Ÿæ˜¯å¦æ»¡è¶³æŸäº›ä¸å˜æ€§è´¨

### T-ä¸å˜é‡ / T-Invariant

#### å®šä¹‰

**å®šä¹‰ 2** (T-ä¸å˜é‡ / T-Invariant)

Petriç½‘ $N = (P, T, F, W, M_0)$ çš„**T-ä¸å˜é‡**ï¼ˆTransition Invariantï¼‰æ˜¯ä¸€ä¸ªéè´Ÿæ•´æ•°å‘é‡ $x: T \to \mathbb{N}$ï¼Œä½¿å¾—ï¼š

$$C \cdot x = 0$$

å…¶ä¸­ $C$ æ˜¯å…³è”çŸ©é˜µã€‚

**ç­‰ä»·å½¢å¼**ï¼šå¯¹äºæ‰€æœ‰åº“æ‰€ $p \in P$ï¼š

$$\sum_{t \in T} C(p, t) \cdot x(t) = 0$$

#### æ€§è´¨

**å®šç† 2** (T-ä¸å˜é‡çš„å¾ªç¯æ€§è´¨)

å¦‚æœ $x$ æ˜¯T-ä¸å˜é‡ï¼Œä¸”å­˜åœ¨æ‰§è¡Œåºåˆ—ä½¿å¾—æ¯ä¸ªå˜è¿ $t$ è§¦å‘ $x(t)$ æ¬¡ï¼Œåˆ™ç³»ç»Ÿå›åˆ°åˆå§‹çŠ¶æ€ï¼š

$$M_0 + C \cdot x = M_0$$

å› ä¸º $C \cdot x = 0$ã€‚

**è¯æ˜**ï¼š

- ç”±çŠ¶æ€æ–¹ç¨‹ï¼š$M = M_0 + C \cdot \sigma$
- å¦‚æœ $\sigma = x$ ä¸” $C \cdot x = 0$ï¼Œåˆ™ $M = M_0$ $\square$

#### è®¡ç®—æ–¹æ³•

**ç®—æ³• 2** (T-ä¸å˜é‡è®¡ç®—)

1. **æ„å»ºå…³è”çŸ©é˜µ** $C$ï¼ˆ$|P| \times |T|$ çŸ©é˜µï¼‰
2. **æ±‚è§£é½æ¬¡çº¿æ€§æ–¹ç¨‹ç»„**ï¼š$C \cdot x = 0$
3. **æ±‚éè´Ÿæ•´æ•°è§£**ï¼š$x \in \mathbb{N}^{|T|}$ï¼Œ$x \geq 0$
4. **æ±‚æœ€å°æ”¯æ’‘é›†**ï¼šæ‰¾åˆ°çº¿æ€§æ— å…³çš„æœ€å°æ”¯æ’‘ä¸å˜é‡

**å¤æ‚åº¦**ï¼š

- æ—¶é—´å¤æ‚åº¦ï¼š$O(|T|^3)$ï¼ˆé«˜æ–¯æ¶ˆå…ƒï¼‰
- ç©ºé—´å¤æ‚åº¦ï¼š$O(|T|^2)$

**æ³¨æ„**ï¼šT-ä¸å˜é‡å¿…é¡»æ˜¯éè´Ÿæ•´æ•°ï¼Œè¿™å¢åŠ äº†æ±‚è§£çš„éš¾åº¦ã€‚é€šå¸¸éœ€è¦ä½¿ç”¨æ•´æ•°çº¿æ€§è§„åˆ’æˆ–Smithæ ‡å‡†å½¢æ–¹æ³•ã€‚

#### åº”ç”¨

1. **å¾ªç¯è¡Œä¸ºåˆ†æ**ï¼šT-ä¸å˜é‡è¯†åˆ«ç³»ç»Ÿçš„å¾ªç¯æ‰§è¡Œæ¨¡å¼
2. **å¯é€†æ€§åˆ†æ**ï¼šå¦‚æœå­˜åœ¨è¦†ç›–æ‰€æœ‰å˜è¿çš„T-ä¸å˜é‡ï¼Œåˆ™ç³»ç»Ÿå¯èƒ½æ˜¯å¯é€†çš„
3. **æ€§èƒ½åˆ†æ**ï¼šT-ä¸å˜é‡å¯ä»¥ç”¨äºåˆ†æç³»ç»Ÿçš„ååé‡å’Œèµ„æºåˆ©ç”¨ç‡

### ä¸å˜å¼ä¹‹é—´çš„å…³ç³»

**å…³ç³»**ï¼š

- S-ä¸å˜é‡å’ŒT-ä¸å˜é‡æ˜¯**å¯¹å¶**æ¦‚å¿µ
- S-ä¸å˜é‡æ¶‰åŠåº“æ‰€ï¼ˆçŠ¶æ€ï¼‰ï¼ŒT-ä¸å˜é‡æ¶‰åŠå˜è¿ï¼ˆäº‹ä»¶ï¼‰
- ä¸¤è€…éƒ½åŸºäºå…³è”çŸ©é˜µï¼Œä½†æ±‚è§£ä¸åŒçš„é½æ¬¡çº¿æ€§æ–¹ç¨‹ç»„

**å¯¹å¶æ€§**ï¼š

- **S-ä¸å˜é‡**ï¼š$y^T \cdot C = 0$ï¼ˆè¡Œå‘é‡ä¸çŸ©é˜µç›¸ä¹˜ï¼‰
- **T-ä¸å˜é‡**ï¼š$C \cdot x = 0$ï¼ˆçŸ©é˜µä¸åˆ—å‘é‡ç›¸ä¹˜ï¼‰

### ç®—æ³•å¤æ‚åº¦æ¯”è¾ƒ

| æ–¹æ³• | S-ä¸å˜é‡ | T-ä¸å˜é‡ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|---------|---------|------|------|
| **é«˜æ–¯æ¶ˆå…ƒæ³•** | $O(|P|^3)$ | $O(|T|^3)$ | ç²¾ç¡®ï¼Œæ•´æ•°è§£ | éœ€è¦æ•´æ•°è¿ç®— |
| **é›¶ç©ºé—´æ–¹æ³•** | $O(|P|^3)$ | $O(|T|^3)$ | æ•°å€¼ç¨³å®š | éœ€è¦è½¬æ¢ä¸ºæ•´æ•° |
| **Smithæ ‡å‡†å½¢** | $O(|P|^3)$ | $O(|T|^3)$ | ç›´æ¥å¾—åˆ°æ•´æ•°åŸº | å®ç°å¤æ‚ |
| **æ•´æ•°çº¿æ€§è§„åˆ’** | æŒ‡æ•°æ—¶é—´ | æŒ‡æ•°æ—¶é—´ | æ”¯æŒçº¦æŸ | æœ€åæƒ…å†µæ…¢ |

---

## ğŸ“ **åº”ç”¨ç¤ºä¾‹ / Application Examples**

### ç¤ºä¾‹1ï¼šç”Ÿäº§è€…-æ¶ˆè´¹è€…ç³»ç»Ÿçš„S-ä¸å˜é‡

**Petriç½‘æ¨¡å‹**ï¼š

```mermaid
graph LR
    P((ç”Ÿäº§è€…)) -->|1| T1[ç”Ÿäº§]
    T1 -->|1| B((ç¼“å†²åŒº))
    B -->|1| T2[æ¶ˆè´¹]
    T2 -->|1| C((æ¶ˆè´¹è€…))
    T2 -->|1| P
```

**å…³è”çŸ©é˜µ**ï¼š

$$C = \begin{pmatrix}
-1 & 0 \\
1 & -1 \\
0 & 1
\end{pmatrix}$$

å…¶ä¸­è¡Œå¯¹åº”åº“æ‰€ï¼ˆç”Ÿäº§è€…ã€ç¼“å†²åŒºã€æ¶ˆè´¹è€…ï¼‰ï¼Œåˆ—å¯¹åº”å˜è¿ï¼ˆç”Ÿäº§ã€æ¶ˆè´¹ï¼‰ã€‚

**è®¡ç®—S-ä¸å˜é‡**ï¼š

æ±‚è§£ $C^T \cdot y = 0$ï¼š

$$\begin{pmatrix}
-1 & 1 & 0 \\
0 & -1 & 1
\end{pmatrix} \begin{pmatrix}
y_1 \\ y_2 \\ y_3
\end{pmatrix} = \begin{pmatrix}
0 \\ 0
\end{pmatrix}$$

è§£å¾—ï¼š$y_1 = y_2 = y_3$ï¼Œå³ $y = (1, 1, 1)$ æ˜¯S-ä¸å˜é‡ã€‚

**éªŒè¯**ï¼š

- åˆå§‹æ ‡è¯†ï¼š$M_0 = (1, 0, 0)$ï¼ˆç”Ÿäº§è€…æœ‰1ä¸ªä»¤ç‰Œï¼‰
- $y^T \cdot M_0 = 1 \cdot 1 + 1 \cdot 0 + 1 \cdot 0 = 1$
- å¯¹äºä»»æ„å¯è¾¾æ ‡è¯† $M$ï¼Œ$y^T \cdot M = 1$ï¼ˆä»¤ç‰Œæ€»æ•°å®ˆæ’ï¼‰

**è§£é‡Š**ï¼šS-ä¸å˜é‡ $y = (1, 1, 1)$ è¡¨ç¤º"ç”Ÿäº§è€… + ç¼“å†²åŒº + æ¶ˆè´¹è€… = å¸¸æ•°"çš„å®ˆæ’æ€§è´¨ã€‚

### ç¤ºä¾‹2ï¼šå¾ªç¯ç³»ç»Ÿçš„T-ä¸å˜é‡

**Petriç½‘æ¨¡å‹**ï¼š

```mermaid
graph LR
    P1((P1<br/>â€¢)) -->|1| T1[T1]
    T1 -->|1| P2((P2))
    P2 -->|1| T2[T2]
    T2 -->|1| P1
```

**å…³è”çŸ©é˜µ**ï¼š

$$C = \begin{pmatrix}
-1 & 1 \\
1 & -1
\end{pmatrix}$$

**è®¡ç®—T-ä¸å˜é‡**ï¼š

æ±‚è§£ $C \cdot x = 0$ï¼Œ$x \geq 0$ï¼š

$$\begin{pmatrix}
-1 & 1 \\
1 & -1
\end{pmatrix} \begin{pmatrix}
x_1 \\ x_2
\end{pmatrix} = \begin{pmatrix}
0 \\ 0
\end{pmatrix}$$

è§£å¾—ï¼š$x_1 = x_2$ï¼Œå³ $x = (1, 1)$ æ˜¯T-ä¸å˜é‡ã€‚

**éªŒè¯**ï¼š

- å¦‚æœ $T1$ å’Œ $T2$ å„è§¦å‘1æ¬¡ï¼Œç³»ç»Ÿå›åˆ°åˆå§‹çŠ¶æ€
- $M_0 + C \cdot (1, 1)^T = M_0 + (0, 0)^T = M_0$ âœ“

**è§£é‡Š**ï¼šT-ä¸å˜é‡ $x = (1, 1)$ è¡¨ç¤ºä¸€ä¸ªå®Œæ•´çš„å¾ªç¯æ‰§è¡Œåºåˆ—ã€‚

### ç¤ºä¾‹3ï¼šä½¿ç”¨ä»£ç è®¡ç®—ä¸å˜å¼

```python
# åˆ›å»ºç”Ÿäº§è€…-æ¶ˆè´¹è€…Petriç½‘
places = ['Producer', 'Buffer', 'Consumer']
transitions = ['Produce', 'Consume']
flows = [
    ('Producer', 'Produce', 1),
    ('Produce', 'Buffer', 1),
    ('Buffer', 'Consume', 1),
    ('Consume', 'Consumer', 1),
    ('Consume', 'Producer', 1)
]
initial_marking = {'Producer': 1, 'Buffer': 0, 'Consumer': 0}

net = PetriNet(places, transitions, flows, initial_marking)
invariant_calculator = PetriNetInvariant(net)

# è®¡ç®—S-ä¸å˜é‡
s_invariants = invariant_calculator.compute_s_invariants(method="nullspace")
print("S-ä¸å˜é‡ï¼š")
for inv in s_invariants:
    print(f"  {inv}")
# è¾“å‡º: {'Producer': 1, 'Buffer': 1, 'Consumer': 1}

# è®¡ç®—T-ä¸å˜é‡
t_invariants = invariant_calculator.compute_t_invariants(method="nullspace")
print("\nT-ä¸å˜é‡ï¼š")
for inv in t_invariants:
    print(f"  {inv}")
    is_valid = invariant_calculator.verify_t_invariant(inv)
    print(f"  éªŒè¯: {'âœ“' if is_valid else 'âœ—'}")
```

---

## ğŸ”¬ **æµ‹è¯•ç”¨ä¾‹ / Test Cases**

### æµ‹è¯•ç”¨ä¾‹1ï¼šç®€å•å¾ªç¯ç½‘

**è¾“å…¥**ï¼š

- åº“æ‰€ï¼šP1, P2
- å˜è¿ï¼šT1, T2
- æµå…³ç³»ï¼š(P1, T1, 1), (T1, P2, 1), (P2, T2, 1), (T2, P1, 1)
- åˆå§‹æ ‡è¯†ï¼šP1=1, P2=0

**é¢„æœŸè¾“å‡º**ï¼š

- S-ä¸å˜é‡ï¼š[(1, 1)]ï¼ˆP1å’ŒP2çš„åŠ æƒå’Œå®ˆæ’ï¼‰
- T-ä¸å˜é‡ï¼š[(1, 1)]ï¼ˆT1å’ŒT2å„è§¦å‘1æ¬¡å½¢æˆå¾ªç¯ï¼‰

### æµ‹è¯•ç”¨ä¾‹2ï¼šèµ„æºç«äº‰ç½‘

**è¾“å…¥**ï¼š

- åº“æ‰€ï¼šResource, Process1, Process2
- å˜è¿ï¼šAcquire1, Release1, Acquire2, Release2
- æµå…³ç³»ï¼šç•¥ï¼ˆèµ„æºç«äº‰æ¨¡å¼ï¼‰

**é¢„æœŸè¾“å‡º**ï¼š

- S-ä¸å˜é‡ï¼šéªŒè¯èµ„æºæ€»æ•°å®ˆæ’
- T-ä¸å˜é‡ï¼šè¯†åˆ«èµ„æºè·å–-é‡Šæ”¾å¾ªç¯

---

## âš ï¸ **æ³¨æ„äº‹é¡¹ / Notes**

1. **æ•´æ•°è§£é—®é¢˜**ï¼šä¸å˜å¼è®¡ç®—éœ€è¦æ•´æ•°è§£ï¼Œè€Œæ•°å€¼æ–¹æ³•é€šå¸¸å¾—åˆ°å®æ•°è§£ï¼Œéœ€è¦è½¬æ¢ä¸ºæ•´æ•°
2. **éè´Ÿçº¦æŸ**ï¼šT-ä¸å˜é‡å¿…é¡»éè´Ÿï¼Œè¿™å¢åŠ äº†æ±‚è§£éš¾åº¦
3. **æœ€å°æ”¯æ’‘é›†**ï¼šé€šå¸¸éœ€è¦æ‰¾åˆ°æœ€å°æ”¯æ’‘çš„ä¸å˜é‡ï¼Œè€Œä¸æ˜¯æ‰€æœ‰å¯èƒ½çš„çº¿æ€§ç»„åˆ
4. **è®¡ç®—å¤æ‚åº¦**ï¼šå¯¹äºå¤§è§„æ¨¡Petriç½‘ï¼Œä¸å˜å¼è®¡ç®—å¯èƒ½å¾ˆè€—æ—¶
5. **æ•°å€¼ç¨³å®šæ€§**ï¼šä½¿ç”¨æµ®ç‚¹è¿ç®—æ—¶éœ€è¦æ³¨æ„æ•°å€¼ç¨³å®šæ€§é—®é¢˜

---

## ğŸ”— **ç›¸å…³é“¾æ¥ / Related Links**

- [Petriç½‘ç†è®ºä¸»ç›®å½•](../../README.md)
- [ç®—æ³•å®ç°ç›®å½•](../README.md)
- [ä¸å˜å¼åˆ†æ](../../03-åˆ†ææ–¹æ³•/02-ä¸å˜å¼åˆ†æ.md)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**çŠ¶æ€**: âœ… **å·²å®Œæˆ**
