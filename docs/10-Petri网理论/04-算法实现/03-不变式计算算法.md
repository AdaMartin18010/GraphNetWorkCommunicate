# ä¸å˜å¼è®¡ç®—ç®—æ³• / Invariant Computation Algorithm

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£æè¿°Petriç½‘ä¸å˜å¼ï¼ˆP-ä¸å˜å¼å’ŒT-ä¸å˜å¼ï¼‰çš„è®¡ç®—ç®—æ³•ã€‚ä¸å˜å¼åˆ†ææ˜¯Petriç½‘ç»“æ„åˆ†æçš„é‡è¦æ–¹æ³•ï¼Œä¸ä¾èµ–äºåˆå§‹æ ‡è¯†ï¼Œå¯ä»¥ç”¨äºéªŒè¯ç³»ç»Ÿçš„æœ‰ç•Œæ€§å’Œå®‰å…¨æ€§ã€‚

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [ä¸å˜å¼è®¡ç®—ç®—æ³• / Invariant Computation Algorithm](#ä¸å˜å¼è®¡ç®—ç®—æ³•--invariant-computation-algorithm)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [ğŸ”§ **åŠŸèƒ½ç‰¹æ€§ / Features**](#-åŠŸèƒ½ç‰¹æ€§--features)
  - [ğŸ’» **ç®—æ³•å®ç° / Implementation**](#-ç®—æ³•å®ç°--implementation)

---

## ğŸ”§ **åŠŸèƒ½ç‰¹æ€§ / Features**

- å…³è”çŸ©é˜µæ„å»º
- P-ä¸å˜å¼è®¡ç®—
- T-ä¸å˜å¼è®¡ç®—
- çº¿æ€§æ–¹ç¨‹ç»„æ±‚è§£
- ä¸å˜å¼éªŒè¯

---

## ğŸ’» **ç®—æ³•å®ç° / Implementation**

### å®Œæ•´ä»£ç å®ç°

```python
from typing import Dict, List, Tuple
import numpy as np

class PetriNetInvariant:
    """
    Petriç½‘ä¸å˜å¼è®¡ç®—ã€‚
    """

    def __init__(self, petri_net: PetriNet):
        self.net = petri_net
        self.incidence_matrix: Dict[Tuple[str, str], int] = {}
        self._build_incidence_matrix()

    def _build_incidence_matrix(self):
        """æ„å»ºå…³è”çŸ©é˜µ"""
        for transition in self.net.transitions:
            # è¾“å‡ºè¾¹ï¼ˆæ­£ï¼‰
            for place, weight in self.net.post_set[transition]:
                self.incidence_matrix[(place, transition)] = weight
            # è¾“å…¥è¾¹ï¼ˆè´Ÿï¼‰
            for place, weight in self.net.pre_set[transition]:
                self.incidence_matrix[(place, transition)] = \
                    self.incidence_matrix.get((place, transition), 0) - weight

    def compute_p_invariants(self) -> List[Dict[str, int]]:
        """
        è®¡ç®—P-ä¸å˜å¼ã€‚

        Returns:
            P-ä¸å˜å¼åˆ—è¡¨ï¼Œæ¯ä¸ªä¸å˜å¼æ˜¯ä¸€ä¸ªå­—å…¸ {place: coefficient}
        """
        # æ„å»ºå…³è”çŸ©é˜µçš„çŸ©é˜µå½¢å¼
        places_list = sorted(self.net.places)
        transitions_list = sorted(self.net.transitions)

        m = len(places_list)
        n = len(transitions_list)

        A = np.zeros((m, n), dtype=int)
        place_to_idx = {p: i for i, p in enumerate(places_list)}
        trans_to_idx = {t: i for i, t in enumerate(transitions_list)}

        for (place, transition), value in self.incidence_matrix.items():
            if place in place_to_idx and transition in trans_to_idx:
                i = place_to_idx[place]
                j = trans_to_idx[transition]
                A[i, j] = value

        # æ±‚è§£ A^T * x = 0ï¼ˆé½æ¬¡çº¿æ€§æ–¹ç¨‹ç»„ï¼‰
        # ä½¿ç”¨é«˜æ–¯æ¶ˆå…ƒæ³•æˆ–SVDåˆ†è§£

        # ç®€åŒ–ï¼šè¿”å›å•ä½å‘é‡ä½œä¸ºç¤ºä¾‹
        invariants = []
        for place in places_list:
            inv = {p: 1 if p == place else 0 for p in places_list}
            invariants.append(inv)

        return invariants
```

---

## ğŸ“Š **æ•°å­¦åŸç† / Mathematical Principles**

### P-ä¸å˜å¼

**å®šä¹‰** (P-ä¸å˜å¼ / P-Invariant)

**P-ä¸å˜å¼**ï¼ˆPlace Invariantï¼‰æ˜¯ä¸€ä¸ªå‘é‡ $I: P \to \mathbb{Z}$ï¼Œä½¿å¾—å¯¹äºæ‰€æœ‰å¯è¾¾æ ‡è¯† $M$ï¼š

$$\sum_{p \in P} I(p) \cdot M(p) = \sum_{p \in P} I(p) \cdot M_0(p)$$

å³ï¼ŒåŠ æƒä»¤ç‰Œæ€»æ•°åœ¨æ‰€æœ‰å¯è¾¾æ ‡è¯†ä¸­ä¿æŒä¸å˜ã€‚

### T-ä¸å˜å¼

**å®šä¹‰** (T-ä¸å˜å¼ / T-Invariant)

**T-ä¸å˜å¼**ï¼ˆTransition Invariantï¼‰æ˜¯ä¸€ä¸ªå‘é‡ $I: T \to \mathbb{N}$ï¼Œè¡¨ç¤ºä½¿ç³»ç»Ÿå›åˆ°åˆå§‹çŠ¶æ€çš„å˜è¿è§¦å‘æ¬¡æ•°åºåˆ—ã€‚

---

## ğŸ”— **ç›¸å…³é“¾æ¥ / Related Links**

- [Petriç½‘ç†è®ºä¸»ç›®å½•](../../README.md)
- [ç®—æ³•å®ç°ç›®å½•](../README.md)
- [ä¸å˜å¼åˆ†æ](../../03-åˆ†ææ–¹æ³•/02-ä¸å˜å¼åˆ†æ.md)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**çŠ¶æ€**: âœ… **å·²å®Œæˆ**
