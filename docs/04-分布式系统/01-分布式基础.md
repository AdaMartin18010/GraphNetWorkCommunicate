# 分布式系统 - 分布式基础

## 1. 分布式系统定义

### 1.1 基本概念

**定义 1.1** (分布式系统)
**分布式系统**是由多个独立计算节点组成的系统，这些节点通过网络进行通信和协作，形式化为：
$$\mathcal{DS} = \langle N, C, P, T \rangle$$

其中：

- $N = \{n_1, n_2, \ldots, n_k\}$ 是节点集
- $C$ 是通信网络
- $P$ 是协议集
- $T$ 是时间模型

**定义 1.2** (分布式节点)
**分布式节点**是具有独立计算能力的实体：
$$n_i = \langle S_i, P_i, M_i \rangle$$

其中：

- $S_i$ 是节点状态
- $P_i$ 是节点处理能力
- $M_i$ 是节点内存

### 1.2 系统特性

**定义 1.3** (分布式系统特性)
分布式系统具有以下特性：

- **并发性**：多个节点可以同时执行
- **独立性**：节点具有独立的计算能力
- **通信性**：节点通过网络进行通信
- **透明性**：用户感知不到系统的分布性

## 2. 分布式系统模型

### 2.1 同步模型

**定义 2.1** (同步分布式系统)
**同步分布式系统**中，所有节点共享全局时钟，消息传递有固定上界。

**形式化表示**：
$$\mathcal{S}_{sync} = \langle N, C, \tau, \Delta \rangle$$

其中：

- $\tau$ 是全局时钟
- $\Delta$ 是消息传递延迟上界

**性质 2.1** (同步系统性质)

- 消息传递延迟有上界：$\forall m: \text{delay}(m) \leq \Delta$
- 时钟同步：$\forall n_i, n_j: |\tau_i - \tau_j| \leq \epsilon$
- 处理时间有上界：$\forall p: \text{time}(p) \leq T$

### 2.2 异步模型

**定义 2.2** (异步分布式系统)
**异步分布式系统**中，节点没有共享时钟，消息传递延迟无上界。

**形式化表示**：
$$\mathcal{S}_{async} = \langle N, C, \mathcal{E} \rangle$$

其中 $\mathcal{E}$ 是事件集。

**性质 2.2** (异步系统性质)

- 消息传递延迟无上界：$\forall \Delta > 0, \exists m: \text{delay}(m) > \Delta$
- 无全局时钟：$\forall \tau: \text{not global}(\tau)$
- 处理时间无上界：$\forall T > 0, \exists p: \text{time}(p) > T$

### 2.3 部分同步模型

**定义 2.3** (部分同步分布式系统)
**部分同步分布式系统**介于同步和异步之间，具有部分同步特性。

**形式化表示**：
$$\mathcal{S}_{psync} = \langle N, C, \tau, \Delta, \mathcal{E} \rangle$$

**性质 2.3** (部分同步系统性质)

- 消息传递延迟有概率上界：$P(\text{delay}(m) \leq \Delta) \geq p$
- 时钟同步有概率保证：$P(|\tau_i - \tau_j| \leq \epsilon) \geq q$
- 处理时间有概率上界：$P(\text{time}(p) \leq T) \geq r$

## 3. 分布式一致性

### 3.1 一致性模型

**定义 3.1** (强一致性)
**强一致性**要求所有节点看到相同的操作顺序：
$$\forall n_i, n_j: \text{order}_i = \text{order}_j$$

**定义 3.2** (弱一致性)
**弱一致性**允许节点看到不同的操作顺序，但最终会收敛：
$$\exists t: \forall t' > t, n_i, n_j: \text{state}_i(t') = \text{state}_j(t')$$

**定义 3.3** (最终一致性)
**最终一致性**保证系统最终会达到一致状态：
$$\lim_{t \to \infty} \text{state}_i(t) = \text{state}_j(t)$$

### 3.2 CAP定理

**定理 3.1** (CAP定理)
在分布式系统中，最多只能同时满足以下三个性质中的两个：

- **一致性** (Consistency)：所有节点看到相同的数据
- **可用性** (Availability)：每个请求都能得到响应
- **分区容错性** (Partition Tolerance)：网络分区时系统仍能工作

**证明**：
假设系统满足一致性(C)和可用性(A)，当网络分区发生时：

1. 为了保证一致性，系统必须拒绝写操作
2. 这违反了可用性要求
3. 因此无法同时满足C、A、P三个性质

### 3.3 一致性协议

**定义 3.4** (两阶段提交)
**两阶段提交** (2PC) 是分布式事务协议：

**阶段1** (准备阶段)：

```text
协调者 -> 参与者：PREPARE
参与者 -> 协调者：VOTE (YES/NO)
```

**阶段2** (提交阶段)：

```text
协调者 -> 参与者：COMMIT/ABORT
参与者 -> 协调者：ACK
```

**算法 3.1** (2PC算法)

```text
输入：事务 T，参与者集 P
输出：提交或中止

阶段1：准备
1. 协调者发送 PREPARE 给所有参与者
2. 参与者执行事务，记录日志
3. 参与者返回 VOTE (YES/NO)
4. 如果所有参与者返回 YES，进入阶段2
5. 否则，中止事务

阶段2：提交
1. 协调者发送 COMMIT/ABORT 给所有参与者
2. 参与者执行提交或回滚
3. 参与者返回 ACK
4. 协调者完成事务
```

## 4. 分布式容错

### 4.1 故障模型

**定义 4.1** (故障类型)
分布式系统中的故障类型包括：

- **崩溃故障**：节点停止工作
- **拜占庭故障**：节点发送错误信息
- **遗漏故障**：节点遗漏某些消息
- **时序故障**：节点响应时间异常

**定义 4.2** (故障模型)
**故障模型**描述系统中可能发生的故障：
$$\mathcal{F} = \langle F_t, F_p, F_s \rangle$$

其中：

- $F_t$ 是故障类型集
- $F_p$ 是故障概率
- $F_s$ 是故障严重程度

### 4.2 容错机制

**定义 4.3** (冗余)
**冗余**是通过复制组件提高系统可靠性：
$$\text{Reliability} = 1 - \prod_{i=1}^n (1 - R_i)$$

其中 $R_i$ 是第 $i$ 个副本的可靠性。

**算法 4.1** (主从复制)

```text
输入：数据 D，副本数 n
输出：复制数据

1. 选择主节点：master = select_primary()
2. 复制数据：for i = 1 to n-1 do
   a. 选择从节点：slave_i = select_slave()
   b. 复制数据：slave_i.data = master.data
3. 同步更新：master.update() -> broadcast_to_slaves()
4. 故障检测：monitor_health()
5. 故障恢复：if master.failed then
   a. 选择新主节点：new_master = elect_leader()
   b. 重新同步：sync_data(new_master)
```

**算法 4.2** (拜占庭容错)

```text
输入：节点集 N，故障节点数 f
输出：一致决策

1. 初始化：每个节点提出值 v_i
2. 预准备阶段：
   a. 主节点广播预准备消息
   b. 其他节点验证并转发
3. 准备阶段：
   a. 每个节点广播准备消息
   b. 收集 2f+1 个准备消息
4. 提交阶段：
   a. 每个节点广播提交消息
   b. 收集 2f+1 个提交消息
5. 决策：根据收集的消息决定最终值
```

## 5. 分布式算法

### 5.1 领导者选举

**定义 5.1** (领导者选举)
**领导者选举**是在分布式系统中选择一个节点作为协调者。

**算法 5.1** (Bully算法)

```text
输入：节点集 N，节点ID id
输出：领导者

1. 检测故障：if coordinator.failed then
2. 发起选举：send ELECTION to higher_id_nodes()
3. 等待响应：wait for response
4. 如果收到响应：
   a. 等待新领导者：wait for COORDINATOR
5. 否则：
   a. 成为领导者：send COORDINATOR to all()
   b. 开始协调：start_coordination()
```

**算法 5.2** (Ring算法)

```text
输入：环形节点集 N
输出：领导者

1. 初始化：每个节点知道邻居
2. 发起选举：if need_election then
   a. 发送 ELECTION 给下一个节点
3. 转发选举：if received ELECTION then
   a. 添加自己的ID到消息
   b. 转发给下一个节点
4. 完成选举：if received own ELECTION then
   a. 成为领导者：send COORDINATOR
5. 传播结果：forward COORDINATOR
```

### 5.2 分布式共识

**定义 5.3** (共识问题)
**共识问题**是让分布式系统中的节点就某个值达成一致。

**算法 5.3** (Paxos算法)

```text
输入：提议值 v
输出：共识值

阶段1：准备
1. 提议者选择提议号 n
2. 发送 PREPARE(n) 给多数派
3. 接受者响应：
   a. 如果 n > max_n，则接受
   b. 返回 (n, v) 给提议者

阶段2：接受
1. 提议者发送 ACCEPT(n, v) 给多数派
2. 接受者响应：
   a. 如果 n >= max_n，则接受
   b. 返回 ACCEPTED
3. 如果多数派接受，则达成共识
```

## 6. 分布式存储

### 6.1 数据分布

**定义 6.1** (数据分片)
**数据分片**是将数据分布到多个节点：
$$\text{Shard}_i = \{d \in D : \text{hash}(d) \bmod n = i\}$$

**算法 6.1** (一致性哈希)

```text
输入：节点集 N，数据 D
输出：数据分布

1. 构造哈希环：ring = hash_ring(N)
2. 分配数据：for each d in D do
   a. 计算哈希：h = hash(d)
   b. 找到下一个节点：n = find_next_node(h, ring)
   c. 分配数据：assign(d, n)
3. 处理节点变化：
   a. 添加节点：redistribute_data()
   b. 删除节点：migrate_data()
```

### 6.2 复制策略

**定义 6.2** (复制策略)
**复制策略**决定数据副本的分布方式：

- **同步复制**：所有副本同时更新
- **异步复制**：副本延迟更新
- **半同步复制**：部分副本同步更新

**算法 6.2** (多版本并发控制)

```text
输入：事务 T，数据 D
输出：事务结果

1. 读取阶段：
   a. 获取快照：snapshot = get_snapshot()
   b. 读取数据：read from snapshot
2. 验证阶段：
   a. 检查冲突：check_conflicts(T)
   b. 如果冲突，则中止
3. 写入阶段：
   a. 创建新版本：new_version = create_version()
   b. 更新数据：update_data(new_version)
4. 提交：commit_transaction()
```

## 7. 分布式监控

### 7.1 监控指标

**定义 7.1** (分布式监控指标)
分布式系统的监控指标包括：

- **可用性**：$A = \frac{\text{正常运行时间}}{\text{总时间}}$
- **吞吐量**：$T = \frac{\text{处理请求数}}{\text{时间}}$
- **延迟**：$L = \text{平均响应时间}$
- **错误率**：$E = \frac{\text{错误请求数}}{\text{总请求数}}$

### 7.2 监控系统

**定义 7.2** (分布式监控系统)
**分布式监控系统**收集和分析系统状态：
$$\mathcal{M} = \langle S, C, A, V \rangle$$

其中：

- $S$ 是监控传感器
- $C$ 是数据收集器
- $A$ 是分析器
- $V$ 是可视化器

**算法 7.1** (心跳检测)

```text
输入：节点集 N，超时时间 t
输出：节点状态

1. 初始化：for each n in N do
   a. 设置状态：n.status = UNKNOWN
2. 发送心跳：for each n in N do
   a. 发送 PING 给 n
   b. 设置超时：set_timeout(n, t)
3. 接收响应：if received PONG from n then
   a. 更新状态：n.status = ALIVE
4. 超时处理：if timeout(n) then
   a. 更新状态：n.status = DEAD
5. 报告状态：report_node_status()
```

---

*本文档提供了分布式系统的基础理论和算法，为分布式网络通信系统的设计提供了理论基础。*
