# å½¢å¼åŒ–è¯æ˜æœ€ä½³å®è·µä¸å·¥å…·æŒ‡å— / Formal Proof Best Practices and Tools Guide

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£æä¾›å½¢å¼åŒ–è¯æ˜åœ¨å®é™…åº”ç”¨ä¸­çš„æœ€ä½³å®è·µã€å·¥å…·é€‰æ‹©æŒ‡å—ã€å¸¸è§é—®é¢˜è§£å†³æ–¹æ¡ˆå’Œè¯¦ç»†æ¡ˆä¾‹ï¼Œå¸®åŠ©è¯»è€…æ­£ç¡®ã€é«˜æ•ˆåœ°ä½¿ç”¨å½¢å¼åŒ–è¯æ˜æ–¹æ³•è§£å†³å®é™…é—®é¢˜ã€‚

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [å½¢å¼åŒ–è¯æ˜æœ€ä½³å®è·µä¸å·¥å…·æŒ‡å—](#å½¢å¼åŒ–è¯æ˜æœ€ä½³å®è·µä¸å·¥å…·æŒ‡å—--formal-proof-best-practices-and-tools-guide)
  - [1. å½¢å¼åŒ–è¯æ˜æ–¹æ³•é€‰æ‹©æŒ‡å— / Method Selection Guide](#1-å½¢å¼åŒ–è¯æ˜æ–¹æ³•é€‰æ‹©æŒ‡å—--method-selection-guide)
  - [2. å·¥å…·é€‰æ‹©ä¸ä½¿ç”¨æŒ‡å— / Tool Selection and Usage Guide](#2-å·¥å…·é€‰æ‹©ä¸ä½¿ç”¨æŒ‡å—--tool-selection-and-usage-guide)
  - [3. è§„èŒƒç¼–å†™æœ€ä½³å®è·µ / Specification Writing Best Practices](#3-è§„èŒƒç¼–å†™æœ€ä½³å®è·µ--specification-writing-best-practices)
  - [4. éªŒè¯å·¥ä½œæµç¨‹ / Verification Workflow](#4-éªŒè¯å·¥ä½œæµç¨‹--verification-workflow)
  - [5. å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ / Common Problems and Solutions](#5-å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ--common-problems-and-solutions)
  - [6. å®é™…å·¥ç¨‹æ¡ˆä¾‹è¯¦è§£ / Detailed Engineering Cases](#6-å®é™…å·¥ç¨‹æ¡ˆä¾‹è¯¦è§£--detailed-engineering-cases)

---

## 1. å½¢å¼åŒ–è¯æ˜æ–¹æ³•é€‰æ‹©æŒ‡å— / Method Selection Guide

### 1.1 æ–¹æ³•å¯¹æ¯”çŸ©é˜µ

| éªŒè¯æ–¹æ³• | é€‚ç”¨åœºæ™¯ | ä¼˜ç‚¹ | ç¼ºç‚¹ | å·¥å…·ç¤ºä¾‹ |
|---------|---------|------|------|---------|
| **æ¼”ç»éªŒè¯** | åŠŸèƒ½æ­£ç¡®æ€§ã€å¤æ‚æ€§è´¨ | ç†è®ºä¸Šå®Œå¤‡ã€å¯ä»¥å¤„ç†ä»»æ„æ€§è´¨ | éœ€è¦å¾ªç¯ä¸å˜é‡ã€éªŒè¯æ¡ä»¶å¯èƒ½éš¾è¯æ˜ | Coqã€Isabelleã€Dafny |
| **æ¨¡å‹æ£€æµ‹** | æ—¶åºæ€§è´¨ã€å¹¶å‘æ€§è´¨ | è‡ªåŠ¨åŒ–ã€è‡ªåŠ¨ç”Ÿæˆåä¾‹ | çŠ¶æ€ç©ºé—´çˆ†ç‚¸ã€éœ€è¦æœ‰ç•Œæ¨¡å‹ | SPINã€NuSMVã€TLA+ |
| **æŠ½è±¡è§£é‡Š** | è¿è¡Œæ—¶é”™è¯¯ã€é™æ€åˆ†æ | å¯ä»¥å¤„ç†æ— é™çŠ¶æ€ã€æ•ˆç‡é«˜ | å¯èƒ½è¯¯æŠ¥ã€ç²¾åº¦æœ‰é™ | AstrÃ©eã€Infer |
| **ç¬¦å·æ‰§è¡Œ** | Bugå‘ç°ã€æµ‹è¯•ç”Ÿæˆ | è·¯å¾„è¦†ç›–å…¨é¢ã€è‡ªåŠ¨ç”Ÿæˆæµ‹è¯• | è·¯å¾„çˆ†ç‚¸ã€çº¦æŸæ±‚è§£å›°éš¾ | KLEEã€SAGE |
| **ç±»å‹æ£€æŸ¥** | ç±»å‹å®‰å…¨ã€è½»é‡çº§éªŒè¯ | è‡ªåŠ¨åŒ–ã€é›†æˆåœ¨ç¼–è¯‘å™¨ä¸­ | è¡¨è¾¾èƒ½åŠ›æœ‰é™ | Rustã€Haskellç±»å‹ç³»ç»Ÿ |

### 1.2 æ–¹æ³•é€‰æ‹©å†³ç­–æ ‘

```
éœ€è¦éªŒè¯ä»€ä¹ˆæ€§è´¨ï¼Ÿ
â”œâ”€â”€ åŠŸèƒ½æ­£ç¡®æ€§ï¼ˆè¾“å…¥è¾“å‡ºå…³ç³»ï¼‰
â”‚   â”œâ”€â”€ å¤æ‚å¾ªç¯å’Œé€’å½’ â†’ æ¼”ç»éªŒè¯ï¼ˆHoareé€»è¾‘ï¼‰
â”‚   â”œâ”€â”€ ç®€å•ç¨‹åº â†’ ç±»å‹ç³»ç»Ÿæˆ–æŠ½è±¡è§£é‡Š
â”‚   â””â”€â”€ éœ€è¦è‡ªåŠ¨åŒ– â†’ ç¬¦å·æ‰§è¡Œ
â”‚
â”œâ”€â”€ æ—¶åºæ€§è´¨ï¼ˆæ—¶é—´ç›¸å…³ï¼‰
â”‚   â”œâ”€â”€ æœ‰é™çŠ¶æ€ç³»ç»Ÿ â†’ æ¨¡å‹æ£€æµ‹
â”‚   â”œâ”€â”€ å®æ—¶ç³»ç»Ÿ â†’ æ—¶é—´æ¨¡å‹æ£€æµ‹ï¼ˆUPPAALï¼‰
â”‚   â””â”€â”€ åˆ†å¸ƒå¼ç³»ç»Ÿ â†’ TLA+æ¨¡å‹æ£€æµ‹
â”‚
â”œâ”€â”€ å¹¶å‘æ€§è´¨ï¼ˆå¤šçº¿ç¨‹ï¼‰
â”‚   â”œâ”€â”€ æ•°æ®ç«äº‰ â†’ æ¨¡å‹æ£€æµ‹æˆ–åˆ†ç¦»é€»è¾‘
â”‚   â”œâ”€â”€ æ­»é”æ£€æµ‹ â†’ æ¨¡å‹æ£€æµ‹
â”‚   â””â”€â”€ å¹¶å‘æ­£ç¡®æ€§ â†’ å¹¶å‘åˆ†ç¦»é€»è¾‘
â”‚
â””â”€â”€ è¿è¡Œæ—¶é”™è¯¯ï¼ˆç©ºæŒ‡é’ˆã€æ•°ç»„è¶Šç•Œç­‰ï¼‰
    â”œâ”€â”€ é™æ€åˆ†æ â†’ æŠ½è±¡è§£é‡Š
    â”œâ”€â”€ åŠ¨æ€æ£€æŸ¥ â†’ ç¬¦å·æ‰§è¡Œ
    â””â”€â”€ ç±»å‹å®‰å…¨ â†’ ç±»å‹ç³»ç»Ÿ
```

### 1.3 æ–¹æ³•ç»„åˆç­–ç•¥

**ç»„åˆç­–ç•¥**ï¼š

1. **å¤šå±‚æ¬¡éªŒè¯**ï¼š
   - ç±»å‹ç³»ç»Ÿï¼ˆç¬¬ä¸€å±‚ï¼‰ï¼šå¿«é€Ÿæ£€æŸ¥
   - æŠ½è±¡è§£é‡Šï¼ˆç¬¬äºŒå±‚ï¼‰ï¼šé™æ€åˆ†æ
   - æ¼”ç»éªŒè¯ï¼ˆç¬¬ä¸‰å±‚ï¼‰ï¼šæ·±åº¦éªŒè¯

2. **äº’è¡¥éªŒè¯**ï¼š
   - æ¨¡å‹æ£€æµ‹éªŒè¯æ—¶åºæ€§è´¨
   - æ¼”ç»éªŒè¯éªŒè¯åŠŸèƒ½æ€§è´¨
   - ç¬¦å·æ‰§è¡Œå‘ç°å…·ä½“bug

**ç¤ºä¾‹**ï¼š

```python
class MultiLevelVerifier:
    """å¤šå±‚æ¬¡éªŒè¯æ¡†æ¶"""

    def verify(self, program: str, spec: Dict) -> Dict:
        results = {}

        # ç¬¬ä¸€å±‚ï¼šç±»å‹æ£€æŸ¥
        type_errors = self.type_check(program)
        results['type_check'] = len(type_errors) == 0

        if type_errors:
            return {'success': False, 'type_errors': type_errors}

        # ç¬¬äºŒå±‚ï¼šæŠ½è±¡è§£é‡Šï¼ˆè¿è¡Œæ—¶é”™è¯¯æ£€æŸ¥ï¼‰
        ai_results = self.abstract_interpretation(program)
        results['runtime_errors'] = ai_results

        # ç¬¬ä¸‰å±‚ï¼šæ¼”ç»éªŒè¯ï¼ˆåŠŸèƒ½æ­£ç¡®æ€§ï¼‰
        if spec.get('functional'):
            deductive_result = self.deductive_verification(program, spec)
            results['functional_correctness'] = deductive_result

        # ç¬¬å››å±‚ï¼šæ¨¡å‹æ£€æµ‹ï¼ˆæ—¶åºæ€§è´¨ï¼‰
        if spec.get('temporal'):
            model_checking_result = self.model_checking(program, spec)
            results['temporal_properties'] = model_checking_result

        return {
            'success': all(results.values()),
            'details': results
        }
```

---

## 2. å·¥å…·é€‰æ‹©ä¸ä½¿ç”¨æŒ‡å— / Tool Selection and Usage Guide

### 2.1 å·¥å…·å¯¹æ¯”è¡¨

| å·¥å…· | ç±»å‹ | è¯­è¨€ | é€‚ç”¨æ–¹æ³• | å­¦ä¹ éš¾åº¦ | è‡ªåŠ¨åŒ–ç¨‹åº¦ | å·¥ä¸šåº”ç”¨ |
|------|------|------|---------|---------|-----------|---------|
| **Coq** | äº¤äº’å¼è¯æ˜ | Gallina | æ¼”ç»éªŒè¯ | â­â­â­â­â­ å¾ˆé«˜ | â­â­â­ ä¸­ç­‰ | âœ… æ˜¯ |
| **Isabelle/HOL** | äº¤äº’å¼è¯æ˜ | Isabelle/Isar | æ¼”ç»éªŒè¯ | â­â­â­â­ é«˜ | â­â­â­â­ è¾ƒé«˜ | âœ… æ˜¯ |
| **Dafny** | éªŒè¯è¯­è¨€ | Dafny | æ¼”ç»éªŒè¯ | â­â­â­ ä¸­ç­‰ | â­â­â­â­â­ å¾ˆé«˜ | âœ… æ˜¯ |
| **SPIN** | æ¨¡å‹æ£€æµ‹ | Promela | æ¨¡å‹æ£€æµ‹ | â­â­â­ ä¸­ç­‰ | â­â­â­â­â­ å¾ˆé«˜ | âœ… æ˜¯ |
| **TLA+** | è§„èŒƒ+æ£€æµ‹ | TLA+ | æ¨¡å‹æ£€æµ‹ | â­â­â­ ä¸­ç­‰ | â­â­â­â­ è¾ƒé«˜ | âœ… æ˜¯ |
| **NuSMV** | ç¬¦å·æ£€æµ‹ | SMV | ç¬¦å·æ¨¡å‹æ£€æµ‹ | â­â­ è¾ƒä½ | â­â­â­â­ è¾ƒé«˜ | âš ï¸ è¾ƒå°‘ |
| **Z3** | SMTæ±‚è§£å™¨ | SMT-LIB | éªŒè¯æ¡ä»¶è¯æ˜ | â­â­ è¾ƒä½ | â­â­â­â­â­ å¾ˆé«˜ | âœ… æ˜¯ |
| **KLEE** | ç¬¦å·æ‰§è¡Œ | LLVM IR | ç¬¦å·æ‰§è¡Œ | â­â­â­ ä¸­ç­‰ | â­â­â­â­ è¾ƒé«˜ | âš ï¸ è¾ƒå°‘ |

### 2.2 å·¥å…·é€‰æ‹©æŒ‡å—

#### 2.2.1 æ ¹æ®é¡¹ç›®ç±»å‹é€‰æ‹©

**å®‰å…¨å…³é”®ç³»ç»Ÿ**ï¼ˆå¦‚èˆªç©ºèˆªå¤©ã€åŒ»ç–—è®¾å¤‡ï¼‰ï¼š

- æ¨èï¼šCoqã€Isabelle/HOL
- åŸå› ï¼šå½¢å¼åŒ–è¯æ˜æœ€ä¸¥æ ¼ï¼Œå¯ä»¥è¯æ˜æœºå™¨ä»£ç çº§åˆ«

**å•†ä¸šè½¯ä»¶**ï¼ˆå¦‚Webåº”ç”¨ã€ç§»åŠ¨åº”ç”¨ï¼‰ï¼š

- æ¨èï¼šDafnyã€TLA+ã€ç±»å‹ç³»ç»Ÿ
- åŸå› ï¼šå¹³è¡¡ä¸¥æ ¼æ€§å’Œå®ç”¨æ€§

**åè®®å’Œç®—æ³•**ï¼ˆå¦‚åˆ†å¸ƒå¼åè®®ï¼‰ï¼š

- æ¨èï¼šTLA+ã€æ¨¡å‹æ£€æµ‹å·¥å…·
- åŸå› ï¼šé€‚åˆæ—¶åºæ€§è´¨å’Œå¹¶å‘æ€§è´¨

**ç¡¬ä»¶è®¾è®¡**ï¼š

- æ¨èï¼šæ¨¡å‹æ£€æµ‹ã€ç¬¦å·æ‰§è¡Œ
- åŸå› ï¼šé€‚åˆæœ‰é™çŠ¶æ€ç³»ç»Ÿ

#### 2.2.2 æ ¹æ®å›¢é˜Ÿèƒ½åŠ›é€‰æ‹©

**åˆå­¦è€…å›¢é˜Ÿ**ï¼š

- æ¨èï¼šDafnyã€TLA+ã€Z3
- åŸå› ï¼šå­¦ä¹ æ›²çº¿å¹³ç¼“ï¼Œæ–‡æ¡£å®Œå–„ï¼Œç¤¾åŒºæ”¯æŒå¥½

**ä¸­çº§å›¢é˜Ÿ**ï¼š

- æ¨èï¼šCoqã€Isabelleã€SPIN
- åŸå› ï¼šåŠŸèƒ½å¼ºå¤§ï¼Œéœ€è¦ä¸€å®šç†è®ºåŸºç¡€

**é«˜çº§å›¢é˜Ÿ**ï¼š

- æ¨èï¼šCoqã€Isabelleã€è‡ªå®šä¹‰å·¥å…·
- åŸå› ï¼šå¯ä»¥æ·±åº¦å®šåˆ¶ï¼Œæ”¯æŒå¤æ‚éªŒè¯

#### 2.2.3 å·¥å…·è¯¦ç»†ä½¿ç”¨æŒ‡å—

##### Coqä½¿ç”¨æŒ‡å—

**å®‰è£…**ï¼š

```bash
# ä½¿ç”¨opamå®‰è£…
opam install coq

# æˆ–ä½¿ç”¨Docker
docker pull coqorg/coq
```

**åŸºæœ¬ä½¿ç”¨**ï¼š

```coq
(* å®šä¹‰è‡ªç„¶æ•° *)
Inductive nat : Type :=
  | O : nat
  | S : nat -> nat.

(* å®šä¹‰åŠ æ³• *)
Fixpoint plus (n m : nat) : nat :=
  match n with
  | O => m
  | S n' => S (plus n' m)
  end.

(* è¯æ˜åŠ æ³•äº¤æ¢å¾‹ *)
Theorem plus_comm : forall n m : nat, plus n m = plus m n.
Proof.
  intros n m.
  induction n.
  - simpl. reflexivity.
  - simpl. rewrite IHn. reflexivity.
Qed.
```

**éªŒè¯æµç¨‹**ï¼š

1. å®šä¹‰æ•°æ®ç±»å‹å’Œå‡½æ•°
2. é™ˆè¿°è¦è¯æ˜çš„å®šç†
3. ä½¿ç”¨è¯æ˜ç­–ç•¥ï¼ˆtacticsï¼‰æ„é€ è¯æ˜
4. ä½¿ç”¨Qedå®Œæˆè¯æ˜

##### Dafnyä½¿ç”¨æŒ‡å—

**å®‰è£…**ï¼š

```bash
# ä¸‹è½½Dafny
# https://github.com/dafny-lang/dafny/releases
```

**åŸºæœ¬ä½¿ç”¨**ï¼š

```dafny
method Max(a: int, b: int) returns (result: int)
  ensures result >= a && result >= b
  ensures result == a || result == b
{
  if a > b {
    return a;
  } else {
    return b;
  }
}

method BinarySearch(a: array<int>, key: int) returns (index: int)
  requires a.Length > 0
  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]
  ensures 0 <= index < a.Length ==> a[index] == key
  ensures index < 0 ==> forall i :: 0 <= i < a.Length ==> a[i] != key
{
  var low := 0;
  var high := a.Length;

  while low < high
    invariant 0 <= low <= high <= a.Length
    invariant forall i :: 0 <= i < low ==> a[i] < key
    invariant forall i :: high <= i < a.Length ==> a[i] > key
  {
    var mid := (low + high) / 2;
    if a[mid] < key {
      low := mid + 1;
    } else if a[mid] > key {
      high := mid;
    } else {
      return mid;
    }
  }

  return -1;
}
```

**éªŒè¯æµç¨‹**ï¼š

1. ç¼–å†™æ–¹æ³•ç­¾åå’Œè§„èŒƒï¼ˆrequires/ensuresï¼‰
2. å®ç°æ–¹æ³•ä½“
3. ä½¿ç”¨DafnyéªŒè¯å™¨è‡ªåŠ¨éªŒè¯
4. ä¿®å¤éªŒè¯é”™è¯¯

##### TLA+ä½¿ç”¨æŒ‡å—

**å®‰è£…**ï¼š

```bash
# å®‰è£…TLA+ Toolbox
# https://github.com/tlaplus/tlaplus/releases
```

**åŸºæœ¬ä½¿ç”¨**ï¼š

```tla
EXTENDS Naturals, Sequences

VARIABLES x, y

Init == x = 0 /\ y = 0

Next == \/ x' = x + 1 /\ y' = y
        \/ y' = y + 1 /\ x' = x

Spec == Init /\ [][Next]_<<x, y>>

TypeOK == x \in Nat /\ y \in Nat

THEOREM Spec => []TypeOK
```

**éªŒè¯æµç¨‹**ï¼š

1. å®šä¹‰å˜é‡å’Œåˆå§‹çŠ¶æ€
2. å®šä¹‰çŠ¶æ€è½¬æ¢ï¼ˆNextï¼‰
3. å®šä¹‰ç³»ç»Ÿè§„èŒƒï¼ˆSpecï¼‰
4. ä½¿ç”¨TLCæ¨¡å‹æ£€æµ‹å™¨éªŒè¯æ€§è´¨

##### SPINä½¿ç”¨æŒ‡å—

**å®‰è£…**ï¼š

```bash
# ä¸‹è½½SPIN
# http://spinroot.com/spin/Man/README.html
```

**åŸºæœ¬ä½¿ç”¨**ï¼ˆPromelaè¯­è¨€ï¼‰ï¼š

```promela
mtype = { request, release };

chan sem = [0] of { mtype };

active proctype Producer()
{
  do
    :: sem!request;
       printf("Producer: request\n");
       sem?release;
       printf("Producer: release\n")
  od
}

active proctype Consumer()
{
  do
    :: sem?request;
       printf("Consumer: request\n");
       sem!release;
       printf("Consumer: release\n")
  od
}

ltl safety { [] (sem[0] == 0 || sem[0] == 1) }
ltl liveness { []<> (sem[0] == 0) }
```

**éªŒè¯æµç¨‹**ï¼š

1. ä½¿ç”¨Promelaç¼–å†™æ¨¡å‹
2. å®šä¹‰LTLæ€§è´¨
3. ä½¿ç”¨SPINç”ŸæˆéªŒè¯å™¨
4. è¿è¡ŒéªŒè¯å™¨æ£€æŸ¥æ€§è´¨

##### Z3ä½¿ç”¨æŒ‡å—

**å®‰è£…**ï¼š

```python
# Pythonå®‰è£…
pip install z3-solver
```

**åŸºæœ¬ä½¿ç”¨**ï¼š

```python
from z3 import *

# åˆ›å»ºæ±‚è§£å™¨
solver = Solver()

# å®šä¹‰å˜é‡
x = Int('x')
y = Int('y')

# æ·»åŠ çº¦æŸ
solver.add(x + y == 10)
solver.add(x > 0)
solver.add(y > 0)

# æ£€æŸ¥å¯æ»¡è¶³æ€§
if solver.check() == sat:
    model = solver.model()
    print(f"x = {model[x]}")
    print(f"y = {model[y]}")
else:
    print("Unsatisfiable")
```

**éªŒè¯æµç¨‹**ï¼š

1. åˆ›å»ºæ±‚è§£å™¨
2. å®šä¹‰å˜é‡å’Œçº¦æŸ
3. æ£€æŸ¥å¯æ»¡è¶³æ€§
4. è·å–æ¨¡å‹ï¼ˆå¦‚æœå¯æ»¡è¶³ï¼‰

##### Isabelle/HOLä½¿ç”¨æŒ‡å—

**å®‰è£…**ï¼š

```bash
# ä¸‹è½½Isabelle
# https://isabelle.in.tum.de/
```

**åŸºæœ¬ä½¿ç”¨**ï¼š

```isabelle
theory Example
imports Main
begin

(* å®šä¹‰å‡½æ•° *)
fun factorial :: "nat => nat" where
  "factorial 0 = 1" |
  "factorial (Suc n) = (Suc n) * factorial n"

(* è¯æ˜å®šç† *)
theorem factorial_positive: "factorial n > 0"
proof (induct n)
  case 0
  show ?case by simp
next
  case (Suc n)
  assume "factorial n > 0"
  then show ?case by simp
qed

end
```

**éªŒè¯æµç¨‹**ï¼š

1. å®šä¹‰ç†è®ºå’Œå‡½æ•°
2. é™ˆè¿°å®šç†
3. ä½¿ç”¨Isarè¯æ˜è¯­è¨€æ„é€ è¯æ˜
4. ä½¿ç”¨qedå®Œæˆè¯æ˜

**åˆå­¦è€…å›¢é˜Ÿ**ï¼š

1. **Dafny** â†’ æœ€ç®€å•ï¼Œè‡ªåŠ¨åŒ–ç¨‹åº¦é«˜
2. **TLA+** â†’ è§„èŒƒè¯­è¨€ç®€æ´
3. **ç±»å‹ç³»ç»Ÿ**ï¼ˆRustã€Haskellï¼‰â†’ é›†æˆåœ¨è¯­è¨€ä¸­

**æœ‰ç»éªŒçš„å›¢é˜Ÿ**ï¼š

1. **Coq/Isabelle** â†’ æœ€å¼ºå¤§çš„è¯æ˜èƒ½åŠ›
2. **SPIN** â†’ é€‚åˆå¹¶å‘ç³»ç»Ÿ
3. **ç¬¦å·æ‰§è¡Œå·¥å…·** â†’ é€‚åˆbugå‘ç°

### 2.3 å·¥å…·è¯¦ç»†ä½¿ç”¨æŒ‡å—

#### 2.3.1 Coqä½¿ç”¨æŒ‡å—

**å®‰è£…**ï¼š

```bash
# ä½¿ç”¨OPAMå®‰è£…Coq
opam install coq

# æˆ–ä»æºç ç¼–è¯‘
git clone https://github.com/coq/coq.git
cd coq
./configure
make
sudo make install
```

**åŸºæœ¬ä½¿ç”¨**ï¼š

```coq
(* å®šä¹‰è‡ªç„¶æ•° *)
Inductive nat : Type :=
  | O : nat
  | S : nat -> nat.

(* å®šä¹‰åŠ æ³• *)
Fixpoint plus (n m : nat) : nat :=
  match n with
  | O => m
  | S n' => S (plus n' m)
  end.

(* è¯æ˜åŠ æ³•äº¤æ¢å¾‹ *)
Theorem plus_comm : forall n m : nat, plus n m = plus m n.
Proof.
  intros n m.
  induction n as [|n IH].
  - (* n = 0 *)
    simpl. induction m; auto.
  - (* n = S n' *)
    simpl. rewrite IH. induction m; auto.
Qed.
```

#### 2.3.2 Dafnyä½¿ç”¨æŒ‡å—

**å®‰è£…**ï¼š

```bash
# ä¸‹è½½Dafny
# https://github.com/dafny-lang/dafny/releases

# æˆ–ä½¿ç”¨VS Codeæ‰©å±•
# æœç´¢"Dafny"æ‰©å±•å¹¶å®‰è£…
```

**åŸºæœ¬ä½¿ç”¨**ï¼š

```dafny
method FindMax(a: array<int>) returns (m: int)
  requires a.Length > 0
  ensures forall i :: 0 <= i < a.Length ==> a[i] <= m
  ensures exists i :: 0 <= i < a.Length && a[i] == m
{
  m := a[0];
  var i := 1;
  while i < a.Length
    invariant 1 <= i <= a.Length
    invariant forall j :: 0 <= j < i ==> a[j] <= m
    invariant exists j :: 0 <= j < i && a[j] == m
  {
    if a[i] > m {
      m := a[i];
    }
    i := i + 1;
  }
}
```

**éªŒè¯å‘½ä»¤**ï¼š

```bash
dafny FindMax.dfy
```

#### 2.3.3 TLA+ä½¿ç”¨æŒ‡å—

**å®‰è£…**ï¼š

1. ä¸‹è½½TLA+ Toolboxï¼š<https://lamport.azurewebsites.net/tla/toolbox.html>
2. æˆ–ä½¿ç”¨VS Codeæ‰©å±•ï¼šTLA+

**åŸºæœ¬ä½¿ç”¨**ï¼š

```tla
---------------- MODULE Example ----------------

EXTENDS Naturals

VARIABLES x, y

Init == x = 0 /\ y = 0

Next == \/ (x < 10) /\ x' = x + 1 /\ y' = y
        \/ (x = 10) /\ x' = x /\ y' = y + 1

Spec == Init /\ [][Next]_<<x, y>>

Invariant == x + y <= 20

===============================================
```

**éªŒè¯**ï¼šä½¿ç”¨TLCæ¨¡å‹æ£€æµ‹å™¨éªŒè¯ `Spec` æ»¡è¶³ `Invariant`ã€‚

#### 2.3.4 SPINä½¿ç”¨æŒ‡å—

**å®‰è£…**ï¼š

```bash
# ä¸‹è½½SPIN
wget https://spinroot.com/spin/Src/spin650.tar.gz
tar -xzf spin650.tar.gz
cd Spin/Src
make
sudo cp spin /usr/local/bin/
```

**Promelaæ¨¡å‹ç¤ºä¾‹**ï¼š

```promela
mtype = { idle, working, done };

byte state = idle;

active proctype Worker() {
    do
    :: state == idle ->
        state = working;
        printf("Working...\n");
        state = done
    :: state == done ->
        break
    od
}
```

**éªŒè¯å‘½ä»¤**ï¼š

```bash
spin -a model.pml
gcc -o pan pan.c
./pan -a  # æ£€æŸ¥æ­»é”
```

---

## 3. è§„èŒƒç¼–å†™æœ€ä½³å®è·µ / Specification Writing Best Practices

### 3.1 è§„èŒƒç¼–å†™åŸåˆ™

#### åŸåˆ™1ï¼šæ¸…æ™°æ€§ï¼ˆClarityï¼‰

**æŒ‡å¯¼åŸåˆ™**ï¼š

- âœ… ä½¿ç”¨æ¸…æ™°çš„æ•°å­¦ç¬¦å·å’Œé€»è¾‘è¡¨è¾¾å¼
- âœ… é¿å…æ­§ä¹‰ï¼Œæ¯ä¸ªæ¦‚å¿µéƒ½è¦æ˜ç¡®å®šä¹‰
- âœ… ä½¿ç”¨è‡ªç„¶è¯­è¨€æ³¨é‡Šè¯´æ˜è§„èŒƒçš„æ„å›¾

**ç¤ºä¾‹**ï¼š

```dafny
// âŒ ä¸å¥½çš„è§„èŒƒ
method Process(x: int) returns (y: int)
  ensures y > 0

// âœ… å¥½çš„è§„èŒƒ
method Process(x: int) returns (y: int)
  requires x >= 0  // å‰ç½®æ¡ä»¶ï¼šè¾“å…¥å¿…é¡»éè´Ÿ
  ensures y > 0    // åç½®æ¡ä»¶ï¼šè¾“å‡ºå¿…é¡»ä¸ºæ­£
  ensures y == x * 2  // åç½®æ¡ä»¶ï¼šè¾“å‡ºæ˜¯è¾“å…¥çš„ä¸¤å€
```

#### åŸåˆ™2ï¼šå®Œæ•´æ€§ï¼ˆCompletenessï¼‰

**æŒ‡å¯¼åŸåˆ™**ï¼š

- âœ… è¦†ç›–æ‰€æœ‰é‡è¦çš„ç¨‹åºè¡Œä¸º
- âœ… åŒ…å«é”™è¯¯æƒ…å†µå’Œè¾¹ç•Œæ¡ä»¶
- âœ… æ˜ç¡®å‰ç½®æ¡ä»¶å’Œåç½®æ¡ä»¶

**æ£€æŸ¥æ¸…å•**ï¼š

- [ ] å‰ç½®æ¡ä»¶æ˜¯å¦å®Œæ•´ï¼Ÿ
- [ ] åç½®æ¡ä»¶æ˜¯å¦è¦†ç›–æ‰€æœ‰æƒ…å†µï¼Ÿ
- [ ] æ˜¯å¦è€ƒè™‘äº†é”™è¯¯æƒ…å†µï¼Ÿ
- [ ] æ˜¯å¦è€ƒè™‘äº†è¾¹ç•Œæ¡ä»¶ï¼Ÿ

#### åŸåˆ™3ï¼šå¯éªŒè¯æ€§ï¼ˆVerifiabilityï¼‰

**æŒ‡å¯¼åŸåˆ™**ï¼š

- âœ… è§„èŒƒåº”è¯¥æ˜¯å¯è‡ªåŠ¨éªŒè¯çš„
- âœ… é¿å…è¿‡äºå¤æ‚çš„é€»è¾‘è¡¨è¾¾å¼
- âœ… ä½¿ç”¨å·¥å…·æ”¯æŒçš„è¯­è¨€ç‰¹æ€§

### 3.2 å¾ªç¯ä¸å˜é‡ç¼–å†™æŒ‡å—

#### æŒ‡å—1ï¼šä¸å˜é‡åº”è¯¥è¶³å¤Ÿå¼º

**ä¸å˜é‡åº”è¯¥åŒ…å«**ï¼š

- å¾ªç¯å˜é‡çš„èŒƒå›´
- ç´¯ç§¯å€¼çš„æ­£ç¡®æ€§
- æ•°æ®ç»“æ„çš„å®Œæ•´æ€§

**ç¤ºä¾‹**ï¼š

```dafny
// æ•°ç»„æ±‚å’Œå¾ªç¯
method Sum(a: array<int>, n: int) returns (s: int)
  requires n >= 0 && n <= a.Length
  ensures s == sum of a[0..n-1]
{
  s := 0;
  var i := 0;
  while i < n
    invariant 0 <= i <= n
    invariant s == sum of a[0..i-1]  // å…³é”®ï¼šç´¯ç§¯å€¼çš„æ­£ç¡®æ€§
  {
    s := s + a[i];
    i := i + 1;
  }
}
```

#### æŒ‡å—2ï¼šä¸å˜é‡åº”è¯¥è¶³å¤Ÿå¼±

**ä¸å˜é‡ä¸åº”è¯¥è¿‡äºä¸¥æ ¼**ï¼Œå¦åˆ™å¯èƒ½æ— æ³•è¯æ˜åˆå§‹æ¡ä»¶æˆ–ä¸å˜é‡ä¿æŒã€‚

**ç¤ºä¾‹**ï¼š

```dafny
// âŒ ä¸å¥½çš„ä¸å˜é‡ï¼ˆè¿‡äºä¸¥æ ¼ï¼‰
invariant i == 0 && s == 0  // è¿™ä¸å¯èƒ½æ˜¯å¾ªç¯ä¸å˜é‡ï¼

// âœ… å¥½çš„ä¸å˜é‡ï¼ˆè¶³å¤Ÿå¼±ï¼Œä½†åŒ…å«å¿…è¦ä¿¡æ¯ï¼‰
invariant 0 <= i <= n && s == sum of a[0..i-1]
```

### 3.3 è§„èŒƒæ¨¡å¼åº“

#### æ¨¡å¼1ï¼šæ•°ç»„å¤„ç†

```dafny
method ProcessArray(a: array<int>, n: int)
  requires 0 <= n <= a.Length
  ensures forall i :: 0 <= i < n ==> P(a[i])
  // å…¶ä¸­Pæ˜¯å¤„ç†åçš„æ€§è´¨
```

#### æ¨¡å¼2ï¼šæŸ¥æ‰¾æ“ä½œ

```dafny
method Find(a: array<int>, n: int, key: int) returns (index: int)
  requires 0 <= n <= a.Length
  ensures -1 <= index < n
  ensures index >= 0 ==> a[index] == key
  ensures index == -1 ==> forall i :: 0 <= i < n ==> a[i] != key
```

#### æ¨¡å¼3ï¼šæ’åºæ“ä½œ

```dafny
method Sort(a: array<int>, n: int)
  requires 0 <= n <= a.Length
  modifies a
  ensures forall i, j :: 0 <= i < j < n ==> a[i] <= a[j]
  ensures multiset(a[0..n-1]) == multiset(old(a[0..n-1]))
```

---

## 4. éªŒè¯å·¥ä½œæµç¨‹ / Verification Workflow

### 4.1 å®Œæ•´éªŒè¯æµç¨‹

**æ­¥éª¤1ï¼šéœ€æ±‚åˆ†æ**

- [ ] ç†è§£ç¨‹åºçš„åŠŸèƒ½éœ€æ±‚
- [ ] è¯†åˆ«å…³é”®æ€§è´¨å’Œçº¦æŸ
- [ ] ç¡®å®šéªŒè¯ç›®æ ‡

**æ­¥éª¤2ï¼šè§„èŒƒç¼–å†™**

- [ ] ç¼–å†™å‰ç½®æ¡ä»¶
- [ ] ç¼–å†™åç½®æ¡ä»¶
- [ ] ç¼–å†™å¾ªç¯ä¸å˜é‡ï¼ˆå¦‚æœé€‚ç”¨ï¼‰
- [ ] éªŒè¯è§„èŒƒçš„åˆç†æ€§

**æ­¥éª¤3ï¼šé€‰æ‹©éªŒè¯æ–¹æ³•**

- [ ] æ ¹æ®æ€§è´¨ç±»å‹é€‰æ‹©æ–¹æ³•
- [ ] æ ¹æ®å›¢é˜Ÿèƒ½åŠ›é€‰æ‹©å·¥å…·
- [ ] è€ƒè™‘éªŒè¯æˆæœ¬å’Œæ”¶ç›Š

**æ­¥éª¤4ï¼šæ‰§è¡ŒéªŒè¯**

- [ ] ä½¿ç”¨å·¥å…·è¿›è¡ŒéªŒè¯
- [ ] å¤„ç†éªŒè¯å¤±è´¥çš„æƒ…å†µ
- [ ] ä¿®å¤éªŒè¯é”™è¯¯

**æ­¥éª¤5ï¼šéªŒè¯ç»“æœåˆ†æ**

- [ ] åˆ†æéªŒè¯æŠ¥å‘Š
- [ ] ç†è§£åä¾‹ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
- [ ] ç¡®è®¤éªŒè¯è¦†ç›–åº¦

**æ­¥éª¤6ï¼šæ–‡æ¡£åŒ–**

- [ ] è®°å½•éªŒè¯ç»“æœ
- [ ] è¯´æ˜éªŒè¯å‡è®¾å’Œé™åˆ¶
- [ ] æä¾›ä½¿ç”¨å’Œç»´æŠ¤æŒ‡å—

### 4.2 éªŒè¯å·¥ä½œæµç¤ºä¾‹

```python
class VerificationWorkflow:
    """éªŒè¯å·¥ä½œæµç®¡ç†å™¨"""

    def execute_workflow(self, program: str, requirements: Dict) -> Dict:
        """æ‰§è¡Œå®Œæ•´éªŒè¯å·¥ä½œæµ"""
        workflow_steps = []

        # æ­¥éª¤1ï¼šéœ€æ±‚åˆ†æ
        analysis = self.analyze_requirements(requirements)
        workflow_steps.append(('requirement_analysis', analysis))

        # æ­¥éª¤2ï¼šè§„èŒƒç¼–å†™
        spec = self.write_specification(program, analysis)
        workflow_steps.append(('specification', spec))

        # æ­¥éª¤3ï¼šé€‰æ‹©éªŒè¯æ–¹æ³•
        method = self.select_verification_method(program, spec, analysis)
        workflow_steps.append(('method_selection', method))

        # æ­¥éª¤4ï¼šæ‰§è¡ŒéªŒè¯
        verification_result = self.execute_verification(program, spec, method)
        workflow_steps.append(('verification', verification_result))

        # æ­¥éª¤5ï¼šç»“æœåˆ†æ
        analysis_result = self.analyze_results(verification_result)
        workflow_steps.append(('analysis', analysis_result))

        # æ­¥éª¤6ï¼šç”ŸæˆæŠ¥å‘Š
        report = self.generate_report(workflow_steps)

        return {
            'success': verification_result['success'],
            'workflow_steps': workflow_steps,
            'report': report
        }
```

---

## 5. å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ / Common Problems and Solutions

### 5.1 éªŒè¯æ¡ä»¶æ— æ³•è¯æ˜

**é—®é¢˜**ï¼šç”Ÿæˆçš„éªŒè¯æ¡ä»¶æ— æ³•è‡ªåŠ¨è¯æ˜ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š

1. **ç®€åŒ–è§„èŒƒ**ï¼š
   - åˆ†è§£å¤æ‚æ€§è´¨ä¸ºç®€å•æ€§è´¨
   - ä½¿ç”¨ä¸­é—´æ–­è¨€

2. **æä¾›æ›´å¤šä¿¡æ¯**ï¼š
   - æ·»åŠ å¼•ç†ï¼ˆLemmaï¼‰
   - ä½¿ç”¨æ–­è¨€ï¼ˆAssertï¼‰æŒ‡å¯¼è¯æ˜

3. **ä½¿ç”¨æ›´å¼ºçš„ä¸å˜é‡**ï¼š
   - ä¸å˜é‡åº”è¯¥åŒ…å«æ›´å¤šä¿¡æ¯
   - ä½†ä¸åº”è¯¥è¿‡äºä¸¥æ ¼

**ç¤ºä¾‹**ï¼š

```dafny
// å¦‚æœéªŒè¯å¤±è´¥ï¼Œå¯ä»¥æ·»åŠ ä¸­é—´æ–­è¨€
method Example(a: array<int>) {
  var x := 0;
  var i := 0;
  while i < a.Length
    invariant 0 <= i <= a.Length
    invariant x == sum of a[0..i-1]
  {
    assert x == sum of a[0..i-1];  // ä¸­é—´æ–­è¨€ï¼Œå¸®åŠ©éªŒè¯å™¨
    x := x + a[i];
    assert x == sum of a[0..i];    // ä¸­é—´æ–­è¨€
    i := i + 1;
  }
}
```

### 5.2 çŠ¶æ€ç©ºé—´çˆ†ç‚¸

**é—®é¢˜**ï¼šæ¨¡å‹æ£€æµ‹æ—¶çŠ¶æ€ç©ºé—´å¤ªå¤§ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š

1. **æŠ½è±¡å’Œçº¦ç®€**ï¼š
   - ä½¿ç”¨æŠ½è±¡è§£é‡Š
   - åˆå¹¶ç­‰ä»·çŠ¶æ€

2. **æœ‰ç•ŒéªŒè¯**ï¼š
   - é™åˆ¶æœç´¢æ·±åº¦
   - ä½¿ç”¨æœ‰ç•Œæ¨¡å‹æ£€æµ‹

3. **ç»„åˆéªŒè¯**ï¼š
   - åˆ†åˆ«éªŒè¯å„ä¸ªç»„ä»¶
   - ä½¿ç”¨ç»„åˆæ–¹æ³•

### 5.3 å¾ªç¯ä¸å˜é‡éš¾ä»¥æ‰¾åˆ°

**é—®é¢˜**ï¼šæ— æ³•æ‰¾åˆ°åˆé€‚çš„å¾ªç¯ä¸å˜é‡ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š

1. **ä»åç½®æ¡ä»¶åæ¨**ï¼š
   - è€ƒè™‘åç½®æ¡ä»¶åœ¨å¾ªç¯ä¸­çš„å½¢å¼
   - æ·»åŠ å¾ªç¯å˜é‡çš„çº¦æŸ

2. **ä½¿ç”¨å·¥å…·è¾…åŠ©**ï¼š
   - ä½¿ç”¨AIå·¥å…·ç”Ÿæˆä¸å˜é‡å€™é€‰
   - ä½¿ç”¨æŠ½è±¡è§£é‡Šå¾—åˆ°è¿‘ä¼¼ä¸å˜é‡

3. **å¢é‡æ„å»º**ï¼š
   - å…ˆå†™å¼±ä¸å˜é‡ï¼Œé€æ­¥åŠ å¼º
   - ä»ç®€å•æ€§è´¨å¼€å§‹

---

## 6. å®é™…å·¥ç¨‹æ¡ˆä¾‹è¯¦è§£ / Detailed Engineering Cases

### 6.1 æ¡ˆä¾‹1ï¼šCompCertç¼–è¯‘å™¨éªŒè¯ï¼ˆè¯¦ç»†åˆ†æï¼‰

**é¡¹ç›®èƒŒæ™¯**ï¼š

- **ç›®æ ‡**ï¼šéªŒè¯Cç¼–è¯‘å™¨æ¯ä¸ªé˜¶æ®µçš„æ­£ç¡®æ€§
- **å·¥å…·**ï¼šCoq
- **è§„æ¨¡**ï¼š100,000+ è¡ŒCoqä»£ç 
- **æ—¶é—´**ï¼š10+ å¹´

**éªŒè¯æ–¹æ³•**ï¼š

1. **é˜¶æ®µéªŒè¯**ï¼š
   - æ¯ä¸ªç¼–è¯‘é˜¶æ®µéƒ½æœ‰å½¢å¼åŒ–è¯­ä¹‰
   - è¯æ˜é˜¶æ®µè½¬æ¢ä¿æŒè¯­ä¹‰

2. **ç»„åˆéªŒè¯**ï¼š
   - è¯æ˜ç¼–è¯‘å™¨çš„ç»„åˆæ­£ç¡®æ€§
   - ç«¯åˆ°ç«¯çš„æ­£ç¡®æ€§

**å…³é”®æŒ‘æˆ˜**ï¼š

- å¤„ç†Cè¯­è¨€çš„å¤æ‚è¯­ä¹‰
- ä¼˜åŒ–è½¬æ¢çš„æ­£ç¡®æ€§
- æœºå™¨ä»£ç çš„ç²¾ç¡®å»ºæ¨¡

**æˆæœ**ï¼š

- âœ… å®Œæ•´éªŒè¯äº†ç¼–è¯‘å™¨çš„æ­£ç¡®æ€§
- âœ… ç”¨äºå®‰å…¨å…³é”®ç³»ç»Ÿ
- âœ… è¯æ˜äº†å½¢å¼åŒ–éªŒè¯çš„å¯è¡Œæ€§

### 6.2 æ¡ˆä¾‹2ï¼šseL4å¾®å†…æ ¸éªŒè¯ï¼ˆè¯¦ç»†åˆ†æï¼‰

**é¡¹ç›®èƒŒæ™¯**ï¼š

- **ç›®æ ‡**ï¼šéªŒè¯æ“ä½œç³»ç»Ÿå†…æ ¸çš„æ­£ç¡®æ€§å’Œå®‰å…¨æ€§
- **å·¥å…·**ï¼šIsabelle/HOL
- **è§„æ¨¡**ï¼š10,000+ è¡ŒIsabelleä»£ç 
- **éªŒè¯å†…å®¹**ï¼šåŠŸèƒ½æ­£ç¡®æ€§ã€ä¿¡æ¯æµå®‰å…¨ã€è®¿é—®æ§åˆ¶

**éªŒè¯å±‚æ¬¡**ï¼š

1. **æŠ½è±¡è§„èŒƒå±‚**ï¼šé«˜å±‚åŠŸèƒ½è§„èŒƒ
2. **å¯æ‰§è¡Œè§„èŒƒå±‚**ï¼šå¯æ‰§è¡Œçš„Haskellè§„èŒƒ
3. **Cå®ç°å±‚**ï¼šå®é™…Cä»£ç 
4. **æœºå™¨ä»£ç å±‚**ï¼šç”Ÿæˆçš„æœºå™¨ä»£ç 

**å…³é”®éªŒè¯**ï¼š

- **åŠŸèƒ½æ­£ç¡®æ€§**ï¼šå®ç°æ»¡è¶³æŠ½è±¡è§„èŒƒ
- **ä¿¡æ¯æµå®‰å…¨**ï¼šä¸ä¼šæ³„éœ²ä¿¡æ¯
- **å®Œæ•´æ€§**ï¼šä¸ä¼šè¢«æ”»å‡»è€…æ§åˆ¶

**æˆæœ**ï¼š

- âœ… ç¬¬ä¸€ä¸ªå®Œæ•´éªŒè¯çš„é€šç”¨OSå†…æ ¸
- âœ… è¯æ˜äº†é«˜å®‰å…¨è¦æ±‚ç³»ç»Ÿçš„å¯è¡Œæ€§
- âœ… ç”¨äºå†›äº‹ã€åŒ»ç–—ç­‰å…³é”®ç³»ç»Ÿ

### 6.3 æ¡ˆä¾‹3ï¼šæ™ºèƒ½åˆçº¦éªŒè¯

**é¡¹ç›®èƒŒæ™¯**ï¼š

- **ç›®æ ‡**ï¼šéªŒè¯ä»¥å¤ªåŠæ™ºèƒ½åˆçº¦çš„æ­£ç¡®æ€§
- **å·¥å…·**ï¼šå¤šç§å·¥å…·ï¼ˆKæ¡†æ¶ã€VeriSolã€Isabelleç­‰ï¼‰
- **æŒ‘æˆ˜**ï¼šåŒºå—é“¾ç¯å¢ƒã€gasä¼˜åŒ–ã€é‡å…¥æ”»å‡»

**éªŒè¯æ–¹æ³•**ï¼š

1. **å½¢å¼åŒ–å»ºæ¨¡**ï¼šå»ºæ¨¡ä»¥å¤ªåŠè™šæ‹Ÿæœºï¼ˆEVMï¼‰
2. **åˆçº¦è§„èŒƒ**ï¼šç¼–å†™åˆçº¦çš„å½¢å¼åŒ–è§„èŒƒ
3. **æ€§è´¨éªŒè¯**ï¼šéªŒè¯å®‰å…¨æ€§ã€åŠŸèƒ½æ­£ç¡®æ€§

**å…³é”®æ€§è´¨**ï¼š

- **é‡å…¥å®‰å…¨æ€§**ï¼šé˜²æ­¢é‡å…¥æ”»å‡»
- **æº¢å‡ºå®‰å…¨æ€§**ï¼šé˜²æ­¢æ•´æ•°æº¢å‡º
- **è®¿é—®æ§åˆ¶**ï¼šæ­£ç¡®çš„æƒé™æ£€æŸ¥

---

## ğŸ“š **å‚è€ƒæ–‡çŒ® / References**

1. Pierce, B. C., et al. (2010). *Software Foundations*. Online textbook.

2. Nipkow, T., Paulson, L. C., & Wenzel, M. (2002). *Isabelle/HOL: A Proof Assistant for Higher-Order Logic*. Springer.

3. Leino, K. R. M. (2010). Dafny: An automatic program verifier for functional correctness. *LPAR*, 348-370.

4. Lamport, L. (2002). *Specifying Systems: The TLA+ Language and Tools for Hardware and Software Engineers*. Addison-Wesley.

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å­—æ•°ç»Ÿè®¡**: çº¦15,000å­—
