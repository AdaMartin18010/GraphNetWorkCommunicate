# 社会网络 - 网络分析

## 1. 网络分析基础

### 1.1 分析框架

**定义 1.1** (网络分析框架)
**网络分析框架**是社会网络分析的理论基础：
$$\mathcal{NAF} = \langle \mathcal{G}, \mathcal{M}, \mathcal{A}, \mathcal{V} \rangle$$

其中：

- $\mathcal{G}$ 是图结构
- $\mathcal{M}$ 是度量指标
- $\mathcal{A}$ 是分析算法
- $\mathcal{V}$ 是验证方法

**定义 1.2** (分析维度)
**分析维度**包括：

- **结构维度**：网络拓扑、连通性、中心性
- **关系维度**：关系类型、强度、方向
- **时间维度**：演化、动态、时序
- **属性维度**：节点属性、边属性、全局属性

### 1.2 分析层次

**定义 1.3** (微观分析)
**微观分析**关注个体层面：
$$M_i = \{C_D(i), C_C(i), C_B(i), C_E(i)\}$$

**定义 1.4** (中观分析)
**中观分析**关注群体层面：
$$M_g = \{C(g), D(g), \rho(g)\}$$

其中 $C(g)$ 是聚类系数，$D(g)$ 是密度，$\rho(g)$ 是互惠性。

**定义 1.5** (宏观分析)
**宏观分析**关注整体层面：
$$M_G = \{L, C, D, \gamma\}$$

其中 $L$ 是平均路径长度，$C$ 是全局聚类系数，$D$ 是密度，$\gamma$ 是度分布指数。

## 2. 结构分析

### 2.1 连通性分析

**定义 2.1** (连通分量)
**连通分量**是网络中最大的连通子图：
$$CC(G) = \{C_1, C_2, \ldots, C_k\}$$

其中每个 $C_i$ 是连通分量。

**算法 2.1** (连通分量检测)

```text
输入：图 G = (V, E)
输出：连通分量集合 CC

1. 初始化：visited = {}, CC = []
2. 深度优先搜索：for each v in V do
   a. if v not in visited then
      b. component = dfs(v, visited)
      c. CC.append(component)
3. 返回连通分量：return CC
```

**定义 2.2** (桥接节点)
**桥接节点**是连接不同社区的关键节点：
$$Bridge(v) = \frac{\sigma_{st}(v)}{\sigma_{st}}$$

其中 $\sigma_{st}$ 是节点对间的路径数，$\sigma_{st}(v)$ 是经过 $v$ 的路径数。

### 2.2 中心性分析

**定义 2.3** (度中心性分布)
**度中心性分布**描述网络中节点的连接分布：
$$P(C_D) = \frac{|\{v : C_D(v) = c\}|}{|V|}$$

**定义 2.4** (中心性相关性)
**中心性相关性**衡量不同中心性指标的关系：
$$\rho(C_1, C_2) = \frac{\text{Cov}(C_1, C_2)}{\sigma_{C_1} \sigma_{C_2}}$$

**算法 2.2** (中心性计算)

```text
输入：图 G = (V, E)
输出：中心性指标

1. 度中心性：for each v in V do
   a. C_D(v) = degree(v) / (|V| - 1)
2. 接近中心性：for each v in V do
   a. C_C(v) = (|V| - 1) / sum(shortest_paths(v))
3. 介数中心性：for each v in V do
   a. C_B(v) = sum(betweenness(v, s, t))
4. 特征向量中心性：solve eigenvalue problem
5. 返回中心性指标：return {C_D, C_C, C_B, C_E}
```

## 3. 社区分析

### 3.1 社区检测

**定义 3.1** (模块度)
**模块度**衡量社区划分的质量：
$$Q = \frac{1}{2m} \sum_{ij} \left[A_{ij} - \frac{k_i k_j}{2m}\right] \delta(c_i, c_j)$$

其中 $m$ 是边数，$k_i$ 是节点 $i$ 的度，$c_i$ 是节点 $i$ 的社区。

**算法 3.1** (Louvain算法)

```text
输入：图 G = (V, E)
输出：社区划分 C

1. 初始化：每个节点一个社区
2. 迭代优化：
   a. for each node v do
      b. 计算模块度增益：ΔQ = compute_modularity_gain(v)
      c. if ΔQ > 0 then
         d. 移动到最优社区：move_to_best_community(v)
3. 聚合社区：aggregate_communities()
4. 重复步骤2-3直到收敛
5. 返回社区划分：return C
```

**算法 3.2** (标签传播算法)

```text
输入：图 G = (V, E)
输出：社区划分 C

1. 初始化标签：for each v in V do
   a. label(v) = v
2. 标签传播：repeat until convergence
   a. for each v in V do
      b. 选择邻居中最频繁的标签：label(v) = most_frequent_neighbor_label(v)
3. 返回社区划分：return C
```

### 3.2 社区质量评估

**定义 3.2** (社区内密度)
**社区内密度**衡量社区内部的连接密度：
$$D_{in}(C) = \frac{2|E(C)|}{|C|(|C| - 1)}$$

**定义 3.3** (社区间密度)
**社区间密度**衡量社区间的连接密度：
$$D_{out}(C_1, C_2) = \frac{|E(C_1, C_2)|}{|C_1| \cdot |C_2|}$$

**定义 3.4** (社区稳定性)
**社区稳定性**衡量社区结构的稳定性：
$$S(C) = \frac{1}{|C|} \sum_{v \in C} \frac{|\{u \in C : (v, u) \in E\}|}{|\{u : (v, u) \in E\}|}$$

## 4. 动态分析

### 4.1 时序分析

**定义 4.1** (时序网络)
**时序网络**是带有时间信息的网络：
$$\mathcal{TN} = \langle G_t, T, \mathcal{E} \rangle$$

其中 $G_t$ 是时刻 $t$ 的网络，$T$ 是时间序列，$\mathcal{E}$ 是演化规则。

**定义 4.2** (网络演化)
**网络演化**描述网络结构随时间的变化：
$$\frac{dG_t}{dt} = f(G_t, \theta_t)$$

其中 $\theta_t$ 是演化参数。

**算法 4.1** (时序社区检测)

```text
输入：时序网络 {G_1, G_2, ..., G_T}
输出：时序社区划分 {C_1, C_2, ..., C_T}

1. 初始化：C_1 = detect_communities(G_1)
2. 时序传播：for t = 2 to T do
   a. 预测社区：C_t_pred = predict_communities(C_{t-1}, G_t)
   b. 检测社区：C_t_det = detect_communities(G_t)
   c. 融合结果：C_t = merge_communities(C_t_pred, C_t_det)
3. 返回时序社区：return {C_1, C_2, ..., C_T}
```

### 4.2 传播分析

**定义 4.3** (传播模型)
**传播模型**描述信息或行为在网络中的传播：
$$\frac{dI_i(t)}{dt} = \beta \sum_{j} A_{ij} I_j(t) - \gamma I_i(t)$$

其中 $I_i(t)$ 是节点 $i$ 在时刻 $t$ 的感染状态，$\beta$ 是传播率，$\gamma$ 是恢复率。

**算法 4.2** (独立级联模型)

```text
输入：图 G = (V, E)，种子集 S，传播概率 p
输出：最终感染节点集 I

1. 初始化：I = S, active = S
2. 传播过程：while active is not empty do
   a. new_active = {}
   b. for each v in active do
      c. for each neighbor u of v do
         d. if u not in I and random() < p then
            e. I.add(u), new_active.add(u)
   f. active = new_active
3. 返回感染节点：return I
```

## 5. 异常检测

### 5.1 异常模式

**定义 5.1** (结构异常)
**结构异常**是网络结构中的异常模式：
$$Anomaly(v) = \frac{|C_D(v) - \mu_{C_D}|}{\sigma_{C_D}}$$

其中 $\mu_{C_D}$ 和 $\sigma_{C_D}$ 是度中心性的均值和标准差。

**定义 5.2** (行为异常)
**行为异常**是节点行为模式的异常：
$$BehaviorAnomaly(v) = \sum_{t} |B_v(t) - \bar{B}_v|$$

其中 $B_v(t)$ 是节点 $v$ 在时刻 $t$ 的行为，$\bar{B}_v$ 是平均行为。

**算法 5.1** (异常检测算法)

```text
输入：图 G = (V, E)，时间窗口 T
输出：异常节点集 A

1. 计算特征：for each v in V do
   a. features(v) = compute_features(v, T)
2. 异常检测：for each v in V do
   a. score(v) = anomaly_score(features(v))
   b. if score(v) > threshold then
      c. A.add(v)
3. 返回异常节点：return A
```

### 5.2 社区异常

**定义 5.3** (社区异常)
**社区异常**是社区结构中的异常：
$$CommunityAnomaly(C) = \frac{|Q(C) - \mu_Q|}{\sigma_Q}$$

其中 $Q(C)$ 是社区 $C$ 的模块度，$\mu_Q$ 和 $\sigma_Q$ 是模块度的均值和标准差。

## 6. 影响力分析

### 6.1 影响力传播

**定义 6.1** (影响力函数)
**影响力函数**衡量节点的影响力：
$$I(v) = \alpha C_D(v) + \beta C_C(v) + \gamma C_B(v)$$

其中 $\alpha, \beta, \gamma$ 是权重参数。

**定义 6.2** (影响力传播)
**影响力传播**描述影响力在网络中的传播：
$$\frac{dI_i(t)}{dt} = \sum_{j} A_{ij} w_{ij} I_j(t) - \delta I_i(t)$$

其中 $w_{ij}$ 是边权重，$\delta$ 是衰减率。

**算法 6.1** (影响力最大化)

```text
输入：图 G = (V, E)，种子数量 k
输出：最优种子集 S

1. 初始化：S = {}
2. 贪心选择：for i = 1 to k do
   a. 计算边际增益：for each v in V - S do
      b. gain(v) = influence(S ∪ {v}) - influence(S)
   c. 选择最大增益节点：v* = argmax(gain)
   d. S.add(v*)
3. 返回种子集：return S
```

### 6.2 影响力评估

**定义 6.3** (影响力范围)
**影响力范围**是影响力传播的覆盖范围：
$$Reach(S) = |\{v : I_v(S) > \theta\}|$$

其中 $I_v(S)$ 是种子集 $S$ 对节点 $v$ 的影响力，$\theta$ 是阈值。

**定义 6.4** (影响力效率)
**影响力效率**是单位成本的影响力：
$$Efficiency(S) = \frac{Reach(S)}{|S|}$$

## 7. 网络分析工具

### 7.1 分析框架

**框架 7.1** (网络分析流程)

```text
1. 数据预处理：清洗、标准化、去重
2. 网络构建：节点、边、权重、属性
3. 基础分析：度分布、连通性、中心性
4. 高级分析：社区检测、异常检测、影响力分析
5. 结果验证：统计检验、交叉验证
6. 可视化：网络图、热力图、时序图
```

### 7.2 评估指标

**指标 7.1** (分析质量指标)

- **准确性**：$Accuracy = \frac{TP + TN}{TP + TN + FP + FN}$
- **精确率**：$Precision = \frac{TP}{TP + FP}$
- **召回率**：$Recall = \frac{TP}{TP + FN}$
- **F1分数**：$F1 = \frac{2 \times Precision \times Recall}{Precision + Recall}$

## 8. 社会网络分析的结构化梳理、主要定理、极值、语义模型与自动化验证

### 8.1 结构化梳理

- 网络结构、社区检测、动态演化、异常检测、影响力传播、传播模型、时序分析等
- 属性：连通性、社区性、动态性、异常性、影响力、传播性、时序性

### 8.2 主要定理与极值

**定理 8.2.1（社区检测极值）**
最大模块度社区划分是NP难问题，贪心算法可得到近似解。

**定理 8.2.2（影响力传播极值）**
影响力最大化问题在独立级联模型下是NP难问题。

**定理 8.2.3（异常检测极值）**
最优异常检测阈值使F1分数最大化。

### 8.3 形式语义模型

- 网络分析$NA=(G,M,A,V)$，社区划分$C$，影响力函数$I$，异常检测$D$等
- 性质可用一阶/概率/时序逻辑公式表达，如$\forall v\in V, I(v)\geq\theta$（影响力阈值）
- 社区检测、影响力传播、异常检测等可形式化为范畴上的函子或逻辑推理过程

### 8.4 保持性与极值定理

**定理 8.4.1（分析映射下结构保持）**
网络分析映射$h:NA_1\to NA_2$保持连通性、社区性、影响力等结构性性质。

**定理 8.4.2（极值保持性）**
最大影响力、最小异常率等极值性质在分析保持映射下不减弱。

### 8.5 自动化验证建议

- Coq/Lean等定理证明器可形式化社区检测、影响力传播、异常检测、极值、保持性等定理。
- Rust/Go代码可实现网络分析、社区检测、影响力传播、异常检测与自动化验证。

## 多模态表达与可视化

- **网络分析层次图**：用Gephi/D3.js/NetworkX展示分析结果、社区结构。
- **影响力传播动画**：用social_community_animation.py生成传播过程动画。
- **异常检测热力图**：用NetworkX/Matplotlib绘制异常分数分布。
- **自动化脚本建议**：
  - `scripts/social_community_animation.py`：输入网络分析结果，输出层次/传播动画。
- **示例**：
  - Mermaid分析流程图：

    ```mermaid
    graph TD;
      数据预处理-->网络构建;
      网络构建-->基础分析;
      基础分析-->高级分析;
      高级分析-->结果验证;
      结果验证-->可视化;
    ```

---

*本文档提供了社会网络分析的完整理论框架和方法体系，为社会网络通信系统的分析提供了理论基础。*
