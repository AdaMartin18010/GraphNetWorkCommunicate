# ç¤¾ä¼šç½‘ç»œç®—æ³•å®ç°æŒ‡å— / Social Networks Algorithm Implementation Guide

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£æä¾›ç¤¾ä¼šç½‘ç»œæ ¸å¿ƒç®—æ³•çš„å®ç°æŒ‡å—ï¼ŒåŒ…æ‹¬ç®—æ³•åŸç†ã€Pythonå®ç°ã€å¤æ‚åº¦åˆ†æå’Œå®é™…åº”ç”¨æ¡ˆä¾‹ã€‚

**é€‚ç”¨å¯¹è±¡**: ç®—æ³•å¼€å‘è€…ã€æ•°æ®ç§‘å­¦å®¶ã€ç³»ç»Ÿå·¥ç¨‹å¸ˆ

---

## ğŸ“‹ **ç›®å½• / Table of Contents**

- [ç¤¾ä¼šç½‘ç»œç®—æ³•å®ç°æŒ‡å— / Social Networks Algorithm Implementation Guide](#ç¤¾ä¼šç½‘ç»œç®—æ³•å®ç°æŒ‡å—--social-networks-algorithm-implementation-guide)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‹ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [ğŸ” **ä¸€ã€ä¸­å¿ƒæ€§ç®—æ³•å®ç° / Part 1: Centrality Algorithm Implementation**](#-ä¸€ä¸­å¿ƒæ€§ç®—æ³•å®ç°--part-1-centrality-algorithm-implementation)
    - [1.1 åº¦ä¸­å¿ƒæ€§](#11-åº¦ä¸­å¿ƒæ€§)
    - [1.2 ä»‹æ•°ä¸­å¿ƒæ€§](#12-ä»‹æ•°ä¸­å¿ƒæ€§)
    - [1.3 æ¥è¿‘ä¸­å¿ƒæ€§](#13-æ¥è¿‘ä¸­å¿ƒæ€§)
    - [1.4 ç‰¹å¾å‘é‡ä¸­å¿ƒæ€§](#14-ç‰¹å¾å‘é‡ä¸­å¿ƒæ€§)
  - [ğŸ‘¥ **äºŒã€ç¤¾åŒºæ£€æµ‹ç®—æ³•å®ç° / Part 2: Community Detection Algorithm Implementation**](#-äºŒç¤¾åŒºæ£€æµ‹ç®—æ³•å®ç°--part-2-community-detection-algorithm-implementation)
    - [2.1 Louvainç®—æ³•](#21-louvainç®—æ³•)
    - [2.2 Leidenç®—æ³•](#22-leidenç®—æ³•)
    - [2.3 æ ‡ç­¾ä¼ æ’­ç®—æ³•](#23-æ ‡ç­¾ä¼ æ’­ç®—æ³•)
    - [2.4 è°±èšç±»ç®—æ³•](#24-è°±èšç±»ç®—æ³•)
  - [ğŸ“Š **ä¸‰ã€å½±å“åŠ›ä¼ æ’­ç®—æ³•å®ç° / Part 3: Influence Propagation Algorithm Implementation**](#-ä¸‰å½±å“åŠ›ä¼ æ’­ç®—æ³•å®ç°--part-3-influence-propagation-algorithm-implementation)
    - [3.1 ç‹¬ç«‹çº§è”æ¨¡å‹](#31-ç‹¬ç«‹çº§è”æ¨¡å‹)
    - [3.2 çº¿æ€§é˜ˆå€¼æ¨¡å‹](#32-çº¿æ€§é˜ˆå€¼æ¨¡å‹)
    - [3.3 å½±å“åŠ›æœ€å¤§åŒ–ç®—æ³•](#33-å½±å“åŠ›æœ€å¤§åŒ–ç®—æ³•)
  - [ğŸ”— **å››ã€é“¾æ¥é¢„æµ‹ç®—æ³•å®ç° / Part 4: Link Prediction Algorithm Implementation**](#-å››é“¾æ¥é¢„æµ‹ç®—æ³•å®ç°--part-4-link-prediction-algorithm-implementation)
    - [4.1 å…±åŒé‚»å±…ç®—æ³•](#41-å…±åŒé‚»å±…ç®—æ³•)
    - [4.2 Adamic-Adarç®—æ³•](#42-adamic-adarç®—æ³•)
    - [4.3 èµ„æºåˆ†é…ç®—æ³•](#43-èµ„æºåˆ†é…ç®—æ³•)
  - [ğŸ“ˆ **äº”ã€ç½‘ç»œæ¼”åŒ–ç®—æ³•å®ç° / Part 5: Network Evolution Algorithm Implementation**](#-äº”ç½‘ç»œæ¼”åŒ–ç®—æ³•å®ç°--part-5-network-evolution-algorithm-implementation)
    - [5.1 ç½‘ç»œå¢é•¿æ¨¡å‹](#51-ç½‘ç»œå¢é•¿æ¨¡å‹)
    - [5.2 ä¼˜å…ˆè¿æ¥æ¨¡å‹](#52-ä¼˜å…ˆè¿æ¥æ¨¡å‹)
    - [5.3 å°ä¸–ç•Œç½‘ç»œç”Ÿæˆ](#53-å°ä¸–ç•Œç½‘ç»œç”Ÿæˆ)
  - [ğŸ“š **å…­ã€å‚è€ƒæ–‡æ¡£ / Part 6: Reference Documents**](#-å…­å‚è€ƒæ–‡æ¡£--part-6-reference-documents)

---

## ğŸ” **ä¸€ã€ä¸­å¿ƒæ€§ç®—æ³•å®ç° / Part 1: Centrality Algorithm Implementation**

### 1.1 åº¦ä¸­å¿ƒæ€§

**ç®—æ³•åŸç†**:

åº¦ä¸­å¿ƒæ€§æ˜¯æœ€ç®€å•çš„ä¸­å¿ƒæ€§åº¦é‡ï¼Œå®šä¹‰ä¸ºèŠ‚ç‚¹çš„è¿æ¥æ•°ã€‚

**æ•°å­¦å®šä¹‰**:

```math
C_D(v) = \frac{deg(v)}{n-1}
```

å…¶ä¸­ï¼š

- `deg(v)`: èŠ‚ç‚¹vçš„åº¦æ•°
- `n`: ç½‘ç»œèŠ‚ç‚¹æ€»æ•°

**Pythonå®ç°**:

```python
import networkx as nx

def degree_centrality(graph):
    """
    è®¡ç®—åº¦ä¸­å¿ƒæ€§

    å‚æ•°:
        graph: NetworkXå›¾å¯¹è±¡

    è¿”å›:
        dict: èŠ‚ç‚¹åˆ°ä¸­å¿ƒæ€§å€¼çš„æ˜ å°„
    """
    n = graph.number_of_nodes()
    if n <= 1:
        return {node: 0 for node in graph.nodes()}

    centrality = {}
    for node in graph.nodes():
        degree = graph.degree(node)
        centrality[node] = degree / (n - 1)

    return centrality

# ä½¿ç”¨NetworkXå†…ç½®å‡½æ•°
G = nx.karate_club_graph()
centrality = nx.degree_centrality(G)
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(V + E)ï¼Œå…¶ä¸­Væ˜¯èŠ‚ç‚¹æ•°ï¼ŒEæ˜¯è¾¹æ•°
- ç©ºé—´å¤æ‚åº¦: O(V)

**åº”ç”¨åœºæ™¯**:

- è¯†åˆ«é«˜è¿æ¥åº¦ç”¨æˆ·
- ç½‘ç»œhubèŠ‚ç‚¹æ£€æµ‹
- ç®€å•çš„å½±å“åŠ›è¯„ä¼°

---

### 1.2 ä»‹æ•°ä¸­å¿ƒæ€§

**ç®—æ³•åŸç†**:

ä»‹æ•°ä¸­å¿ƒæ€§è¡¡é‡èŠ‚ç‚¹åœ¨æ‰€æœ‰æœ€çŸ­è·¯å¾„ä¸­å‡ºç°çš„é¢‘ç‡ã€‚

**æ•°å­¦å®šä¹‰**:

```math
C_B(v) = \sum_{s \neq v \neq t} \frac{\sigma_{st}(v)}{\sigma_{st}}
```

å…¶ä¸­ï¼š

- `Ïƒ_{st}`: ä»såˆ°tçš„æœ€çŸ­è·¯å¾„æ•°
- `Ïƒ_{st}(v)`: ç»è¿‡èŠ‚ç‚¹vçš„æœ€çŸ­è·¯å¾„æ•°

**Pythonå®ç°**:

```python
import networkx as nx
from collections import defaultdict

def betweenness_centrality(graph):
    """
    è®¡ç®—ä»‹æ•°ä¸­å¿ƒæ€§ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰

    å‚æ•°:
        graph: NetworkXå›¾å¯¹è±¡

    è¿”å›:
        dict: èŠ‚ç‚¹åˆ°ä¸­å¿ƒæ€§å€¼çš„æ˜ å°„
    """
    centrality = defaultdict(float)
    nodes = list(graph.nodes())
    n = len(nodes)

    for s in nodes:
        # ä½¿ç”¨BFSè®¡ç®—æœ€çŸ­è·¯å¾„
        paths = nx.single_source_shortest_path(graph, s)
        for t in paths:
            if s != t:
                path = paths[t]
                for v in path[1:-1]:  # æ’é™¤èµ·ç‚¹å’Œç»ˆç‚¹
                    centrality[v] += 1.0

    # å½’ä¸€åŒ–
    if n > 2:
        normalization = (n - 1) * (n - 2) / 2
        for v in centrality:
            centrality[v] /= normalization

    return dict(centrality)

# ä½¿ç”¨NetworkXå†…ç½®å‡½æ•°ï¼ˆæ›´é«˜æ•ˆï¼‰
G = nx.karate_club_graph()
centrality = nx.betweenness_centrality(G)
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(VÂ·E) å¯¹äºæ— æƒå›¾ï¼ŒO(VÂ·E + VÂ²Â·log V) å¯¹äºæœ‰æƒå›¾
- ç©ºé—´å¤æ‚åº¦: O(V + E)

**åº”ç”¨åœºæ™¯**:

- è¯†åˆ«ç½‘ç»œä¸­çš„å…³é”®ä¸­ä»‹èŠ‚ç‚¹
- ä¿¡æ¯ä¼ æ’­è·¯å¾„åˆ†æ
- ç½‘ç»œç“¶é¢ˆè¯†åˆ«

---

### 1.3 æ¥è¿‘ä¸­å¿ƒæ€§

**ç®—æ³•åŸç†**:

æ¥è¿‘ä¸­å¿ƒæ€§è¡¡é‡èŠ‚ç‚¹åˆ°å…¶ä»–æ‰€æœ‰èŠ‚ç‚¹çš„å¹³å‡è·ç¦»çš„å€’æ•°ã€‚

**æ•°å­¦å®šä¹‰**:

```math
C_C(v) = \frac{n-1}{\sum_{u \neq v} d(u, v)}
```

å…¶ä¸­ï¼š

- `d(u, v)`: ä»uåˆ°vçš„æœ€çŸ­è·¯å¾„é•¿åº¦
- `n`: ç½‘ç»œèŠ‚ç‚¹æ€»æ•°

**Pythonå®ç°**:

```python
import networkx as nx

def closeness_centrality(graph):
    """
    è®¡ç®—æ¥è¿‘ä¸­å¿ƒæ€§

    å‚æ•°:
        graph: NetworkXå›¾å¯¹è±¡

    è¿”å›:
        dict: èŠ‚ç‚¹åˆ°ä¸­å¿ƒæ€§å€¼çš„æ˜ å°„
    """
    centrality = {}
    n = graph.number_of_nodes()

    for node in graph.nodes():
        # è®¡ç®—åˆ°æ‰€æœ‰å…¶ä»–èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„é•¿åº¦
        path_lengths = nx.single_source_shortest_path_length(graph, node)
        total_distance = sum(path_lengths.values()) - path_lengths[node]  # æ’é™¤è‡ªå·±

        if total_distance > 0:
            centrality[node] = (n - 1) / total_distance
        else:
            centrality[node] = 0.0

    return centrality

# ä½¿ç”¨NetworkXå†…ç½®å‡½æ•°
G = nx.karate_club_graph()
centrality = nx.closeness_centrality(G)
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(VÂ·(V + E))ï¼Œéœ€è¦å¯¹æ¯ä¸ªèŠ‚ç‚¹è®¡ç®—æœ€çŸ­è·¯å¾„
- ç©ºé—´å¤æ‚åº¦: O(V)

**åº”ç”¨åœºæ™¯**:

- è¯†åˆ«ç½‘ç»œä¸­å¿ƒèŠ‚ç‚¹
- ä¿¡æ¯ä¼ æ’­æ•ˆç‡åˆ†æ
- ç½‘ç»œå¯è¾¾æ€§è¯„ä¼°

---

### 1.4 ç‰¹å¾å‘é‡ä¸­å¿ƒæ€§

**ç®—æ³•åŸç†**:

ç‰¹å¾å‘é‡ä¸­å¿ƒæ€§åŸºäºé‚»æ¥çŸ©é˜µçš„ä¸»ç‰¹å¾å‘é‡ï¼Œè€ƒè™‘é‚»å±…èŠ‚ç‚¹çš„é‡è¦æ€§ã€‚

**æ•°å­¦å®šä¹‰**:

```math
C_E(v) = \frac{1}{\lambda} \sum_{u \in N(v)} C_E(u)
```

å…¶ä¸­ï¼š

- `Î»`: é‚»æ¥çŸ©é˜µçš„æœ€å¤§ç‰¹å¾å€¼
- `N(v)`: èŠ‚ç‚¹vçš„é‚»å±…é›†åˆ

**Pythonå®ç°**:

```python
import networkx as nx
import numpy as np

def eigenvector_centrality(graph, max_iter=100, tol=1.0e-6):
    """
    è®¡ç®—ç‰¹å¾å‘é‡ä¸­å¿ƒæ€§ï¼ˆå¹‚è¿­ä»£æ³•ï¼‰

    å‚æ•°:
        graph: NetworkXå›¾å¯¹è±¡
        max_iter: æœ€å¤§è¿­ä»£æ¬¡æ•°
        tol: æ”¶æ•›å®¹å·®

    è¿”å›:
        dict: èŠ‚ç‚¹åˆ°ä¸­å¿ƒæ€§å€¼çš„æ˜ å°„
    """
    nodes = list(graph.nodes())
    n = len(nodes)
    node_to_idx = {node: i for i, node in enumerate(nodes)}

    # æ„å»ºé‚»æ¥çŸ©é˜µ
    A = nx.adjacency_matrix(graph, nodelist=nodes).todense()

    # åˆå§‹åŒ–
    x = np.ones(n) / np.sqrt(n)

    # å¹‚è¿­ä»£
    for _ in range(max_iter):
        x_new = A @ x
        norm = np.linalg.norm(x_new)
        if norm == 0:
            break
        x_new = x_new / norm

        if np.linalg.norm(x_new - x) < tol:
            break
        x = x_new

    # å½’ä¸€åŒ–
    if np.max(x) > 0:
        x = x / np.max(x)

    return {nodes[i]: float(x[i]) for i in range(n)}

# ä½¿ç”¨NetworkXå†…ç½®å‡½æ•°
G = nx.karate_club_graph()
centrality = nx.eigenvector_centrality(G)
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(VÂ²Â·k)ï¼Œå…¶ä¸­kæ˜¯è¿­ä»£æ¬¡æ•°ï¼ˆé€šå¸¸k << Vï¼‰
- ç©ºé—´å¤æ‚åº¦: O(VÂ²)

**åº”ç”¨åœºæ™¯**:

- è¯†åˆ«æœ‰å½±å“åŠ›çš„èŠ‚ç‚¹
- PageRankç®—æ³•çš„åŸºç¡€
- ç½‘ç»œé‡è¦æ€§è¯„ä¼°

---

## ğŸ‘¥ **äºŒã€ç¤¾åŒºæ£€æµ‹ç®—æ³•å®ç° / Part 2: Community Detection Algorithm Implementation**

### 2.1 Louvainç®—æ³•

**ç®—æ³•åŸç†**:

Louvainç®—æ³•é€šè¿‡æ¨¡å—åº¦ä¼˜åŒ–è¿›è¡Œç¤¾åŒºæ£€æµ‹ï¼Œé‡‡ç”¨è´ªå¿ƒç­–ç•¥å’Œå±‚æ¬¡èšåˆã€‚

**æ¨¡å—åº¦å®šä¹‰**:

```math
Q = \frac{1}{2m} \sum_{ij} \left[A_{ij} - \frac{k_i k_j}{2m}\right] \delta(c_i, c_j)
```

å…¶ä¸­ï¼š

- `A_{ij}`: é‚»æ¥çŸ©é˜µå…ƒç´ 
- `k_i`: èŠ‚ç‚¹içš„åº¦
- `m`: æ€»è¾¹æ•°
- `Î´(c_i, c_j)`: å¦‚æœèŠ‚ç‚¹iå’Œjåœ¨åŒä¸€ç¤¾åŒºåˆ™ä¸º1ï¼Œå¦åˆ™ä¸º0

**Pythonå®ç°**:

```python
import networkx as nx
import random
from collections import defaultdict

def louvain_community_detection(graph):
    """
    Louvainç¤¾åŒºæ£€æµ‹ç®—æ³•ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰

    å‚æ•°:
        graph: NetworkXå›¾å¯¹è±¡

    è¿”å›:
        dict: èŠ‚ç‚¹åˆ°ç¤¾åŒºIDçš„æ˜ å°„
    """
    # åˆå§‹åŒ–ï¼šæ¯ä¸ªèŠ‚ç‚¹ä¸€ä¸ªç¤¾åŒº
    communities = {node: i for i, node in enumerate(graph.nodes())}
    m = graph.number_of_edges()

    def modularity_gain(node, new_community):
        """è®¡ç®—å°†èŠ‚ç‚¹ç§»åŠ¨åˆ°æ–°ç¤¾åŒºçš„æ¨¡å—åº¦å¢ç›Š"""
        # ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦è®¡ç®—è¯¦ç»†çš„æ¨¡å—åº¦å˜åŒ–
        return 0.0  # å ä½ç¬¦

    improved = True
    while improved:
        improved = False
        nodes = list(graph.nodes())
        random.shuffle(nodes)  # éšæœºé¡ºåº

        for node in nodes:
            best_community = communities[node]
            best_gain = 0.0

            # å°è¯•ç§»åŠ¨åˆ°é‚»å±…çš„ç¤¾åŒº
            for neighbor in graph.neighbors(node):
                neighbor_community = communities[neighbor]
                if neighbor_community != communities[node]:
                    gain = modularity_gain(node, neighbor_community)
                    if gain > best_gain:
                        best_gain = gain
                        best_community = neighbor_community

            if best_community != communities[node]:
                communities[node] = best_community
                improved = True

    return communities

# ä½¿ç”¨python-louvainåº“ï¼ˆæ¨èï¼‰
# pip install python-louvain
import community.community_louvain as community_louvain

G = nx.karate_club_graph()
partition = community_louvain.best_partition(G)
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(VÂ·log V) å¹³å‡æƒ…å†µ
- ç©ºé—´å¤æ‚åº¦: O(V + E)

**åº”ç”¨åœºæ™¯**:

- å¤§è§„æ¨¡ç½‘ç»œç¤¾åŒºæ£€æµ‹
- ç¤¾äº¤ç½‘ç»œå…´è¶£ç¾¤ä½“è¯†åˆ«
- æ¨èç³»ç»Ÿç”¨æˆ·åˆ†ç¾¤

---

### 2.2 Leidenç®—æ³•

**ç®—æ³•åŸç†**:

Leidenç®—æ³•æ˜¯Louvainç®—æ³•çš„æ”¹è¿›ç‰ˆæœ¬ï¼Œä¿è¯ç¤¾åŒºåˆ’åˆ†çš„è´¨é‡å’Œå±€éƒ¨æœ€ä¼˜æ€§ã€‚

**Pythonå®ç°**:

```python
# ä½¿ç”¨cdlibåº“ï¼ˆæ¨èï¼‰
# pip install cdlib

from cdlib import algorithms
import networkx as nx

G = nx.karate_club_graph()
communities = algorithms.leiden(G)
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(VÂ·log V) å¹³å‡æƒ…å†µ
- ç©ºé—´å¤æ‚åº¦: O(V + E)

**ä¼˜åŠ¿**:

- æ¯”Louvainç®—æ³•äº§ç”Ÿæ›´é«˜è´¨é‡çš„ç¤¾åŒº
- ä¿è¯å±€éƒ¨æœ€ä¼˜æ€§
- é€‚åˆå¤§è§„æ¨¡ç½‘ç»œ

---

### 2.3 æ ‡ç­¾ä¼ æ’­ç®—æ³•

**ç®—æ³•åŸç†**:

æ ‡ç­¾ä¼ æ’­ç®—æ³•é€šè¿‡è¿­ä»£æ›´æ–°èŠ‚ç‚¹æ ‡ç­¾ï¼Œä½¿æ ‡ç­¾åœ¨ç½‘ç»œä¸­ä¼ æ’­å¹¶æ”¶æ•›åˆ°ç¤¾åŒºç»“æ„ã€‚

**Pythonå®ç°**:

```python
import networkx as nx
import random
from collections import Counter

def label_propagation(graph, max_iter=100):
    """
    æ ‡ç­¾ä¼ æ’­ç®—æ³•

    å‚æ•°:
        graph: NetworkXå›¾å¯¹è±¡
        max_iter: æœ€å¤§è¿­ä»£æ¬¡æ•°

    è¿”å›:
        dict: èŠ‚ç‚¹åˆ°ç¤¾åŒºIDçš„æ˜ å°„
    """
    # åˆå§‹åŒ–ï¼šæ¯ä¸ªèŠ‚ç‚¹ä¸€ä¸ªå”¯ä¸€æ ‡ç­¾
    labels = {node: i for i, node in enumerate(graph.nodes())}

    for iteration in range(max_iter):
        changed = False
        nodes = list(graph.nodes())
        random.shuffle(nodes)

        for node in nodes:
            # ç»Ÿè®¡é‚»å±…æ ‡ç­¾
            neighbor_labels = [labels[neighbor] for neighbor in graph.neighbors(node)]
            if neighbor_labels:
                # é€‰æ‹©æœ€å¸¸è§çš„æ ‡ç­¾
                label_counts = Counter(neighbor_labels)
                most_common_label = label_counts.most_common(1)[0][0]

                if labels[node] != most_common_label:
                    labels[node] = most_common_label
                    changed = True

        if not changed:
            break

    return labels

# ä½¿ç”¨NetworkXå†…ç½®å‡½æ•°
G = nx.karate_club_graph()
communities = nx.community.label_propagation_communities(G)
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(mÂ·k)ï¼Œå…¶ä¸­mæ˜¯è¾¹æ•°ï¼Œkæ˜¯è¿­ä»£æ¬¡æ•°ï¼ˆé€šå¸¸kå¾ˆå°ï¼‰
- ç©ºé—´å¤æ‚åº¦: O(V)

**åº”ç”¨åœºæ™¯**:

- å¿«é€Ÿç¤¾åŒºæ£€æµ‹
- å®æ—¶ç½‘ç»œåˆ†æ
- å¤§è§„æ¨¡ç½‘ç»œåˆæ­¥åˆ†æ

---

### 2.4 è°±èšç±»ç®—æ³•

**ç®—æ³•åŸç†**:

è°±èšç±»åŸºäºå›¾çš„æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µçš„ç‰¹å¾å‘é‡è¿›è¡Œèšç±»ã€‚

**Pythonå®ç°**:

```python
import networkx as nx
import numpy as np
from sklearn.cluster import KMeans

def spectral_clustering(graph, n_clusters):
    """
    è°±èšç±»ç®—æ³•

    å‚æ•°:
        graph: NetworkXå›¾å¯¹è±¡
        n_clusters: ç¤¾åŒºæ•°é‡

    è¿”å›:
        dict: èŠ‚ç‚¹åˆ°ç¤¾åŒºIDçš„æ˜ å°„
    """
    # è®¡ç®—æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µ
    L = nx.normalized_laplacian_matrix(graph).todense()

    # è®¡ç®—ç‰¹å¾å€¼å’Œç‰¹å¾å‘é‡
    eigenvalues, eigenvectors = np.linalg.eigh(L)

    # é€‰æ‹©å‰kä¸ªæœ€å°ç‰¹å¾å€¼å¯¹åº”çš„ç‰¹å¾å‘é‡
    k = n_clusters
    indices = np.argsort(eigenvalues)[:k]
    features = eigenvectors[:, indices]

    # K-meansèšç±»
    kmeans = KMeans(n_clusters=k, random_state=42)
    labels = kmeans.fit_predict(features)

    # è½¬æ¢ä¸ºå­—å…¸
    nodes = list(graph.nodes())
    communities = {nodes[i]: int(labels[i]) for i in range(len(nodes))}

    return communities

# ä½¿ç”¨ç¤ºä¾‹
G = nx.karate_club_graph()
communities = spectral_clustering(G, n_clusters=2)
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(VÂ³)ï¼Œä¸»è¦ç“¶é¢ˆåœ¨ç‰¹å¾å€¼åˆ†è§£
- ç©ºé—´å¤æ‚åº¦: O(VÂ²)

**åº”ç”¨åœºæ™¯**:

- å°è§„æ¨¡ç½‘ç»œç²¾ç¡®ç¤¾åŒºæ£€æµ‹
- ç†è®ºåˆ†æ
- éœ€è¦ç†è®ºä¿è¯çš„åœºæ™¯

---

## ğŸ“Š **ä¸‰ã€å½±å“åŠ›ä¼ æ’­ç®—æ³•å®ç° / Part 3: Influence Propagation Algorithm Implementation**

### 3.1 ç‹¬ç«‹çº§è”æ¨¡å‹

**ç®—æ³•åŸç†**:

ç‹¬ç«‹çº§è”æ¨¡å‹ï¼ˆICMï¼‰ä¸­ï¼Œæ¯ä¸ªæ¿€æ´»èŠ‚ç‚¹ä»¥ç‹¬ç«‹æ¦‚ç‡æ¿€æ´»å…¶æœªæ¿€æ´»çš„é‚»å±…ã€‚

**Pythonå®ç°**:

```python
import networkx as nx
import random

def independent_cascade(graph, seed_set, activation_prob=0.1, max_iter=100):
    """
    ç‹¬ç«‹çº§è”æ¨¡å‹

    å‚æ•°:
        graph: NetworkXå›¾å¯¹è±¡
        seed_set: åˆå§‹æ¿€æ´»èŠ‚ç‚¹é›†åˆ
        activation_prob: æ¿€æ´»æ¦‚ç‡
        max_iter: æœ€å¤§è¿­ä»£æ¬¡æ•°

    è¿”å›:
        set: æœ€ç»ˆæ¿€æ´»çš„èŠ‚ç‚¹é›†åˆ
    """
    activated = set(seed_set)
    newly_activated = set(seed_set)

    for iteration in range(max_iter):
        if not newly_activated:
            break

        next_activated = set()
        for node in newly_activated:
            for neighbor in graph.neighbors(node):
                if neighbor not in activated:
                    if random.random() < activation_prob:
                        next_activated.add(neighbor)

        activated.update(next_activated)
        newly_activated = next_activated

    return activated

# ä½¿ç”¨ç¤ºä¾‹
G = nx.karate_club_graph()
seed_set = [0, 1, 2]  # åˆå§‹æ¿€æ´»èŠ‚ç‚¹
activated = independent_cascade(G, seed_set, activation_prob=0.2)
print(f"æ¿€æ´»èŠ‚ç‚¹æ•°: {len(activated)}")
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(EÂ·k)ï¼Œå…¶ä¸­kæ˜¯ä¼ æ’­è½®æ•°
- ç©ºé—´å¤æ‚åº¦: O(V)

**åº”ç”¨åœºæ™¯**:

- ä¿¡æ¯ä¼ æ’­æ¨¡æ‹Ÿ
- ç—…æ¯’å¼è¥é”€åˆ†æ
- èˆ†æƒ…ä¼ æ’­é¢„æµ‹

---

### 3.2 çº¿æ€§é˜ˆå€¼æ¨¡å‹

**ç®—æ³•åŸç†**:

çº¿æ€§é˜ˆå€¼æ¨¡å‹ï¼ˆLTMï¼‰ä¸­ï¼ŒèŠ‚ç‚¹åœ¨é‚»å±…æ¿€æ´»æƒé‡ä¹‹å’Œè¶…è¿‡é˜ˆå€¼æ—¶è¢«æ¿€æ´»ã€‚

**Pythonå®ç°**:

```python
import networkx as nx
import random

def linear_threshold(graph, seed_set, thresholds=None, max_iter=100):
    """
    çº¿æ€§é˜ˆå€¼æ¨¡å‹

    å‚æ•°:
        graph: NetworkXå›¾å¯¹è±¡
        seed_set: åˆå§‹æ¿€æ´»èŠ‚ç‚¹é›†åˆ
        thresholds: èŠ‚ç‚¹é˜ˆå€¼å­—å…¸ï¼ˆå¦‚æœNoneåˆ™éšæœºç”Ÿæˆï¼‰
        max_iter: æœ€å¤§è¿­ä»£æ¬¡æ•°

    è¿”å›:
        set: æœ€ç»ˆæ¿€æ´»çš„èŠ‚ç‚¹é›†åˆ
    """
    activated = set(seed_set)
    newly_activated = set(seed_set)

    # åˆå§‹åŒ–é˜ˆå€¼
    if thresholds is None:
        thresholds = {node: random.random() for node in graph.nodes()}

    # è®¡ç®—è¾¹æƒé‡ï¼ˆå½’ä¸€åŒ–ï¼‰
    edge_weights = {}
    for node in graph.nodes():
        total_weight = sum(graph[node].get('weight', 1.0) for _ in graph.neighbors(node))
        if total_weight > 0:
            for neighbor in graph.neighbors(node):
                weight = graph[node].get('weight', 1.0) / total_weight
                edge_weights[(node, neighbor)] = weight

    for iteration in range(max_iter):
        if not newly_activated:
            break

        next_activated = set()
        for node in graph.nodes():
            if node not in activated:
                # è®¡ç®—æ¿€æ´»é‚»å±…çš„æƒé‡å’Œ
                influence = sum(
                    edge_weights.get((neighbor, node), 0.0)
                    for neighbor in graph.neighbors(node)
                    if neighbor in activated
                )

                if influence >= thresholds[node]:
                    next_activated.add(node)

        activated.update(next_activated)
        newly_activated = next_activated

    return activated

# ä½¿ç”¨ç¤ºä¾‹
G = nx.karate_club_graph()
seed_set = [0, 1, 2]
activated = linear_threshold(G, seed_set)
print(f"æ¿€æ´»èŠ‚ç‚¹æ•°: {len(activated)}")
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(VÂ·EÂ·k)ï¼Œå…¶ä¸­kæ˜¯ä¼ æ’­è½®æ•°
- ç©ºé—´å¤æ‚åº¦: O(V + E)

**åº”ç”¨åœºæ™¯**:

- æ„è§ä¼ æ’­å»ºæ¨¡
- åˆ›æ–°æ‰©æ•£åˆ†æ
- è¡Œä¸ºæ”¹å˜é¢„æµ‹

---

### 3.3 å½±å“åŠ›æœ€å¤§åŒ–ç®—æ³•

**ç®—æ³•åŸç†**:

å½±å“åŠ›æœ€å¤§åŒ–é—®é¢˜æ˜¯åœ¨ç»™å®šé¢„ç®—kä¸‹ï¼Œé€‰æ‹©kä¸ªç§å­èŠ‚ç‚¹ä½¿æœ€ç»ˆæ¿€æ´»èŠ‚ç‚¹æ•°æœ€å¤§åŒ–ã€‚

**è´ªå¿ƒç®—æ³•å®ç°**:

```python
import networkx as nx

def greedy_influence_maximization(graph, k, propagation_model, n_simulations=100):
    """
    è´ªå¿ƒç®—æ³•æ±‚è§£å½±å“åŠ›æœ€å¤§åŒ–

    å‚æ•°:
        graph: NetworkXå›¾å¯¹è±¡
        k: ç§å­èŠ‚ç‚¹æ•°é‡
        propagation_model: ä¼ æ’­æ¨¡å‹å‡½æ•°
        n_simulations: è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿæ¬¡æ•°

    è¿”å›:
        list: ç§å­èŠ‚ç‚¹åˆ—è¡¨
    """
    seed_set = []

    for _ in range(k):
        best_node = None
        best_influence = -1

        for node in graph.nodes():
            if node not in seed_set:
                # è®¡ç®—æ·»åŠ è¯¥èŠ‚ç‚¹åçš„å¹³å‡å½±å“åŠ›
                total_influence = 0
                for _ in range(n_simulations):
                    activated = propagation_model(graph, seed_set + [node])
                    total_influence += len(activated)

                avg_influence = total_influence / n_simulations

                if avg_influence > best_influence:
                    best_influence = avg_influence
                    best_node = node

        if best_node is not None:
            seed_set.append(best_node)

    return seed_set

# ä½¿ç”¨ç¤ºä¾‹
G = nx.karate_club_graph()
seed_set = greedy_influence_maximization(
    G,
    k=3,
    propagation_model=lambda g, s: independent_cascade(g, s, 0.2)
)
print(f"ç§å­èŠ‚ç‚¹: {seed_set}")
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(kÂ·VÂ·n_simulationsÂ·ä¼ æ’­å¤æ‚åº¦)
- ç©ºé—´å¤æ‚åº¦: O(V)

**åº”ç”¨åœºæ™¯**:

- è¥é”€æ¨å¹¿ç­–ç•¥
- å…³é”®ç”¨æˆ·è¯†åˆ«
- ä¿¡æ¯ä¼ æ’­ä¼˜åŒ–

---

## ğŸ”— **å››ã€é“¾æ¥é¢„æµ‹ç®—æ³•å®ç° / Part 4: Link Prediction Algorithm Implementation**

### 4.1 å…±åŒé‚»å±…ç®—æ³•

**ç®—æ³•åŸç†**:

å…±åŒé‚»å±…ç®—æ³•åŸºäºä¸¤ä¸ªèŠ‚ç‚¹å…±åŒé‚»å±…çš„æ•°é‡é¢„æµ‹é“¾æ¥ã€‚

**æ•°å­¦å®šä¹‰**:

```math
score(u, v) = |N(u) \cap N(v)|
```

å…¶ä¸­ï¼š

- `N(u)`: èŠ‚ç‚¹uçš„é‚»å±…é›†åˆ

**Pythonå®ç°**:

```python
import networkx as nx

def common_neighbors_score(graph, u, v):
    """
    è®¡ç®—å…±åŒé‚»å±…åˆ†æ•°

    å‚æ•°:
        graph: NetworkXå›¾å¯¹è±¡
        u, v: èŠ‚ç‚¹

    è¿”å›:
        int: å…±åŒé‚»å±…æ•°é‡
    """
    neighbors_u = set(graph.neighbors(u))
    neighbors_v = set(graph.neighbors(v))
    return len(neighbors_u & neighbors_v)

def link_prediction_common_neighbors(graph, node_pairs):
    """
    åŸºäºå…±åŒé‚»å±…çš„é“¾æ¥é¢„æµ‹

    å‚æ•°:
        graph: NetworkXå›¾å¯¹è±¡
        node_pairs: å¾…é¢„æµ‹çš„èŠ‚ç‚¹å¯¹åˆ—è¡¨

    è¿”å›:
        dict: èŠ‚ç‚¹å¯¹åˆ°åˆ†æ•°çš„æ˜ å°„
    """
    scores = {}
    for u, v in node_pairs:
        scores[(u, v)] = common_neighbors_score(graph, u, v)
    return scores

# ä½¿ç”¨ç¤ºä¾‹
G = nx.karate_club_graph()
node_pairs = [(0, 5), (1, 10), (2, 15)]
scores = link_prediction_common_neighbors(G, node_pairs)
print(scores)
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(VÂ²Â·d_avg)ï¼Œå…¶ä¸­d_avgæ˜¯å¹³å‡åº¦
- ç©ºé—´å¤æ‚åº¦: O(V)

---

### 4.2 Adamic-Adarç®—æ³•

**ç®—æ³•åŸç†**:

Adamic-Adarç®—æ³•å¯¹å…±åŒé‚»å±…çš„åº¦å–å€’æ•°æ±‚å’Œï¼Œç»™äºˆä½åº¦é‚»å±…æ›´é«˜æƒé‡ã€‚

**æ•°å­¦å®šä¹‰**:

```math
score(u, v) = \sum_{w \in N(u) \cap N(v)} \frac{1}{\log(deg(w))}
```

**Pythonå®ç°**:

```python
import networkx as nx
import math

def adamic_adar_score(graph, u, v):
    """
    è®¡ç®—Adamic-Adaråˆ†æ•°

    å‚æ•°:
        graph: NetworkXå›¾å¯¹è±¡
        u, v: èŠ‚ç‚¹

    è¿”å›:
        float: Adamic-Adaråˆ†æ•°
    """
    neighbors_u = set(graph.neighbors(u))
    neighbors_v = set(graph.neighbors(v))
    common_neighbors = neighbors_u & neighbors_v

    score = 0.0
    for w in common_neighbors:
        degree = graph.degree(w)
        if degree > 1:
            score += 1.0 / math.log(degree)

    return score

# ä½¿ç”¨NetworkXå†…ç½®å‡½æ•°
G = nx.karate_club_graph()
scores = nx.adamic_adar_index(G, [(0, 5), (1, 10)])
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(VÂ²Â·d_avg)
- ç©ºé—´å¤æ‚åº¦: O(V)

---

### 4.3 èµ„æºåˆ†é…ç®—æ³•

**ç®—æ³•åŸç†**:

èµ„æºåˆ†é…ç®—æ³•å‡è®¾èµ„æºä»èŠ‚ç‚¹uåˆ†é…åˆ°èŠ‚ç‚¹vï¼Œé€šè¿‡å…±åŒé‚»å±…ä¼ é€’ã€‚

**æ•°å­¦å®šä¹‰**:

```math
score(u, v) = \sum_{w \in N(u) \cap N(v)} \frac{1}{deg(w)}
```

**Pythonå®ç°**:

```python
import networkx as nx

def resource_allocation_score(graph, u, v):
    """
    è®¡ç®—èµ„æºåˆ†é…åˆ†æ•°

    å‚æ•°:
        graph: NetworkXå›¾å¯¹è±¡
        u, v: èŠ‚ç‚¹

    è¿”å›:
        float: èµ„æºåˆ†é…åˆ†æ•°
    """
    neighbors_u = set(graph.neighbors(u))
    neighbors_v = set(graph.neighbors(v))
    common_neighbors = neighbors_u & neighbors_v

    score = 0.0
    for w in common_neighbors:
        degree = graph.degree(w)
        if degree > 0:
            score += 1.0 / degree

    return score

# ä½¿ç”¨NetworkXå†…ç½®å‡½æ•°
G = nx.karate_club_graph()
scores = nx.resource_allocation_index(G, [(0, 5), (1, 10)])
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(VÂ²Â·d_avg)
- ç©ºé—´å¤æ‚åº¦: O(V)

---

## ğŸ“ˆ **äº”ã€ç½‘ç»œæ¼”åŒ–ç®—æ³•å®ç° / Part 5: Network Evolution Algorithm Implementation**

### 5.1 ç½‘ç»œå¢é•¿æ¨¡å‹

**ç®—æ³•åŸç†**:

ç½‘ç»œå¢é•¿æ¨¡å‹æ¨¡æ‹Ÿç½‘ç»œé€šè¿‡æ·»åŠ æ–°èŠ‚ç‚¹å’Œè¾¹è€Œå¢é•¿çš„è¿‡ç¨‹ã€‚

**Pythonå®ç°**:

```python
import networkx as nx
import random

def network_growth_model(n_nodes, m_edges_per_node=2):
    """
    ç½‘ç»œå¢é•¿æ¨¡å‹ï¼ˆBarabÃ¡si-Albertæ¨¡å‹ç®€åŒ–ç‰ˆï¼‰

    å‚æ•°:
        n_nodes: æœ€ç»ˆèŠ‚ç‚¹æ•°
        m_edges_per_node: æ¯ä¸ªæ–°èŠ‚ç‚¹æ·»åŠ çš„è¾¹æ•°

    è¿”å›:
        NetworkXå›¾å¯¹è±¡
    """
    G = nx.Graph()

    # åˆå§‹åŒ–ï¼šåˆ›å»ºm_edges_per_nodeä¸ªèŠ‚ç‚¹çš„å®Œå…¨å›¾
    initial_nodes = m_edges_per_node
    G.add_nodes_from(range(initial_nodes))
    for i in range(initial_nodes):
        for j in range(i + 1, initial_nodes):
            G.add_edge(i, j)

    # å¢é•¿è¿‡ç¨‹
    for new_node in range(initial_nodes, n_nodes):
        G.add_node(new_node)

        # ä¼˜å…ˆè¿æ¥ï¼šæ ¹æ®åº¦é€‰æ‹©è¿æ¥ç›®æ ‡
        degrees = dict(G.degree())
        total_degree = sum(degrees.values())

        targets = []
        while len(targets) < m_edges_per_node and len(targets) < len(G) - 1:
            # æŒ‰åº¦æ¦‚ç‡é€‰æ‹©èŠ‚ç‚¹
            r = random.random() * total_degree
            cumulative = 0
            for node, degree in degrees.items():
                if node != new_node and node not in targets:
                    cumulative += degree
                    if cumulative >= r:
                        targets.append(node)
                        break

        for target in targets:
            G.add_edge(new_node, target)

    return G

# ä½¿ç”¨ç¤ºä¾‹
G = network_growth_model(n_nodes=100, m_edges_per_node=2)
print(f"èŠ‚ç‚¹æ•°: {G.number_of_nodes()}, è¾¹æ•°: {G.number_of_edges()}")
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(nÂ·m)ï¼Œå…¶ä¸­næ˜¯èŠ‚ç‚¹æ•°ï¼Œmæ˜¯æ¯èŠ‚ç‚¹è¾¹æ•°
- ç©ºé—´å¤æ‚åº¦: O(n + mÂ·n)

---

### 5.2 ä¼˜å…ˆè¿æ¥æ¨¡å‹

**ç®—æ³•åŸç†**:

ä¼˜å…ˆè¿æ¥æ¨¡å‹ï¼ˆBarabÃ¡si-Albertæ¨¡å‹ï¼‰ä¸­ï¼Œæ–°èŠ‚ç‚¹å€¾å‘äºè¿æ¥åˆ°é«˜åº¦èŠ‚ç‚¹ã€‚

**Pythonå®ç°**:

```python
import networkx as nx
import random

def barabasi_albert_model(n, m):
    """
    BarabÃ¡si-Albertæ— æ ‡åº¦ç½‘ç»œæ¨¡å‹

    å‚æ•°:
        n: èŠ‚ç‚¹æ•°
        m: æ¯ä¸ªæ–°èŠ‚ç‚¹æ·»åŠ çš„è¾¹æ•°

    è¿”å›:
        NetworkXå›¾å¯¹è±¡
    """
    G = nx.Graph()

    # åˆå§‹åŒ–ï¼šåˆ›å»ºmä¸ªèŠ‚ç‚¹çš„å®Œå…¨å›¾
    G.add_nodes_from(range(m))
    for i in range(m):
        for j in range(i + 1, m):
            G.add_edge(i, j)

    # å¢é•¿å’Œä¼˜å…ˆè¿æ¥
    for new_node in range(m, n):
        G.add_node(new_node)

        # è®¡ç®—è¿æ¥æ¦‚ç‡ï¼ˆåŸºäºåº¦ï¼‰
        degrees = dict(G.degree())
        nodes = list(G.nodes())
        nodes.remove(new_node)

        # æŒ‰åº¦é€‰æ‹©mä¸ªç›®æ ‡èŠ‚ç‚¹
        targets = random.choices(
            nodes,
            weights=[degrees[node] for node in nodes],
            k=min(m, len(nodes))
        )

        for target in set(targets):  # å»é‡
            G.add_edge(new_node, target)

    return G

# ä½¿ç”¨NetworkXå†…ç½®å‡½æ•°ï¼ˆæ¨èï¼‰
G = nx.barabasi_albert_graph(n=100, m=2)
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(nÂ·m)
- ç©ºé—´å¤æ‚åº¦: O(n + mÂ·n)

---

### 5.3 å°ä¸–ç•Œç½‘ç»œç”Ÿæˆ

**ç®—æ³•åŸç†**:

å°ä¸–ç•Œç½‘ç»œï¼ˆWatts-Strogatzæ¨¡å‹ï¼‰é€šè¿‡é‡è¿è§„åˆ™å›¾ç”Ÿæˆï¼Œå…·æœ‰é«˜èšç±»ç³»æ•°å’ŒçŸ­å¹³å‡è·¯å¾„é•¿åº¦ã€‚

**Pythonå®ç°**:

```python
import networkx as nx
import random

def watts_strogatz_model(n, k, p):
    """
    Watts-Strogatzå°ä¸–ç•Œç½‘ç»œæ¨¡å‹

    å‚æ•°:
        n: èŠ‚ç‚¹æ•°
        k: æ¯ä¸ªèŠ‚ç‚¹çš„é‚»å±…æ•°ï¼ˆå¶æ•°ï¼‰
        p: é‡è¿æ¦‚ç‡

    è¿”å›:
        NetworkXå›¾å¯¹è±¡
    """
    # åˆ›å»ºè§„åˆ™å›¾ï¼ˆç¯å½¢ï¼‰
    G = nx.watts_strogatz_graph(n, k, p)
    return G

# ä½¿ç”¨NetworkXå†…ç½®å‡½æ•°
G = nx.watts_strogatz_graph(n=100, k=4, p=0.1)
print(f"èšç±»ç³»æ•°: {nx.average_clustering(G)}")
print(f"å¹³å‡è·¯å¾„é•¿åº¦: {nx.average_shortest_path_length(G)}")
```

**å¤æ‚åº¦åˆ†æ**:

- æ—¶é—´å¤æ‚åº¦: O(nÂ·k)
- ç©ºé—´å¤æ‚åº¦: O(nÂ·k)

---

## ğŸ“š **å…­ã€å‚è€ƒæ–‡æ¡£ / Part 6: Reference Documents**

### 6.1 æ ¸å¿ƒæ–‡æ¡£

- **[ç¤¾ä¼šç½‘ç»œåŸºç¡€](01-ç¤¾ä¼šç½‘ç»œåŸºç¡€.md)** - åŸºæœ¬æ¦‚å¿µå’Œç†è®º
- **[ç½‘ç»œåˆ†æ](02-ç½‘ç»œåˆ†æ.md)** - åˆ†ææ–¹æ³•å’Œå·¥å…·
- **[ç†è®ºåº”ç”¨ä¸æ¡ˆä¾‹](99-ç†è®ºåº”ç”¨ä¸æ¡ˆä¾‹.md)** - å·¥ç¨‹æ¡ˆä¾‹

### 6.2 ç†è®ºå…³ç³»æ–‡æ¡£

- **[ç¤¾ä¼šç½‘ç»œæ¨¡å—ç†è®ºå…³ç³»æ¢³ç†](../12-ç†è®ºå…³ç³»ä¸è®¤çŸ¥æ¡†æ¶/01-ç†è®ºé€»è¾‘è„‰ç»œ/10-ç¤¾ä¼šç½‘ç»œæ¨¡å—ç†è®ºå…³ç³»æ¢³ç†.md)** - ä¸ä¸‰å¤§ç†è®ºçš„å…³ç³»

### 6.3 åº”ç”¨æ¨¡å¼æ–‡æ¡£

- **[ç¤¾ä¼šç½‘ç»œåº”ç”¨æ¨¡å¼æ¸…å•](../13-åº”ç”¨æ¨¡å¼å½’çº³/10-ç¤¾ä¼šç½‘ç»œåº”ç”¨æ¨¡å¼/ç¤¾ä¼šç½‘ç»œåº”ç”¨æ¨¡å¼æ¸…å•.md)** - åº”ç”¨æ¨¡å¼å½’çº³

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
**çŠ¶æ€**: âœ… å®Œæˆ
