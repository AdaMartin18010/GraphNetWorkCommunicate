# ç”Ÿç‰©ç½‘ç»œåŠ¨åŠ›å­¦åˆ†æ / Biological Network Dynamics Analysis

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä»‹ç»ç”Ÿç‰©ç½‘ç»œåŠ¨åŠ›å­¦åˆ†æç†è®ºï¼ŒåŒ…æ‹¬åŠ¨åŠ›å­¦æ¨¡å‹ã€ç¨³å®šæ€§åˆ†æã€æŒ¯è¡åˆ†æå’ŒåŠ¨åŠ›å­¦æ§åˆ¶æ–¹æ³•ã€‚

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [ç”Ÿç‰©ç½‘ç»œåŠ¨åŠ›å­¦åˆ†æ / Biological Network Dynamics Analysis](#ç”Ÿç‰©ç½‘ç»œåŠ¨åŠ›å­¦åˆ†æ--biological-network-dynamics-analysis)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [1. å½¢å¼åŒ–å®šä¹‰ / Formal Definition](#1-å½¢å¼åŒ–å®šä¹‰--formal-definition)
  - [2. åŠ¨åŠ›å­¦æ¨¡å‹ / Dynamics Models](#2-åŠ¨åŠ›å­¦æ¨¡å‹--dynamics-models)
  - [3. ç¨³å®šæ€§åˆ†æ / Stability Analysis](#3-ç¨³å®šæ€§åˆ†æ--stability-analysis)
  - [4. åº”ç”¨åœºæ™¯ / Application Scenarios](#4-åº”ç”¨åœºæ™¯--application-scenarios)
  - [ğŸ”— **ç›¸å…³é“¾æ¥ / Related Links**](#-ç›¸å…³é“¾æ¥--related-links)

---

## 1. å½¢å¼åŒ–å®šä¹‰ / Formal Definition

### å®šä¹‰ 1.1 (ç”Ÿç‰©ç½‘ç»œåŠ¨åŠ›å­¦ / Biological Network Dynamics)

**ç”Ÿç‰©ç½‘ç»œåŠ¨åŠ›å­¦**æè¿°ç”Ÿç‰©ç½‘ç»œä¸­èŠ‚ç‚¹çŠ¶æ€éšæ—¶é—´æ¼”åŒ–çš„è¿‡ç¨‹ã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š

è®¾ç”Ÿç‰©ç½‘ç»œ $G = (V, E)$ï¼ŒèŠ‚ç‚¹ $v \in V$ çš„çŠ¶æ€ä¸º $x_v(t)$ï¼Œåˆ™åŠ¨åŠ›å­¦æ–¹ç¨‹ä¸ºï¼š

$$\frac{dx_v}{dt} = f_v(x_v, \{x_u : (u, v) \in E\}, t)$$

å…¶ä¸­ $f_v$ æ˜¯èŠ‚ç‚¹ $v$ çš„åŠ¨åŠ›å­¦å‡½æ•°ã€‚

### å®šä¹‰ 1.2 (ç¨³æ€ / Steady State)

**ç¨³æ€**æ˜¯ç½‘ç»œçŠ¶æ€ä¸å†å˜åŒ–çš„çŠ¶æ€ï¼Œå³ï¼š

$$\frac{dx_v}{dt} = 0, \quad \forall v \in V$$

---

## 2. åŠ¨åŠ›å­¦æ¨¡å‹ / Dynamics Models

### 2.1 åŸºå› è°ƒæ§ç½‘ç»œåŠ¨åŠ›å­¦

**æ¨¡å‹ 2.1** (HillåŠ¨åŠ›å­¦æ¨¡å‹)

å¯¹äºåŸºå› è°ƒæ§ç½‘ç»œï¼Œä½¿ç”¨HillåŠ¨åŠ›å­¦æ¨¡å‹ï¼š

$$\frac{dx_i}{dt} = \beta_i \frac{x_j^n}{K^n + x_j^n} - \gamma_i x_i$$

å…¶ä¸­ï¼š

- $x_i$ æ˜¯åŸºå›  $i$ çš„è¡¨è¾¾æ°´å¹³
- $\beta_i$ æ˜¯æœ€å¤§è¡¨è¾¾ç‡
- $K$ æ˜¯åŠæœ€å¤§æµ“åº¦
- $n$ æ˜¯Hillç³»æ•°
- $\gamma_i$ æ˜¯é™è§£ç‡

### 2.2 è›‹ç™½è´¨ç›¸äº’ä½œç”¨ç½‘ç»œåŠ¨åŠ›å­¦

**æ¨¡å‹ 2.2** (è´¨é‡ä½œç”¨åŠ¨åŠ›å­¦)

å¯¹äºè›‹ç™½è´¨ç›¸äº’ä½œç”¨ç½‘ç»œï¼Œä½¿ç”¨è´¨é‡ä½œç”¨åŠ¨åŠ›å­¦ï¼š

$$\frac{dx_i}{dt} = \sum_j k_{ij} x_j - \sum_k k_{ik} x_i x_k - \gamma_i x_i$$

å…¶ä¸­ $k_{ij}$ æ˜¯ååº”é€Ÿç‡å¸¸æ•°ã€‚

### ç®—æ³• 2.1 (åŠ¨åŠ›å­¦æ¨¡æ‹Ÿ)

```python
import numpy as np
from typing import Dict, List, Callable
from scipy.integrate import odeint

class BiologicalNetworkDynamics:
    """
    ç”Ÿç‰©ç½‘ç»œåŠ¨åŠ›å­¦åˆ†æå™¨ã€‚
    """

    def __init__(self, network, dynamics_function: Callable):
        """
        åˆå§‹åŒ–ã€‚

        Args:
            network: ç”Ÿç‰©ç½‘ç»œ
            dynamics_function: åŠ¨åŠ›å­¦å‡½æ•°
        """
        self.network = network
        self.dynamics_function = dynamics_function
        self.states = {}

    def simulate(self, initial_state: Dict, time_points: np.ndarray) -> np.ndarray:
        """
        æ¨¡æ‹Ÿç½‘ç»œåŠ¨åŠ›å­¦ã€‚

        Args:
            initial_state: åˆå§‹çŠ¶æ€
            time_points: æ—¶é—´ç‚¹æ•°ç»„

        Returns:
            çŠ¶æ€æ¼”åŒ–è½¨è¿¹
        """
        # æ„å»ºçŠ¶æ€å‘é‡
        state_vector = np.array([initial_state.get(node, 0.0)
                                 for node in self.network.nodes])

        # æ±‚è§£ODE
        trajectory = odeint(self._ode_system, state_vector, time_points)

        return trajectory

    def _ode_system(self, state: np.ndarray, t: float) -> np.ndarray:
        """
        ODEç³»ç»Ÿã€‚

        Args:
            state: å½“å‰çŠ¶æ€
            t: æ—¶é—´

        Returns:
            çŠ¶æ€å¯¼æ•°
        """
        # æ„å»ºçŠ¶æ€å­—å…¸
        state_dict = {node: state[i]
                     for i, node in enumerate(self.network.nodes)}

        # è®¡ç®—å¯¼æ•°
        derivatives = []
        for node in self.network.nodes:
            derivative = self.dynamics_function(node, state_dict, t, self.network)
            derivatives.append(derivative)

        return np.array(derivatives)

    def find_steady_state(self, initial_state: Dict,
                         tolerance: float = 1e-6) -> Dict:
        """
        å¯»æ‰¾ç¨³æ€ã€‚

        Args:
            initial_state: åˆå§‹çŠ¶æ€
            tolerance: å®¹å·®

        Returns:
            ç¨³æ€çŠ¶æ€
        """
        # ä½¿ç”¨æ•°å€¼æ–¹æ³•å¯»æ‰¾ç¨³æ€
        state = np.array([initial_state.get(node, 0.0)
                          for node in self.network.nodes])

        for _ in range(1000):
            # è®¡ç®—å¯¼æ•°
            derivatives = self._ode_system(state, 0.0)

            # æ£€æŸ¥æ˜¯å¦è¾¾åˆ°ç¨³æ€
            if np.max(np.abs(derivatives)) < tolerance:
                break

            # æ›´æ–°çŠ¶æ€ï¼ˆç®€å•æ¬§æ‹‰æ³•ï¼‰
            state = state + 0.01 * derivatives

        # æ„å»ºçŠ¶æ€å­—å…¸
        steady_state = {node: state[i]
                       for i, node in enumerate(self.network.nodes)}

        return steady_state
```

---

## 3. ç¨³å®šæ€§åˆ†æ / Stability Analysis

### 3.1 çº¿æ€§ç¨³å®šæ€§åˆ†æ

**æ–¹æ³• 3.1** (é›…å¯æ¯”çŸ©é˜µåˆ†æ)

å¯¹äºç¨³æ€ $x^*$ï¼Œè®¡ç®—é›…å¯æ¯”çŸ©é˜µï¼š

$$J_{ij} = \frac{\partial f_i}{\partial x_j}\Big|_{x=x^*}$$

å¦‚æœ $J$ çš„æ‰€æœ‰ç‰¹å¾å€¼éƒ½æœ‰è´Ÿå®éƒ¨ï¼Œåˆ™ç¨³æ€æ˜¯ç¨³å®šçš„ã€‚

### ç®—æ³• 3.1 (ç¨³å®šæ€§åˆ†æ)

```python
    def analyze_stability(self, steady_state: Dict) -> Dict:
        """
        åˆ†æç¨³æ€çš„ç¨³å®šæ€§ã€‚

        Args:
            steady_state: ç¨³æ€çŠ¶æ€

        Returns:
            ç¨³å®šæ€§åˆ†æç»“æœ
        """
        # è®¡ç®—é›…å¯æ¯”çŸ©é˜µ
        jacobian = self.compute_jacobian(steady_state)

        # è®¡ç®—ç‰¹å¾å€¼
        eigenvalues = np.linalg.eigvals(jacobian)

        # åˆ¤æ–­ç¨³å®šæ€§
        is_stable = np.all(np.real(eigenvalues) < 0)

        return {
            'is_stable': is_stable,
            'eigenvalues': eigenvalues,
            'jacobian': jacobian
        }

    def compute_jacobian(self, state: Dict) -> np.ndarray:
        """
        è®¡ç®—é›…å¯æ¯”çŸ©é˜µã€‚

        Args:
            state: çŠ¶æ€

        Returns:
            é›…å¯æ¯”çŸ©é˜µ
        """
        n = len(self.network.nodes)
        jacobian = np.zeros((n, n))

        # æ•°å€¼è®¡ç®—åå¯¼æ•°
        epsilon = 1e-6
        state_vector = np.array([state.get(node, 0.0)
                                for node in self.network.nodes])

        for i in range(n):
            for j in range(n):
                # æ‰°åŠ¨çŠ¶æ€
                perturbed_state = state_vector.copy()
                perturbed_state[j] += epsilon

                # è®¡ç®—å¯¼æ•°
                state_dict = {node: perturbed_state[k]
                             for k, node in enumerate(self.network.nodes)}
                derivative_i = self.dynamics_function(
                    self.network.nodes[i], state_dict, 0.0, self.network
                )

                # è®¡ç®—åå¯¼æ•°
                original_derivative = self.dynamics_function(
                    self.network.nodes[i], state, 0.0, self.network
                )

                jacobian[i, j] = (derivative_i - original_derivative) / epsilon

        return jacobian
```

---

## 4. åº”ç”¨åœºæ™¯ / Application Scenarios

### 4.1 ç–¾ç—…ç½‘ç»œåŠ¨åŠ›å­¦åˆ†æ

**é—®é¢˜**: åˆ†æç–¾ç—…ç›¸å…³åŸºå› ç½‘ç»œçš„åŠ¨åŠ›å­¦è¡Œä¸ºã€‚

**åº”ç”¨**: ç–¾ç—…æœºåˆ¶ç†è§£ã€è¯ç‰©é¶ç‚¹è¯†åˆ«

### 4.2 ä»£è°¢ç½‘ç»œåŠ¨åŠ›å­¦åˆ†æ

**é—®é¢˜**: åˆ†æä»£è°¢ç½‘ç»œçš„é€šé‡åˆ†å¸ƒå’Œç¨³å®šæ€§ã€‚

**åº”ç”¨**: ä»£è°¢å·¥ç¨‹ã€ç³»ç»Ÿç”Ÿç‰©å­¦

### 4.3 ä¿¡å·è½¬å¯¼ç½‘ç»œåŠ¨åŠ›å­¦åˆ†æ

**é—®é¢˜**: åˆ†æä¿¡å·è½¬å¯¼ç½‘ç»œçš„å“åº”å’ŒæŒ¯è¡è¡Œä¸ºã€‚

**åº”ç”¨**: ä¿¡å·é€šè·¯è®¾è®¡ã€è¯ç‰©è®¾è®¡

---

## ğŸ”— **ç›¸å…³é“¾æ¥ / Related Links**

- [ç”Ÿç‰©ç½‘ç»œæ¼”åŒ–ç†è®º](02-ç”Ÿç‰©ç½‘ç»œæ¼”åŒ–ç†è®º.md)
- [ç”Ÿç‰©ç½‘ç»œæ§åˆ¶ç†è®º](03-ç”Ÿç‰©ç½‘ç»œæ§åˆ¶ç†è®º.md)
- [ç”Ÿç‰©ç½‘ç»œä¼˜åŒ–æ–¹æ³•](04-ç”Ÿç‰©ç½‘ç»œä¼˜åŒ–æ–¹æ³•.md)
- [ç”Ÿç‰©ç½‘ç»œé«˜çº§ç†è®ºä¸»ç›®å½•](README.md)
- [ç”Ÿç‰©ç½‘ç»œæ¨¡å—ä¸»é¡µ](../README.md)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
