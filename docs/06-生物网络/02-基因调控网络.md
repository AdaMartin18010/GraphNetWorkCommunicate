# åŸºå› è°ƒæ§ç½‘ç»œ / Gene Regulatory Networks

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä»‹ç»åŸºå› è°ƒæ§ç½‘ç»œçš„åŸºç¡€æ¦‚å¿µã€è½¬å½•å› å­è°ƒæ§ã€ç½‘ç»œåŠ¨åŠ›å­¦åˆ†æã€ç½‘ç»œé‡æ„å’Œå®é™…åº”ç”¨ã€‚

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [åŸºå› è°ƒæ§ç½‘ç»œ / Gene Regulatory Networks](#åŸºå› è°ƒæ§ç½‘ç»œ--gene-regulatory-networks)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [2.1 åŸºå› è°ƒæ§åŸºç¡€](#21-åŸºå› è°ƒæ§åŸºç¡€)
    - [2.1.1 åŸºå› è¡¨è¾¾è°ƒæ§](#211-åŸºå› è¡¨è¾¾è°ƒæ§)
    - [2.1.2 è°ƒæ§ç½‘ç»œæ‹“æ‰‘](#212-è°ƒæ§ç½‘ç»œæ‹“æ‰‘)
  - [2.2 è½¬å½•å› å­è°ƒæ§](#22-è½¬å½•å› å­è°ƒæ§)
    - [2.2.1 è½¬å½•å› å­ç»“åˆ](#221-è½¬å½•å› å­ç»“åˆ)
    - [2.2.2 è°ƒæ§å¼ºåº¦è®¡ç®—](#222-è°ƒæ§å¼ºåº¦è®¡ç®—)
  - [2.3 ç½‘ç»œåŠ¨åŠ›å­¦åˆ†æ](#23-ç½‘ç»œåŠ¨åŠ›å­¦åˆ†æ)
    - [2.3.1 ç¨³å®šæ€§åˆ†æ](#231-ç¨³å®šæ€§åˆ†æ)
    - [2.3.2 å¸å¼•å­åˆ†æ](#232-å¸å¼•å­åˆ†æ)
  - [2.4 ç½‘ç»œé‡æ„](#24-ç½‘ç»œé‡æ„)
    - [2.4.1 åŸºäºè¡¨è¾¾æ•°æ®çš„ç½‘ç»œé‡æ„](#241-åŸºäºè¡¨è¾¾æ•°æ®çš„ç½‘ç»œé‡æ„)
    - [2.4.2 æœºå™¨å­¦ä¹ æ–¹æ³•](#242-æœºå™¨å­¦ä¹ æ–¹æ³•)
  - [2.5 å®é™…åº”ç”¨](#25-å®é™…åº”ç”¨)
    - [2.5.1 ç–¾ç—…ç›¸å…³åŸºå› ç½‘ç»œ](#251-ç–¾ç—…ç›¸å…³åŸºå› ç½‘ç»œ)
    - [2.5.2 è¯ç‰©é¶ç‚¹é¢„æµ‹](#252-è¯ç‰©é¶ç‚¹é¢„æµ‹)
  - [2.6 æ€»ç»“](#26-æ€»ç»“)
  - [å¤šæ¨¡æ€è¡¨è¾¾ä¸å¯è§†åŒ–](#å¤šæ¨¡æ€è¡¨è¾¾ä¸å¯è§†åŒ–)

---

## 2.1 åŸºå› è°ƒæ§åŸºç¡€

### 2.1.1 åŸºå› è¡¨è¾¾è°ƒæ§

**å®šä¹‰ 2.1.1** åŸºå› è°ƒæ§ç½‘ç»œæ˜¯æè¿°åŸºå› ä¹‹é—´ç›¸äº’è°ƒæ§å…³ç³»çš„å¤æ‚ç½‘ç»œï¼Œå…¶ä¸­èŠ‚ç‚¹ä»£è¡¨åŸºå› ï¼Œè¾¹ä»£è¡¨è°ƒæ§å…³ç³»ã€‚

**å®šç† 2.1.1** åŸºå› è°ƒæ§ç½‘ç»œçš„åŸºæœ¬ç‰¹å¾ï¼š

1. **éçº¿æ€§æ€§**ï¼šåŸºå› è¡¨è¾¾æ°´å¹³ä¸è°ƒæ§å› å­æµ“åº¦å‘ˆéçº¿æ€§å…³ç³»
2. **æ—¶é—´å»¶è¿Ÿ**ï¼šåŸºå› è¡¨è¾¾å˜åŒ–å­˜åœ¨æ—¶é—´å»¶è¿Ÿ
3. **åé¦ˆæœºåˆ¶**ï¼šåŸºå› ä¹‹é—´å­˜åœ¨æ­£åé¦ˆå’Œè´Ÿåé¦ˆå¾ªç¯

**ç®—æ³• 2.1.1** åŸºå› è¡¨è¾¾åŠ¨åŠ›å­¦æ¨¡å‹

```python
class GeneExpressionModel:
    def __init__(self, genes, regulators):
        self.genes = genes
        self.regulators = regulators
        self.expression_levels = {}
        self.regulation_matrix = {}

    def hill_function(self, concentration, k, n):
        """Hillå‡½æ•°æè¿°è°ƒæ§å…³ç³»"""
        return concentration**n / (k**n + concentration**n)

    def gene_expression_rate(self, gene, time):
        """è®¡ç®—åŸºå› è¡¨è¾¾é€Ÿç‡"""
        # åŸºç¡€è¡¨è¾¾é€Ÿç‡
        basal_rate = self.genes[gene]['basal_rate']

        # è°ƒæ§å› å­å½±å“
        regulation_effect = 1.0
        for regulator in self.regulators.get(gene, []):
            regulator_concentration = self.expression_levels[regulator][time]
            k = self.regulation_matrix[regulator][gene]['k']
            n = self.regulation_matrix[regulator][gene]['n']
            effect_type = self.regulation_matrix[regulator][gene]['type']

            if effect_type == 'activation':
                regulation_effect *= self.hill_function(regulator_concentration, k, n)
            elif effect_type == 'repression':
                regulation_effect *= (1 - self.hill_function(regulator_concentration, k, n))

        # é™è§£é€Ÿç‡
        degradation_rate = self.genes[gene]['degradation_rate']
        current_expression = self.expression_levels[gene][time]

        # å¾®åˆ†æ–¹ç¨‹ï¼šd[gene]/dt = synthesis - degradation
        synthesis_rate = basal_rate * regulation_effect
        degradation = degradation_rate * current_expression

        return synthesis_rate - degradation

    def simulate_expression(self, time_points):
        """æ¨¡æ‹ŸåŸºå› è¡¨è¾¾åŠ¨æ€"""
        # åˆå§‹åŒ–è¡¨è¾¾æ°´å¹³
        for gene in self.genes:
            self.expression_levels[gene] = {0: self.genes[gene]['initial_level']}

        # æ—¶é—´æ­¥è¿›æ¨¡æ‹Ÿ
        for t in range(1, len(time_points)):
            dt = time_points[t] - time_points[t-1]

            for gene in self.genes:
                # ä½¿ç”¨æ¬§æ‹‰æ–¹æ³•æ±‚è§£å¾®åˆ†æ–¹ç¨‹
                current_rate = self.gene_expression_rate(gene, t-1)
                new_level = self.expression_levels[gene][t-1] + current_rate * dt

                # ç¡®ä¿è¡¨è¾¾æ°´å¹³éè´Ÿ
                self.expression_levels[gene][t] = max(0, new_level)
```

### 2.1.2 è°ƒæ§ç½‘ç»œæ‹“æ‰‘

**å®šä¹‰ 2.1.2** åŸºå› è°ƒæ§ç½‘ç»œçš„æ‹“æ‰‘ç»“æ„åæ˜ äº†åŸºå› ä¹‹é—´çš„è°ƒæ§å…³ç³»æ¨¡å¼ã€‚

**ç®—æ³• 2.1.2** è°ƒæ§ç½‘ç»œæ„å»ºç®—æ³•

```python
class GeneRegulatoryNetwork:
    def __init__(self):
        self.nodes = {}  # åŸºå› èŠ‚ç‚¹
        self.edges = {}  # è°ƒæ§è¾¹
        self.expression_data = {}

    def add_gene(self, gene_id, properties):
        """æ·»åŠ åŸºå› èŠ‚ç‚¹"""
        self.nodes[gene_id] = {
            'id': gene_id,
            'name': properties.get('name', gene_id),
            'type': properties.get('type', 'protein_coding'),
            'expression_profile': properties.get('expression_profile', []),
            'regulators': [],
            'targets': []
        }

    def add_regulation(self, regulator_id, target_id, regulation_type, strength):
        """æ·»åŠ è°ƒæ§å…³ç³»"""
        edge_id = f"{regulator_id}_{target_id}"
        self.edges[edge_id] = {
            'regulator': regulator_id,
            'target': target_id,
            'type': regulation_type,  # 'activation' or 'repression'
            'strength': strength,
            'confidence': 0.8  # è°ƒæ§å…³ç³»ç½®ä¿¡åº¦
        }

        # æ›´æ–°èŠ‚ç‚¹è¿æ¥ä¿¡æ¯
        self.nodes[regulator_id]['targets'].append(target_id)
        self.nodes[target_id]['regulators'].append(regulator_id)

    def calculate_network_metrics(self):
        """è®¡ç®—ç½‘ç»œæŒ‡æ ‡"""
        metrics = {}

        # åº¦åˆ†å¸ƒ
        in_degrees = {}
        out_degrees = {}
        for gene_id in self.nodes:
            in_degrees[gene_id] = len(self.nodes[gene_id]['regulators'])
            out_degrees[gene_id] = len(self.nodes[gene_id]['targets'])

        metrics['in_degree_distribution'] = in_degrees
        metrics['out_degree_distribution'] = out_degrees

        # èšç±»ç³»æ•°
        clustering_coefficients = {}
        for gene_id in self.nodes:
            neighbors = set(self.nodes[gene_id]['regulators'] + self.nodes[gene_id]['targets'])
            if len(neighbors) >= 2:
                # è®¡ç®—é‚»å±…é—´çš„è¿æ¥æ•°
                neighbor_connections = 0
                for n1 in neighbors:
                    for n2 in neighbors:
                        if n1 != n2:
                            edge_id = f"{n1}_{n2}"
                            if edge_id in self.edges:
                                neighbor_connections += 1

                clustering_coefficients[gene_id] = neighbor_connections / (len(neighbors) * (len(neighbors) - 1))
            else:
                clustering_coefficients[gene_id] = 0

        metrics['clustering_coefficients'] = clustering_coefficients

        return metrics
```

## 2.2 è½¬å½•å› å­è°ƒæ§

### 2.2.1 è½¬å½•å› å­ç»“åˆ

**å®šä¹‰ 2.2.1** è½¬å½•å› å­æ˜¯èƒ½å¤Ÿç»“åˆåˆ°DNAç‰¹å®šåºåˆ—ä¸Šçš„è›‹ç™½è´¨ï¼Œè°ƒæ§åŸºå› çš„è½¬å½•è¿‡ç¨‹ã€‚

**ç®—æ³• 2.2.1** è½¬å½•å› å­ç»“åˆé¢„æµ‹

```python
class TranscriptionFactorBinding:
    def __init__(self):
        self.tf_motifs = {}  # è½¬å½•å› å­ç»“åˆä½ç‚¹æ¨¡å¼
        self.promoter_sequences = {}  # å¯åŠ¨å­åºåˆ—

    def add_tf_motif(self, tf_name, motif_sequence, binding_affinity):
        """æ·»åŠ è½¬å½•å› å­ç»“åˆä½ç‚¹"""
        self.tf_motifs[tf_name] = {
            'sequence': motif_sequence,
            'affinity': binding_affinity,
            'position_weight_matrix': self.create_pwm(motif_sequence)
        }

    def create_pwm(self, motif_sequence):
        """åˆ›å»ºä½ç½®æƒé‡çŸ©é˜µ"""
        # ç®€åŒ–çš„PWMåˆ›å»º
        pwm = {}
        for i, base in enumerate(motif_sequence):
            if i not in pwm:
                pwm[i] = {'A': 0, 'T': 0, 'G': 0, 'C': 0}
            pwm[i][base] += 1

        return pwm

    def predict_binding_sites(self, promoter_sequence, tf_name):
        """é¢„æµ‹ç»“åˆä½ç‚¹"""
        motif = self.tf_motifs[tf_name]
        motif_length = len(motif['sequence'])
        binding_sites = []

        # æ»‘åŠ¨çª—å£æœç´¢
        for i in range(len(promoter_sequence) - motif_length + 1):
            window = promoter_sequence[i:i+motif_length]
            score = self.calculate_binding_score(window, motif)

            if score > 0.7:  # é˜ˆå€¼
                binding_sites.append({
                    'position': i,
                    'sequence': window,
                    'score': score
                })

        return binding_sites

    def calculate_binding_score(self, sequence, motif):
        """è®¡ç®—ç»“åˆå¾—åˆ†"""
        score = 0
        pwm = motif['position_weight_matrix']

        for i, base in enumerate(sequence):
            if i in pwm and base in pwm[i]:
                score += pwm[i][base]

        return score / len(sequence)
```

### 2.2.2 è°ƒæ§å¼ºåº¦è®¡ç®—

**å®šä¹‰ 2.2.2** è°ƒæ§å¼ºåº¦åæ˜ äº†è½¬å½•å› å­å¯¹ç›®æ ‡åŸºå› è¡¨è¾¾çš„å½±å“ç¨‹åº¦ã€‚

**ç®—æ³• 2.2.2** è°ƒæ§å¼ºåº¦è®¡ç®—

```python
class RegulationStrength:
    def __init__(self):
        self.expression_data = {}
        self.regulation_network = {}

    def calculate_regulation_strength(self, tf_gene, target_gene):
        """è®¡ç®—è°ƒæ§å¼ºåº¦"""
        # è·å–è¡¨è¾¾æ•°æ®
        tf_expression = self.expression_data[tf_gene]
        target_expression = self.expression_data[target_gene]

        # è®¡ç®—ç›¸å…³ç³»æ•°
        correlation = self.calculate_correlation(tf_expression, target_expression)

        # è®¡ç®—äº’ä¿¡æ¯
        mutual_information = self.calculate_mutual_information(tf_expression, target_expression)

        # ç»¼åˆè¯„åˆ†
        strength = (correlation + mutual_information) / 2

        return strength

    def calculate_correlation(self, x, y):
        """è®¡ç®—çš®å°”é€Šç›¸å…³ç³»æ•°"""
        n = len(x)
        if n != len(y):
            return 0

        mean_x = sum(x) / n
        mean_y = sum(y) / n

        numerator = sum((x[i] - mean_x) * (y[i] - mean_y) for i in range(n))
        denominator_x = sum((x[i] - mean_x) ** 2 for i in range(n))
        denominator_y = sum((y[i] - mean_y) ** 2 for i in range(n))

        if denominator_x == 0 or denominator_y == 0:
            return 0

        return numerator / (denominator_x * denominator_y) ** 0.5

    def calculate_mutual_information(self, x, y):
        """è®¡ç®—äº’ä¿¡æ¯"""
        # ç¦»æ•£åŒ–æ•°æ®
        x_discrete = self.discretize_data(x, bins=10)
        y_discrete = self.discretize_data(y, bins=10)

        # è®¡ç®—è”åˆæ¦‚ç‡åˆ†å¸ƒ
        joint_prob = self.calculate_joint_probability(x_discrete, y_discrete)
        x_prob = self.calculate_marginal_probability(x_discrete)
        y_prob = self.calculate_marginal_probability(y_discrete)

        # è®¡ç®—äº’ä¿¡æ¯
        mi = 0
        for i in range(len(joint_prob)):
            for j in range(len(joint_prob[0])):
                if joint_prob[i][j] > 0:
                    mi += joint_prob[i][j] * np.log2(
                        joint_prob[i][j] / (x_prob[i] * y_prob[j])
                    )

        return mi

    def discretize_data(self, data, bins):
        """ç¦»æ•£åŒ–æ•°æ®"""
        min_val = min(data)
        max_val = max(data)
        bin_size = (max_val - min_val) / bins

        discrete_data = []
        for value in data:
            bin_index = min(int((value - min_val) / bin_size), bins - 1)
            discrete_data.append(bin_index)

        return discrete_data
```

## 2.3 ç½‘ç»œåŠ¨åŠ›å­¦åˆ†æ

### 2.3.1 ç¨³å®šæ€§åˆ†æ

**å®šä¹‰ 2.3.1** åŸºå› è°ƒæ§ç½‘ç»œçš„ç¨³å®šæ€§åˆ†æç ”ç©¶ç½‘ç»œåœ¨æ‰°åŠ¨ä¸‹çš„è¡Œä¸ºç‰¹æ€§ã€‚

**ç®—æ³• 2.3.1** ç¨³å®šæ€§åˆ†æç®—æ³•

```python
class NetworkStability:
    def __init__(self, gene_network):
        self.network = gene_network
        self.jacobian_matrix = None

    def calculate_jacobian(self, expression_levels):
        """è®¡ç®—é›…å¯æ¯”çŸ©é˜µ"""
        n_genes = len(self.network.nodes)
        jacobian = np.zeros((n_genes, n_genes))

        for i, gene1 in enumerate(self.network.nodes):
            for j, gene2 in enumerate(self.network.nodes):
                # è®¡ç®—åå¯¼æ•° âˆ‚f_i/âˆ‚x_j
                jacobian[i][j] = self.calculate_partial_derivative(
                    gene1, gene2, expression_levels
                )

        return jacobian

    def calculate_partial_derivative(self, gene1, gene2, expression_levels):
        """è®¡ç®—åå¯¼æ•°"""
        if gene1 == gene2:
            # è‡ªè°ƒæ§é¡¹
            return -self.network.nodes[gene1]['degradation_rate']
        else:
            # äº¤å‰è°ƒæ§é¡¹
            if gene2 in self.network.nodes[gene1]['regulators']:
                # è®¡ç®—è°ƒæ§å¼ºåº¦
                regulation_strength = self.calculate_regulation_strength(gene2, gene1)
                return regulation_strength
            else:
                return 0

    def analyze_stability(self, expression_levels):
        """åˆ†æç¨³å®šæ€§"""
        # è®¡ç®—é›…å¯æ¯”çŸ©é˜µ
        jacobian = self.calculate_jacobian(expression_levels)

        # è®¡ç®—ç‰¹å¾å€¼
        eigenvalues = np.linalg.eigvals(jacobian)

        # åˆ¤æ–­ç¨³å®šæ€§
        max_real_part = max(eigenvalues.real)

        if max_real_part < 0:
            stability = "stable"
        elif max_real_part > 0:
            stability = "unstable"
        else:
            stability = "marginally_stable"

        return {
            'stability': stability,
            'eigenvalues': eigenvalues,
            'max_real_part': max_real_part
        }
```

### 2.3.2 å¸å¼•å­åˆ†æ

**å®šä¹‰ 2.3.2** å¸å¼•å­æ˜¯åŸºå› è°ƒæ§ç½‘ç»œä¸­çš„ç¨³å®šçŠ¶æ€ï¼Œç½‘ç»œæœ€ç»ˆä¼šæ”¶æ•›åˆ°è¿™äº›çŠ¶æ€ã€‚

**ç®—æ³• 2.3.2** å¸å¼•å­è¯†åˆ«ç®—æ³•

```python
class AttractorAnalysis:
    def __init__(self, gene_network):
        self.network = gene_network
        self.attractors = []

    def find_attractors(self, initial_states, max_iterations=1000):
        """å¯»æ‰¾å¸å¼•å­"""
        attractors = []

        for initial_state in initial_states:
            # æ¨¡æ‹Ÿç½‘ç»œæ¼”åŒ–
            trajectory = self.simulate_trajectory(initial_state, max_iterations)

            # æ£€æµ‹æ”¶æ•›
            if self.is_converged(trajectory):
                final_state = trajectory[-1]

                # æ£€æŸ¥æ˜¯å¦æ˜¯æ–°å¸å¼•å­
                if not self.is_existing_attractor(final_state, attractors):
                    attractors.append({
                        'state': final_state,
                        'basin_size': self.calculate_basin_size(final_state, initial_states)
                    })

        return attractors

    def simulate_trajectory(self, initial_state, max_iterations):
        """æ¨¡æ‹Ÿè½¨è¿¹"""
        trajectory = [initial_state]
        current_state = initial_state.copy()

        for iteration in range(max_iterations):
            # æ›´æ–°çŠ¶æ€
            new_state = self.update_state(current_state)
            trajectory.append(new_state)

            # æ£€æŸ¥æ”¶æ•›
            if self.is_converged(trajectory):
                break

            current_state = new_state

        return trajectory

    def update_state(self, state):
        """æ›´æ–°çŠ¶æ€"""
        new_state = {}

        for gene in self.network.nodes:
            # è®¡ç®—åŸºå› è¡¨è¾¾å˜åŒ–
            expression_rate = self.calculate_expression_rate(gene, state)
            degradation_rate = self.network.nodes[gene]['degradation_rate']

            # æ›´æ–°è¡¨è¾¾æ°´å¹³
            new_expression = state[gene] + expression_rate - degradation_rate * state[gene]
            new_state[gene] = max(0, new_expression)

        return new_state

    def is_converged(self, trajectory, threshold=0.01):
        """æ£€æŸ¥æ˜¯å¦æ”¶æ•›"""
        if len(trajectory) < 10:
            return False

        # æ£€æŸ¥æœ€åå‡ ä¸ªçŠ¶æ€çš„å˜åŒ–
        recent_states = trajectory[-10:]

        for i in range(1, len(recent_states)):
            state_diff = sum(abs(recent_states[i][gene] - recent_states[i-1][gene])
                           for gene in recent_states[i])

            if state_diff > threshold:
                return False

        return True
```

## 2.4 ç½‘ç»œé‡æ„

### 2.4.1 åŸºäºè¡¨è¾¾æ•°æ®çš„ç½‘ç»œé‡æ„

**å®šä¹‰ 2.4.1** ç½‘ç»œé‡æ„æ˜¯ä»åŸºå› è¡¨è¾¾æ•°æ®æ¨æ–­åŸºå› è°ƒæ§å…³ç³»çš„è¿‡ç¨‹ã€‚

**ç®—æ³• 2.4.1** ç›¸å…³æ€§ç½‘ç»œé‡æ„

```python
class NetworkReconstruction:
    def __init__(self, expression_data):
        self.expression_data = expression_data
        self.reconstructed_network = {}

    def correlation_based_reconstruction(self, threshold=0.7):
        """åŸºäºç›¸å…³æ€§çš„ç½‘ç»œé‡æ„"""
        genes = list(self.expression_data.keys())
        n_genes = len(genes)

        # è®¡ç®—ç›¸å…³ç³»æ•°çŸ©é˜µ
        correlation_matrix = np.zeros((n_genes, n_genes))

        for i, gene1 in enumerate(genes):
            for j, gene2 in enumerate(genes):
                if i != j:
                    correlation = self.calculate_correlation(
                        self.expression_data[gene1],
                        self.expression_data[gene2]
                    )
                    correlation_matrix[i][j] = correlation

        # åº”ç”¨é˜ˆå€¼ç­›é€‰
        for i, gene1 in enumerate(genes):
            for j, gene2 in enumerate(genes):
                if i != j and abs(correlation_matrix[i][j]) > threshold:
                    # æ·»åŠ è°ƒæ§å…³ç³»
                    regulation_type = 'activation' if correlation_matrix[i][j] > 0 else 'repression'
                    self.add_regulation(gene1, gene2, regulation_type, abs(correlation_matrix[i][j]))

    def mutual_information_reconstruction(self, threshold=0.5):
        """åŸºäºäº’ä¿¡æ¯çš„ç½‘ç»œé‡æ„"""
        genes = list(self.expression_data.keys())

        for gene1 in genes:
            for gene2 in genes:
                if gene1 != gene2:
                    mi = self.calculate_mutual_information(
                        self.expression_data[gene1],
                        self.expression_data[gene2]
                    )

                    if mi > threshold:
                        # æ·»åŠ è°ƒæ§å…³ç³»
                        self.add_regulation(gene1, gene2, 'unknown', mi)

    def add_regulation(self, regulator, target, regulation_type, strength):
        """æ·»åŠ è°ƒæ§å…³ç³»"""
        edge_id = f"{regulator}_{target}"
        self.reconstructed_network[edge_id] = {
            'regulator': regulator,
            'target': target,
            'type': regulation_type,
            'strength': strength,
            'confidence': min(strength, 1.0)
        }
```

### 2.4.2 æœºå™¨å­¦ä¹ æ–¹æ³•

**ç®—æ³• 2.4.2** åŸºäºæœºå™¨å­¦ä¹ çš„ç½‘ç»œé‡æ„

```python
class MLNetworkReconstruction:
    def __init__(self, expression_data):
        self.expression_data = expression_data
        self.models = {}

    def lasso_regression_reconstruction(self, alpha=0.1):
        """åŸºäºLassoå›å½’çš„ç½‘ç»œé‡æ„"""
        from sklearn.linear_model import Lasso

        genes = list(self.expression_data.keys())

        for target_gene in genes:
            # å‡†å¤‡è®­ç»ƒæ•°æ®
            X = []
            y = self.expression_data[target_gene]

            for regulator_gene in genes:
                if regulator_gene != target_gene:
                    X.append(self.expression_data[regulator_gene])

            X = np.array(X).T

            # è®­ç»ƒLassoæ¨¡å‹
            lasso = Lasso(alpha=alpha)
            lasso.fit(X, y)

            # æå–éé›¶ç³»æ•°
            for i, regulator_gene in enumerate(genes):
                if regulator_gene != target_gene:
                    coefficient = lasso.coef_[i]
                    if abs(coefficient) > 0.01:  # é˜ˆå€¼
                        regulation_type = 'activation' if coefficient > 0 else 'repression'
                        self.add_regulation(regulator_gene, target_gene, regulation_type, abs(coefficient))

    def random_forest_reconstruction(self, n_estimators=100):
        """åŸºäºéšæœºæ£®æ—çš„ç½‘ç»œé‡æ„"""
        from sklearn.ensemble import RandomForestRegressor

        genes = list(self.expression_data.keys())

        for target_gene in genes:
            # å‡†å¤‡è®­ç»ƒæ•°æ®
            X = []
            y = self.expression_data[target_gene]

            for regulator_gene in genes:
                if regulator_gene != target_gene:
                    X.append(self.expression_data[regulator_gene])

            X = np.array(X).T

            # è®­ç»ƒéšæœºæ£®æ—æ¨¡å‹
            rf = RandomForestRegressor(n_estimators=n_estimators)
            rf.fit(X, y)

            # æå–ç‰¹å¾é‡è¦æ€§
            for i, regulator_gene in enumerate(genes):
                if regulator_gene != target_gene:
                    importance = rf.feature_importances_[i]
                    if importance > 0.01:  # é˜ˆå€¼
                        self.add_regulation(regulator_gene, target_gene, 'unknown', importance)
```

## 2.5 å®é™…åº”ç”¨

### 2.5.1 ç–¾ç—…ç›¸å…³åŸºå› ç½‘ç»œ

**æ¡ˆä¾‹ 2.5.1** ç™Œç—‡åŸºå› è°ƒæ§ç½‘ç»œåˆ†æ

```python
class CancerGeneNetwork:
    def __init__(self):
        self.normal_network = {}
        self.cancer_network = {}
        self.differential_genes = []

    def identify_differential_genes(self, normal_data, cancer_data, threshold=0.05):
        """è¯†åˆ«å·®å¼‚è¡¨è¾¾åŸºå› """
        differential_genes = []

        for gene in normal_data:
            if gene in cancer_data:
                # è®¡ç®—è¡¨è¾¾å·®å¼‚
                normal_expression = np.mean(normal_data[gene])
                cancer_expression = np.mean(cancer_data[gene])

                # è®¡ç®—ç»Ÿè®¡æ˜¾è‘—æ€§
                p_value = self.calculate_p_value(normal_data[gene], cancer_data[gene])

                if p_value < threshold:
                    differential_genes.append({
                        'gene': gene,
                        'fold_change': cancer_expression / normal_expression,
                        'p_value': p_value
                    })

        return differential_genes

    def analyze_network_differences(self):
        """åˆ†æç½‘ç»œå·®å¼‚"""
        differences = {}

        for edge_id in self.normal_network:
            if edge_id in self.cancer_network:
                normal_strength = self.normal_network[edge_id]['strength']
                cancer_strength = self.cancer_network[edge_id]['strength']

                difference = cancer_strength - normal_strength
                if abs(difference) > 0.1:  # é˜ˆå€¼
                    differences[edge_id] = {
                        'difference': difference,
                        'normal_strength': normal_strength,
                        'cancer_strength': cancer_strength
                    }

        return differences
```

### 2.5.2 è¯ç‰©é¶ç‚¹é¢„æµ‹

**æ¡ˆä¾‹ 2.5.2** åŸºäºç½‘ç»œçš„è¯ç‰©é¶ç‚¹é¢„æµ‹

```python
class DrugTargetPrediction:
    def __init__(self, gene_network):
        self.network = gene_network
        self.drug_targets = {}

    def predict_drug_targets(self, drug_effect_genes, method='network_propagation'):
        """é¢„æµ‹è¯ç‰©é¶ç‚¹"""
        if method == 'network_propagation':
            return self.network_propagation_method(drug_effect_genes)
        elif method == 'shortest_path':
            return self.shortest_path_method(drug_effect_genes)
        else:
            return self.random_walk_method(drug_effect_genes)

    def network_propagation_method(self, drug_effect_genes):
        """ç½‘ç»œä¼ æ’­æ–¹æ³•"""
        # åˆå§‹åŒ–ä¼ æ’­åˆ†æ•°
        propagation_scores = {}
        for gene in self.network.nodes:
            if gene in drug_effect_genes:
                propagation_scores[gene] = 1.0
            else:
                propagation_scores[gene] = 0.0

        # è¿­ä»£ä¼ æ’­
        for iteration in range(10):
            new_scores = propagation_scores.copy()

            for gene in self.network.nodes:
                if gene not in drug_effect_genes:
                    # è®¡ç®—æ¥è‡ªé‚»å±…çš„ä¼ æ’­åˆ†æ•°
                    neighbor_score = 0
                    for regulator in self.network.nodes[gene]['regulators']:
                        if regulator in propagation_scores:
                            edge_id = f"{regulator}_{gene}"
                            if edge_id in self.network.edges:
                                strength = self.network.edges[edge_id]['strength']
                                neighbor_score += propagation_scores[regulator] * strength

                    new_scores[gene] = neighbor_score * 0.8  # è¡°å‡å› å­

            propagation_scores = new_scores

        return propagation_scores
```

## 2.6 æ€»ç»“

æœ¬ç« ä»‹ç»äº†åŸºå› è°ƒæ§ç½‘ç»œçš„æ ¸å¿ƒå†…å®¹ï¼š

1. **åŸºç¡€æ¦‚å¿µ**ï¼šåŸºå› è¡¨è¾¾è°ƒæ§çš„åŸºæœ¬åŸç†å’ŒåŠ¨åŠ›å­¦æ¨¡å‹
2. **è½¬å½•å› å­è°ƒæ§**ï¼šè½¬å½•å› å­ç»“åˆé¢„æµ‹å’Œè°ƒæ§å¼ºåº¦è®¡ç®—
3. **ç½‘ç»œåŠ¨åŠ›å­¦**ï¼šç¨³å®šæ€§åˆ†æå’Œå¸å¼•å­è¯†åˆ«
4. **ç½‘ç»œé‡æ„**ï¼šä»è¡¨è¾¾æ•°æ®æ¨æ–­è°ƒæ§å…³ç³»çš„æ–¹æ³•
5. **å®é™…åº”ç”¨**ï¼šç–¾ç—…ç½‘ç»œåˆ†æå’Œè¯ç‰©é¶ç‚¹é¢„æµ‹

åŸºå› è°ƒæ§ç½‘ç»œä¸ºç†è§£ç”Ÿç‰©ç³»ç»Ÿçš„å¤æ‚æ€§å’Œé¢„æµ‹åŸºå› åŠŸèƒ½æä¾›äº†é‡è¦çš„ç†è®ºåŸºç¡€å’Œå®ç”¨å·¥å…·ã€‚

## å¤šæ¨¡æ€è¡¨è¾¾ä¸å¯è§†åŒ–

- **åŸºå› è°ƒæ§ç½‘ç»œç»“æ„å›¾**ï¼šç”¨Cytoscape/Graphvizç»˜åˆ¶è°ƒæ§å…³ç³»ã€‚
- **æ¨¡ä½“åˆ†å¸ƒçƒ­åŠ›å›¾**ï¼šç”¨Matplotlibå±•ç¤ºæ¨¡ä½“ç»Ÿè®¡ã€‚
- **è‡ªåŠ¨åŒ–è„šæœ¬å»ºè®®**ï¼š
  - `scripts/biological_network_visualizer.py`ï¼šè¾“å…¥åŸºå› è°ƒæ§ç½‘ç»œæ•°æ®ï¼Œè¾“å‡ºç»“æ„å›¾ã€çƒ­åŠ›å›¾ã€‚
- **ç¤ºä¾‹**ï¼š
  - MermaidåŸºå› è°ƒæ§æµç¨‹ï¼š

    ```mermaid
    graph TD;
      GeneA-->GeneB;
      GeneB-->GeneC;
    ```
