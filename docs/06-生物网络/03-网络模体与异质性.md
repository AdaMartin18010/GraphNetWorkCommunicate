# 生物网络 - 网络模体与异质性

## 1. 网络模体基础

### 1.1 基本定义

**定义 1.1** (网络模体)
**网络模体**是网络中频繁出现的小型子结构：
$$\mathcal{M} = \langle V_M, E_M, P_M \rangle$$

其中：

- $V_M$ 是模体节点集
- $E_M$ 是模体边集
- $P_M$ 是模体模式

**定义 1.2** (模体类型)
**常见模体类型**包括：

- **三元环**：$C_3 = \{(i,j), (j,k), (k,i)\}$
- **双向链**：$L_2 = \{(i,j), (j,i)\}$
- **反馈回路**：$F = \{(i,j), (j,k), (k,i)\}$

### 1.2 模体统计

**定义 1.3** (模体频率)
**模体频率**是模体在网络中的出现次数：
$$F(M) = \frac{|\{M_i : M_i \cong M\}|}{|\mathcal{S}|}$$

其中 $\mathcal{S}$ 是所有可能的子图。

**定义 1.4** (统计显著性)
**统计显著性**衡量模体的重要性：
$$Z(M) = \frac{F_{real}(M) - \mu_{rand}(M)}{\sigma_{rand}(M)}$$

其中 $F_{real}(M)$ 是真实网络中的频率，$\mu_{rand}(M)$ 和 $\sigma_{rand}(M)$ 是随机网络中的均值和标准差。

## 2. 模体检测算法

### 2.1 ESU算法

**定义 2.1** (ESU算法)
**ESU算法**是枚举子图的算法：
$$\text{ESU}(G, k) = \{S : S \subseteq G, |S| = k\}$$

**算法 2.1** (ESU模体检测)

```text
输入：图 G = (V, E)，模体大小 k
输出：所有k节点子图

1. 初始化：for each v in V do
   a. 创建子图：S = {v}
   b. 扩展子图：extend_subgraph(S, v, k)
2. 扩展函数：extend_subgraph(S, v, k)
   a. if |S| == k then
      b. 记录子图：record_subgraph(S)
      c. return
   d. 选择邻居：for each u in neighbors(v) do
      e. if u > v and u not in S then
         f. 添加节点：S.add(u)
         g. 递归扩展：extend_subgraph(S, u, k)
         h. 移除节点：S.remove(u)
3. 返回结果：return all_subgraphs
```

### 2.2 FANMOD算法

**定义 2.2** (FANMOD算法)
**FANMOD算法**是快速网络模体检测算法：
$$\text{FANMOD}(G, k) = \text{Sample}(G, k) \cup \text{Count}(G, k)$$

**算法 2.2** (FANMOD实现)

```text
输入：图 G，模体大小 k，采样次数 N
输出：模体统计

1. 初始化：motif_counts = {}
2. 随机采样：for i = 1 to N do
   a. 随机选择：S = random_subgraph(G, k)
   b. 识别模体：motif = identify_motif(S)
   c. 更新计数：motif_counts[motif]++
3. 计算频率：for each motif do
   a. frequency[motif] = motif_counts[motif] / N
4. 返回结果：return frequency
```

## 3. 网络异质性

### 3.1 异质性定义

**定义 3.1** (网络异质性)
**网络异质性**是网络属性的多样性：
$$\mathcal{H} = \langle \mathcal{D}, \mathcal{F}, \mathcal{I} \rangle$$

其中：

- $\mathcal{D}$ 是度分布
- $\mathcal{F}$ 是功能多样性
- $\mathcal{I}$ 是交互强度

**定义 3.2** (度分布异质性)
**度分布异质性**衡量节点连接的不均匀性：
$$H_D = -\sum_{k} P(k) \log P(k)$$

其中 $P(k)$ 是度为 $k$ 的节点比例。

### 3.2 异质性度量

**定义 3.3** (基尼系数)
**基尼系数**衡量分布的不平等性：
$$G = \frac{\sum_{i=1}^{n} \sum_{j=1}^{n} |x_i - x_j|}{2n^2 \bar{x}}$$

其中 $x_i$ 是节点 $i$ 的属性值，$\bar{x}$ 是平均值。

**定义 3.4** (香农熵)
**香农熵**衡量信息的不确定性：
$$H = -\sum_{i} p_i \log p_i$$

其中 $p_i$ 是第 $i$ 个类别的概率。

**算法 3.1** (异质性计算)

```text
输入：网络 G，属性集合 A
输出：异质性指标

1. 计算度分布：degree_dist = compute_degree_distribution(G)
2. 计算基尼系数：gini = compute_gini_coefficient(degree_dist)
3. 计算香农熵：entropy = compute_shannon_entropy(degree_dist)
4. 计算功能多样性：functional_diversity = compute_functional_diversity(A)
5. 返回指标：return {gini, entropy, functional_diversity}
```

## 4. 模体与异质性分析

### 4.1 模体功能分析

**定义 4.1** (模体功能)
**模体功能**描述模体的生物学作用：
$$F(M) = \langle \text{Regulation}, \text{Signal}, \text{Control} \rangle$$

**算法 4.1** (模体功能分析)

```text
输入：模体集合 M，功能注释 A
输出：功能分析结果

1. 模体识别：for each motif in M do
   a. 识别实例：instances = find_motif_instances(motif)
   b. 功能注释：annotations = annotate_instances(instances, A)
   c. 统计分析：statistics = analyze_functional_enrichment(annotations)
2. 返回结果：return functional_analysis
```

### 4.2 异质性影响分析

**定义 4.2** (异质性影响)
**异质性影响**分析异质性对网络功能的影响：
$$I(\mathcal{H}) = \langle \text{Robustness}, \text{Adaptability}, \text{Efficiency} \rangle$$

**算法 4.2** (异质性影响分析)

```text
输入：网络 G，异质性指标 H
输出：影响分析结果

1. 鲁棒性分析：robustness = analyze_robustness(G, H)
2. 适应性分析：adaptability = analyze_adaptability(G, H)
3. 效率分析：efficiency = analyze_efficiency(G, H)
4. 返回结果：return {robustness, adaptability, efficiency}
```

## 5. 高级模体分析

### 5.1 动态模体

**定义 5.1** (动态模体)
**动态模体**随时间变化的模体：
$$\mathcal{DM}(t) = \langle M(t), \Delta M, \text{Evolution} \rangle$$

**算法 5.1** (动态模体检测)

```text
输入：时序网络 {G_1, G_2, ..., G_T}
输出：动态模体序列

1. 初始化：dynamic_motifs = []
2. 时序分析：for t = 1 to T do
   a. 检测模体：motifs = detect_motifs(G_t)
   b. 跟踪变化：changes = track_motif_changes(motifs, t-1)
   c. 记录动态：dynamic_motifs.append(changes)
3. 返回结果：return dynamic_motifs
```

### 5.2 加权模体

**定义 5.2** (加权模体)
**加权模体**考虑边权重的模体：
$$\mathcal{WM} = \langle V_M, E_M, W_M \rangle$$

其中 $W_M$ 是边权重集合。

**算法 5.2** (加权模体检测)

```text
输入：加权图 G = (V, E, W)
输出：加权模体

1. 权重归一化：normalize_weights(G)
2. 阈值过滤：filter_by_weight_threshold(G, threshold)
3. 模体检测：motifs = detect_motifs(filtered_graph)
4. 权重分析：analyze_weight_distribution(motifs)
5. 返回结果：return weighted_motifs
```

## 6. 异质性建模

### 6.1 异质性生成模型

**定义 6.1** (异质性模型)
**异质性模型**生成具有特定异质性的网络：
$$\mathcal{HM} = \langle \text{Distribution}, \text{Parameters}, \text{Generation} \rangle$$

**算法 6.1** (异质性网络生成)

```text
输入：异质性参数 H，节点数 N
输出：异质性网络 G

1. 生成度分布：degree_dist = generate_degree_distribution(H, N)
2. 分配度数：assign_degrees(degree_dist)
3. 连接节点：connect_nodes_by_degree()
4. 验证异质性：verify_heterogeneity(G, H)
5. 返回网络：return G
```

### 6.2 异质性演化

**定义 6.2** (异质性演化)
**异质性演化**描述异质性的动态变化：
$$\frac{dH(t)}{dt} = f(H(t), \text{Environment})$$

**算法 6.2** (异质性演化模拟)

```text
输入：初始网络 G_0，演化参数 P
输出：演化序列 {G_1, G_2, ..., G_T}

1. 初始化：G = G_0
2. 演化循环：for t = 1 to T do
   a. 计算异质性：H = compute_heterogeneity(G)
   b. 应用演化规则：G = apply_evolution_rules(G, H, P)
   c. 记录状态：record_state(G, t)
3. 返回序列：return evolution_sequence
```

## 7. 模体与异质性实现

### 7.1 Rust实现

**代码 7.1** (Rust模体检测)

```rust
use std::collections::HashMap;

#[derive(Clone, Debug)]
pub struct Motif {
    pub nodes: Vec<usize>,
    pub edges: Vec<(usize, usize)>,
    pub pattern: String,
}

pub struct MotifDetector {
    pub graph: Vec<Vec<usize>>,
    pub motif_size: usize,
}

impl MotifDetector {
    pub fn new(graph: Vec<Vec<usize>>, motif_size: usize) -> Self {
        MotifDetector { graph, motif_size }
    }
    
    pub fn detect_motifs(&self) -> Vec<Motif> {
        let mut motifs = Vec::new();
        let subgraphs = self.enumerate_subgraphs();
        
        for subgraph in subgraphs {
            let pattern = self.identify_pattern(&subgraph);
            let motif = Motif {
                nodes: subgraph.clone(),
                edges: self.extract_edges(&subgraph),
                pattern,
            };
            motifs.push(motif);
        }
        
        motifs
    }
    
    fn enumerate_subgraphs(&self) -> Vec<Vec<usize>> {
        let mut result = Vec::new();
        let mut visited = vec![false; self.graph.len()];
        
        for start in 0..self.graph.len() {
            self.dfs_subgraphs(start, &mut Vec::new(), &mut visited, &mut result);
        }
        
        result
    }
    
    fn dfs_subgraphs(&self, node: usize, current: &mut Vec<usize>, visited: &mut Vec<bool>, result: &mut Vec<Vec<usize>>) {
        if current.len() == self.motif_size {
            result.push(current.clone());
            return;
        }
        
        visited[node] = true;
        current.push(node);
        
        for &neighbor in &self.graph[node] {
            if !visited[neighbor] {
                self.dfs_subgraphs(neighbor, current, visited, result);
            }
        }
        
        current.pop();
        visited[node] = false;
    }
    
    fn identify_pattern(&self, subgraph: &[usize]) -> String {
        // 简化的模式识别
        if subgraph.len() == 3 {
            "triangle".to_string()
        } else {
            "unknown".to_string()
        }
    }
    
    fn extract_edges(&self, subgraph: &[usize]) -> Vec<(usize, usize)> {
        let mut edges = Vec::new();
        for &node in subgraph {
            for &neighbor in &self.graph[node] {
                if subgraph.contains(&neighbor) {
                    edges.push((node, neighbor));
                }
            }
        }
        edges
    }
}
```

### 7.2 Go实现

**代码 7.2** (Go异质性分析)

```go
package biologicalnetwork

import (
    "math"
    "sort"
)

type HeterogeneityAnalyzer struct {
    Graph [][]int
    Nodes int
}

type HeterogeneityMetrics struct {
    GiniCoefficient    float64
    ShannonEntropy     float64
    DegreeVariance     float64
    FunctionalDiversity float64
}

func NewHeterogeneityAnalyzer(graph [][]int) *HeterogeneityAnalyzer {
    return &HeterogeneityAnalyzer{
        Graph: graph,
        Nodes: len(graph),
    }
}

func (ha *HeterogeneityAnalyzer) AnalyzeHeterogeneity() *HeterogeneityMetrics {
    degreeDist := ha.computeDegreeDistribution()
    
    return &HeterogeneityMetrics{
        GiniCoefficient:    ha.computeGiniCoefficient(degreeDist),
        ShannonEntropy:     ha.computeShannonEntropy(degreeDist),
        DegreeVariance:     ha.computeDegreeVariance(degreeDist),
        FunctionalDiversity: ha.computeFunctionalDiversity(),
    }
}

func (ha *HeterogeneityAnalyzer) computeDegreeDistribution() map[int]int {
    degreeCount := make(map[int]int)
    
    for _, neighbors := range ha.Graph {
        degree := len(neighbors)
        degreeCount[degree]++
    }
    
    return degreeCount
}

func (ha *HeterogeneityAnalyzer) computeGiniCoefficient(degreeDist map[int]int) float64 {
    degrees := make([]int, 0)
    for degree, count := range degreeDist {
        for i := 0; i < count; i++ {
            degrees = append(degrees, degree)
        }
    }
    
    sort.Ints(degrees)
    
    n := len(degrees)
    if n == 0 {
        return 0.0
    }
    
    sum := 0.0
    for i, degree := range degrees {
        sum += float64(degree) * float64(2*i+1-n)
    }
    
    totalSum := 0.0
    for _, degree := range degrees {
        totalSum += float64(degree)
    }
    
    return sum / (2.0 * float64(n) * totalSum)
}

func (ha *HeterogeneityAnalyzer) computeShannonEntropy(degreeDist map[int]int) float64 {
    total := 0
    for _, count := range degreeDist {
        total += count
    }
    
    entropy := 0.0
    for _, count := range degreeDist {
        if count > 0 {
            p := float64(count) / float64(total)
            entropy -= p * math.Log2(p)
        }
    }
    
    return entropy
}

func (ha *HeterogeneityAnalyzer) computeDegreeVariance(degreeDist map[int]int) float64 {
    total := 0
    sum := 0.0
    for degree, count := range degreeDist {
        total += count
        sum += float64(degree * count)
    }
    
    mean := sum / float64(total)
    
    variance := 0.0
    for degree, count := range degreeDist {
        diff := float64(degree) - mean
        variance += diff * diff * float64(count)
    }
    
    return variance / float64(total)
}

func (ha *HeterogeneityAnalyzer) computeFunctionalDiversity() float64 {
    // 简化的功能多样性计算
    // 实际应用中需要基于功能注释
    return 0.5 // 示例值
}
```

## 8. 网络模体与异质性的结构化梳理、主要定理、极值、语义模型与自动化验证

### 8.1 结构化梳理

- 网络模体、异质性度量、模体检测、异质性分析、动态模体、加权模体等
- 属性：统计显著性、功能多样性、鲁棒性、适应性、效率

### 8.2 主要定理与极值

**定理 8.2.1（模体统计极值）**
最优模体检测算法在计算复杂度和检测精度之间达到平衡。

**定理 8.2.2（异质性极值）**
适度异质性使网络在鲁棒性和效率之间达到最优平衡。

**定理 8.2.3（功能多样性极值）**
最大功能多样性在资源约束下实现最优网络性能。

### 8.3 形式语义模型

- 网络模体$M=(V_M,E_M,P_M)$，异质性$H=(D,F,I)$，模体检测$D$，异质性分析$A$等
- 性质可用一阶/概率/统计逻辑公式表达，如$\forall M, Z(M)>2\implies\text{Significant}(M)$（统计显著性）
- 模体检测、异质性分析、功能评估等可形式化为范畴上的函子或逻辑推理过程

### 8.4 保持性与极值定理

**定理 8.4.1（模体映射下结构保持）**
模体映射$h:M_1\to M_2$保持统计显著性、功能模式等结构性性质。

**定理 8.4.2（异质性保持性）**
异质性保持映射$h:H_1\to H_2$保持多样性、鲁棒性等结构性性质。

### 8.5 自动化验证建议

- Coq/Lean等定理证明器可形式化模体检测、异质性分析、统计显著性、极值、保持性等定理。
- Rust/Go代码可实现模体检测、异质性分析、功能评估与自动化验证。

## 多模态表达与可视化

- **模体结构图**：用NetworkX/Gephi展示常见模体结构。
- **异质性热力图**：用Matplotlib绘制异质性分布。
- **动态模体动画**：用biological_network_visualizer.py生成模体演化动画。
- **自动化脚本建议**：
  - `scripts/biological_network_visualizer.py`：输入模体数据，输出结构图、热力图。
- **示例**：
  - Mermaid模体检测流程：

    ```mermaid
    graph TD;
      网络数据-->子图枚举;
      子图枚举-->模体识别;
      模体识别-->统计分析;
      统计分析-->功能注释;
    ```

---

*本文档提供了网络模体与异质性的完整理论框架和方法体系，为生物网络分析提供了理论基础。*

### 3.8.4 批判性分析

- ESU算法适合小规模模体枚举，大规模网络需用采样或并行优化。
- Rust/Go实现有助于高性能，但需注意递归深度与内存消耗。
- 模体统计显著性依赖于随机网络生成方法，需合理选择对照组。

## 3.9 网络模体与异质性的保持性定理与范畴结构

### 3.9.1 网络模体范畴结构

**定义 3.9.1.1（模体范畴）**：

- 对象：所有网络模体$M$
- 态射：模体嵌入$h:M_1\to M_2$，保持节点与边结构
- 满足范畴公理

### 3.9.2 模体保持性定理

**定理 3.9.2.1（嵌入下模体保持性）**
若$h:M_1\to M_2$为模体嵌入，且$M_1$为某网络$G$的模体，则$h(M_1)$在$h(G)$中仍为模体。

**证明：**

1. $h$为节点与边的单射，结构不变。
2. $M_1$在$G$中频繁出现，$h(M_1)$在$h(G)$中频繁出现。
$\boxed{\text{证毕}}$

### 3.9.3 异质性范畴结构

**定义 3.9.3.1（异质性范畴）**：

- 对象：带属性的网络$B=(G,F,R)$
- 态射：属性保持的网络同态$h:B_1\to B_2$，保持节点、边及属性映射

### 3.9.4 异质性保持性定理

**定理 3.9.4.1（同态下异质性保持）**
若$h:B_1\to B_2$为属性保持的网络同态，则$B_1$的异质性度量在$B_2$中保持。

**证明：**

1. $h$保持节点、边及属性映射，度分布、功能多样性等度量不变。
2. 若$B_2$异质性降低，则$B_1$经$h^{-1}$也降低，矛盾。
$\boxed{\text{证毕}}$

### 3.9.5 形式化语义模型

- 模体与异质性结构可视为范畴$\mathcal{M}$、$\mathcal{B}$的对象，嵌入/同态为态射。
- 性质可用一阶逻辑/属性逻辑公式描述。
- 检测与分析算法可形式化为范畴上的函子或逻辑推理过程。

### 3.9.6 自动化验证建议

- 可用Coq/Lean等定理证明器形式化模体/异质性保持性。
- Rust/Go代码可实现模体嵌入、异质性度量与自动验证。

### 3.9.7 多模态表达与可视化

- **网络模体结构图**：用NetworkX/Graphviz展示典型模体结构。
- **异质网络结构图**：用Cytoscape展示多类型节点/边。
- **自动化脚本建议**：
  - `scripts/biological_network_visualizer.py`：输入模体/异质网络数据，输出结构图。
- **示例**：
  - Mermaid模体结构：

    ```mermaid
    graph TD;
      Motif1-->Motif2;
      Motif2-->Motif3;
    ```
