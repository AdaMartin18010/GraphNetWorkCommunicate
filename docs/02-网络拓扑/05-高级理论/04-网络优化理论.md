# ç½‘ç»œä¼˜åŒ–ç†è®º / Network Optimization Theory

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä»‹ç»ç½‘ç»œä¼˜åŒ–ç†è®ºï¼ŒåŒ…æ‹¬ç½‘ç»œä¼˜åŒ–é—®é¢˜çš„å®šä¹‰ã€ä¼˜åŒ–ç›®æ ‡å’Œç®—æ³•å®ç°ã€‚

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [ç½‘ç»œä¼˜åŒ–ç†è®º / Network Optimization Theory](#ç½‘ç»œä¼˜åŒ–ç†è®º--network-optimization-theory)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [1. å½¢å¼åŒ–å®šä¹‰ / Formal Definition](#1-å½¢å¼åŒ–å®šä¹‰--formal-definition)
  - [2. ä¼˜åŒ–é—®é¢˜ç±»å‹ / Types of Optimization Problems](#2-ä¼˜åŒ–é—®é¢˜ç±»å‹--types-of-optimization-problems)
  - [3. ä¼˜åŒ–ç®—æ³• / Optimization Algorithms](#3-ä¼˜åŒ–ç®—æ³•--optimization-algorithms)
  - [4. åº”ç”¨åœºæ™¯ / Application Scenarios](#4-åº”ç”¨åœºæ™¯--application-scenarios)
  - [ğŸ”— **ç›¸å…³é“¾æ¥ / Related Links**](#-ç›¸å…³é“¾æ¥--related-links)

---

## 1. å½¢å¼åŒ–å®šä¹‰ / Formal Definition

### å®šä¹‰ 1.1 (ç½‘ç»œä¼˜åŒ–é—®é¢˜ / Network Optimization Problem)

**ç½‘ç»œä¼˜åŒ–é—®é¢˜**æ˜¯åœ¨ç»™å®šçº¦æŸæ¡ä»¶ä¸‹ï¼Œä¼˜åŒ–ç½‘ç»œçš„æŸä¸ªç›®æ ‡å‡½æ•°ã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š

$$\min_{G \in \mathcal{G}} f(G)$$

çº¦æŸæ¡ä»¶ï¼š
- $g_i(G) \leq 0, i = 1, \ldots, m$
- $h_j(G) = 0, j = 1, \ldots, p$

å…¶ä¸­ï¼š
- $\mathcal{G}$ æ˜¯ç½‘ç»œç©ºé—´
- $f$ æ˜¯ç›®æ ‡å‡½æ•°
- $g_i, h_j$ æ˜¯çº¦æŸå‡½æ•°

### å®šä¹‰ 1.2 (ç½‘ç»œè®¾è®¡é—®é¢˜ / Network Design Problem)

**ç½‘ç»œè®¾è®¡é—®é¢˜**æ˜¯è®¾è®¡æ»¡è¶³ç‰¹å®šè¦æ±‚çš„ç½‘ç»œç»“æ„ã€‚

### å®šä¹‰ 1.3 (ç½‘ç»œé‡æ„é—®é¢˜ / Network Reconfiguration Problem)

**ç½‘ç»œé‡æ„é—®é¢˜**æ˜¯åœ¨ç°æœ‰ç½‘ç»œåŸºç¡€ä¸Šï¼Œé€šè¿‡æ·»åŠ æˆ–åˆ é™¤è¾¹æ¥ä¼˜åŒ–ç½‘ç»œæ€§èƒ½ã€‚

---

## 2. ä¼˜åŒ–é—®é¢˜ç±»å‹ / Types of Optimization Problems

### 2.1 æœ€å°åŒ–å¹³å‡è·¯å¾„é•¿åº¦

**é—®é¢˜ 2.1** (æœ€å°åŒ–å¹³å‡è·¯å¾„é•¿åº¦)

ç»™å®šèŠ‚ç‚¹æ•° $n$ å’Œè¾¹æ•° $m$ï¼Œè®¾è®¡ç½‘ç»œä½¿å¾—å¹³å‡è·¯å¾„é•¿åº¦æœ€å°ï¼š

$$\min_{G: |V|=n, |E|=m} APL(G)$$

### 2.2 æœ€å¤§åŒ–ç½‘ç»œæ•ˆç‡

**é—®é¢˜ 2.2** (æœ€å¤§åŒ–ç½‘ç»œæ•ˆç‡)

$$\max_{G: |V|=n, |E|=m} E(G) = \frac{1}{n(n-1)} \sum_{u \neq v} \frac{1}{d(u, v)}$$

### 2.3 æœ€å°åŒ–ç½‘ç»œç›´å¾„

**é—®é¢˜ 2.3** (æœ€å°åŒ–ç½‘ç»œç›´å¾„)

$$\min_{G: |V|=n, |E|=m} \text{diameter}(G) = \max_{u, v} d(u, v)$$

### 2.4 æœ€å¤§åŒ–ç½‘ç»œéŸ§æ€§

**é—®é¢˜ 2.4** (æœ€å¤§åŒ–ç½‘ç»œéŸ§æ€§)

$$\max_{G: |V|=n, |E|=m} R(G) = \min_{S \subseteq V, |S| \leq k} \frac{f(G) - f(G \setminus S)}{f(G)}$$

---

## 3. ä¼˜åŒ–ç®—æ³• / Optimization Algorithms

### 3.1 è´ªå¿ƒç®—æ³•

**ç®—æ³• 3.1** (è´ªå¿ƒç½‘ç»œä¼˜åŒ–)

```python
from typing import List, Set, Tuple
import networkx as nx
import numpy as np

class NetworkOptimizer:
    """
    ç½‘ç»œä¼˜åŒ–å™¨ã€‚
    """

    def __init__(self, n: int, m: int):
        """
        åˆå§‹åŒ–ã€‚

        Args:
            n: èŠ‚ç‚¹æ•°
            m: è¾¹æ•°
        """
        self.n = n
        self.m = m

    def greedy_minimize_apl(self) -> nx.Graph:
        """
        è´ªå¿ƒç®—æ³•æœ€å°åŒ–å¹³å‡è·¯å¾„é•¿åº¦ã€‚

        Returns:
            ä¼˜åŒ–åçš„å›¾
        """
        # åˆå§‹åŒ–ç©ºå›¾
        G = nx.Graph()
        G.add_nodes_from(range(self.n))

        # è´ªå¿ƒåœ°æ·»åŠ è¾¹
        for _ in range(self.m):
            best_edge = None
            best_improvement = float('inf')

            # å°è¯•æ‰€æœ‰å¯èƒ½çš„è¾¹
            for u in range(self.n):
                for v in range(u + 1, self.n):
                    if not G.has_edge(u, v):
                        # æ·»åŠ è¾¹
                        G.add_edge(u, v)

                        # è®¡ç®—å¹³å‡è·¯å¾„é•¿åº¦
                        if nx.is_connected(G):
                            apl = nx.average_shortest_path_length(G)
                            improvement = apl
                        else:
                            improvement = float('inf')

                        # ç§»é™¤è¾¹
                        G.remove_edge(u, v)

                        if improvement < best_improvement:
                            best_improvement = improvement
                            best_edge = (u, v)

            if best_edge:
                G.add_edge(*best_edge)

        return G
```

### 3.2 æ¨¡æ‹Ÿé€€ç«ç®—æ³•

**ç®—æ³• 3.2** (æ¨¡æ‹Ÿé€€ç«ç½‘ç»œä¼˜åŒ–)

```python
    def simulated_annealing(self, objective_func, initial_temp: float = 100.0,
                           cooling_rate: float = 0.95, iterations: int = 1000) -> nx.Graph:
        """
        æ¨¡æ‹Ÿé€€ç«ç®—æ³•ä¼˜åŒ–ç½‘ç»œã€‚

        Args:
            objective_func: ç›®æ ‡å‡½æ•°
            initial_temp: åˆå§‹æ¸©åº¦
            cooling_rate: å†·å´ç‡
            iterations: è¿­ä»£æ¬¡æ•°

        Returns:
            ä¼˜åŒ–åçš„å›¾
        """
        # åˆå§‹åŒ–ï¼šéšæœºå›¾
        G = nx.gnm_random_graph(self.n, self.m)
        current_obj = objective_func(G)
        best_G = G.copy()
        best_obj = current_obj

        temp = initial_temp

        for i in range(iterations):
            # ç”Ÿæˆæ–°è§£ï¼šéšæœºæ·»åŠ æˆ–åˆ é™¤ä¸€æ¡è¾¹
            new_G = G.copy()

            if np.random.random() < 0.5 and new_G.number_of_edges() < self.m:
                # æ·»åŠ è¾¹
                non_edges = list(nx.non_edges(new_G))
                if non_edges:
                    edge = np.random.choice(len(non_edges))
                    new_G.add_edge(*non_edges[edge])
            elif new_G.number_of_edges() > 0:
                # åˆ é™¤è¾¹
                edges = list(new_G.edges())
                edge = np.random.choice(len(edges))
                new_G.remove_edge(*edges[edge])

            # è®¡ç®—æ–°ç›®æ ‡å€¼
            if nx.is_connected(new_G):
                new_obj = objective_func(new_G)

                # æ¥å—æˆ–æ‹’ç»
                if new_obj < current_obj or np.random.random() < np.exp(-(new_obj - current_obj) / temp):
                    G = new_G
                    current_obj = new_obj

                    if new_obj < best_obj:
                        best_G = new_G.copy()
                        best_obj = new_obj

            # é™ä½æ¸©åº¦
            temp *= cooling_rate

        return best_G
```

### 3.3 é—ä¼ ç®—æ³•

**ç®—æ³• 3.3** (é—ä¼ ç®—æ³•ç½‘ç»œä¼˜åŒ–)

```python
    def genetic_algorithm(self, objective_func, population_size: int = 50,
                        generations: int = 100, mutation_rate: float = 0.1) -> nx.Graph:
        """
        é—ä¼ ç®—æ³•ä¼˜åŒ–ç½‘ç»œã€‚

        Args:
            objective_func: ç›®æ ‡å‡½æ•°
            population_size: ç§ç¾¤å¤§å°
            generations: ä»£æ•°
            mutation_rate: å˜å¼‚ç‡

        Returns:
            ä¼˜åŒ–åçš„å›¾
        """
        # åˆå§‹åŒ–ç§ç¾¤
        population = [nx.gnm_random_graph(self.n, self.m) for _ in range(population_size)]

        for generation in range(generations):
            # è¯„ä¼°é€‚åº”åº¦
            fitness = [objective_func(G) for G in population]

            # é€‰æ‹©ï¼ˆè½®ç›˜èµŒé€‰æ‹©ï¼‰
            total_fitness = sum(fitness)
            probabilities = [f / total_fitness for f in fitness]

            # ç”Ÿæˆæ–°ç§ç¾¤
            new_population = []
            for _ in range(population_size):
                # é€‰æ‹©çˆ¶ä»£
                parent1 = population[np.random.choice(len(population), p=probabilities)]
                parent2 = population[np.random.choice(len(population), p=probabilities)]

                # äº¤å‰
                child = self.crossover(parent1, parent2)

                # å˜å¼‚
                if np.random.random() < mutation_rate:
                    child = self.mutate(child)

                new_population.append(child)

            population = new_population

        # è¿”å›æœ€ä¼˜è§£
        fitness = [objective_func(G) for G in population]
        best_idx = np.argmin(fitness)
        return population[best_idx]

    def crossover(self, parent1: nx.Graph, parent2: nx.Graph) -> nx.Graph:
        """
        äº¤å‰æ“ä½œã€‚

        Args:
            parent1: çˆ¶ä»£1
            parent2: çˆ¶ä»£2

        Returns:
            å­ä»£
        """
        child = nx.Graph()
        child.add_nodes_from(range(self.n))

        # åˆå¹¶çˆ¶ä»£çš„è¾¹
        edges1 = set(parent1.edges())
        edges2 = set(parent2.edges())
        common_edges = edges1 & edges2

        # æ·»åŠ å…±åŒè¾¹
        child.add_edges_from(common_edges)

        # éšæœºæ·»åŠ å…¶ä»–è¾¹ç›´åˆ°è¾¾åˆ°ç›®æ ‡è¾¹æ•°
        remaining_edges = list((edges1 | edges2) - common_edges)
        np.random.shuffle(remaining_edges)

        for edge in remaining_edges:
            if child.number_of_edges() >= self.m:
                break
            child.add_edge(*edge)

        return child

    def mutate(self, graph: nx.Graph) -> nx.Graph:
        """
        å˜å¼‚æ“ä½œã€‚

        Args:
            graph: åŸå›¾

        Returns:
            å˜å¼‚åçš„å›¾
        """
        mutated = graph.copy()

        # éšæœºåˆ é™¤ä¸€æ¡è¾¹
        if mutated.number_of_edges() > 0:
            edges = list(mutated.edges())
            edge = np.random.choice(len(edges))
            mutated.remove_edge(*edges[edge])

        # éšæœºæ·»åŠ ä¸€æ¡è¾¹
        non_edges = list(nx.non_edges(mutated))
        if non_edges and mutated.number_of_edges() < self.m:
            edge = np.random.choice(len(non_edges))
            mutated.add_edge(*non_edges[edge])

        return mutated
```

---

## 4. åº”ç”¨åœºæ™¯ / Application Scenarios

### 4.1 é€šä¿¡ç½‘ç»œè®¾è®¡

**é—®é¢˜**: è®¾è®¡é€šä¿¡ç½‘ç»œï¼Œæœ€å°åŒ–å»¶è¿Ÿï¼Œæœ€å¤§åŒ–å¯é æ€§ã€‚

**åº”ç”¨**: äº’è”ç½‘è·¯ç”±ã€ç§»åŠ¨é€šä¿¡ç½‘ç»œ

### 4.2 äº¤é€šç½‘ç»œä¼˜åŒ–

**é—®é¢˜**: ä¼˜åŒ–äº¤é€šç½‘ç»œï¼Œæœ€å°åŒ–æ—…è¡Œæ—¶é—´ï¼Œæœ€å¤§åŒ–æµé‡ã€‚

**åº”ç”¨**: åŸå¸‚äº¤é€šè§„åˆ’ã€ç‰©æµç½‘ç»œ

### 4.3 ç¤¾äº¤ç½‘ç»œåˆ†æ

**é—®é¢˜**: ä¼˜åŒ–ç¤¾äº¤ç½‘ç»œç»“æ„ï¼Œæœ€å¤§åŒ–ä¿¡æ¯ä¼ æ’­æ•ˆç‡ã€‚

**åº”ç”¨**: ç¤¾äº¤åª’ä½“ã€æ¨èç³»ç»Ÿ

---

## ğŸ”— **ç›¸å…³é“¾æ¥ / Related Links**

- [ç½‘ç»œéŸ§æ€§ç†è®º](03-ç½‘ç»œéŸ§æ€§ç†è®º.md)
- [ç½‘ç»œåŠ¨åŠ›å­¦æ§åˆ¶](01-ç½‘ç»œåŠ¨åŠ›å­¦/04-ç½‘ç»œåŠ¨åŠ›å­¦æ§åˆ¶.md)
- [ç½‘ç»œæ‹“æ‰‘é«˜çº§ç†è®ºä¸»ç›®å½•](README.md)
- [ç½‘ç»œæ‹“æ‰‘æ¨¡å—ä¸»é¡µ](../README.md)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
