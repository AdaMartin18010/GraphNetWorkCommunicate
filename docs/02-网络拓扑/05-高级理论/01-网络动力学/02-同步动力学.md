# åŒæ­¥åŠ¨åŠ›å­¦ / åŒæ­¥åŠ¨åŠ›å­¦

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä»‹ç»åŒæ­¥åŠ¨åŠ›å­¦çš„è¯¦ç»†ç†è®ºå’Œå®ç°ã€‚

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [åŒæ­¥åŠ¨åŠ›å­¦ / åŒæ­¥åŠ¨åŠ›å­¦](#åŒæ­¥åŠ¨åŠ›å­¦--åŒæ­¥åŠ¨åŠ›å­¦)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [åŒæ­¥åŠ¨åŠ›å­¦ / Synchronization Dynamics](#åŒæ­¥åŠ¨åŠ›å­¦--synchronization-dynamics)

---

## åŒæ­¥åŠ¨åŠ›å­¦ / Synchronization Dynamics

**å®šä¹‰ 5.1.4** (ç½‘ç»œåŒæ­¥ / Network Synchronization)

ç½‘ç»œä¸Šçš„**åŒæ­¥**æ˜¯æŒ‡ç½‘ç»œä¸­æ‰€æœ‰èŠ‚ç‚¹çš„çŠ¶æ€è¶‹äºä¸€è‡´ï¼š
$$\lim_{t \to \infty} |x_i(t) - x_j(t)| = 0 \quad \forall i, j$$

**Kuramotoæ¨¡å‹**ï¼š

$$\frac{d\theta_i}{dt} = \omega_i + K \sum_{j=1}^{n} A_{ij} \sin(\theta_j - \theta_i)$$

å…¶ä¸­ï¼š

- $\theta_i$ æ˜¯èŠ‚ç‚¹ $i$ çš„ç›¸ä½
- $\omega_i$ æ˜¯èŠ‚ç‚¹ $i$ çš„è‡ªç„¶é¢‘ç‡
- $K$ æ˜¯è€¦åˆå¼ºåº¦
- $A_{ij}$ æ˜¯é‚»æ¥çŸ©é˜µå…ƒç´ 

**åŒæ­¥æ¡ä»¶**ï¼š

ç½‘ç»œåŒæ­¥çš„å……åˆ†æ¡ä»¶ï¼š
$$K > K_c = \frac{\Delta \omega}{\lambda_2(L)}$$

å…¶ä¸­ï¼š

- $\Delta \omega = \max_i \omega_i - \min_i \omega_i$ æ˜¯é¢‘ç‡èŒƒå›´
- $\lambda_2(L)$ æ˜¯æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µçš„ç¬¬äºŒä¸ªæœ€å°ç‰¹å¾å€¼ï¼ˆä»£æ•°è¿é€šåº¦ï¼‰

**ç®—æ³•å®ç°**ï¼š

```python
import numpy as np
from typing import Dict, List
import scipy.sparse as sp
from scipy.sparse.csgraph import laplacian

class NetworkSynchronization:
    """
    ç½‘ç»œåŒæ­¥åŠ¨åŠ›å­¦å®ç°ã€‚
    """

    def __init__(self, graph: Dict[int, List[int]],
                 natural_frequencies: Dict[int, float] = None):
        """
        åˆå§‹åŒ–ç½‘ç»œåŒæ­¥æ¨¡å‹ã€‚

        Args:
            graph: å›¾çš„é‚»æ¥è¡¨è¡¨ç¤º
            natural_frequencies: èŠ‚ç‚¹çš„è‡ªç„¶é¢‘ç‡
        """
        self.graph = graph
        self.nodes = sorted(set(graph.keys()) |
                           {n for neighbors in graph.values() for n in neighbors})
        self.n = len(self.nodes)
        self.node_to_idx = {node: i for i, node in enumerate(self.nodes)}

        # æ„å»ºé‚»æ¥çŸ©é˜µ
        self.adj_matrix = self._build_adjacency_matrix()
        self.laplacian = laplacian(self.adj_matrix, normed=False)

        # è‡ªç„¶é¢‘ç‡
        if natural_frequencies is None:
            self.omega = {node: np.random.uniform(-1, 1) for node in self.nodes}
        else:
            self.omega = natural_frequencies

    def _build_adjacency_matrix(self) -> np.ndarray:
        """æ„å»ºé‚»æ¥çŸ©é˜µ"""
        A = np.zeros((self.n, self.n))
        for node, neighbors in self.graph.items():
            i = self.node_to_idx[node]
            for neighbor in neighbors:
                j = self.node_to_idx[neighbor]
                A[i, j] = 1
                A[j, i] = 1
        return A

    def kuramoto_model(self, K: float, dt: float = 0.01,
                      steps: int = 1000, initial_phases: Dict[int, float] = None) -> np.ndarray:
        """
        Kuramotoæ¨¡å‹æ¨¡æ‹Ÿã€‚

        Args:
            K: è€¦åˆå¼ºåº¦
            dt: æ—¶é—´æ­¥é•¿
            steps: æ¨¡æ‹Ÿæ­¥æ•°
            initial_phases: åˆå§‹ç›¸ä½

        Returns:
            ç›¸ä½æ—¶é—´åºåˆ—
        """
        # åˆå§‹åŒ–ç›¸ä½
        if initial_phases is None:
            theta = np.random.uniform(0, 2 * np.pi, self.n)
        else:
            theta = np.array([initial_phases.get(node, 0) for node in self.nodes])

        # è‡ªç„¶é¢‘ç‡å‘é‡
        omega_vec = np.array([self.omega[node] for node in self.nodes])

        history = np.zeros((steps, self.n))
        history[0] = theta

        for step in range(1, steps):
            dtheta = np.zeros(self.n)

            for i, node_i in enumerate(self.nodes):
                dtheta[i] = omega_vec[i]

                # è€¦åˆé¡¹
                for j, node_j in enumerate(self.nodes):
                    if self.adj_matrix[i, j] > 0:
                        dtheta[i] += K * np.sin(theta[j] - theta[i])

            theta += dtheta * dt
            theta = np.mod(theta, 2 * np.pi)  # ä¿æŒç›¸ä½åœ¨[0, 2Ï€]
            history[step] = theta

        return history

    def order_parameter(self, theta: np.ndarray) -> float:
        """
        è®¡ç®—åºå‚é‡ï¼ˆåŒæ­¥ç¨‹åº¦ï¼‰ã€‚

        Args:
            theta: ç›¸ä½å‘é‡

        Returns:
            åºå‚é‡å€¼ï¼ˆ0åˆ°1ä¹‹é—´ï¼Œ1è¡¨ç¤ºå®Œå…¨åŒæ­¥ï¼‰
        """
        r = np.abs(np.mean(np.exp(1j * theta)))
        return r

    def critical_coupling(self) -> float:
        """
        è®¡ç®—ä¸´ç•Œè€¦åˆå¼ºåº¦ã€‚

        Returns:
            ä¸´ç•Œè€¦åˆå¼ºåº¦K_c
        """
        # è®¡ç®—é¢‘ç‡èŒƒå›´
        omega_values = list(self.omega.values())
        delta_omega = max(omega_values) - min(omega_values)

        # è®¡ç®—æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µçš„ç¬¬äºŒä¸ªæœ€å°ç‰¹å¾å€¼
        eigenvals = np.linalg.eigvals(self.laplacian.toarray())
        eigenvals_sorted = np.sort(eigenvals)
        lambda_2 = eigenvals_sorted[1] if len(eigenvals_sorted) > 1 else eigenvals_sorted[0]

        if lambda_2 < 1e-10:
            return float('inf')  # å›¾ä¸è¿é€š

        K_c = delta_omega / lambda_2
        return K_c

# å¤æ‚åº¦åˆ†æ
# kuramoto_model: O(steps * n^2) - æ¯ä¸ªæ—¶é—´æ­¥éœ€è¦è®¡ç®—æ‰€æœ‰èŠ‚ç‚¹å¯¹çš„è€¦åˆ
# order_parameter: O(n)
# critical_coupling: O(n^3) - ç‰¹å¾å€¼è®¡ç®—
```

---

## ğŸš€ **æœ€æ–°ç ”ç©¶è¿›å±•ï¼ˆ2024-2025ï¼‰/ Latest Research Progress (2024-2025)**

### 1. Graphonç†è®ºä¸å¤§è§„æ¨¡éšæœºKuramotoç½‘ç»œï¼ˆ2025å¹´ï¼‰â­â­â­â­â­

#### 1.1 Graphonç†è®ºæ¡†æ¶

**æ¥æº**: arXiv 2025-03-01589, arXiv 2025-05-16213

**æ ¸å¿ƒåˆ›æ–°**:
- ä½¿ç”¨graphonç†è®ºåˆ†æå¤§è§„æ¨¡éšæœºKuramotoç½‘ç»œ
- ç¡®å®šåŒæ­¥è§£å‡ºç°çš„æ¡ä»¶
- å»ºç«‹æœ‰é™éšæœºç½‘ç»œä¸æ— é™å›¾ç³»ç»Ÿçš„è¿æ¥

**ç†è®ºæ¡†æ¶**:

**å®šä¹‰ 1.1** (Graphon / Graphon)

ä¸€ä¸ª**graphon**æ˜¯ä¸€ä¸ªå¯æµ‹å‡½æ•° $W: [0,1]^2 \to [0,1]$ï¼Œè¡¨ç¤ºå›¾çš„æé™å¯¹è±¡ã€‚

**å®šä¹‰ 1.2** (Graphon Kuramotoæ–¹ç¨‹ / Graphon Kuramoto Equation)

å¯¹äºgraphon $W$ å’Œè‡ªç„¶é¢‘ç‡åˆ†å¸ƒ $g(\omega)$ï¼Œgraphon Kuramotoæ–¹ç¨‹ä¸ºï¼š

$$\frac{\partial \theta(t, x)}{\partial t} = \omega(x) + K \int_0^1 W(x, y) \sin(\theta(t, y) - \theta(t, x)) dy$$

å…¶ä¸­ $\theta(t, x)$ æ˜¯ä½ç½® $x \in [0,1]$ åœ¨æ—¶é—´ $t$ çš„ç›¸ä½ã€‚

**å…³é”®å®šç†**:

**å®šç† 1.1** (åŒæ­¥åˆ†å²”çš„å­˜åœ¨æ€§ / Existence of Synchrony Bifurcations)

å¯¹äºå¤§è§„æ¨¡éšæœºKuramotoç½‘ç»œï¼Œå¦‚æœgraphonæ–¹ç¨‹å­˜åœ¨åŒæ­¥åˆ†å²”ï¼Œåˆ™å¯¹äºè¶³å¤Ÿå¤§çš„ç³»ç»Ÿè§„æ¨¡ï¼Œæœ‰é™éšæœºç½‘ç»œä¸­ä¹Ÿå­˜åœ¨ç›¸åº”çš„åŒæ­¥åˆ†å²”ã€‚

**è¯æ˜æ€è·¯**:
1. ä½¿ç”¨mean-fieldæ¨¡å‹å’Œæ— é™æŒ¯è¡å™¨æé™
2. è¯æ˜graphonæ–¹ç¨‹çš„åˆ†å²”åœ¨æœ‰é™ç½‘ç»œä¸­é‡ç°
3. ä½¿ç”¨ErdÅ‘s-RÃ©nyiéšæœºç½‘ç»œè¿›è¡Œè¯¦ç»†åº”ç”¨

**ç®—æ³•å®ç°**:

```python
import numpy as np
from scipy.integrate import odeint
from scipy.stats import uniform

class GraphonKuramotoModel:
    """
    Graphonç†è®ºæ¡†æ¶ä¸‹çš„Kuramotoæ¨¡å‹
    
    å‚è€ƒæ–‡çŒ®:
    - Bramburger, J. J., & Holzer, M. (2025). Capturing the critical coupling 
      of large random Kuramoto networks with graphons. arXiv:2503.01589
    """
    
    def __init__(self, graphon_func, frequency_distribution, K):
        """
        åˆå§‹åŒ–Graphon Kuramotoæ¨¡å‹
        
        å‚æ•°:
            graphon_func: Graphonå‡½æ•° W(x, y)
            frequency_distribution: è‡ªç„¶é¢‘ç‡åˆ†å¸ƒ g(omega)
            K: è€¦åˆå¼ºåº¦
        """
        self.W = graphon_func
        self.g = frequency_distribution
        self.K = K
    
    def graphon_kuramoto_ode(self, theta, t, x_positions):
        """
        Graphon Kuramotoæ–¹ç¨‹çš„ODEç³»ç»Ÿ
        
        å‚æ•°:
            theta: ç›¸ä½å‘é‡ [theta(x_1), ..., theta(x_n)]
            t: æ—¶é—´
            x_positions: ä½ç½®å‘é‡ [x_1, ..., x_n] in [0,1]
        
        è¿”å›:
            dtheta/dt
        """
        n = len(theta)
        dtheta_dt = np.zeros(n)
        
        # è‡ªç„¶é¢‘ç‡
        omega = np.array([self.g.rvs() for _ in range(n)])
        
        for i in range(n):
            dtheta_dt[i] = omega[i]
            
            # Graphonç§¯åˆ†é¡¹
            integral_term = 0.0
            for j in range(n):
                # ä½¿ç”¨æ•°å€¼ç§¯åˆ†è¿‘ä¼¼
                W_ij = self.W(x_positions[i], x_positions[j])
                integral_term += W_ij * np.sin(theta[j] - theta[i]) / n
            
            dtheta_dt[i] += self.K * integral_term
        
        return dtheta_dt
    
    def find_critical_coupling(self, x_positions, tolerance=1e-6):
        """
        å¯»æ‰¾ä¸´ç•Œè€¦åˆå¼ºåº¦
        
        å‚æ•°:
            x_positions: ä½ç½®å‘é‡
            tolerance: æ”¶æ•›å®¹å·®
        
        è¿”å›:
            K_c: ä¸´ç•Œè€¦åˆå¼ºåº¦
        """
        # ä½¿ç”¨äºŒåˆ†æœç´¢å¯»æ‰¾ä¸´ç•Œè€¦åˆå¼ºåº¦
        K_low = 0.0
        K_high = 10.0
        
        while K_high - K_low > tolerance:
            K_mid = (K_low + K_high) / 2
            self.K = K_mid
            
            # æ¨¡æ‹Ÿå¹¶æ£€æŸ¥æ˜¯å¦åŒæ­¥
            theta0 = np.random.uniform(0, 2*np.pi, len(x_positions))
            t_span = np.linspace(0, 100, 1000)
            sol = odeint(self.graphon_kuramoto_ode, theta0, t_span, 
                        args=(x_positions,))
            
            # è®¡ç®—æœ€ç»ˆåŒæ­¥ç¨‹åº¦
            final_order = self._order_parameter(sol[-1])
            
            if final_order > 0.9:  # åŒæ­¥
                K_high = K_mid
            else:  # ä¸åŒæ­¥
                K_low = K_mid
        
        return (K_low + K_high) / 2
    
    def _order_parameter(self, theta):
        """è®¡ç®—åºå‚é‡"""
        return np.abs(np.mean(np.exp(1j * theta)))
```

**åº”ç”¨æ¡ˆä¾‹**:

**æ¡ˆä¾‹1.1**: ErdÅ‘s-RÃ©nyiéšæœºç½‘ç»œ

å¯¹äºErdÅ‘s-RÃ©nyiéšæœºå›¾ $G(n, p)$ï¼Œå¯¹åº”çš„graphonä¸ºå¸¸æ•°å‡½æ•° $W(x, y) = p$ã€‚ç ”ç©¶å‘ç°ï¼Œå¹¶éæ‰€æœ‰åŒæ­¥åˆ†å²”éƒ½é€šè¿‡ç®€å•çš„co-dimension oneåˆ†å²”å‘ç”Ÿã€‚

**æ¡ˆä¾‹1.2**: å¤§è§„æ¨¡ç”Ÿç‰©ç½‘ç»œ

åœ¨ç¥ç»å…ƒç½‘ç»œä¸­ï¼Œgraphonç†è®ºå¯ä»¥é¢„æµ‹å¤§è§„æ¨¡ç½‘ç»œçš„åŒæ­¥è¡Œä¸ºï¼Œä¸ºç†è§£å¤§è„‘åŒæ­¥æœºåˆ¶æä¾›ç†è®ºæ¡†æ¶ã€‚

---

### 2. Transient Dynamicsä¸åŒæ­¥æ•ˆç‡ï¼ˆ2024å¹´ï¼‰â­â­â­â­â­

#### 2.1 Transverse Reactivityæ¦‚å¿µ

**æ¥æº**: Nature Communications 2024, arXiv 2024-04-16864

**æ ¸å¿ƒåˆ›æ–°**:
- ä»æ¸è¿‘ç¨³å®šæ€§è½¬å‘ç¬æ€è¡Œä¸ºåˆ†æ
- å¼•å…¥"transverse reactivity"é‡åŒ–å»åŒæ­¥æ‰°åŠ¨çš„å¢é•¿/è¡°å‡é€Ÿåº¦
- å¼•å…¥"network syncreactivity"åº¦é‡ç½‘ç»œæ‹“æ‰‘å¯¹åŒæ­¥æ•ˆç‡çš„å½±å“

**ç†è®ºå®šä¹‰**:

**å®šä¹‰ 2.1** (Transverse Reactivity / æ¨ªå‘ååº”æ€§)

**Transverse reactivity** $\rho_T(t)$ é‡åŒ–åœ¨åŒæ­¥æµå½¢ä¸Šï¼Œå»åŒæ­¥æ‰°åŠ¨çš„ç¬æ—¶å¢é•¿æˆ–è¡°å‡é€Ÿç‡ï¼š

$$\rho_T(t) = \max_{\|v\|=1, v \perp M} \frac{d}{dt} \|v(t)\|$$

å…¶ä¸­ $M$ æ˜¯åŒæ­¥æµå½¢ï¼Œ$v$ æ˜¯å‚ç›´äº $M$ çš„æ‰°åŠ¨å‘é‡ã€‚

**å®šä¹‰ 2.2** (Network Syncreactivity / ç½‘ç»œåŒæ­¥ååº”æ€§)

**Network syncreactivity** $\sigma(G)$ æ˜¯ç½‘ç»œæ‹“æ‰‘çš„ä¸€ä¸ªæ€§è´¨ï¼Œå®šä¹‰ä¸ºï¼š

$$\sigma(G) = \max_{i} \frac{\lambda_i(L)}{\lambda_2(L)}$$

å…¶ä¸­ $\lambda_i(L)$ æ˜¯æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µ $L$ çš„ç¬¬ $i$ ä¸ªç‰¹å¾å€¼ï¼Œ$\lambda_2(L)$ æ˜¯ä»£æ•°è¿é€šåº¦ã€‚

**å…³é”®å‘ç°**:

**å®šç† 2.1** (åŒæ­¥æ•ˆç‡ä¸Network Syncreactivity)

å…·æœ‰æ›´å¤§syncreactivityçš„ç½‘ç»œåœ¨åŒæ­¥æµå½¢ä¸Šçš„æ¯ä¸€ç‚¹éƒ½è¡¨ç°å‡ºæ›´å¤§çš„transverse reactivityï¼Œç‹¬ç«‹äºæŒ¯è¡å™¨åŠ¨åŠ›å­¦ã€‚

**è¯æ˜æ€è·¯**:
1. åˆ†æåŒæ­¥æµå½¢ä¸Šçš„çº¿æ€§åŒ–åŠ¨åŠ›å­¦
2. å»ºç«‹transverse reactivityä¸æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µç‰¹å¾å€¼çš„å…³ç³»
3. è¯æ˜syncreactivityæ˜¯æ‹“æ‰‘æ€§è´¨

**ç®—æ³•å®ç°**:

```python
import numpy as np
from scipy.sparse import csgraph
from scipy.linalg import eigh

class TransientSynchronizationAnalysis:
    """
    Transient Dynamicså’ŒåŒæ­¥æ•ˆç‡åˆ†æ
    
    å‚è€ƒæ–‡çŒ®:
    - Skardal, P. S., et al. (2024). The efficiency of synchronization dynamics 
      and the role of network syncreactivity. Nature Communications, 15, 52486.
    """
    
    def __init__(self, graph, natural_frequencies):
        """
        åˆå§‹åŒ–transient synchronizationåˆ†æ
        
        å‚æ•°:
            graph: å›¾çš„é‚»æ¥çŸ©é˜µ
            natural_frequencies: è‡ªç„¶é¢‘ç‡å‘é‡
        """
        self.graph = graph
        self.omega = natural_frequencies
        self.n = len(natural_frequencies)
        
        # è®¡ç®—æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µ
        self.L = csgraph.laplacian(graph, normed=False)
        
        # è®¡ç®—ç‰¹å¾å€¼å’Œç‰¹å¾å‘é‡
        eigenvals, eigenvecs = eigh(self.L.toarray())
        self.eigenvals = eigenvals
        self.eigenvecs = eigenvecs
    
    def network_syncreactivity(self):
        """
        è®¡ç®—network syncreactivity
        
        è¿”å›:
            sigma: network syncreactivityå€¼
        """
        lambda_2 = self.eigenvals[1]  # ä»£æ•°è¿é€šåº¦
        
        if lambda_2 < 1e-10:
            return float('inf')  # å›¾ä¸è¿é€š
        
        # è®¡ç®—æœ€å¤§ç‰¹å¾å€¼æ¯”
        sigma = np.max(self.eigenvals) / lambda_2
        
        return sigma
    
    def transverse_reactivity(self, theta, K):
        """
        è®¡ç®—transverse reactivity
        
        å‚æ•°:
            theta: å½“å‰ç›¸ä½å‘é‡
            K: è€¦åˆå¼ºåº¦
        
        è¿”å›:
            rho_T: transverse reactivityå€¼
        """
        # è®¡ç®—åŒæ­¥æµå½¢ä¸Šçš„çº¿æ€§åŒ–çŸ©é˜µ
        # å¯¹äºKuramotoæ¨¡å‹ï¼Œtransverse reactivityä¸æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µç›¸å…³
        
        # è®¡ç®—å¹³å‡ç›¸ä½
        theta_mean = np.mean(theta)
        
        # è®¡ç®—ç›¸ä½å·®
        delta_theta = theta - theta_mean
        
        # çº¿æ€§åŒ–çŸ©é˜µï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
        J = np.zeros((self.n, self.n))
        for i in range(self.n):
            for j in range(self.n):
                if i == j:
                    J[i, j] = -K * np.sum(self.graph[i, :]) * np.cos(delta_theta[i])
                else:
                    J[i, j] = K * self.graph[i, j] * np.cos(delta_theta[j] - delta_theta[i])
        
        # è®¡ç®—æœ€å¤§ç‰¹å¾å€¼çš„å®éƒ¨ï¼ˆtransverse reactivityçš„è¿‘ä¼¼ï¼‰
        eigenvals_J = np.linalg.eigvals(J)
        rho_T = np.max(np.real(eigenvals_J))
        
        return rho_T
    
    def dynamic_coupling_strategy(self, initial_K, target_sync=0.95, dt=0.01):
        """
        åŸºäºtransverse reactivityçš„åŠ¨æ€è€¦åˆç­–ç•¥
        
        å‚æ•°:
            initial_K: åˆå§‹è€¦åˆå¼ºåº¦
            target_sync: ç›®æ ‡åŒæ­¥ç¨‹åº¦
            dt: æ—¶é—´æ­¥é•¿
        
        è¿”å›:
            K_history: è€¦åˆå¼ºåº¦å†å²
            sync_history: åŒæ­¥ç¨‹åº¦å†å²
        """
        K = initial_K
        theta = np.random.uniform(0, 2*np.pi, self.n)
        
        K_history = [K]
        sync_history = [self._order_parameter(theta)]
        
        steps = 1000
        for step in range(steps):
            # è®¡ç®—transverse reactivity
            rho_T = self.transverse_reactivity(theta, K)
            
            # åŠ¨æ€è°ƒæ•´è€¦åˆå¼ºåº¦
            if rho_T > 0:  # å»åŒæ­¥
                K *= 1.1  # å¢åŠ è€¦åˆ
            else:  # åŒæ­¥
                K *= 0.99  # å‡å°‘è€¦åˆï¼ˆèŠ‚èƒ½ï¼‰
            
            # æ›´æ–°ç›¸ä½
            dtheta = self.omega + K * np.sum(
                self.graph * np.sin(theta[:, None] - theta[None, :]), axis=1
            )
            theta += dtheta * dt
            theta = np.mod(theta, 2 * np.pi)
            
            K_history.append(K)
            sync_history.append(self._order_parameter(theta))
        
        return np.array(K_history), np.array(sync_history)
    
    def _order_parameter(self, theta):
        """è®¡ç®—åºå‚é‡"""
        return np.abs(np.mean(np.exp(1j * theta)))
```

**æ€§èƒ½æå‡**:

- âœ… **åŠ¨æ€è€¦åˆç­–ç•¥**å¯ä»¥åŒæ­¥æ¯”å›ºå®šè€¦åˆå¤§å‡ ä¸ªæ•°é‡çº§çš„è€¦åˆå¼ºåº¦èŒƒå›´
- âœ… **èƒ½é‡æ•ˆç‡**æ˜¾è‘—æå‡
- âœ… **ç½‘ç»œæ‹“æ‰‘**æ˜¾è‘—å½±å“ç¬æ€åŠ¨åŠ›å­¦

**åº”ç”¨æ¡ˆä¾‹**:

**æ¡ˆä¾‹2.1**: ç”µåŠ›ç½‘ç»œåŒæ­¥

åœ¨ç”µåŠ›ç½‘ç»œä¸­ï¼Œä½¿ç”¨transient dynamicsåˆ†æå¯ä»¥ä¼˜åŒ–åŒæ­¥æ•ˆç‡ï¼Œå‡å°‘èƒ½é‡æ¶ˆè€—ã€‚

**æ¡ˆä¾‹2.2**: ç”Ÿç‰©èŠ‚å¾‹ç½‘ç»œ

åœ¨ç”Ÿç‰©èŠ‚å¾‹ç½‘ç»œä¸­ï¼Œnetwork syncreactivityå¯ä»¥é¢„æµ‹ç½‘ç»œçš„åŒæ­¥æ•ˆç‡ï¼Œä¸ºç†è§£ç”Ÿç‰©é’Ÿæœºåˆ¶æä¾›æ–°è§†è§’ã€‚

---

### 3. Complex Synchronization Statesï¼ˆ2024å¹´ï¼‰â­â­â­â­â­

#### 3.1 Complex Kuramotoæ¨¡å‹

**æ¥æº**: arXiv 2024-03-02006

**æ ¸å¿ƒåˆ›æ–°**:
- å…è®¸å¤æ•°å€¼çŠ¶æ€å˜é‡å’Œå‚æ•°çš„Kuramotoæ¨¡å‹æ¨å¹¿
- å‘ç°æ–°çš„"complex locked states"
- æ­ç¤ºå¤§ç½‘ç»œä¸­çš„ä¸è¿ç»­ç›¸å˜

**ç†è®ºå®šä¹‰**:

**å®šä¹‰ 3.1** (Complex Kuramotoæ¨¡å‹ / Complex Kuramoto Model)

**Complex Kuramotoæ¨¡å‹**å…è®¸å¤æ•°å€¼ç›¸ä½å’Œè€¦åˆï¼š

$$\frac{dz_i}{dt} = \omega_i + K \sum_{j=1}^{n} A_{ij} \sin(z_j - z_i)$$

å…¶ä¸­ $z_i \in \mathbb{C}$ æ˜¯å¤æ•°å€¼ç›¸ä½ï¼Œ$K \in \mathbb{C}$ æ˜¯å¤æ•°å€¼è€¦åˆå¼ºåº¦ã€‚

**å…³é”®å‘ç°**:

**å®šç† 3.1** (çº¯è™šæ•°è€¦åˆçš„å¼‚æ­¥æ€§)

å¯¹äºçº¯è™šæ•°è€¦åˆ $K = iK_0$ï¼ˆ$K_0 \in \mathbb{R}$ï¼‰ï¼Œç³»ç»Ÿä¿æŒå¼‚æ­¥ï¼Œæ— è®ºè€¦åˆå¼ºåº¦å¦‚ä½•ã€‚

**è¯æ˜æ€è·¯**:
1. åˆ†æå¤æ•°å€¼ç›¸ä½çš„åŠ¨åŠ›å­¦
2. è¯æ˜çº¯è™šæ•°è€¦åˆæ— æ³•äº§ç”ŸåŒæ­¥
3. åˆ†æé€šç”¨å¤è€¦åˆçš„è¡Œä¸º

**å®šç† 3.2** (Complex Locked States)

å¯¹äºé€šç”¨å¤è€¦åˆï¼Œç³»ç»Ÿå¯ä»¥äº§ç”Ÿæ–°çš„"complex locked states"ï¼Œè¿™äº›çŠ¶æ€ä¸åœ¨å®å­ç©ºé—´ä¸­ã€‚

**ç®—æ³•å®ç°**:

```python
import numpy as np
from scipy.integrate import odeint

class ComplexKuramotoModel:
    """
    Complex Kuramotoæ¨¡å‹
    
    å‚è€ƒæ–‡çŒ®:
    - Complexified Synchrony (2024). arXiv:2403.02006
    """
    
    def __init__(self, graph, natural_frequencies, K_complex):
        """
        åˆå§‹åŒ–Complex Kuramotoæ¨¡å‹
        
        å‚æ•°:
            graph: å›¾çš„é‚»æ¥çŸ©é˜µ
            natural_frequencies: è‡ªç„¶é¢‘ç‡å‘é‡ï¼ˆå¯ä»¥æ˜¯å¤æ•°ï¼‰
            K_complex: å¤æ•°å€¼è€¦åˆå¼ºåº¦
        """
        self.graph = graph
        self.omega = natural_frequencies
        self.K = K_complex
        self.n = len(natural_frequencies)
    
    def complex_kuramoto_ode(self, z, t):
        """
        Complex Kuramotoæ–¹ç¨‹çš„ODEç³»ç»Ÿ
        
        å‚æ•°:
            z: å¤æ•°å€¼ç›¸ä½å‘é‡ [z_1, ..., z_n]
            t: æ—¶é—´
        
        è¿”å›:
            dz/dt
        """
        z = z.reshape(self.n, 2)  # [real, imag]
        z_complex = z[:, 0] + 1j * z[:, 1]
        
        dz_dt = np.zeros((self.n, 2), dtype=complex)
        
        for i in range(self.n):
            dz_dt[i] = self.omega[i]
            
            # å¤æ•°å€¼è€¦åˆé¡¹
            coupling_term = 0.0
            for j in range(self.n):
                if self.graph[i, j] > 0:
                    coupling_term += np.sin(z_complex[j] - z_complex[i])
            
            dz_dt[i] += self.K * coupling_term
        
        # è½¬æ¢ä¸ºå®å€¼å½¢å¼
        dz_dt_real = np.zeros((self.n, 2))
        dz_dt_real[:, 0] = np.real(dz_dt)
        dz_dt_real[:, 1] = np.imag(dz_dt)
        
        return dz_dt_real.flatten()
    
    def find_complex_locked_states(self, initial_z, t_span):
        """
        å¯»æ‰¾complex locked states
        
        å‚æ•°:
            initial_z: åˆå§‹å¤æ•°å€¼ç›¸ä½
            t_span: æ—¶é—´èŒƒå›´
        
        è¿”å›:
            z_history: ç›¸ä½å†å²
            locked_states: é”å®šçš„çŠ¶æ€
        """
        z0 = np.zeros((self.n, 2))
        z0[:, 0] = np.real(initial_z)
        z0[:, 1] = np.imag(initial_z)
        
        sol = odeint(self.complex_kuramoto_ode, z0.flatten(), t_span)
        
        z_history = sol.reshape(len(t_span), self.n, 2)
        z_complex_history = z_history[:, :, 0] + 1j * z_history[:, :, 1]
        
        # æ£€æµ‹locked states
        locked_states = []
        for i in range(len(t_span) - 1):
            phase_diff = np.abs(z_complex_history[i+1] - z_complex_history[i])
            if np.all(phase_diff < 1e-6):  # é”å®š
                locked_states.append(z_complex_history[i])
        
        return z_complex_history, locked_states
```

**åº”ç”¨æ¡ˆä¾‹**:

**æ¡ˆä¾‹3.1**: é‡å­åŒæ­¥

åœ¨é‡å­ç³»ç»Ÿä¸­ï¼Œcomplex Kuramotoæ¨¡å‹å¯ä»¥æè¿°é‡å­ç›¸ä½åŒæ­¥ï¼Œä¸ºé‡å­ç½‘ç»œåŒæ­¥æä¾›æ–°æ¡†æ¶ã€‚

---

### 4. Extreme Synchronization Transitionsï¼ˆ2025å¹´ï¼‰â­â­â­â­â­

#### 4.1 Extreme Transitionsç†è®º

**æ¥æº**: arXiv 2025-05-10114

**æ ¸å¿ƒåˆ›æ–°**:
- å‘ç°æœ‰é™ç³»ç»Ÿä¸­ä»æ— åºåˆ°é«˜åº¦åŒæ­¥çŠ¶æ€çš„æç«¯è·³è·ƒ
- åºå‚é‡ä»~N^(-1/2)è·³åˆ°æ¥è¿‘1
- åœ¨ç”Ÿç‰©å’Œå·¥ç¨‹ç³»ç»Ÿä¸­çš„åº”ç”¨

**ç†è®ºå®šä¹‰**:

**å®šä¹‰ 4.1** (Extreme Synchronization Transition / æç«¯åŒæ­¥è½¬å˜)

**Extreme synchronization transition**æ˜¯æœ‰é™ç³»ç»Ÿä¸­çš„ä¸€ç§ç›¸å˜ï¼Œå…¶ä¸­åºå‚é‡ $r$ åœ¨ä¸´ç•Œè€¦åˆå¼ºåº¦ $K_c$ å¤„ä» $r \sim N^{-1/2}$ è·³è·ƒåˆ° $r \approx 1$ã€‚

**å…³é”®å‘ç°**:

**å®šç† 4.1** (Extreme Transitionçš„å­˜åœ¨æ€§)

å¯¹äºæŸäº›ç½‘ç»œæ‹“æ‰‘å’Œé¢‘ç‡åˆ†å¸ƒï¼Œå­˜åœ¨extreme synchronization transitionï¼Œå…¶ä¸­åºå‚é‡åœ¨ä¸´ç•Œç‚¹å‘ç”Ÿä¸è¿ç»­è·³è·ƒã€‚

**ç®—æ³•å®ç°**:

```python
import numpy as np
from scipy.optimize import minimize_scalar

class ExtremeSynchronizationTransition:
    """
    Extreme Synchronization Transitionsåˆ†æ
    
    å‚è€ƒæ–‡çŒ®:
    - Extreme Synchronization Transitions (2025). arXiv:2505.10114
    """
    
    def __init__(self, graph, natural_frequencies):
        """
        åˆå§‹åŒ–extreme transitionåˆ†æ
        
        å‚æ•°:
            graph: å›¾çš„é‚»æ¥çŸ©é˜µ
            natural_frequencies: è‡ªç„¶é¢‘ç‡å‘é‡
        """
        self.graph = graph
        self.omega = natural_frequencies
        self.n = len(natural_frequencies)
    
    def find_extreme_transition(self, K_range, steps=1000):
        """
        å¯»æ‰¾extreme synchronization transition
        
        å‚æ•°:
            K_range: è€¦åˆå¼ºåº¦èŒƒå›´ (K_min, K_max)
            steps: æ¨¡æ‹Ÿæ­¥æ•°
        
        è¿”å›:
            K_values: è€¦åˆå¼ºåº¦å€¼
            order_params: åºå‚é‡å€¼
            transition_point: è½¬å˜ç‚¹
        """
        K_min, K_max = K_range
        K_values = np.linspace(K_min, K_max, 100)
        order_params = []
        
        for K in K_values:
            # æ¨¡æ‹ŸKuramotoæ¨¡å‹
            theta = np.random.uniform(0, 2*np.pi, self.n)
            dt = 0.01
            
            for _ in range(steps):
                dtheta = self.omega + K * np.sum(
                    self.graph * np.sin(theta[:, None] - theta[None, :]), axis=1
                )
                theta += dtheta * dt
                theta = np.mod(theta, 2 * np.pi)
            
            # è®¡ç®—åºå‚é‡
            r = np.abs(np.mean(np.exp(1j * theta)))
            order_params.append(r)
        
        order_params = np.array(order_params)
        
        # æ£€æµ‹extreme transitionï¼ˆåºå‚é‡çš„ä¸è¿ç»­è·³è·ƒï¼‰
        dr = np.diff(order_params)
        transition_idx = np.argmax(np.abs(dr))
        transition_point = K_values[transition_idx]
        
        return K_values, order_params, transition_point
```

**åº”ç”¨æ¡ˆä¾‹**:

**æ¡ˆä¾‹4.1**: ç”Ÿç‰©ç½‘ç»œåŒæ­¥

åœ¨ç¥ç»å…ƒç½‘ç»œä¸­ï¼Œextreme transitionså¯ä»¥è§£é‡Šçªç„¶çš„åŒæ­¥çˆ†å‘ï¼Œä¸ºç†è§£ç™«ç—«ç­‰ç–¾ç—…æä¾›æ–°è§†è§’ã€‚

**æ¡ˆä¾‹4.2**: å·¥ç¨‹ç³»ç»ŸåŒæ­¥

åœ¨å·¥ç¨‹ç³»ç»Ÿä¸­ï¼Œextreme transitionså¯ä»¥ç”¨äºè®¾è®¡é«˜æ•ˆçš„åŒæ­¥æ§åˆ¶ç­–ç•¥ã€‚

---

## ğŸ“š **å‚è€ƒæ–‡çŒ® / References**

### æœ€æ–°ç ”ç©¶è®ºæ–‡ï¼ˆ2024-2025ï¼‰

1. Bramburger, J. J., & Holzer, M. (2025). Capturing the critical coupling of large random Kuramoto networks with graphons. arXiv:2503.01589

2. Yagasaki, K. (2025). Continuum limit of the Kuramoto model with random natural frequencies on uniform graphs. arXiv:2505.16213

3. Skardal, P. S., et al. (2024). The efficiency of synchronization dynamics and the role of network syncreactivity. Nature Communications, 15, 52486. arXiv:2404.16864

4. Complexified Synchrony (2024). arXiv:2403.02006

5. Extreme Synchronization Transitions (2025). arXiv:2505.10114

---

**æ–‡æ¡£ç‰ˆæœ¬**: v2.0ï¼ˆ2025-01-28æ›´æ–°ï¼‰
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ28æ—¥
**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆï¼ˆå·²è¡¥å……2024-2025æœ€æ–°ç ”ç©¶ï¼‰
