# åŒæ­¥åŠ¨åŠ›å­¦ / åŒæ­¥åŠ¨åŠ›å­¦

## ðŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä»‹ç»åŒæ­¥åŠ¨åŠ›å­¦çš„è¯¦ç»†ç†è®ºå’Œå®žçŽ°ã€‚

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆ

---

## åŒæ­¥åŠ¨åŠ›å­¦ / Synchronization Dynamics

**å®šä¹‰ 5.1.4** (ç½‘ç»œåŒæ­¥ / Network Synchronization)

ç½‘ç»œä¸Šçš„**åŒæ­¥**æ˜¯æŒ‡ç½‘ç»œä¸­æ‰€æœ‰èŠ‚ç‚¹çš„çŠ¶æ€è¶‹äºŽä¸€è‡´ï¼š
$$\lim_{t \to \infty} |x_i(t) - x_j(t)| = 0 \quad \forall i, j$$

**Kuramotoæ¨¡åž‹**ï¼š

$$\frac{d\theta_i}{dt} = \omega_i + K \sum_{j=1}^{n} A_{ij} \sin(\theta_j - \theta_i)$$

å…¶ä¸­ï¼š

- $\theta_i$ æ˜¯èŠ‚ç‚¹ $i$ çš„ç›¸ä½
- $\omega_i$ æ˜¯èŠ‚ç‚¹ $i$ çš„è‡ªç„¶é¢‘çŽ‡
- $K$ æ˜¯è€¦åˆå¼ºåº¦
- $A_{ij}$ æ˜¯é‚»æŽ¥çŸ©é˜µå…ƒç´ 

**åŒæ­¥æ¡ä»¶**ï¼š

ç½‘ç»œåŒæ­¥çš„å……åˆ†æ¡ä»¶ï¼š
$$K > K_c = \frac{\Delta \omega}{\lambda_2(L)}$$

å…¶ä¸­ï¼š

- $\Delta \omega = \max_i \omega_i - \min_i \omega_i$ æ˜¯é¢‘çŽ‡èŒƒå›´
- $\lambda_2(L)$ æ˜¯æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µçš„ç¬¬äºŒä¸ªæœ€å°ç‰¹å¾å€¼ï¼ˆä»£æ•°è¿žé€šåº¦ï¼‰

**ç®—æ³•å®žçŽ°**ï¼š

```python
import numpy as np
from typing import Dict, List
import scipy.sparse as sp
from scipy.sparse.csgraph import laplacian

class NetworkSynchronization:
    """
    ç½‘ç»œåŒæ­¥åŠ¨åŠ›å­¦å®žçŽ°ã€‚
    """

    def __init__(self, graph: Dict[int, List[int]],
                 natural_frequencies: Dict[int, float] = None):
        """
        åˆå§‹åŒ–ç½‘ç»œåŒæ­¥æ¨¡åž‹ã€‚

        Args:
            graph: å›¾çš„é‚»æŽ¥è¡¨è¡¨ç¤º
            natural_frequencies: èŠ‚ç‚¹çš„è‡ªç„¶é¢‘çŽ‡
        """
        self.graph = graph
        self.nodes = sorted(set(graph.keys()) |
                           {n for neighbors in graph.values() for n in neighbors})
        self.n = len(self.nodes)
        self.node_to_idx = {node: i for i, node in enumerate(self.nodes)}

        # æž„å»ºé‚»æŽ¥çŸ©é˜µ
        self.adj_matrix = self._build_adjacency_matrix()
        self.laplacian = laplacian(self.adj_matrix, normed=False)

        # è‡ªç„¶é¢‘çŽ‡
        if natural_frequencies is None:
            self.omega = {node: np.random.uniform(-1, 1) for node in self.nodes}
        else:
            self.omega = natural_frequencies

    def _build_adjacency_matrix(self) -> np.ndarray:
        """æž„å»ºé‚»æŽ¥çŸ©é˜µ"""
        A = np.zeros((self.n, self.n))
        for node, neighbors in self.graph.items():
            i = self.node_to_idx[node]
            for neighbor in neighbors:
                j = self.node_to_idx[neighbor]
                A[i, j] = 1
                A[j, i] = 1
        return A

    def kuramoto_model(self, K: float, dt: float = 0.01,
                      steps: int = 1000, initial_phases: Dict[int, float] = None) -> np.ndarray:
        """
        Kuramotoæ¨¡åž‹æ¨¡æ‹Ÿã€‚

        Args:
            K: è€¦åˆå¼ºåº¦
            dt: æ—¶é—´æ­¥é•¿
            steps: æ¨¡æ‹Ÿæ­¥æ•°
            initial_phases: åˆå§‹ç›¸ä½

        Returns:
            ç›¸ä½æ—¶é—´åºåˆ—
        """
        # åˆå§‹åŒ–ç›¸ä½
        if initial_phases is None:
            theta = np.random.uniform(0, 2 * np.pi, self.n)
        else:
            theta = np.array([initial_phases.get(node, 0) for node in self.nodes])

        # è‡ªç„¶é¢‘çŽ‡å‘é‡
        omega_vec = np.array([self.omega[node] for node in self.nodes])

        history = np.zeros((steps, self.n))
        history[0] = theta

        for step in range(1, steps):
            dtheta = np.zeros(self.n)

            for i, node_i in enumerate(self.nodes):
                dtheta[i] = omega_vec[i]

                # è€¦åˆé¡¹
                for j, node_j in enumerate(self.nodes):
                    if self.adj_matrix[i, j] > 0:
                        dtheta[i] += K * np.sin(theta[j] - theta[i])

            theta += dtheta * dt
            theta = np.mod(theta, 2 * np.pi)  # ä¿æŒç›¸ä½åœ¨[0, 2Ï€]
            history[step] = theta

        return history

    def order_parameter(self, theta: np.ndarray) -> float:
        """
        è®¡ç®—åºå‚é‡ï¼ˆåŒæ­¥ç¨‹åº¦ï¼‰ã€‚

        Args:
            theta: ç›¸ä½å‘é‡

        Returns:
            åºå‚é‡å€¼ï¼ˆ0åˆ°1ä¹‹é—´ï¼Œ1è¡¨ç¤ºå®Œå…¨åŒæ­¥ï¼‰
        """
        r = np.abs(np.mean(np.exp(1j * theta)))
        return r

    def critical_coupling(self) -> float:
        """
        è®¡ç®—ä¸´ç•Œè€¦åˆå¼ºåº¦ã€‚

        Returns:
            ä¸´ç•Œè€¦åˆå¼ºåº¦K_c
        """
        # è®¡ç®—é¢‘çŽ‡èŒƒå›´
        omega_values = list(self.omega.values())
        delta_omega = max(omega_values) - min(omega_values)

        # è®¡ç®—æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µçš„ç¬¬äºŒä¸ªæœ€å°ç‰¹å¾å€¼
        eigenvals = np.linalg.eigvals(self.laplacian.toarray())
        eigenvals_sorted = np.sort(eigenvals)
        lambda_2 = eigenvals_sorted[1] if len(eigenvals_sorted) > 1 else eigenvals_sorted[0]

        if lambda_2 < 1e-10:
            return float('inf')  # å›¾ä¸è¿žé€š

        K_c = delta_omega / lambda_2
        return K_c

# å¤æ‚åº¦åˆ†æž
# kuramoto_model: O(steps * n^2) - æ¯ä¸ªæ—¶é—´æ­¥éœ€è¦è®¡ç®—æ‰€æœ‰èŠ‚ç‚¹å¯¹çš„è€¦åˆ
# order_parameter: O(n)
# critical_coupling: O(n^3) - ç‰¹å¾å€¼è®¡ç®—
```



---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**æœ€åŽæ›´æ–°**: 2025å¹´1æœˆ
**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆ
