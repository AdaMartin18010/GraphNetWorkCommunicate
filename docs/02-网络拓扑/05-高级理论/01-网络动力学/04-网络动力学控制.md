# ç½‘ç»œåŠ¨åŠ›å­¦æ§åˆ¶ / ç½‘ç»œåŠ¨åŠ›å­¦æ§åˆ¶

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä»‹ç»ç½‘ç»œåŠ¨åŠ›å­¦æ§åˆ¶çš„è¯¦ç»†ç†è®ºå’Œå®ç°ã€‚

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆ

---

## ç½‘ç»œåŠ¨åŠ›å­¦æ§åˆ¶ / Network Dynamics Control

**å®šä¹‰ 5.1.6** (ç½‘ç»œæ§åˆ¶ / Network Control)

**ç½‘ç»œæ§åˆ¶**é—®é¢˜æ˜¯åœ¨ç»™å®šæ§åˆ¶è¾“å…¥çš„æƒ…å†µä¸‹ï¼Œä½¿ç½‘ç»œçŠ¶æ€è¾¾åˆ°æœŸæœ›å€¼ã€‚

**çº¿æ€§æ—¶ä¸å˜ç½‘ç»œæ§åˆ¶**ï¼š

$$\frac{dx(t)}{dt} = Ax(t) + Bu(t)$$

å…¶ä¸­ï¼š

- $x(t)$ æ˜¯çŠ¶æ€å‘é‡
- $A$ æ˜¯ç½‘ç»œè€¦åˆçŸ©é˜µ
- $B$ æ˜¯æ§åˆ¶è¾“å…¥çŸ©é˜µ
- $u(t)$ æ˜¯æ§åˆ¶è¾“å…¥

**å¯æ§æ€§**ï¼š

ç³»ç»Ÿå¯æ§å½“ä¸”ä»…å½“å¯æ§æ€§çŸ©é˜µæ»¡ç§©ï¼š
$$\text{rank}([B, AB, A^2B, \ldots, A^{n-1}B]) = n$$

**ç®—æ³•å®ç°**ï¼š

```python
import numpy as np
from typing import List, Set

class NetworkControl:
    """
    ç½‘ç»œæ§åˆ¶ç†è®ºå®ç°ã€‚
    """

    def __init__(self, A: np.ndarray):
        """
        åˆå§‹åŒ–ç½‘ç»œæ§åˆ¶ç³»ç»Ÿã€‚

        Args:
            A: ç½‘ç»œè€¦åˆçŸ©é˜µ
        """
        self.A = A
        self.n = A.shape[0]

    def controllability_matrix(self, B: np.ndarray) -> np.ndarray:
        """
        æ„å»ºå¯æ§æ€§çŸ©é˜µã€‚

        Args:
            B: æ§åˆ¶è¾“å…¥çŸ©é˜µ

        Returns:
            å¯æ§æ€§çŸ©é˜µ
        """
        C = B.copy()
        current = B.copy()

        for i in range(1, self.n):
            current = self.A @ current
            C = np.hstack([C, current])

        return C

    def is_controllable(self, B: np.ndarray) -> bool:
        """
        æ£€æŸ¥ç³»ç»Ÿæ˜¯å¦å¯æ§ã€‚

        Args:
            B: æ§åˆ¶è¾“å…¥çŸ©é˜µ

        Returns:
            å¦‚æœå¯æ§è¿”å›True
        """
        C = self.controllability_matrix(B)
        rank = np.linalg.matrix_rank(C)
        return rank == self.n

    def minimum_control_nodes(self) -> List[int]:
        """
        æ‰¾åˆ°æœ€å°æ§åˆ¶èŠ‚ç‚¹é›†ï¼ˆç®€åŒ–ç‰ˆï¼Œä½¿ç”¨åº¦å¯å‘å¼ï¼‰ã€‚

        Returns:
            æ§åˆ¶èŠ‚ç‚¹åˆ—è¡¨
        """
        # ç®€åŒ–å®ç°ï¼šé€‰æ‹©åº¦æœ€å¤§çš„èŠ‚ç‚¹
        degrees = np.sum(np.abs(self.A), axis=1)
        control_nodes = np.argsort[degrees](::-1)[:int(np.ceil(self.n / 2))]
        return control_nodes.tolist()

# å¤æ‚åº¦åˆ†æ
# controllability_matrix: O(n^2 * m) å…¶ä¸­mæ˜¯æ§åˆ¶è¾“å…¥æ•°
# is_controllable: O(n^3) - çŸ©é˜µç§©è®¡ç®—
```

---



---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆ
