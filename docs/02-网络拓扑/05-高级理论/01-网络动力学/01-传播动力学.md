# ä¼ æ’­åŠ¨åŠ›å­¦ / ä¼ æ’­åŠ¨åŠ›å­¦

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä»‹ç»ä¼ æ’­åŠ¨åŠ›å­¦çš„è¯¦ç»†ç†è®ºå’Œå®ç°ã€‚

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [ä¼ æ’­åŠ¨åŠ›å­¦ / ä¼ æ’­åŠ¨åŠ›å­¦](#ä¼ æ’­åŠ¨åŠ›å­¦--ä¼ æ’­åŠ¨åŠ›å­¦)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [ä¼ æ’­åŠ¨åŠ›å­¦ / Propagation Dynamics](#ä¼ æ’­åŠ¨åŠ›å­¦--propagation-dynamics)
    - [5.1.1.1 SIRä¼ æ’­æ¨¡å‹](#5111-sirä¼ æ’­æ¨¡å‹)
      - [5.1.1.2 ä¿¡æ¯ä¼ æ’­æ¨¡å‹](#5112-ä¿¡æ¯ä¼ æ’­æ¨¡å‹)
  - [ğŸš€ **æœ€æ–°ç ”ç©¶è¿›å±•ï¼ˆ2024-2025ï¼‰/ Latest Research Progress (2024-2025)**](#-æœ€æ–°ç ”ç©¶è¿›å±•2024-2025-latest-research-progress-2024-2025)
    - [1. Networked Infectiousnessä¸Power-Lawåˆ†å¸ƒï¼ˆ2025å¹´ï¼‰â­â­â­â­â­](#1-networked-infectiousnessä¸power-lawåˆ†å¸ƒ2025å¹´)
      - [1.1 Power-Lawåˆ†å¸ƒç†è®º](#11-power-lawåˆ†å¸ƒç†è®º)
    - [2. Long TiesåŠ é€Ÿç¤¾ä¼šä¼ æ’­ï¼ˆ2024å¹´ï¼‰â­â­â­â­â­](#2-long-tiesåŠ é€Ÿç¤¾ä¼šä¼ æ’­2024å¹´)
      - [2.1 Long Tiesç†è®º](#21-long-tiesç†è®º)
    - [3. ICä¸SIRæ¨¡å‹æ·±å…¥å¯¹æ¯”ï¼ˆ2025å¹´ï¼‰â­â­â­â­â­](#3-icä¸siræ¨¡å‹æ·±å…¥å¯¹æ¯”2025å¹´)
      - [3.1 IC vs SIRæ¨¡å‹å¯¹æ¯”åˆ†æ](#31-ic-vs-siræ¨¡å‹å¯¹æ¯”åˆ†æ)
    - [4. Self-Reinforcing Cascadesï¼ˆ2024-2025å¹´ï¼‰â­â­â­â­â­](#4-self-reinforcing-cascades2024-2025å¹´)
      - [4.1 Self-Reinforcingæœºåˆ¶](#41-self-reinforcingæœºåˆ¶)
  - [ğŸ“š **å‚è€ƒæ–‡çŒ® / References**](#-å‚è€ƒæ–‡çŒ®--references)
    - [æœ€æ–°ç ”ç©¶è®ºæ–‡ï¼ˆ2024-2025ï¼‰](#æœ€æ–°ç ”ç©¶è®ºæ–‡2024-2025)

---

## ä¼ æ’­åŠ¨åŠ›å­¦ / Propagation Dynamics

**å®šä¹‰ 5.1.1** (ç½‘ç»œä¼ æ’­æ¨¡å‹ / Network Propagation Model)

ç½‘ç»œä¸Šçš„**ä¼ æ’­è¿‡ç¨‹**å¯ä»¥å»ºæ¨¡ä¸ºï¼š
$$\frac{dx_i(t)}{dt} = f_i(x_1(t), \ldots, x_n(t), A, \theta)$$

å…¶ä¸­ï¼š

- $x_i(t)$ æ˜¯èŠ‚ç‚¹ $i$ åœ¨æ—¶é—´ $t$ çš„çŠ¶æ€
- $A$ æ˜¯ç½‘ç»œçš„é‚»æ¥çŸ©é˜µ
- $\theta$ æ˜¯æ¨¡å‹å‚æ•°

### 5.1.1.1 SIRä¼ æ’­æ¨¡å‹

**å®šä¹‰ 5.1.2** (SIRæ¨¡å‹ / SIR Model)

**SIRæ¨¡å‹**ï¼ˆSusceptible-Infectious-Recoveredï¼‰å°†èŠ‚ç‚¹åˆ†ä¸ºä¸‰ç±»çŠ¶æ€ï¼š

- **æ˜“æ„Ÿè€…ï¼ˆSï¼‰**ï¼šå¯èƒ½è¢«æ„ŸæŸ“
- **æ„ŸæŸ“è€…ï¼ˆIï¼‰**ï¼šå·²ç»æ„ŸæŸ“å¹¶å¯ä¼ æ’­
- **åº·å¤è€…ï¼ˆRï¼‰**ï¼šå·²ç»åº·å¤ä¸”å…ç–«

**åŠ¨åŠ›å­¦æ–¹ç¨‹**ï¼š
$$
\begin{align}
\frac{dS_i}{dt} &= -\beta S_i \sum_{j} A_{ij} I_j \\
\frac{dI_i}{dt} &= \beta S_i \sum_{j} A_{ij} I_j - \gamma I_i \\
\frac{dR_i}{dt} &= \gamma I_i
\end{align}
$$

å…¶ä¸­ï¼š

- $\beta$ æ˜¯æ„ŸæŸ“ç‡
- $\gamma$ æ˜¯åº·å¤ç‡
- $A_{ij}$ æ˜¯é‚»æ¥çŸ©é˜µå…ƒç´ 

**åŸºæœ¬å†ç”Ÿæ•°**ï¼š
$$R_0 = \frac{\beta}{\gamma} \cdot \lambda_{\max}(A)$$

å…¶ä¸­ $\lambda_{\max}(A)$ æ˜¯é‚»æ¥çŸ©é˜µçš„æœ€å¤§ç‰¹å¾å€¼ã€‚

#### 5.1.1.2 ä¿¡æ¯ä¼ æ’­æ¨¡å‹

**å®šä¹‰ 5.1.3** (ç‹¬ç«‹çº§è”æ¨¡å‹ / Independent Cascade Model)

åœ¨**ç‹¬ç«‹çº§è”æ¨¡å‹**ä¸­ï¼Œæ¯ä¸ªæ¿€æ´»çš„èŠ‚ç‚¹æœ‰ä¸€æ¬¡æœºä¼šä»¥æ¦‚ç‡ $p_{ij}$ æ¿€æ´»å…¶é‚»å±…ã€‚

**ç®—æ³•æè¿°**ï¼š

1. åˆå§‹æ¿€æ´»ç§å­èŠ‚ç‚¹é›†
2. æ¯ä¸ªæ¿€æ´»èŠ‚ç‚¹ä»¥æ¦‚ç‡æ¿€æ´»æœªæ¿€æ´»é‚»å±…
3. é‡å¤æ­¥éª¤2ç›´åˆ°æ²¡æœ‰æ–°æ¿€æ´»èŠ‚ç‚¹

**é˜ˆå€¼æ¨¡å‹**ï¼ˆLinear Threshold Modelï¼‰ï¼š

æ¯ä¸ªèŠ‚ç‚¹ $i$ æœ‰ä¸€ä¸ªé˜ˆå€¼ $\theta_i \in [0, 1]$ï¼Œå½“æ¿€æ´»é‚»å±…çš„åŠ æƒæ¯”ä¾‹è¶…è¿‡é˜ˆå€¼æ—¶ï¼ŒèŠ‚ç‚¹è¢«æ¿€æ´»ã€‚

**ç®—æ³•å®ç°**ï¼š

```python
from typing import Dict, List, Set, Tuple
import numpy as np
import random
from collections import deque

class NetworkPropagation:
    """
    ç½‘ç»œä¼ æ’­åŠ¨åŠ›å­¦å®ç°ã€‚
    """

    def __init__(self, graph: Dict[int, List[int]],
                 edge_weights: Dict[Tuple[int, int], float] = None):
        """
        åˆå§‹åŒ–ç½‘ç»œä¼ æ’­æ¨¡å‹ã€‚

        Args:
            graph: å›¾çš„é‚»æ¥è¡¨è¡¨ç¤º
            edge_weights: è¾¹çš„æƒé‡å­—å…¸
        """
        self.graph = graph
        self.edge_weights = edge_weights if edge_weights else {}
        self.nodes = set(graph.keys())
        for neighbors in graph.values():
            self.nodes.update(neighbors)

    def sir_model(self, initial_infected: Set[int], beta: float, gamma: float,
                  steps: int = 100) -> Dict[int, List[int]]:
        """
        SIRä¼ æ’­æ¨¡å‹æ¨¡æ‹Ÿã€‚

        Args:
            initial_infected: åˆå§‹æ„ŸæŸ“è€…é›†åˆ
            beta: æ„ŸæŸ“ç‡
            gamma: åº·å¤ç‡
            steps: æ¨¡æ‹Ÿæ­¥æ•°

        Returns:
            æ¯ä¸ªæ—¶é—´æ­¥çš„Sã€Iã€Ræ•°é‡
        """
        # åˆå§‹åŒ–çŠ¶æ€ï¼š0=S, 1=I, 2=R
        state = {node: 0 for node in self.nodes}
        for node in initial_infected:
            if node in self.nodes:
                state[node] = 1

        history = {"S": [], "I": [], "R": []}

        for step in range(steps):
            # ç»Ÿè®¡å½“å‰çŠ¶æ€
            s_count = sum(1 for s in state.values() if s == 0)
            i_count = sum(1 for s in state.values() if s == 1)
            r_count = sum(1 for s in state.values() if s == 2)
            history["S"].append(s_count)
            history["I"].append(i_count)
            history["R"].append(r_count)

            # æ›´æ–°çŠ¶æ€
            new_state = dict(state)

            # æ„ŸæŸ“è€…å°è¯•æ„ŸæŸ“é‚»å±…
            for node in self.nodes:
                if state[node] == 1:  # æ„ŸæŸ“è€…
                    for neighbor in self.graph.get(node, []):
                        if state[neighbor] == 0:  # æ˜“æ„Ÿè€…
                            # è®¡ç®—æ„ŸæŸ“æ¦‚ç‡
                            if random.random() < beta:
                                new_state[neighbor] = 1

            # æ„ŸæŸ“è€…åº·å¤
            for node in self.nodes:
                if state[node] == 1:  # æ„ŸæŸ“è€…
                    if random.random() < gamma:
                        new_state[node] = 2  # åº·å¤è€…

            state = new_state

        return history

    def independent_cascade(self, seed_set: Set[int],
                           activation_prob: Dict[Tuple[int, int], float] = None) -> Set[int]:
        """
        ç‹¬ç«‹çº§è”æ¨¡å‹ã€‚

        Args:
            seed_set: åˆå§‹æ¿€æ´»èŠ‚ç‚¹é›†åˆ
            activation_prob: æ¿€æ´»æ¦‚ç‡å­—å…¸ï¼Œå¦‚æœä¸ºNoneåˆ™ä½¿ç”¨é»˜è®¤å€¼

        Returns:
            æœ€ç»ˆæ¿€æ´»çš„èŠ‚ç‚¹é›†åˆ
        """
        activated = set(seed_set)
        queue = deque(seed_set)

        # è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„æ¿€æ´»å°è¯•ï¼ˆæ¯ä¸ªèŠ‚ç‚¹åªèƒ½å°è¯•ä¸€æ¬¡ï¼‰
        attempts = {node: set() for node in self.nodes}

        while queue:
            current = queue.popleft()

            for neighbor in self.graph.get(current, []):
                if neighbor not in activated and neighbor not in attempts[current]:
                    # è·å–æ¿€æ´»æ¦‚ç‡
                    prob = activation_prob.get((current, neighbor), 0.5) if activation_prob else 0.5

                    attempts[current].add(neighbor)

                    if random.random() < prob:
                        activated.add(neighbor)
                        queue.append(neighbor)

        return activated

    def linear_threshold(self, seed_set: Set[int],
                        thresholds: Dict[int, float] = None,
                        edge_weights: Dict[Tuple[int, int], float] = None) -> Set[int]:
        """
        çº¿æ€§é˜ˆå€¼æ¨¡å‹ã€‚

        Args:
            seed_set: åˆå§‹æ¿€æ´»èŠ‚ç‚¹é›†åˆ
            thresholds: èŠ‚ç‚¹é˜ˆå€¼å­—å…¸ï¼Œå¦‚æœä¸ºNoneåˆ™éšæœºç”Ÿæˆ
            edge_weights: è¾¹æƒé‡å­—å…¸

        Returns:
            æœ€ç»ˆæ¿€æ´»çš„èŠ‚ç‚¹é›†åˆ
        """
        activated = set(seed_set)
        newly_activated = set(seed_set)

        # åˆå§‹åŒ–é˜ˆå€¼
        if thresholds is None:
            thresholds = {node: random.random() for node in self.nodes}

        # ä½¿ç”¨æä¾›çš„è¾¹æƒé‡æˆ–é»˜è®¤æƒé‡
        weights = edge_weights if edge_weights else self.edge_weights

        while newly_activated:
            next_newly_activated = set()

            for node in self.nodes:
                if node not in activated:
                    # è®¡ç®—æ¿€æ´»é‚»å±…çš„åŠ æƒå½±å“
                    influence = 0.0
                    total_weight = 0.0

                    for neighbor in self.graph.get(node, []):
                        if neighbor in activated:
                            weight = weights.get((neighbor, node), 1.0)
                            influence += weight
                            total_weight += weight

                    # å½’ä¸€åŒ–
                    if total_weight > 0:
                        normalized_influence = influence / total_weight
                        if normalized_influence >= thresholds[node]:
                            next_newly_activated.add(node)

            newly_activated = next_newly_activated
            activated.update(newly_activated)

        return activated

# å¤æ‚åº¦åˆ†æ
# sir_model: O(steps * (|V| + |E|))
# independent_cascade: O(|V| + |E|) (æœ€åæƒ…å†µ)
# linear_threshold: O(|V|^2) (æœ€åæƒ…å†µï¼Œæ¯æ¬¡è¿­ä»£å¯èƒ½æ¿€æ´»ä¸€ä¸ªèŠ‚ç‚¹)
```

---

## ğŸš€ **æœ€æ–°ç ”ç©¶è¿›å±•ï¼ˆ2024-2025ï¼‰/ Latest Research Progress (2024-2025)**

### 1. Networked Infectiousnessä¸Power-Lawåˆ†å¸ƒï¼ˆ2025å¹´ï¼‰â­â­â­â­â­

#### 1.1 Power-Lawåˆ†å¸ƒç†è®º

**æ¥æº**: arXiv 2025-05-10512

**æ ¸å¿ƒåˆ›æ–°**:

- SIRæ¨¡æ‹Ÿä¸­å‡ºç°è‡ªç»„ç»‡power-lawåˆ†å¸ƒ
- çº§è”æ¨¡å¼åœ¨ç–¾ç—…ä¼ æ’­ä¸­çš„è¡¨ç°
- åœ¨äº¤é€šç½‘ç»œä¸­çš„åº”ç”¨

**ç†è®ºå‘ç°**:

**å®šç† 1.1** (Power-Lawåˆ†å¸ƒçš„å‡ºç° / Emergence of Power-Law Distributions)

åœ¨SIRä¼ æ’­æ¨¡å‹ä¸­ï¼Œç–¾ç—…å¼ºåº¦çš„åˆ†å¸ƒå‘ˆç°è‡ªç»„ç»‡çš„power-lawåˆ†å¸ƒï¼š

$$P(I) \sim I^{-\alpha}$$

å…¶ä¸­ $I$ æ˜¯ç–¾ç—…å¼ºåº¦ï¼Œ$\alpha$ æ˜¯power-lawæŒ‡æ•°ã€‚

**è¯æ˜æ€è·¯**:

1. åˆ†æSIRæ¨¡å‹çš„çº§è”åŠ¨åŠ›å­¦
2. è¯æ˜è‡ªç»„ç»‡æœºåˆ¶å¯¼è‡´power-lawåˆ†å¸ƒ
3. åœ¨äº¤é€šç½‘ç»œä¸­éªŒè¯

**ç®—æ³•å®ç°**:

```python
import numpy as np
from scipy.stats import powerlaw
from collections import Counter

class PowerLawSIRModel:
    """
    Power-Lawåˆ†å¸ƒçš„SIRæ¨¡å‹

    å‚è€ƒæ–‡çŒ®:
    - Networked Infectiousness: Cascades, Power Laws, and Kinetics (2025)
      arXiv:2505.10512
    """

    def __init__(self, graph, beta, gamma):
        """
        åˆå§‹åŒ–Power-Law SIRæ¨¡å‹

        å‚æ•°:
            graph: å›¾çš„é‚»æ¥çŸ©é˜µ
            beta: æ„ŸæŸ“ç‡
            gamma: åº·å¤ç‡
        """
        self.graph = graph
        self.beta = beta
        self.gamma = gamma
        self.n = len(graph)

    def sir_simulation_with_powerlaw(self, initial_infected, steps=1000):
        """
        SIRæ¨¡æ‹Ÿå¹¶åˆ†æpower-lawåˆ†å¸ƒ

        å‚æ•°:
            initial_infected: åˆå§‹æ„ŸæŸ“è€…é›†åˆ
            steps: æ¨¡æ‹Ÿæ­¥æ•°

        è¿”å›:
            disease_strengths: ç–¾ç—…å¼ºåº¦åˆ†å¸ƒ
            powerlaw_exponent: Power-lawæŒ‡æ•°
        """
        # SIRæ¨¡æ‹Ÿ
        state = np.zeros(self.n)  # 0=S, 1=I, 2=R
        for node in initial_infected:
            state[node] = 1

        disease_strengths = []

        for step in range(steps):
            new_state = state.copy()

            # æ„ŸæŸ“è€…ä¼ æ’­
            for i in range(self.n):
                if state[i] == 1:  # æ„ŸæŸ“è€…
                    # è®¡ç®—ç–¾ç—…å¼ºåº¦ï¼ˆæ„ŸæŸ“çš„é‚»å±…æ•°ï¼‰
                    strength = np.sum(self.graph[i, :] * (state == 0))
                    disease_strengths.append(strength)

                    # æ„ŸæŸ“é‚»å±…
                    for j in range(self.n):
                        if self.graph[i, j] > 0 and state[j] == 0:
                            if np.random.random() < self.beta:
                                new_state[j] = 1

            # åº·å¤
            for i in range(self.n):
                if state[i] == 1:
                    if np.random.random() < self.gamma:
                        new_state[i] = 2

            state = new_state

        # åˆ†æpower-lawåˆ†å¸ƒ
        strength_counts = Counter(disease_strengths)
        strengths = np.array(list(strength_counts.keys()))
        counts = np.array(list(strength_counts.values()))

        # ä¼°è®¡power-lawæŒ‡æ•°
        if len(strengths) > 1:
            # ä½¿ç”¨æœ€å°äºŒä¹˜æ³•ä¼°è®¡
            log_strengths = np.log(strengths[strengths > 0])
            log_counts = np.log(counts[strengths > 0])
            alpha = -np.polyfit(log_strengths, log_counts, 1)[0]
        else:
            alpha = None

        return disease_strengths, alpha
```

**åº”ç”¨æ¡ˆä¾‹**:

**æ¡ˆä¾‹1.1**: äº¤é€šç½‘ç»œç–¾ç—…ä¼ æ’­

åœ¨äº¤é€šç½‘ç»œä¸­ï¼Œpower-lawåˆ†å¸ƒå¯ä»¥é¢„æµ‹ç–¾ç—…ä¼ æ’­çš„çº§è”æ¨¡å¼ï¼Œä¸ºåˆ¶å®šæ§åˆ¶ç­–ç•¥æä¾›ä¾æ®ã€‚

---

### 2. Long TiesåŠ é€Ÿç¤¾ä¼šä¼ æ’­ï¼ˆ2024å¹´ï¼‰â­â­â­â­â­

#### 2.1 Long Tiesç†è®º

**æ¥æº**: Nature Human Behaviour 2024

**æ ¸å¿ƒåˆ›æ–°**:

- è¿æ¥ä¸åŒç½‘ç»œåŒºåŸŸçš„é•¿è¿æ¥æ˜¾è‘—åŠ é€Ÿç¤¾ä¼šä¼ æ’­
- å³ä½¿éœ€è¦ç¤¾ä¼šå¼ºåŒ–çš„è¡Œä¸ºä¹Ÿé€‚ç”¨
- ç½‘ç»œç»“æ„ä»æ ¹æœ¬ä¸Šå¡‘é€ ä¿¡æ¯ä¼ æ’­

**ç†è®ºå‘ç°**:

**å®šç† 2.1** (Long Tiesçš„åŠ é€Ÿæ•ˆåº” / Acceleration Effect of Long Ties)

åœ¨ç½‘ç»œä¸­ï¼Œlong tiesï¼ˆè¿æ¥ä¸åŒç¤¾åŒºçš„é•¿è·ç¦»è¿æ¥ï¼‰å¯ä»¥æ˜¾è‘—åŠ é€Ÿç¤¾ä¼šä¼ æ’­ï¼Œå³ä½¿å¯¹äºéœ€è¦ç¤¾ä¼šå¼ºåŒ–çš„è¡Œä¸ºä¹Ÿæ˜¯å¦‚æ­¤ã€‚

**è¯æ˜æ€è·¯**:

1. åˆ†æç½‘ç»œç»“æ„å¯¹ä¼ æ’­çš„å½±å“
2. è¯æ˜long tiesæ‰“ç ´ç¤¾åŒºè¾¹ç•Œ
3. éªŒè¯ç¤¾ä¼šå¼ºåŒ–è¡Œä¸ºä¹Ÿå—ç›Šäºlong ties

**ç®—æ³•å®ç°**:

```python
import networkx as nx
import numpy as np

class LongTiesPropagation:
    """
    Long Tieså¯¹ä¼ æ’­çš„å½±å“åˆ†æ

    å‚è€ƒæ–‡çŒ®:
    - Long ties across networks accelerate the spread of social contagions
      Nature Human Behaviour 2024
    """

    def __init__(self, graph):
        """
        åˆå§‹åŒ–Long Tiesä¼ æ’­åˆ†æ

        å‚æ•°:
            graph: NetworkXå›¾å¯¹è±¡
        """
        self.graph = graph
        self.G = graph

    def identify_long_ties(self, communities):
        """
        è¯†åˆ«long ties

        å‚æ•°:
            communities: ç¤¾åŒºåˆ’åˆ†ï¼ˆèŠ‚ç‚¹åˆ°ç¤¾åŒºçš„æ˜ å°„ï¼‰

        è¿”å›:
            long_ties: Long tiesè¾¹åˆ—è¡¨
        """
        long_ties = []

        for u, v in self.G.edges():
            if communities[u] != communities[v]:  # è·¨ç¤¾åŒºè¿æ¥
                long_ties.append((u, v))

        return long_ties

    def compare_propagation_with_without_longties(self, seed_set,
                                                   activation_prob=0.5,
                                                   reinforcement_threshold=2):
        """
        æ¯”è¾ƒæœ‰/æ— long tiesçš„ä¼ æ’­æ•ˆæœ

        å‚æ•°:
            seed_set: åˆå§‹æ¿€æ´»èŠ‚ç‚¹é›†åˆ
            activation_prob: æ¿€æ´»æ¦‚ç‡
            reinforcement_threshold: ç¤¾ä¼šå¼ºåŒ–é˜ˆå€¼ï¼ˆéœ€è¦å¤šå°‘ä¸ªæ¿€æ´»é‚»å±…ï¼‰

        è¿”å›:
            spread_with: æœ‰long tiesçš„ä¼ æ’­èŒƒå›´
            spread_without: æ— long tiesçš„ä¼ æ’­èŒƒå›´
        """
        # æ£€æµ‹ç¤¾åŒº
        communities = nx.community.greedy_modularity_communities(self.G)
        community_dict = {}
        for i, comm in enumerate(communities):
            for node in comm:
                community_dict[node] = i

        # è¯†åˆ«long ties
        long_ties = self.identify_long_ties(community_dict)

        # æœ‰long tiesçš„ä¼ æ’­
        spread_with = self._reinforcement_cascade(
            seed_set, activation_prob, reinforcement_threshold
        )

        # æ— long tiesçš„ä¼ æ’­ï¼ˆç§»é™¤long tiesï¼‰
        G_no_longties = self.G.copy()
        G_no_longties.remove_edges_from(long_ties)

        spread_without = self._reinforcement_cascade(
            seed_set, activation_prob, reinforcement_threshold, G_no_longties
        )

        return len(spread_with), len(spread_without)

    def _reinforcement_cascade(self, seed_set, activation_prob,
                              reinforcement_threshold, graph=None):
        """
        ç¤¾ä¼šå¼ºåŒ–çº§è”æ¨¡å‹

        å‚æ•°:
            seed_set: åˆå§‹æ¿€æ´»èŠ‚ç‚¹é›†åˆ
            activation_prob: æ¿€æ´»æ¦‚ç‡
            reinforcement_threshold: å¼ºåŒ–é˜ˆå€¼
            graph: ä½¿ç”¨çš„å›¾ï¼ˆå¦‚æœä¸ºNoneåˆ™ä½¿ç”¨self.Gï¼‰

        è¿”å›:
            activated: æœ€ç»ˆæ¿€æ´»çš„èŠ‚ç‚¹é›†åˆ
        """
        if graph is None:
            graph = self.G

        activated = set(seed_set)
        queue = list(seed_set)

        while queue:
            current = queue.pop(0)

            for neighbor in graph.neighbors(current):
                if neighbor not in activated:
                    # è®¡ç®—æ¿€æ´»é‚»å±…æ•°ï¼ˆç¤¾ä¼šå¼ºåŒ–ï¼‰
                    activated_neighbors = sum(
                        1 for n in graph.neighbors(neighbor)
                        if n in activated
                    )

                    # å¦‚æœè¾¾åˆ°å¼ºåŒ–é˜ˆå€¼ï¼Œæ¿€æ´»æ¦‚ç‡å¢åŠ 
                    if activated_neighbors >= reinforcement_threshold:
                        prob = min(activation_prob * 2, 1.0)  # å¼ºåŒ–
                    else:
                        prob = activation_prob

                    if np.random.random() < prob:
                        activated.add(neighbor)
                        queue.append(neighbor)

        return activated
```

**åº”ç”¨æ¡ˆä¾‹**:

**æ¡ˆä¾‹2.1**: ç¤¾äº¤åª’ä½“ä¿¡æ¯ä¼ æ’­

åœ¨ç¤¾äº¤åª’ä½“ç½‘ç»œä¸­ï¼Œlong tieså¯ä»¥åŠ é€Ÿä¿¡æ¯çš„è·¨ç¤¾åŒºä¼ æ’­ï¼Œä¸ºç†è§£ç—…æ¯’å¼ä¼ æ’­æä¾›æ–°è§†è§’ã€‚

---

### 3. ICä¸SIRæ¨¡å‹æ·±å…¥å¯¹æ¯”ï¼ˆ2025å¹´ï¼‰â­â­â­â­â­

#### 3.1 IC vs SIRæ¨¡å‹å¯¹æ¯”åˆ†æ

**æ¥æº**: AAAI 2025

**æ ¸å¿ƒå‘ç°**:

- ICæ¨¡å‹äº§ç”Ÿæ¯”SIRæ¨¡å‹æ›´å¼ºçš„ä¼ æ’­
- SIRæ¨¡å‹çš„èŠ‚ç‚¹æ¢å¤ç‰¹å¾åˆ›å»º"outgoing-edge-correlated"æ„ŸæŸ“
- éœ€è¦ä¸“é—¨çš„å½±å“æœ€å¤§åŒ–ç®—æ³•

**ç†è®ºå¯¹æ¯”**:

**å®šä¹‰ 3.1** (Outgoing-Edge-Correlatedæ„ŸæŸ“ / Outgoing-Edge-Correlated Infections)

åœ¨SIRæ¨¡å‹ä¸­ï¼Œç”±äºèŠ‚ç‚¹çš„æ¢å¤ç‰¹å¾ï¼Œä»ä¸€ä¸ªèŠ‚ç‚¹å‡ºå‘çš„æ„ŸæŸ“äº‹ä»¶å˜å¾—**ç›¸å…³**ï¼Œè€Œåœ¨ICæ¨¡å‹ä¸­è¿™äº›äº‹ä»¶æ˜¯**ç‹¬ç«‹**çš„ã€‚

**å…³é”®å®šç†**:

**å®šç† 3.1** (IC vs SIRä¼ æ’­å¼ºåº¦)

åœ¨ç›¸åŒå‚æ•°å’Œè®¾ç½®ä¸‹ï¼ŒICæ¨¡å‹äº§ç”Ÿçš„ä¼ æ’­å¼ºåº¦**æ˜¾è‘—å¼ºäº**SIRæ¨¡å‹ã€‚

**è¯æ˜æ€è·¯**:

1. åˆ†æä¸¤ç§æ¨¡å‹çš„ä¾èµ–ç»“æ„
2. è¯æ˜SIRæ¨¡å‹çš„ä¾èµ–çº¦æŸé™åˆ¶äº†åŒæ—¶æ„ŸæŸ“
3. é‡åŒ–ä¼ æ’­å¼ºåº¦å·®å¼‚

**ç®—æ³•å®ç°**:

```python
import numpy as np
from typing import Set, Dict, Tuple

class ICvsSIRComparison:
    """
    ICä¸SIRæ¨¡å‹æ·±å…¥å¯¹æ¯”

    å‚è€ƒæ–‡çŒ®:
    - A Thorough Comparison Between Independent Cascade and
      Susceptible-Infected-Recovered Models (AAAI 2025)
    """

    def __init__(self, graph, activation_prob, beta, gamma):
        """
        åˆå§‹åŒ–IC vs SIRå¯¹æ¯”åˆ†æ

        å‚æ•°:
            graph: å›¾çš„é‚»æ¥çŸ©é˜µ
            activation_prob: ICæ¨¡å‹çš„æ¿€æ´»æ¦‚ç‡
            beta: SIRæ¨¡å‹çš„æ„ŸæŸ“ç‡
            gamma: SIRæ¨¡å‹çš„åº·å¤ç‡
        """
        self.graph = graph
        self.activation_prob = activation_prob
        self.beta = beta
        self.gamma = gamma
        self.n = len(graph)

    def ic_model_simulation(self, seed_set: Set[int]) -> Set[int]:
        """
        ICæ¨¡å‹æ¨¡æ‹Ÿ

        å‚æ•°:
            seed_set: åˆå§‹æ¿€æ´»èŠ‚ç‚¹é›†åˆ

        è¿”å›:
            activated: æœ€ç»ˆæ¿€æ´»çš„èŠ‚ç‚¹é›†åˆ
        """
        activated = set(seed_set)
        queue = list(seed_set)
        attempts = {node: set() for node in range(self.n)}

        while queue:
            current = queue.pop(0)

            for neighbor in range(self.n):
                if self.graph[current, neighbor] > 0:
                    if neighbor not in activated and neighbor not in attempts[current]:
                        attempts[current].add(neighbor)

                        if np.random.random() < self.activation_prob:
                            activated.add(neighbor)
                            queue.append(neighbor)

        return activated

    def sir_model_simulation(self, seed_set: Set[int], steps: int = 100) -> Set[int]:
        """
        SIRæ¨¡å‹æ¨¡æ‹Ÿ

        å‚æ•°:
            seed_set: åˆå§‹æ„ŸæŸ“è€…é›†åˆ
            steps: æ¨¡æ‹Ÿæ­¥æ•°

        è¿”å›:
            infected: æœ€ç»ˆæ„ŸæŸ“çš„èŠ‚ç‚¹é›†åˆï¼ˆåŒ…æ‹¬åº·å¤è€…ï¼‰
        """
        state = np.zeros(self.n)  # 0=S, 1=I, 2=R
        for node in seed_set:
            state[node] = 1

        for step in range(steps):
            new_state = state.copy()

            # æ„ŸæŸ“è€…ä¼ æ’­ï¼ˆoutgoing-edge-correlatedï¼‰
            for i in range(self.n):
                if state[i] == 1:  # æ„ŸæŸ“è€…
                    # æ‰€æœ‰é‚»å±…åŒæ—¶è¢«è€ƒè™‘ï¼ˆç›¸å…³äº‹ä»¶ï¼‰
                    neighbors_to_infect = []
                    for j in range(self.n):
                        if self.graph[i, j] > 0 and state[j] == 0:
                            if np.random.random() < self.beta:
                                neighbors_to_infect.append(j)

                    # åŒæ—¶æ„ŸæŸ“ï¼ˆç›¸å…³ï¼‰
                    for j in neighbors_to_infect:
                        new_state[j] = 1

                    # åº·å¤
                    if np.random.random() < self.gamma:
                        new_state[i] = 2

            state = new_state

        # è¿”å›æ‰€æœ‰æ›¾ç»æ„ŸæŸ“çš„èŠ‚ç‚¹
        infected = set(np.where(state > 0)[0])
        return infected

    def compare_models(self, seed_set: Set[int], num_trials: int = 100):
        """
        å¯¹æ¯”ICå’ŒSIRæ¨¡å‹

        å‚æ•°:
            seed_set: åˆå§‹ç§å­é›†åˆ
            num_trials: è¯•éªŒæ¬¡æ•°

        è¿”å›:
            ic_spread: ICæ¨¡å‹å¹³å‡ä¼ æ’­èŒƒå›´
            sir_spread: SIRæ¨¡å‹å¹³å‡ä¼ æ’­èŒƒå›´
            spread_ratio: ä¼ æ’­æ¯”ä¾‹ï¼ˆIC/SIRï¼‰
        """
        ic_spreads = []
        sir_spreads = []

        for trial in range(num_trials):
            ic_result = self.ic_model_simulation(seed_set)
            sir_result = self.sir_model_simulation(seed_set)

            ic_spreads.append(len(ic_result))
            sir_spreads.append(len(sir_result))

        ic_avg = np.mean(ic_spreads)
        sir_avg = np.mean(sir_spreads)
        ratio = ic_avg / sir_avg if sir_avg > 0 else float('inf')

        return ic_avg, sir_avg, ratio

    def sir_influence_maximization(self, k: int, steps: int = 100):
        """
        SIRæ¨¡å‹çš„å½±å“æœ€å¤§åŒ–ç®—æ³•

        å‚æ•°:
            k: ç§å­èŠ‚ç‚¹æ•°é‡
            steps: æ¨¡æ‹Ÿæ­¥æ•°

        è¿”å›:
            seed_set: æœ€ä¼˜ç§å­é›†åˆ
        """
        # ä½¿ç”¨è´ªå¿ƒç®—æ³•
        seed_set = set()

        for _ in range(k):
            best_node = None
            best_margin = -1

            for node in range(self.n):
                if node not in seed_set:
                    # è®¡ç®—è¾¹é™…å¢ç›Š
                    current_spread = self._estimate_sir_spread(
                        seed_set, steps, num_trials=50
                    )
                    new_spread = self._estimate_sir_spread(
                        seed_set | {node}, steps, num_trials=50
                    )
                    margin = new_spread - current_spread

                    if margin > best_margin:
                        best_margin = margin
                        best_node = node

            if best_node is not None:
                seed_set.add(best_node)

        return seed_set

    def _estimate_sir_spread(self, seed_set: Set[int], steps: int, num_trials: int):
        """ä¼°è®¡SIRæ¨¡å‹çš„ä¼ æ’­èŒƒå›´"""
        spreads = []
        for _ in range(num_trials):
            result = self.sir_model_simulation(seed_set, steps)
            spreads.append(len(result))
        return np.mean(spreads)
```

**åº”ç”¨æ¡ˆä¾‹**:

**æ¡ˆä¾‹3.1**: ç¤¾äº¤åª’ä½“å½±å“æœ€å¤§åŒ–

åœ¨ç¤¾äº¤åª’ä½“ä¸­ï¼ŒICæ¨¡å‹æ›´é€‚åˆä¿¡æ¯ä¼ æ’­ï¼Œè€ŒSIRæ¨¡å‹æ›´é€‚åˆç–¾ç—…ä¼ æ’­ã€‚é€‰æ‹©æ­£ç¡®çš„æ¨¡å‹å¯¹å½±å“æœ€å¤§åŒ–è‡³å…³é‡è¦ã€‚

---

### 4. Self-Reinforcing Cascadesï¼ˆ2024-2025å¹´ï¼‰â­â­â­â­â­

#### 4.1 Self-Reinforcingæœºåˆ¶

**æ¥æº**: arXiv 2024-11-00714

**æ ¸å¿ƒåˆ›æ–°**:

- ä¿¡æ¯é€šè¿‡è‡ªå¼ºåŒ–æœºåˆ¶è·å¾—æˆ–å¤±å»åŠ¨é‡
- äº§ç”Ÿç±»ä¸´ç•Œè¡Œä¸º
- éé€šç”¨power-lawæŒ‡æ•°
- è§£é‡Šç»éªŒç¤¾ä¼šæ•°æ®ä¸­power-lawåˆ†å¸ƒçš„æ™®éæ€§

**ç†è®ºå®šä¹‰**:

**å®šä¹‰ 4.1** (Self-Reinforcing Cascade / è‡ªå¼ºåŒ–çº§è”)

**Self-reinforcing cascade**æ˜¯ä¸€ç§ä¼ æ’­æ¨¡å‹ï¼Œå…¶ä¸­ä¼ è¾“æœºåˆ¶éšç€æƒ³æ³•ã€ä¿¡å¿µæˆ–äº§å“çš„ä¼ æ’­è€Œ**åŠ å¼º**ã€‚

**åŠ¨åŠ›å­¦æ–¹ç¨‹**:

$$\frac{dI_i(t)}{dt} = \beta(I_i(t)) \sum_{j} A_{ij} I_j(t)$$

å…¶ä¸­ $\beta(I_i(t))$ æ˜¯ä¾èµ–äºå½“å‰æ„ŸæŸ“æ°´å¹³çš„**åŠ¨æ€æ„ŸæŸ“ç‡**ï¼š

$$\beta(I_i(t)) = \beta_0 \cdot (1 + \alpha \cdot I_i(t))$$

**å…³é”®å‘ç°**:

**å®šç† 4.1** (Power-Lawåˆ†å¸ƒçš„å‡ºç°)

Self-reinforcing cascadesåœ¨å¹¿æ³›çš„å‚æ•°èŒƒå›´å†…äº§ç”Ÿpower-lawçº§è”å¤§å°åˆ†å¸ƒï¼Œå…·æœ‰**éé€šç”¨**çš„scalingæŒ‡æ•°ï¼Œä¸éœ€è¦åœ¨ç²¾ç¡®ä¸´ç•Œç‚¹è¿›è¡Œå¾®è°ƒã€‚

**ç®—æ³•å®ç°**:

```python
import numpy as np
from scipy.stats import powerlaw

class SelfReinforcingCascade:
    """
    Self-Reinforcing Cascadesæ¨¡å‹

    å‚è€ƒæ–‡çŒ®:
    - Self-Reinforcing Cascades (2024-2025). arXiv:2411.00714
    """

    def __init__(self, graph, beta_0, alpha):
        """
        åˆå§‹åŒ–Self-Reinforcing Cascadeæ¨¡å‹

        å‚æ•°:
            graph: å›¾çš„é‚»æ¥çŸ©é˜µ
            beta_0: åŸºç¡€æ„ŸæŸ“ç‡
            alpha: å¼ºåŒ–ç³»æ•°
        """
        self.graph = graph
        self.beta_0 = beta_0
        self.alpha = alpha
        self.n = len(graph)

    def self_reinforcing_simulation(self, seed_set, steps=1000):
        """
        Self-Reinforcing Cascadeæ¨¡æ‹Ÿ

        å‚æ•°:
            seed_set: åˆå§‹æ¿€æ´»èŠ‚ç‚¹é›†åˆ
            steps: æ¨¡æ‹Ÿæ­¥æ•°

        è¿”å›:
            cascade_sizes: çº§è”å¤§å°å†å²
            powerlaw_exponent: Power-lawæŒ‡æ•°
        """
        I = np.zeros(self.n)  # æ„ŸæŸ“æ°´å¹³
        for node in seed_set:
            I[node] = 1.0

        cascade_sizes = [np.sum(I)]

        for step in range(steps):
            dI = np.zeros(self.n)

            for i in range(self.n):
                if I[i] > 0:  # å·²æ¿€æ´»èŠ‚ç‚¹
                    # åŠ¨æ€æ„ŸæŸ“ç‡ï¼ˆè‡ªå¼ºåŒ–ï¼‰
                    beta_i = self.beta_0 * (1 + self.alpha * I[i])

                    # ä¼ æ’­åˆ°é‚»å±…
                    for j in range(self.n):
                        if self.graph[i, j] > 0 and I[j] < 1.0:
                            dI[j] += beta_i * I[i] * (1 - I[j])

            I += dI
            I = np.clip(I, 0, 1)  # é™åˆ¶åœ¨[0, 1]

            cascade_sizes.append(np.sum(I))

        # åˆ†æpower-lawåˆ†å¸ƒ
        final_sizes = cascade_sizes[-100:]  # ä½¿ç”¨æœ€å100ä¸ªæ—¶é—´æ­¥
        size_counts = {}
        for size in final_sizes:
            size_counts[int(size)] = size_counts.get(int(size), 0) + 1

        if len(size_counts) > 1:
            sizes = np.array(list(size_counts.keys()))
            counts = np.array(list(size_counts.values()))
            log_sizes = np.log(sizes[sizes > 0])
            log_counts = np.log(counts[sizes > 0])
            exponent = -np.polyfit(log_sizes, log_counts, 1)[0]
        else:
            exponent = None

        return cascade_sizes, exponent
```

**åº”ç”¨æ¡ˆä¾‹**:

**æ¡ˆä¾‹4.1**: ç¤¾äº¤åª’ä½“ç—…æ¯’å¼ä¼ æ’­

åœ¨ç¤¾äº¤åª’ä½“ä¸­ï¼Œself-reinforcingæœºåˆ¶å¯ä»¥è§£é‡Šä¸ºä»€ä¹ˆæŸäº›å†…å®¹ä¼šçªç„¶çˆ†å‘å¼ä¼ æ’­ï¼Œè€Œå…¶ä»–å†…å®¹åˆ™è¿…é€Ÿæ¶ˆå¤±ã€‚

**æ¡ˆä¾‹4.2**: äº§å“é‡‡ç”¨

åœ¨äº§å“é‡‡ç”¨ä¸­ï¼Œself-reinforcingæœºåˆ¶å¯ä»¥è§£é‡Šä¸ºä»€ä¹ˆæŸäº›äº§å“ä¼šå¿«é€Ÿè·å¾—å¸‚åœºä»½é¢ï¼Œè€Œå…¶ä»–äº§å“åˆ™å¤±è´¥ã€‚

---

## ğŸ“š **å‚è€ƒæ–‡çŒ® / References**

### æœ€æ–°ç ”ç©¶è®ºæ–‡ï¼ˆ2024-2025ï¼‰

1. Networked Infectiousness: Cascades, Power Laws, and Kinetics (arXiv 2025-05-10512)

2. Long ties across networks accelerate the spread of social contagions (Nature Human Behaviour 2024)

3. A Thorough Comparison Between Independent Cascade and Susceptible-Infected-Recovered Models (AAAI 2025)

4. Self-Reinforcing Cascades (arXiv 2024-11-00714)

5. Heterogeneous update processes shape information cascades in social networks (Nature Scientific Reports 2025)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v2.0ï¼ˆ2025-01-28æ›´æ–°ï¼‰
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ28æ—¥
**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆï¼ˆå·²è¡¥å……2024-2025æœ€æ–°ç ”ç©¶ï¼‰
