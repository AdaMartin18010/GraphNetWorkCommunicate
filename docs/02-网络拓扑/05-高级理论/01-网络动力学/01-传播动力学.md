# ä¼ æ’­åŠ¨åŠ›å­¦ / ä¼ æ’­åŠ¨åŠ›å­¦

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä»‹ç»ä¼ æ’­åŠ¨åŠ›å­¦çš„è¯¦ç»†ç†è®ºå’Œå®ç°ã€‚

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [ä¼ æ’­åŠ¨åŠ›å­¦ / ä¼ æ’­åŠ¨åŠ›å­¦](#ä¼ æ’­åŠ¨åŠ›å­¦--ä¼ æ’­åŠ¨åŠ›å­¦)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [ä¼ æ’­åŠ¨åŠ›å­¦ / Propagation Dynamics](#ä¼ æ’­åŠ¨åŠ›å­¦--propagation-dynamics)

---

## ä¼ æ’­åŠ¨åŠ›å­¦ / Propagation Dynamics

**å®šä¹‰ 5.1.1** (ç½‘ç»œä¼ æ’­æ¨¡å‹ / Network Propagation Model)

ç½‘ç»œä¸Šçš„**ä¼ æ’­è¿‡ç¨‹**å¯ä»¥å»ºæ¨¡ä¸ºï¼š
$$\frac{dx_i(t)}{dt} = f_i(x_1(t), \ldots, x_n(t), A, \theta)$$

å…¶ä¸­ï¼š

- $x_i(t)$ æ˜¯èŠ‚ç‚¹ $i$ åœ¨æ—¶é—´ $t$ çš„çŠ¶æ€
- $A$ æ˜¯ç½‘ç»œçš„é‚»æ¥çŸ©é˜µ
- $\theta$ æ˜¯æ¨¡å‹å‚æ•°

#### 5.1.1.1 SIRä¼ æ’­æ¨¡å‹

**å®šä¹‰ 5.1.2** (SIRæ¨¡å‹ / SIR Model)

**SIRæ¨¡å‹**ï¼ˆSusceptible-Infectious-Recoveredï¼‰å°†èŠ‚ç‚¹åˆ†ä¸ºä¸‰ç±»çŠ¶æ€ï¼š

- **æ˜“æ„Ÿè€…ï¼ˆSï¼‰**ï¼šå¯èƒ½è¢«æ„ŸæŸ“
- **æ„ŸæŸ“è€…ï¼ˆIï¼‰**ï¼šå·²ç»æ„ŸæŸ“å¹¶å¯ä¼ æ’­
- **åº·å¤è€…ï¼ˆRï¼‰**ï¼šå·²ç»åº·å¤ä¸”å…ç–«

**åŠ¨åŠ›å­¦æ–¹ç¨‹**ï¼š
$$
\begin{align}
\frac{dS_i}{dt} &= -\beta S_i \sum_{j} A_{ij} I_j \\
\frac{dI_i}{dt} &= \beta S_i \sum_{j} A_{ij} I_j - \gamma I_i \\
\frac{dR_i}{dt} &= \gamma I_i
\end{align}
$$

å…¶ä¸­ï¼š

- $\beta$ æ˜¯æ„ŸæŸ“ç‡
- $\gamma$ æ˜¯åº·å¤ç‡
- $A_{ij}$ æ˜¯é‚»æ¥çŸ©é˜µå…ƒç´ 

**åŸºæœ¬å†ç”Ÿæ•°**ï¼š
$$R_0 = \frac{\beta}{\gamma} \cdot \lambda_{\max}(A)$$

å…¶ä¸­ $\lambda_{\max}(A)$ æ˜¯é‚»æ¥çŸ©é˜µçš„æœ€å¤§ç‰¹å¾å€¼ã€‚

#### 5.1.1.2 ä¿¡æ¯ä¼ æ’­æ¨¡å‹

**å®šä¹‰ 5.1.3** (ç‹¬ç«‹çº§è”æ¨¡å‹ / Independent Cascade Model)

åœ¨**ç‹¬ç«‹çº§è”æ¨¡å‹**ä¸­ï¼Œæ¯ä¸ªæ¿€æ´»çš„èŠ‚ç‚¹æœ‰ä¸€æ¬¡æœºä¼šä»¥æ¦‚ç‡ $p_{ij}$ æ¿€æ´»å…¶é‚»å±…ã€‚

**ç®—æ³•æè¿°**ï¼š

1. åˆå§‹æ¿€æ´»ç§å­èŠ‚ç‚¹é›†
2. æ¯ä¸ªæ¿€æ´»èŠ‚ç‚¹ä»¥æ¦‚ç‡æ¿€æ´»æœªæ¿€æ´»é‚»å±…
3. é‡å¤æ­¥éª¤2ç›´åˆ°æ²¡æœ‰æ–°æ¿€æ´»èŠ‚ç‚¹

**é˜ˆå€¼æ¨¡å‹**ï¼ˆLinear Threshold Modelï¼‰ï¼š

æ¯ä¸ªèŠ‚ç‚¹ $i$ æœ‰ä¸€ä¸ªé˜ˆå€¼ $\theta_i \in [0, 1]$ï¼Œå½“æ¿€æ´»é‚»å±…çš„åŠ æƒæ¯”ä¾‹è¶…è¿‡é˜ˆå€¼æ—¶ï¼ŒèŠ‚ç‚¹è¢«æ¿€æ´»ã€‚

**ç®—æ³•å®ç°**ï¼š

```python
from typing import Dict, List, Set, Tuple
import numpy as np
import random
from collections import deque

class NetworkPropagation:
    """
    ç½‘ç»œä¼ æ’­åŠ¨åŠ›å­¦å®ç°ã€‚
    """

    def __init__(self, graph: Dict[int, List[int]],
                 edge_weights: Dict[Tuple[int, int], float] = None):
        """
        åˆå§‹åŒ–ç½‘ç»œä¼ æ’­æ¨¡å‹ã€‚

        Args:
            graph: å›¾çš„é‚»æ¥è¡¨è¡¨ç¤º
            edge_weights: è¾¹çš„æƒé‡å­—å…¸
        """
        self.graph = graph
        self.edge_weights = edge_weights if edge_weights else {}
        self.nodes = set(graph.keys())
        for neighbors in graph.values():
            self.nodes.update(neighbors)

    def sir_model(self, initial_infected: Set[int], beta: float, gamma: float,
                  steps: int = 100) -> Dict[int, List[int]]:
        """
        SIRä¼ æ’­æ¨¡å‹æ¨¡æ‹Ÿã€‚

        Args:
            initial_infected: åˆå§‹æ„ŸæŸ“è€…é›†åˆ
            beta: æ„ŸæŸ“ç‡
            gamma: åº·å¤ç‡
            steps: æ¨¡æ‹Ÿæ­¥æ•°

        Returns:
            æ¯ä¸ªæ—¶é—´æ­¥çš„Sã€Iã€Ræ•°é‡
        """
        # åˆå§‹åŒ–çŠ¶æ€ï¼š0=S, 1=I, 2=R
        state = {node: 0 for node in self.nodes}
        for node in initial_infected:
            if node in self.nodes:
                state[node] = 1

        history = {"S": [], "I": [], "R": []}

        for step in range(steps):
            # ç»Ÿè®¡å½“å‰çŠ¶æ€
            s_count = sum(1 for s in state.values() if s == 0)
            i_count = sum(1 for s in state.values() if s == 1)
            r_count = sum(1 for s in state.values() if s == 2)
            history["S"].append(s_count)
            history["I"].append(i_count)
            history["R"].append(r_count)

            # æ›´æ–°çŠ¶æ€
            new_state = dict(state)

            # æ„ŸæŸ“è€…å°è¯•æ„ŸæŸ“é‚»å±…
            for node in self.nodes:
                if state[node] == 1:  # æ„ŸæŸ“è€…
                    for neighbor in self.graph.get(node, []):
                        if state[neighbor] == 0:  # æ˜“æ„Ÿè€…
                            # è®¡ç®—æ„ŸæŸ“æ¦‚ç‡
                            if random.random() < beta:
                                new_state[neighbor] = 1

            # æ„ŸæŸ“è€…åº·å¤
            for node in self.nodes:
                if state[node] == 1:  # æ„ŸæŸ“è€…
                    if random.random() < gamma:
                        new_state[node] = 2  # åº·å¤è€…

            state = new_state

        return history

    def independent_cascade(self, seed_set: Set[int],
                           activation_prob: Dict[Tuple[int, int], float] = None) -> Set[int]:
        """
        ç‹¬ç«‹çº§è”æ¨¡å‹ã€‚

        Args:
            seed_set: åˆå§‹æ¿€æ´»èŠ‚ç‚¹é›†åˆ
            activation_prob: æ¿€æ´»æ¦‚ç‡å­—å…¸ï¼Œå¦‚æœä¸ºNoneåˆ™ä½¿ç”¨é»˜è®¤å€¼

        Returns:
            æœ€ç»ˆæ¿€æ´»çš„èŠ‚ç‚¹é›†åˆ
        """
        activated = set(seed_set)
        queue = deque(seed_set)

        # è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„æ¿€æ´»å°è¯•ï¼ˆæ¯ä¸ªèŠ‚ç‚¹åªèƒ½å°è¯•ä¸€æ¬¡ï¼‰
        attempts = {node: set() for node in self.nodes}

        while queue:
            current = queue.popleft()

            for neighbor in self.graph.get(current, []):
                if neighbor not in activated and neighbor not in attempts[current]:
                    # è·å–æ¿€æ´»æ¦‚ç‡
                    prob = activation_prob.get((current, neighbor), 0.5) if activation_prob else 0.5

                    attempts[current].add(neighbor)

                    if random.random() < prob:
                        activated.add(neighbor)
                        queue.append(neighbor)

        return activated

    def linear_threshold(self, seed_set: Set[int],
                        thresholds: Dict[int, float] = None,
                        edge_weights: Dict[Tuple[int, int], float] = None) -> Set[int]:
        """
        çº¿æ€§é˜ˆå€¼æ¨¡å‹ã€‚

        Args:
            seed_set: åˆå§‹æ¿€æ´»èŠ‚ç‚¹é›†åˆ
            thresholds: èŠ‚ç‚¹é˜ˆå€¼å­—å…¸ï¼Œå¦‚æœä¸ºNoneåˆ™éšæœºç”Ÿæˆ
            edge_weights: è¾¹æƒé‡å­—å…¸

        Returns:
            æœ€ç»ˆæ¿€æ´»çš„èŠ‚ç‚¹é›†åˆ
        """
        activated = set(seed_set)
        newly_activated = set(seed_set)

        # åˆå§‹åŒ–é˜ˆå€¼
        if thresholds is None:
            thresholds = {node: random.random() for node in self.nodes}

        # ä½¿ç”¨æä¾›çš„è¾¹æƒé‡æˆ–é»˜è®¤æƒé‡
        weights = edge_weights if edge_weights else self.edge_weights

        while newly_activated:
            next_newly_activated = set()

            for node in self.nodes:
                if node not in activated:
                    # è®¡ç®—æ¿€æ´»é‚»å±…çš„åŠ æƒå½±å“
                    influence = 0.0
                    total_weight = 0.0

                    for neighbor in self.graph.get(node, []):
                        if neighbor in activated:
                            weight = weights.get((neighbor, node), 1.0)
                            influence += weight
                            total_weight += weight

                    # å½’ä¸€åŒ–
                    if total_weight > 0:
                        normalized_influence = influence / total_weight
                        if normalized_influence >= thresholds[node]:
                            next_newly_activated.add(node)

            newly_activated = next_newly_activated
            activated.update(newly_activated)

        return activated

# å¤æ‚åº¦åˆ†æ
# sir_model: O(steps * (|V| + |E|))
# independent_cascade: O(|V| + |E|) (æœ€åæƒ…å†µ)
# linear_threshold: O(|V|^2) (æœ€åæƒ…å†µï¼Œæ¯æ¬¡è¿­ä»£å¯èƒ½æ¿€æ´»ä¸€ä¸ªèŠ‚ç‚¹)
```



---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆ
