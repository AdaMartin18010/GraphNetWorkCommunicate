# å‡ ä½•éšæœºå›¾æ¨¡å‹ / å‡ ä½•éšæœºå›¾æ¨¡å‹

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä»‹ç»å‡ ä½•éšæœºå›¾æ¨¡å‹çš„è¯¦ç»†ç†è®ºå’Œå®ç°ã€‚

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆ

---

## å‡ ä½•éšæœºå›¾æ¨¡å‹

**å®šä¹‰ 5.2.4** (å‡ ä½•éšæœºå›¾ / Geometric Random Graph)

**å‡ ä½•éšæœºå›¾** $G(n, r)$ æ˜¯åœ¨å•ä½å¹³æ–¹ä¸­éšæœºæ”¾ç½® $n$ ä¸ªç‚¹ï¼Œä¸¤ä¸ªç‚¹ä¹‹é—´è¿è¾¹å½“ä¸”ä»…å½“å®ƒä»¬çš„è·ç¦»å°äºç­‰äº $r$ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š

è®¾ $V = \{v_1, \ldots, v_n\}$ æ˜¯å•ä½å¹³æ–¹ $[0,1]^2$ ä¸­çš„éšæœºç‚¹ï¼Œåˆ™ï¼š
$$E = \{(v_i, v_j) \mid d(v_i, v_j) \leq r\}$$

å…¶ä¸­ $d(v_i, v_j)$ æ˜¯æ¬§å‡ é‡Œå¾—è·ç¦»ã€‚

**è¿é€šæ€§é˜ˆå€¼**ï¼š

å½“ $r = \sqrt{\frac{\ln n + c(n)}{\pi n}}$ æ—¶ï¼š

- å¦‚æœ $\lim c(n) = -\infty$ï¼Œåˆ™å‡ ä¹å¿…ç„¶ä¸è¿é€š
- å¦‚æœ $\lim c(n) = +\infty$ï¼Œåˆ™å‡ ä¹å¿…ç„¶è¿é€š

**ç®—æ³•å®ç°**ï¼š

```python
import numpy as np
from typing import Dict, List, Tuple
import math

class GeometricRandomGraph:
    """
    å‡ ä½•éšæœºå›¾æ¨¡å‹å®ç°ã€‚
    """

    def __init__(self):
        pass

    def geometric_graph(self, n: int, r: float,
                       positions: List[Tuple[float, float]] = None,
                       dim: int = 2) -> Tuple[Dict[int, List[int]],
                                              List[Tuple[float, ...]]]:
        """
        ç”Ÿæˆå‡ ä½•éšæœºå›¾ã€‚

        Args:
            n: èŠ‚ç‚¹æ•°
            r: è¿æ¥åŠå¾„
            positions: èŠ‚ç‚¹ä½ç½®ï¼Œå¦‚æœä¸ºNoneåˆ™éšæœºç”Ÿæˆ
            dim: ç©ºé—´ç»´åº¦ï¼ˆ2æˆ–3ï¼‰

        Returns:
            (å›¾, èŠ‚ç‚¹ä½ç½®)
        """
        # ç”Ÿæˆæˆ–ä½¿ç”¨æä¾›çš„èŠ‚ç‚¹ä½ç½®
        if positions is None:
            if dim == 2:
                positions = [(np.random.random(), np.random.random())
                            for _ in range(n)]
            else:
                positions = [(np.random.random(), np.random.random(), np.random.random())
                            for _ in range(n)]

        graph = {i: [] for i in range(n)}

        # è®¡ç®—è·ç¦»å¹¶è¿è¾¹
        for i in range(n):
            for j in range(i + 1, n):
                distance = self._euclidean_distance(positions[i], positions[j])
                if distance <= r:
                    graph[i].append(j)
                    graph[j].append(i)

        return graph, positions

    def _euclidean_distance(self, p1: Tuple, p2: Tuple) -> float:
        """è®¡ç®—æ¬§å‡ é‡Œå¾—è·ç¦»"""
        return math.sqrt(sum((a - b) ** 2 for a, b in zip(p1, p2)))

    def connectivity_threshold(self, n: int, dim: int = 2) -> float:
        """
        è®¡ç®—è¿é€šæ€§é˜ˆå€¼åŠå¾„ã€‚

        Args:
            n: èŠ‚ç‚¹æ•°
            dim: ç©ºé—´ç»´åº¦

        Returns:
            é˜ˆå€¼åŠå¾„
        """
        if dim == 2:
            # 2D: r = sqrt((ln n + c) / (Ï€ * n))
            r = math.sqrt(math.log(n) / (math.pi * n))
        else:
            # 3D: r = ((ln n + c) / n)^(1/3)
            r = (math.log(n) / n) ** (1/3)

        return r

# å¤æ‚åº¦åˆ†æ
# geometric_graph: O(n^2) - éœ€è¦æ£€æŸ¥æ‰€æœ‰èŠ‚ç‚¹å¯¹çš„è·ç¦»
# connectivity_threshold: O(1)
```



---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆ
