# ç½‘ç»œæ‹“æ‰‘é«˜çº§ç†è®º / Advanced Network Topology Theory

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä»‹ç»ç½‘ç»œæ‹“æ‰‘ä¸­çš„é«˜çº§ç†è®ºä¸»é¢˜ï¼ŒåŒ…æ‹¬ç½‘ç»œåŠ¨åŠ›å­¦å’Œç½‘ç»œç”Ÿæˆæ¨¡å‹ã€‚è¿™äº›ä¸»é¢˜æ˜¯ç½‘ç»œç§‘å­¦çš„æ ¸å¿ƒé«˜çº§å†…å®¹ï¼Œä¸ºç½‘ç»œåˆ†æã€å»ºæ¨¡å’Œä¼˜åŒ–æä¾›äº†é‡è¦çš„ç†è®ºåŸºç¡€ã€‚æœ¬æ–‡æ¡£å¯¹æ ‡å›½é™…é¡¶çº§æ ‡å‡†ï¼ˆMITã€Stanfordã€CMUã€Berkeleyã€Oxfordï¼‰å’Œç»å…¸ç½‘ç»œç§‘å­¦æ•™æï¼Œæä¾›ä¸¥æ ¼ã€å®Œæ•´ã€å›½é™…åŒ–çš„é«˜çº§ç½‘ç»œæ‹“æ‰‘ç†è®ºä½“ç³»ã€‚

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: æŒç»­æ›´æ–°ä¸­ âš™ï¸
**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [ç½‘ç»œæ‹“æ‰‘é«˜çº§ç†è®º / Advanced Network Topology Theory](#ç½‘ç»œæ‹“æ‰‘é«˜çº§ç†è®º--advanced-network-topology-theory)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [5.1 ç½‘ç»œåŠ¨åŠ›å­¦ / Network Dynamics](#51-ç½‘ç»œåŠ¨åŠ›å­¦--network-dynamics)
    - [5.1.1 ä¼ æ’­åŠ¨åŠ›å­¦ / Propagation Dynamics](#511-ä¼ æ’­åŠ¨åŠ›å­¦--propagation-dynamics)
      - [5.1.1.1 SIRä¼ æ’­æ¨¡å‹](#5111-sirä¼ æ’­æ¨¡å‹)
      - [5.1.1.2 ä¿¡æ¯ä¼ æ’­æ¨¡å‹](#5112-ä¿¡æ¯ä¼ æ’­æ¨¡å‹)
    - [5.1.2 åŒæ­¥åŠ¨åŠ›å­¦ / Synchronization Dynamics](#512-åŒæ­¥åŠ¨åŠ›å­¦--synchronization-dynamics)
    - [5.1.3 åšå¼ˆåŠ¨åŠ›å­¦ / Game Dynamics](#513-åšå¼ˆåŠ¨åŠ›å­¦--game-dynamics)
    - [5.1.4 ç½‘ç»œåŠ¨åŠ›å­¦æ§åˆ¶ / Network Dynamics Control](#514-ç½‘ç»œåŠ¨åŠ›å­¦æ§åˆ¶--network-dynamics-control)
  - [5.2 ç½‘ç»œç”Ÿæˆæ¨¡å‹ / Network Generation Models](#52-ç½‘ç»œç”Ÿæˆæ¨¡å‹--network-generation-models)
    - [5.2.1 éšæœºå›¾æ¨¡å‹è¯¦ç»†ç†è®º](#521-éšæœºå›¾æ¨¡å‹è¯¦ç»†ç†è®º)
      - [5.2.1.1 ErdÅ‘sâ€“RÃ©nyiæ¨¡å‹ï¼ˆERæ¨¡å‹ï¼‰](#5211-erdÅ‘srÃ©nyiæ¨¡å‹eræ¨¡å‹)
      - [5.2.1.2 Watts-Strogatzæ¨¡å‹ï¼ˆWSæ¨¡å‹ï¼‰](#5212-watts-strogatzæ¨¡å‹wsæ¨¡å‹)
      - [5.2.1.3 BarabÃ¡si-Albertæ¨¡å‹ï¼ˆBAæ¨¡å‹ï¼‰](#5213-barabÃ¡si-albertæ¨¡å‹baæ¨¡å‹)
    - [5.2.2 å‡ ä½•éšæœºå›¾æ¨¡å‹](#522-å‡ ä½•éšæœºå›¾æ¨¡å‹)
    - [5.2.3 æŒ‡æ•°éšæœºå›¾æ¨¡å‹ï¼ˆERGMï¼‰](#523-æŒ‡æ•°éšæœºå›¾æ¨¡å‹ergm)
    - [5.2.4 å›¾ç”Ÿæˆå¯¹æŠ—ç½‘ç»œï¼ˆGraphGANï¼‰](#524-å›¾ç”Ÿæˆå¯¹æŠ—ç½‘ç»œgraphgan)
  - [5.3 åº”ç”¨æ¡ˆä¾‹ / Application Cases](#53-åº”ç”¨æ¡ˆä¾‹--application-cases)
    - [5.3.1 ä¼ æ’­åŠ¨åŠ›å­¦åº”ç”¨](#531-ä¼ æ’­åŠ¨åŠ›å­¦åº”ç”¨)
      - [5.3.1.1 æµè¡Œç—…ä¼ æ’­å»ºæ¨¡](#5311-æµè¡Œç—…ä¼ æ’­å»ºæ¨¡)
      - [5.3.1.2 ä¿¡æ¯ä¼ æ’­åˆ†æ](#5312-ä¿¡æ¯ä¼ æ’­åˆ†æ)
    - [5.3.2 åŒæ­¥åŠ¨åŠ›å­¦åº”ç”¨](#532-åŒæ­¥åŠ¨åŠ›å­¦åº”ç”¨)
      - [5.3.2.1 ç”µç½‘åŒæ­¥](#5321-ç”µç½‘åŒæ­¥)
      - [5.3.2.2 ç¥ç»å…ƒåŒæ­¥](#5322-ç¥ç»å…ƒåŒæ­¥)
    - [5.3.3 ç½‘ç»œç”Ÿæˆæ¨¡å‹åº”ç”¨](#533-ç½‘ç»œç”Ÿæˆæ¨¡å‹åº”ç”¨)
      - [5.3.3.1 ç½‘ç»œä»¿çœŸ](#5331-ç½‘ç»œä»¿çœŸ)
      - [5.3.3.2 æ•°æ®å¢å¼º](#5332-æ•°æ®å¢å¼º)
  - [5.4 æ€»ç»“ä¸å±•æœ› / Summary and Future Directions](#54-æ€»ç»“ä¸å±•æœ›--summary-and-future-directions)
    - [æœªæ¥ç ”ç©¶æ–¹å‘](#æœªæ¥ç ”ç©¶æ–¹å‘)

---

## 5.1 ç½‘ç»œåŠ¨åŠ›å­¦ / Network Dynamics

ç½‘ç»œåŠ¨åŠ›å­¦ç ”ç©¶ç½‘ç»œä¸Šå„ç§åŠ¨æ€è¿‡ç¨‹ï¼ŒåŒ…æ‹¬ä¼ æ’­ã€åŒæ­¥ã€åšå¼ˆç­‰è¿‡ç¨‹ã€‚

### 5.1.1 ä¼ æ’­åŠ¨åŠ›å­¦ / Propagation Dynamics

**å®šä¹‰ 5.1.1** (ç½‘ç»œä¼ æ’­æ¨¡å‹ / Network Propagation Model)

ç½‘ç»œä¸Šçš„**ä¼ æ’­è¿‡ç¨‹**å¯ä»¥å»ºæ¨¡ä¸ºï¼š
$$\frac{dx_i(t)}{dt} = f_i(x_1(t), \ldots, x_n(t), A, \theta)$$

å…¶ä¸­ï¼š

- $x_i(t)$ æ˜¯èŠ‚ç‚¹ $i$ åœ¨æ—¶é—´ $t$ çš„çŠ¶æ€
- $A$ æ˜¯ç½‘ç»œçš„é‚»æ¥çŸ©é˜µ
- $\theta$ æ˜¯æ¨¡å‹å‚æ•°

#### 5.1.1.1 SIRä¼ æ’­æ¨¡å‹

**å®šä¹‰ 5.1.2** (SIRæ¨¡å‹ / SIR Model)

**SIRæ¨¡å‹**ï¼ˆSusceptible-Infectious-Recoveredï¼‰å°†èŠ‚ç‚¹åˆ†ä¸ºä¸‰ç±»çŠ¶æ€ï¼š

- **æ˜“æ„Ÿè€…ï¼ˆSï¼‰**ï¼šå¯èƒ½è¢«æ„ŸæŸ“
- **æ„ŸæŸ“è€…ï¼ˆIï¼‰**ï¼šå·²ç»æ„ŸæŸ“å¹¶å¯ä¼ æ’­
- **åº·å¤è€…ï¼ˆRï¼‰**ï¼šå·²ç»åº·å¤ä¸”å…ç–«

**åŠ¨åŠ›å­¦æ–¹ç¨‹**ï¼š
$$
\begin{align}
\frac{dS_i}{dt} &= -\beta S_i \sum_{j} A_{ij} I_j \\
\frac{dI_i}{dt} &= \beta S_i \sum_{j} A_{ij} I_j - \gamma I_i \\
\frac{dR_i}{dt} &= \gamma I_i
\end{align}
$$

å…¶ä¸­ï¼š

- $\beta$ æ˜¯æ„ŸæŸ“ç‡
- $\gamma$ æ˜¯åº·å¤ç‡
- $A_{ij}$ æ˜¯é‚»æ¥çŸ©é˜µå…ƒç´ 

**åŸºæœ¬å†ç”Ÿæ•°**ï¼š
$$R_0 = \frac{\beta}{\gamma} \cdot \lambda_{\max}(A)$$

å…¶ä¸­ $\lambda_{\max}(A)$ æ˜¯é‚»æ¥çŸ©é˜µçš„æœ€å¤§ç‰¹å¾å€¼ã€‚

#### 5.1.1.2 ä¿¡æ¯ä¼ æ’­æ¨¡å‹

**å®šä¹‰ 5.1.3** (ç‹¬ç«‹çº§è”æ¨¡å‹ / Independent Cascade Model)

åœ¨**ç‹¬ç«‹çº§è”æ¨¡å‹**ä¸­ï¼Œæ¯ä¸ªæ¿€æ´»çš„èŠ‚ç‚¹æœ‰ä¸€æ¬¡æœºä¼šä»¥æ¦‚ç‡ $p_{ij}$ æ¿€æ´»å…¶é‚»å±…ã€‚

**ç®—æ³•æè¿°**ï¼š

1. åˆå§‹æ¿€æ´»ç§å­èŠ‚ç‚¹é›†
2. æ¯ä¸ªæ¿€æ´»èŠ‚ç‚¹ä»¥æ¦‚ç‡æ¿€æ´»æœªæ¿€æ´»é‚»å±…
3. é‡å¤æ­¥éª¤2ç›´åˆ°æ²¡æœ‰æ–°æ¿€æ´»èŠ‚ç‚¹

**é˜ˆå€¼æ¨¡å‹**ï¼ˆLinear Threshold Modelï¼‰ï¼š

æ¯ä¸ªèŠ‚ç‚¹ $i$ æœ‰ä¸€ä¸ªé˜ˆå€¼ $\theta_i \in [0, 1]$ï¼Œå½“æ¿€æ´»é‚»å±…çš„åŠ æƒæ¯”ä¾‹è¶…è¿‡é˜ˆå€¼æ—¶ï¼ŒèŠ‚ç‚¹è¢«æ¿€æ´»ã€‚

**ç®—æ³•å®ç°**ï¼š

```python
from typing import Dict, List, Set, Tuple
import numpy as np
import random
from collections import deque

class NetworkPropagation:
    """
    ç½‘ç»œä¼ æ’­åŠ¨åŠ›å­¦å®ç°ã€‚
    """

    def __init__(self, graph: Dict[int, List[int]],
                 edge_weights: Dict[Tuple[int, int], float] = None):
        """
        åˆå§‹åŒ–ç½‘ç»œä¼ æ’­æ¨¡å‹ã€‚

        Args:
            graph: å›¾çš„é‚»æ¥è¡¨è¡¨ç¤º
            edge_weights: è¾¹çš„æƒé‡å­—å…¸
        """
        self.graph = graph
        self.edge_weights = edge_weights if edge_weights else {}
        self.nodes = set(graph.keys())
        for neighbors in graph.values():
            self.nodes.update(neighbors)

    def sir_model(self, initial_infected: Set[int], beta: float, gamma: float,
                  steps: int = 100) -> Dict[int, List[int]]:
        """
        SIRä¼ æ’­æ¨¡å‹æ¨¡æ‹Ÿã€‚

        Args:
            initial_infected: åˆå§‹æ„ŸæŸ“è€…é›†åˆ
            beta: æ„ŸæŸ“ç‡
            gamma: åº·å¤ç‡
            steps: æ¨¡æ‹Ÿæ­¥æ•°

        Returns:
            æ¯ä¸ªæ—¶é—´æ­¥çš„Sã€Iã€Ræ•°é‡
        """
        # åˆå§‹åŒ–çŠ¶æ€ï¼š0=S, 1=I, 2=R
        state = {node: 0 for node in self.nodes}
        for node in initial_infected:
            if node in self.nodes:
                state[node] = 1

        history = {"S": [], "I": [], "R": []}

        for step in range(steps):
            # ç»Ÿè®¡å½“å‰çŠ¶æ€
            s_count = sum(1 for s in state.values() if s == 0)
            i_count = sum(1 for s in state.values() if s == 1)
            r_count = sum(1 for s in state.values() if s == 2)
            history["S"].append(s_count)
            history["I"].append(i_count)
            history["R"].append(r_count)

            # æ›´æ–°çŠ¶æ€
            new_state = dict(state)

            # æ„ŸæŸ“è€…å°è¯•æ„ŸæŸ“é‚»å±…
            for node in self.nodes:
                if state[node] == 1:  # æ„ŸæŸ“è€…
                    for neighbor in self.graph.get(node, []):
                        if state[neighbor] == 0:  # æ˜“æ„Ÿè€…
                            # è®¡ç®—æ„ŸæŸ“æ¦‚ç‡
                            if random.random() < beta:
                                new_state[neighbor] = 1

            # æ„ŸæŸ“è€…åº·å¤
            for node in self.nodes:
                if state[node] == 1:  # æ„ŸæŸ“è€…
                    if random.random() < gamma:
                        new_state[node] = 2  # åº·å¤è€…

            state = new_state

        return history

    def independent_cascade(self, seed_set: Set[int],
                           activation_prob: Dict[Tuple[int, int], float] = None) -> Set[int]:
        """
        ç‹¬ç«‹çº§è”æ¨¡å‹ã€‚

        Args:
            seed_set: åˆå§‹æ¿€æ´»èŠ‚ç‚¹é›†åˆ
            activation_prob: æ¿€æ´»æ¦‚ç‡å­—å…¸ï¼Œå¦‚æœä¸ºNoneåˆ™ä½¿ç”¨é»˜è®¤å€¼

        Returns:
            æœ€ç»ˆæ¿€æ´»çš„èŠ‚ç‚¹é›†åˆ
        """
        activated = set(seed_set)
        queue = deque(seed_set)

        # è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„æ¿€æ´»å°è¯•ï¼ˆæ¯ä¸ªèŠ‚ç‚¹åªèƒ½å°è¯•ä¸€æ¬¡ï¼‰
        attempts = {node: set() for node in self.nodes}

        while queue:
            current = queue.popleft()

            for neighbor in self.graph.get(current, []):
                if neighbor not in activated and neighbor not in attempts[current]:
                    # è·å–æ¿€æ´»æ¦‚ç‡
                    prob = activation_prob.get((current, neighbor), 0.5) if activation_prob else 0.5

                    attempts[current].add(neighbor)

                    if random.random() < prob:
                        activated.add(neighbor)
                        queue.append(neighbor)

        return activated

    def linear_threshold(self, seed_set: Set[int],
                        thresholds: Dict[int, float] = None,
                        edge_weights: Dict[Tuple[int, int], float] = None) -> Set[int]:
        """
        çº¿æ€§é˜ˆå€¼æ¨¡å‹ã€‚

        Args:
            seed_set: åˆå§‹æ¿€æ´»èŠ‚ç‚¹é›†åˆ
            thresholds: èŠ‚ç‚¹é˜ˆå€¼å­—å…¸ï¼Œå¦‚æœä¸ºNoneåˆ™éšæœºç”Ÿæˆ
            edge_weights: è¾¹æƒé‡å­—å…¸

        Returns:
            æœ€ç»ˆæ¿€æ´»çš„èŠ‚ç‚¹é›†åˆ
        """
        activated = set(seed_set)
        newly_activated = set(seed_set)

        # åˆå§‹åŒ–é˜ˆå€¼
        if thresholds is None:
            thresholds = {node: random.random() for node in self.nodes}

        # ä½¿ç”¨æä¾›çš„è¾¹æƒé‡æˆ–é»˜è®¤æƒé‡
        weights = edge_weights if edge_weights else self.edge_weights

        while newly_activated:
            next_newly_activated = set()

            for node in self.nodes:
                if node not in activated:
                    # è®¡ç®—æ¿€æ´»é‚»å±…çš„åŠ æƒå½±å“
                    influence = 0.0
                    total_weight = 0.0

                    for neighbor in self.graph.get(node, []):
                        if neighbor in activated:
                            weight = weights.get((neighbor, node), 1.0)
                            influence += weight
                            total_weight += weight

                    # å½’ä¸€åŒ–
                    if total_weight > 0:
                        normalized_influence = influence / total_weight
                        if normalized_influence >= thresholds[node]:
                            next_newly_activated.add(node)

            newly_activated = next_newly_activated
            activated.update(newly_activated)

        return activated

# å¤æ‚åº¦åˆ†æ
# sir_model: O(steps * (|V| + |E|))
# independent_cascade: O(|V| + |E|) (æœ€åæƒ…å†µ)
# linear_threshold: O(|V|^2) (æœ€åæƒ…å†µï¼Œæ¯æ¬¡è¿­ä»£å¯èƒ½æ¿€æ´»ä¸€ä¸ªèŠ‚ç‚¹)
```

### 5.1.2 åŒæ­¥åŠ¨åŠ›å­¦ / Synchronization Dynamics

**å®šä¹‰ 5.1.4** (ç½‘ç»œåŒæ­¥ / Network Synchronization)

ç½‘ç»œä¸Šçš„**åŒæ­¥**æ˜¯æŒ‡ç½‘ç»œä¸­æ‰€æœ‰èŠ‚ç‚¹çš„çŠ¶æ€è¶‹äºä¸€è‡´ï¼š
$$\lim_{t \to \infty} |x_i(t) - x_j(t)| = 0 \quad \forall i, j$$

**Kuramotoæ¨¡å‹**ï¼š

$$\frac{d\theta_i}{dt} = \omega_i + K \sum_{j=1}^{n} A_{ij} \sin(\theta_j - \theta_i)$$

å…¶ä¸­ï¼š

- $\theta_i$ æ˜¯èŠ‚ç‚¹ $i$ çš„ç›¸ä½
- $\omega_i$ æ˜¯èŠ‚ç‚¹ $i$ çš„è‡ªç„¶é¢‘ç‡
- $K$ æ˜¯è€¦åˆå¼ºåº¦
- $A_{ij}$ æ˜¯é‚»æ¥çŸ©é˜µå…ƒç´ 

**åŒæ­¥æ¡ä»¶**ï¼š

ç½‘ç»œåŒæ­¥çš„å……åˆ†æ¡ä»¶ï¼š
$$K > K_c = \frac{\Delta \omega}{\lambda_2(L)}$$

å…¶ä¸­ï¼š

- $\Delta \omega = \max_i \omega_i - \min_i \omega_i$ æ˜¯é¢‘ç‡èŒƒå›´
- $\lambda_2(L)$ æ˜¯æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µçš„ç¬¬äºŒä¸ªæœ€å°ç‰¹å¾å€¼ï¼ˆä»£æ•°è¿é€šåº¦ï¼‰

**ç®—æ³•å®ç°**ï¼š

```python
import numpy as np
from typing import Dict, List
import scipy.sparse as sp
from scipy.sparse.csgraph import laplacian

class NetworkSynchronization:
    """
    ç½‘ç»œåŒæ­¥åŠ¨åŠ›å­¦å®ç°ã€‚
    """

    def __init__(self, graph: Dict[int, List[int]],
                 natural_frequencies: Dict[int, float] = None):
        """
        åˆå§‹åŒ–ç½‘ç»œåŒæ­¥æ¨¡å‹ã€‚

        Args:
            graph: å›¾çš„é‚»æ¥è¡¨è¡¨ç¤º
            natural_frequencies: èŠ‚ç‚¹çš„è‡ªç„¶é¢‘ç‡
        """
        self.graph = graph
        self.nodes = sorted(set(graph.keys()) |
                           {n for neighbors in graph.values() for n in neighbors})
        self.n = len(self.nodes)
        self.node_to_idx = {node: i for i, node in enumerate(self.nodes)}

        # æ„å»ºé‚»æ¥çŸ©é˜µ
        self.adj_matrix = self._build_adjacency_matrix()
        self.laplacian = laplacian(self.adj_matrix, normed=False)

        # è‡ªç„¶é¢‘ç‡
        if natural_frequencies is None:
            self.omega = {node: np.random.uniform(-1, 1) for node in self.nodes}
        else:
            self.omega = natural_frequencies

    def _build_adjacency_matrix(self) -> np.ndarray:
        """æ„å»ºé‚»æ¥çŸ©é˜µ"""
        A = np.zeros((self.n, self.n))
        for node, neighbors in self.graph.items():
            i = self.node_to_idx[node]
            for neighbor in neighbors:
                j = self.node_to_idx[neighbor]
                A[i, j] = 1
                A[j, i] = 1
        return A

    def kuramoto_model(self, K: float, dt: float = 0.01,
                      steps: int = 1000, initial_phases: Dict[int, float] = None) -> np.ndarray:
        """
        Kuramotoæ¨¡å‹æ¨¡æ‹Ÿã€‚

        Args:
            K: è€¦åˆå¼ºåº¦
            dt: æ—¶é—´æ­¥é•¿
            steps: æ¨¡æ‹Ÿæ­¥æ•°
            initial_phases: åˆå§‹ç›¸ä½

        Returns:
            ç›¸ä½æ—¶é—´åºåˆ—
        """
        # åˆå§‹åŒ–ç›¸ä½
        if initial_phases is None:
            theta = np.random.uniform(0, 2 * np.pi, self.n)
        else:
            theta = np.array([initial_phases.get(node, 0) for node in self.nodes])

        # è‡ªç„¶é¢‘ç‡å‘é‡
        omega_vec = np.array([self.omega[node] for node in self.nodes])

        history = np.zeros((steps, self.n))
        history[0] = theta

        for step in range(1, steps):
            dtheta = np.zeros(self.n)

            for i, node_i in enumerate(self.nodes):
                dtheta[i] = omega_vec[i]

                # è€¦åˆé¡¹
                for j, node_j in enumerate(self.nodes):
                    if self.adj_matrix[i, j] > 0:
                        dtheta[i] += K * np.sin(theta[j] - theta[i])

            theta += dtheta * dt
            theta = np.mod(theta, 2 * np.pi)  # ä¿æŒç›¸ä½åœ¨[0, 2Ï€]
            history[step] = theta

        return history

    def order_parameter(self, theta: np.ndarray) -> float:
        """
        è®¡ç®—åºå‚é‡ï¼ˆåŒæ­¥ç¨‹åº¦ï¼‰ã€‚

        Args:
            theta: ç›¸ä½å‘é‡

        Returns:
            åºå‚é‡å€¼ï¼ˆ0åˆ°1ä¹‹é—´ï¼Œ1è¡¨ç¤ºå®Œå…¨åŒæ­¥ï¼‰
        """
        r = np.abs(np.mean(np.exp(1j * theta)))
        return r

    def critical_coupling(self) -> float:
        """
        è®¡ç®—ä¸´ç•Œè€¦åˆå¼ºåº¦ã€‚

        Returns:
            ä¸´ç•Œè€¦åˆå¼ºåº¦K_c
        """
        # è®¡ç®—é¢‘ç‡èŒƒå›´
        omega_values = list(self.omega.values())
        delta_omega = max(omega_values) - min(omega_values)

        # è®¡ç®—æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µçš„ç¬¬äºŒä¸ªæœ€å°ç‰¹å¾å€¼
        eigenvals = np.linalg.eigvals(self.laplacian.toarray())
        eigenvals_sorted = np.sort(eigenvals)
        lambda_2 = eigenvals_sorted[1] if len(eigenvals_sorted) > 1 else eigenvals_sorted[0]

        if lambda_2 < 1e-10:
            return float('inf')  # å›¾ä¸è¿é€š

        K_c = delta_omega / lambda_2
        return K_c

# å¤æ‚åº¦åˆ†æ
# kuramoto_model: O(steps * n^2) - æ¯ä¸ªæ—¶é—´æ­¥éœ€è¦è®¡ç®—æ‰€æœ‰èŠ‚ç‚¹å¯¹çš„è€¦åˆ
# order_parameter: O(n)
# critical_coupling: O(n^3) - ç‰¹å¾å€¼è®¡ç®—
```

### 5.1.3 åšå¼ˆåŠ¨åŠ›å­¦ / Game Dynamics

**å®šä¹‰ 5.1.5** (ç½‘ç»œåšå¼ˆ / Network Game)

**ç½‘ç»œåšå¼ˆ**æ˜¯ç½‘ç»œä¸Šçš„åšå¼ˆï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„æ”¶ç›Šä¾èµ–äºå…¶é‚»å±…çš„ç­–ç•¥ã€‚

**æ¼”åŒ–åšå¼ˆè®º**ï¼š

åœ¨**æ¼”åŒ–åšå¼ˆè®º**ä¸­ï¼ŒèŠ‚ç‚¹æ ¹æ®å…¶æ”¶ç›Šæ›´æ–°ç­–ç•¥ã€‚

**å¤åˆ¶è€…åŠ¨æ€**ï¼ˆReplicator Dynamicsï¼‰ï¼š

$$\frac{dx_i}{dt} = x_i (f_i - \bar{f})$$

å…¶ä¸­ï¼š

- $x_i$ æ˜¯ç­–ç•¥ $i$ çš„é¢‘ç‡
- $f_i$ æ˜¯ç­–ç•¥ $i$ çš„é€‚åº”åº¦
- $\bar{f} = \sum_j x_j f_j$ æ˜¯å¹³å‡é€‚åº”åº¦

**ç½‘ç»œä¸Šçš„æ¼”åŒ–åšå¼ˆ**ï¼š

åœ¨ç½‘ç»œåšå¼ˆä¸­ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„æ”¶ç›Šä¾èµ–äºå…¶é‚»å±…çš„ç­–ç•¥ï¼š
$$u_i = \sum_{j \in N(i)} \pi(s_i, s_j)$$

å…¶ä¸­ $\pi(s_i, s_j)$ æ˜¯æ”¶ç›ŠçŸ©é˜µã€‚

**ç®—æ³•å®ç°**ï¼š

```python
from typing import Dict, List, Set, Tuple
import numpy as np
import random

class NetworkGameDynamics:
    """
    ç½‘ç»œåšå¼ˆåŠ¨åŠ›å­¦å®ç°ã€‚
    """

    def __init__(self, graph: Dict[int, List[int]],
                 payoff_matrix: np.ndarray,
                 strategies: List[str] = None):
        """
        åˆå§‹åŒ–ç½‘ç»œåšå¼ˆæ¨¡å‹ã€‚

        Args:
            graph: å›¾çš„é‚»æ¥è¡¨è¡¨ç¤º
            payoff_matrix: æ”¶ç›ŠçŸ©é˜µ [strategy_i, strategy_j] -> payoff
            strategies: ç­–ç•¥åˆ—è¡¨ï¼Œå¦‚æœä¸ºNoneåˆ™é»˜è®¤["C", "D"]ï¼ˆåˆä½œ/èƒŒå›ï¼‰
        """
        self.graph = graph
        self.payoff_matrix = payoff_matrix

        if strategies is None:
            self.strategies = ["C", "D"]  # åˆä½œï¼ˆCooperateï¼‰ã€èƒŒå›ï¼ˆDefectï¼‰
        else:
            self.strategies = strategies

        self.nodes = sorted(set(graph.keys()) |
                           {n for neighbors in graph.values() for n in neighbors})

    def play_game(self, strategies: Dict[int, str]) -> Dict[int, float]:
        """
        è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„æ”¶ç›Šã€‚

        Args:
            strategies: èŠ‚ç‚¹ç­–ç•¥å­—å…¸

        Returns:
            èŠ‚ç‚¹æ”¶ç›Šå­—å…¸
        """
        payoffs = {node: 0.0 for node in self.nodes}

        for node in self.nodes:
            node_strategy = strategies[node]
            node_strategy_idx = self.strategies.index(node_strategy)

            # ä¸æ‰€æœ‰é‚»å±…åšå¼ˆ
            for neighbor in self.graph.get(node, []):
                neighbor_strategy = strategies[neighbor]
                neighbor_strategy_idx = self.strategies.index(neighbor_strategy)

                # è·å–æ”¶ç›Š
                payoff = self.payoff_matrix[node_strategy_idx, neighbor_strategy_idx]
                payoffs[node] += payoff

        return payoffs

    def replicator_dynamics(self, initial_strategies: Dict[int, str],
                           steps: int = 100, dt: float = 0.01) -> List[Dict[int, str]]:
        """
        å¤åˆ¶è€…åŠ¨æ€æ¼”åŒ–ã€‚

        Args:
            initial_strategies: åˆå§‹ç­–ç•¥
            steps: æ¼”åŒ–æ­¥æ•°
            dt: æ—¶é—´æ­¥é•¿

        Returns:
            ç­–ç•¥æ¼”åŒ–å†å²
        """
        strategies = dict(initial_strategies)
        history = [dict(strategies)]

        # è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹æ¯ç§ç­–ç•¥çš„é€‚åº”åº¦
        for step in range(steps):
            payoffs = self.play_game(strategies)

            # æ›´æ–°ç­–ç•¥ï¼ˆå¤åˆ¶è€…åŠ¨æ€ï¼‰
            new_strategies = {}

            for node in self.nodes:
                # è®¡ç®—é‚»å±…çš„å¹³å‡æ”¶ç›Š
                neighbor_payoffs = [payoffs[neighbor]
                                   for neighbor in self.graph.get(node, [])]

                if neighbor_payoffs:
                    avg_neighbor_payoff = np.mean(neighbor_payoffs)
                    node_payoff = payoffs[node]

                    # ä»¥æ¦‚ç‡é€‰æ‹©æ›´å¥½çš„ç­–ç•¥ï¼ˆç®€åŒ–ï¼šç›´æ¥å¤åˆ¶æœ€é«˜æ”¶ç›Šé‚»å±…çš„ç­–ç•¥ï¼‰
                    if neighbor_payoffs:
                        best_neighbor = max(self.graph.get(node, []),
                                          key=lambda n: payoffs[n])
                        if payoffs[best_neighbor] > node_payoff:
                            new_strategies[node] = strategies[best_neighbor]
                        else:
                            new_strategies[node] = strategies[node]
                    else:
                        new_strategies[node] = strategies[node]
                else:
                    new_strategies[node] = strategies[node]

            strategies = new_strategies
            history.append(dict(strategies))

        return history

    def prisoner_dilemma(self, T: float = 1.5, R: float = 1.0,
                        P: float = 0.0, S: float = -0.5) -> Dict[int, str]:
        """
        å›šå¾’å›°å¢ƒåšå¼ˆã€‚

        æ”¶ç›ŠçŸ©é˜µï¼š
            C   D
        C  R, R  S, T
        D  T, S  P, P

        Args:
            T: è¯±æƒ‘ï¼ˆTemptationï¼‰
            R: å¥–åŠ±ï¼ˆRewardï¼‰
            P: æƒ©ç½šï¼ˆPunishmentï¼‰
            S: å‚»ç“œï¼ˆSuckerï¼‰

        Returns:
            æ¼”åŒ–åçš„ç­–ç•¥åˆ†å¸ƒ
        """
        payoff_matrix = np.array([
            [R, S],  # åˆä½œè€…çš„æ”¶ç›Š
            [T, P]   # èƒŒå›è€…çš„æ”¶ç›Š
        ])

        self.payoff_matrix = payoff_matrix

        # éšæœºåˆå§‹ç­–ç•¥
        initial_strategies = {node: random.choice(["C", "D"])
                            for node in self.nodes}

        # æ¼”åŒ–
        history = self.replicator_dynamics(initial_strategies)

        return history[-1]

# å¤æ‚åº¦åˆ†æ
# play_game: O(n * <d>) å…¶ä¸­<d>æ˜¯å¹³å‡åº¦æ•°
# replicator_dynamics: O(steps * n * <d>)
```

### 5.1.4 ç½‘ç»œåŠ¨åŠ›å­¦æ§åˆ¶ / Network Dynamics Control

**å®šä¹‰ 5.1.6** (ç½‘ç»œæ§åˆ¶ / Network Control)

**ç½‘ç»œæ§åˆ¶**é—®é¢˜æ˜¯åœ¨ç»™å®šæ§åˆ¶è¾“å…¥çš„æƒ…å†µä¸‹ï¼Œä½¿ç½‘ç»œçŠ¶æ€è¾¾åˆ°æœŸæœ›å€¼ã€‚

**çº¿æ€§æ—¶ä¸å˜ç½‘ç»œæ§åˆ¶**ï¼š

$$\frac{dx(t)}{dt} = Ax(t) + Bu(t)$$

å…¶ä¸­ï¼š

- $x(t)$ æ˜¯çŠ¶æ€å‘é‡
- $A$ æ˜¯ç½‘ç»œè€¦åˆçŸ©é˜µ
- $B$ æ˜¯æ§åˆ¶è¾“å…¥çŸ©é˜µ
- $u(t)$ æ˜¯æ§åˆ¶è¾“å…¥

**å¯æ§æ€§**ï¼š

ç³»ç»Ÿå¯æ§å½“ä¸”ä»…å½“å¯æ§æ€§çŸ©é˜µæ»¡ç§©ï¼š
$$\text{rank}([B, AB, A^2B, \ldots, A^{n-1}B]) = n$$

**ç®—æ³•å®ç°**ï¼š

```python
import numpy as np
from typing import List, Set

class NetworkControl:
    """
    ç½‘ç»œæ§åˆ¶ç†è®ºå®ç°ã€‚
    """

    def __init__(self, A: np.ndarray):
        """
        åˆå§‹åŒ–ç½‘ç»œæ§åˆ¶ç³»ç»Ÿã€‚

        Args:
            A: ç½‘ç»œè€¦åˆçŸ©é˜µ
        """
        self.A = A
        self.n = A.shape[0]

    def controllability_matrix(self, B: np.ndarray) -> np.ndarray:
        """
        æ„å»ºå¯æ§æ€§çŸ©é˜µã€‚

        Args:
            B: æ§åˆ¶è¾“å…¥çŸ©é˜µ

        Returns:
            å¯æ§æ€§çŸ©é˜µ
        """
        C = B.copy()
        current = B.copy()

        for i in range(1, self.n):
            current = self.A @ current
            C = np.hstack([C, current])

        return C

    def is_controllable(self, B: np.ndarray) -> bool:
        """
        æ£€æŸ¥ç³»ç»Ÿæ˜¯å¦å¯æ§ã€‚

        Args:
            B: æ§åˆ¶è¾“å…¥çŸ©é˜µ

        Returns:
            å¦‚æœå¯æ§è¿”å›True
        """
        C = self.controllability_matrix(B)
        rank = np.linalg.matrix_rank(C)
        return rank == self.n

    def minimum_control_nodes(self) -> List[int]:
        """
        æ‰¾åˆ°æœ€å°æ§åˆ¶èŠ‚ç‚¹é›†ï¼ˆç®€åŒ–ç‰ˆï¼Œä½¿ç”¨åº¦å¯å‘å¼ï¼‰ã€‚

        Returns:
            æ§åˆ¶èŠ‚ç‚¹åˆ—è¡¨
        """
        # ç®€åŒ–å®ç°ï¼šé€‰æ‹©åº¦æœ€å¤§çš„èŠ‚ç‚¹
        degrees = np.sum(np.abs(self.A), axis=1)
        control_nodes = np.argsort[degrees](::-1)[:int(np.ceil(self.n / 2))]
        return control_nodes.tolist()

# å¤æ‚åº¦åˆ†æ
# controllability_matrix: O(n^2 * m) å…¶ä¸­mæ˜¯æ§åˆ¶è¾“å…¥æ•°
# is_controllable: O(n^3) - çŸ©é˜µç§©è®¡ç®—
```

---

## 5.2 ç½‘ç»œç”Ÿæˆæ¨¡å‹ / Network Generation Models

### 5.2.1 éšæœºå›¾æ¨¡å‹è¯¦ç»†ç†è®º

#### 5.2.1.1 ErdÅ‘sâ€“RÃ©nyiæ¨¡å‹ï¼ˆERæ¨¡å‹ï¼‰

**å®šä¹‰ 5.2.1** (ERéšæœºå›¾ / ErdÅ‘sâ€“RÃ©nyi Random Graph)

**$G(n, p)$ æ¨¡å‹**ï¼š$n$ ä¸ªé¡¶ç‚¹ï¼Œæ¯æ¡è¾¹ä»¥æ¦‚ç‡ $p$ ç‹¬ç«‹å­˜åœ¨ã€‚

**è¾¹æ•°æœŸæœ›**ï¼š
$$E[|E|] = p \binom{n}{2} = \frac{pn(n-1)}{2}$$

**åº¦åˆ†å¸ƒ**ï¼šäºŒé¡¹åˆ†å¸ƒ
$$P(d(v) = k) = \binom{n-1}{k} p^k (1-p)^{n-1-k}$$

å½“ $n$ å¾ˆå¤§ä¸” $np$ ä¸ºå¸¸æ•°æ—¶ï¼Œè¿‘ä¼¼æ³Šæ¾åˆ†å¸ƒï¼š
$$P(d(v) = k) \approx \frac{(np)^k e^{-np}}{k!}$$

**è¿é€šæ€§é˜ˆå€¼**ï¼š

- å¦‚æœ $p < \frac{\ln n}{n}$ï¼Œåˆ™å‡ ä¹å¿…ç„¶ä¸è¿é€š
- å¦‚æœ $p > \frac{\ln n}{n}$ï¼Œåˆ™å‡ ä¹å¿…ç„¶è¿é€š

#### 5.2.1.2 Watts-Strogatzæ¨¡å‹ï¼ˆWSæ¨¡å‹ï¼‰

**å®šä¹‰ 5.2.2** (WSå°ä¸–ç•Œæ¨¡å‹ / Watts-Strogatz Small World Model)

**ç”Ÿæˆç®—æ³•**ï¼š

1. æ„é€  $n$ ä¸ªèŠ‚ç‚¹çš„ç¯å½¢è§„åˆ™å›¾ï¼Œæ¯ä¸ªèŠ‚ç‚¹è¿æ¥ $k$ ä¸ªæœ€è¿‘é‚»å±…
2. ä»¥æ¦‚ç‡ $p$ é‡è¿æ¯æ¡è¾¹çš„ä¸€ç«¯

**æ€§è´¨**ï¼š

- å½“ $p = 0$ æ—¶ï¼Œæ˜¯è§„åˆ™å›¾ï¼ˆé«˜èšç±»ï¼Œé•¿è·¯å¾„ï¼‰
- å½“ $p = 1$ æ—¶ï¼Œæ˜¯éšæœºå›¾ï¼ˆä½èšç±»ï¼ŒçŸ­è·¯å¾„ï¼‰
- å½“ $0 < p < 1$ æ—¶ï¼Œå…·æœ‰å°ä¸–ç•Œç‰¹æ€§ï¼ˆé«˜èšç±»ï¼ŒçŸ­è·¯å¾„ï¼‰

#### 5.2.1.3 BarabÃ¡si-Albertæ¨¡å‹ï¼ˆBAæ¨¡å‹ï¼‰

**å®šä¹‰ 5.2.3** (BAæ— æ ‡åº¦æ¨¡å‹ / BarabÃ¡si-Albert Scale-Free Model)

**ç”Ÿæˆç®—æ³•**ï¼š

1. ä» $m_0$ ä¸ªèŠ‚ç‚¹å¼€å§‹
2. æ¯æ¬¡æ·»åŠ ä¸€ä¸ªæ–°èŠ‚ç‚¹
3. æ–°èŠ‚ç‚¹è¿æ¥ $m \leq m_0$ ä¸ªç°æœ‰èŠ‚ç‚¹
4. è¿æ¥æ¦‚ç‡ä¸èŠ‚ç‚¹åº¦æ•°æˆæ­£æ¯”ï¼ˆåå¥½è¿æ¥ï¼‰

**åº¦åˆ†å¸ƒ**ï¼šå¹‚å¾‹åˆ†å¸ƒ
$$P(k) \sim k^{-3}$$

**ç®—æ³•å®ç°**ï¼š

```python
from typing import List, Dict, Set, Tuple
import random
import math

class NetworkGenerationModels:
    """
    ç½‘ç»œç”Ÿæˆæ¨¡å‹å®ç°ã€‚
    """

    def __init__(self):
        pass

    def er_graph(self, n: int, p: float) -> Dict[int, List[int]]:
        """
        ç”ŸæˆErdÅ‘s-RÃ©nyiéšæœºå›¾ã€‚

        Args:
            n: èŠ‚ç‚¹æ•°
            p: è¿è¾¹æ¦‚ç‡

        Returns:
            é‚»æ¥è¡¨è¡¨ç¤ºçš„å›¾
        """
        graph = {i: [] for i in range(n)}

        for i in range(n):
            for j in range(i + 1, n):
                if random.random() < p:
                    graph[i].append(j)
                    graph[j].append(i)

        return graph

    def ws_small_world(self, n: int, k: int, p: float) -> Dict[int, List[int]]:
        """
        ç”ŸæˆWatts-Strogatzå°ä¸–ç•Œç½‘ç»œã€‚

        Args:
            n: èŠ‚ç‚¹æ•°ï¼ˆå¿…é¡»æ˜¯å¶æ•°ï¼‰
            k: æ¯ä¸ªèŠ‚ç‚¹çš„åˆå§‹é‚»å±…æ•°ï¼ˆå¿…é¡»æ˜¯å¶æ•°ï¼‰
            p: é‡è¿æ¦‚ç‡

        Returns:
            é‚»æ¥è¡¨è¡¨ç¤ºçš„å›¾
        """
        graph = {i: [] for i in range(n)}

        # æ­¥éª¤1ï¼šæ„é€ è§„åˆ™ç¯å½¢å›¾
        for i in range(n):
            for j in range(1, k // 2 + 1):
                neighbor = (i + j) % n
                graph[i].append(neighbor)
                graph[neighbor].append(i)

        # æ­¥éª¤2ï¼šé‡è¿
        for i in range(n):
            edges_to_rewire = []
            for neighbor in graph[i]:
                if neighbor > i:  # é¿å…é‡å¤å¤„ç†
                    if random.random() < p:
                        edges_to_rewire.append((i, neighbor))

            for u, v in edges_to_rewire:
                # ç§»é™¤åŸè¾¹
                graph[u].remove(v)
                graph[v].remove(u)

                # é€‰æ‹©æ–°é‚»å±…
                possible_neighbors = [j for j in range(n)
                                     if j != u and j not in graph[u]]
                if possible_neighbors:
                    new_neighbor = random.choice(possible_neighbors)
                    graph[u].append(new_neighbor)
                    graph[new_neighbor].append(u)

        return graph

    def ba_scale_free(self, n: int, m: int, m0: int = None) -> Dict[int, List[int]]:
        """
        ç”ŸæˆBarabÃ¡si-Albertæ— æ ‡åº¦ç½‘ç»œã€‚

        Args:
            n: æœ€ç»ˆèŠ‚ç‚¹æ•°
            m: æ¯ä¸ªæ–°èŠ‚ç‚¹è¿æ¥çš„è¾¹æ•°
            m0: åˆå§‹èŠ‚ç‚¹æ•°ï¼ˆé»˜è®¤ä¸ºmï¼‰

        Returns:
            é‚»æ¥è¡¨è¡¨ç¤ºçš„å›¾
        """
        if m0 is None:
            m0 = m

        graph = {i: [] for i in range(m0)}

        # åˆå§‹åŒ–ï¼šæ„é€ å®Œå…¨å›¾
        for i in range(m0):
            for j in range(i + 1, m0):
                graph[i].append(j)
                graph[j].append(i)

        # æ·»åŠ æ–°èŠ‚ç‚¹
        for new_node in range(m0, n):
            graph[new_node] = []

            # è®¡ç®—åº¦æ•°æ€»å’Œ
            degrees = [len(neighbors) for neighbors in graph.values()]
            total_degree = sum(degrees)

            # é€‰æ‹©mä¸ªèŠ‚ç‚¹è¿æ¥ï¼ˆåå¥½è¿æ¥ï¼‰
            connected = set()
            for _ in range(min(m, len(graph) - 1)):
                # é€‰æ‹©æœªè¿æ¥çš„èŠ‚ç‚¹
                candidates = [i for i in range(new_node) if i not in connected]
                if not candidates:
                    break

                # æŒ‰åº¦æ•°åŠ æƒéšæœºé€‰æ‹©
                probs = [len(graph[i]) / total_degree for i in candidates]
                chosen = random.choices[candidates, weights=probs](0)

                graph[new_node].append(chosen)
                graph[chosen].append(new_node)
                connected.add(chosen)

        return graph

# å¤æ‚åº¦åˆ†æ
# er_graph: O(n^2 * p) å¹³å‡æƒ…å†µ
# ws_small_world: O(n * k + n * k * p) = O(n * k)
# ba_scale_free: O(n * m)
```

### 5.2.2 å‡ ä½•éšæœºå›¾æ¨¡å‹

**å®šä¹‰ 5.2.4** (å‡ ä½•éšæœºå›¾ / Geometric Random Graph)

**å‡ ä½•éšæœºå›¾** $G(n, r)$ æ˜¯åœ¨å•ä½å¹³æ–¹ä¸­éšæœºæ”¾ç½® $n$ ä¸ªç‚¹ï¼Œä¸¤ä¸ªç‚¹ä¹‹é—´è¿è¾¹å½“ä¸”ä»…å½“å®ƒä»¬çš„è·ç¦»å°äºç­‰äº $r$ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š

è®¾ $V = \{v_1, \ldots, v_n\}$ æ˜¯å•ä½å¹³æ–¹ $[0,1]^2$ ä¸­çš„éšæœºç‚¹ï¼Œåˆ™ï¼š
$$E = \{(v_i, v_j) \mid d(v_i, v_j) \leq r\}$$

å…¶ä¸­ $d(v_i, v_j)$ æ˜¯æ¬§å‡ é‡Œå¾—è·ç¦»ã€‚

**è¿é€šæ€§é˜ˆå€¼**ï¼š

å½“ $r = \sqrt{\frac{\ln n + c(n)}{\pi n}}$ æ—¶ï¼š

- å¦‚æœ $\lim c(n) = -\infty$ï¼Œåˆ™å‡ ä¹å¿…ç„¶ä¸è¿é€š
- å¦‚æœ $\lim c(n) = +\infty$ï¼Œåˆ™å‡ ä¹å¿…ç„¶è¿é€š

**ç®—æ³•å®ç°**ï¼š

```python
import numpy as np
from typing import Dict, List, Tuple
import math

class GeometricRandomGraph:
    """
    å‡ ä½•éšæœºå›¾æ¨¡å‹å®ç°ã€‚
    """

    def __init__(self):
        pass

    def geometric_graph(self, n: int, r: float,
                       positions: List[Tuple[float, float]] = None,
                       dim: int = 2) -> Tuple[Dict[int, List[int]],
                                              List[Tuple[float, ...]]]:
        """
        ç”Ÿæˆå‡ ä½•éšæœºå›¾ã€‚

        Args:
            n: èŠ‚ç‚¹æ•°
            r: è¿æ¥åŠå¾„
            positions: èŠ‚ç‚¹ä½ç½®ï¼Œå¦‚æœä¸ºNoneåˆ™éšæœºç”Ÿæˆ
            dim: ç©ºé—´ç»´åº¦ï¼ˆ2æˆ–3ï¼‰

        Returns:
            (å›¾, èŠ‚ç‚¹ä½ç½®)
        """
        # ç”Ÿæˆæˆ–ä½¿ç”¨æä¾›çš„èŠ‚ç‚¹ä½ç½®
        if positions is None:
            if dim == 2:
                positions = [(np.random.random(), np.random.random())
                            for _ in range(n)]
            else:
                positions = [(np.random.random(), np.random.random(), np.random.random())
                            for _ in range(n)]

        graph = {i: [] for i in range(n)}

        # è®¡ç®—è·ç¦»å¹¶è¿è¾¹
        for i in range(n):
            for j in range(i + 1, n):
                distance = self._euclidean_distance(positions[i], positions[j])
                if distance <= r:
                    graph[i].append(j)
                    graph[j].append(i)

        return graph, positions

    def _euclidean_distance(self, p1: Tuple, p2: Tuple) -> float:
        """è®¡ç®—æ¬§å‡ é‡Œå¾—è·ç¦»"""
        return math.sqrt(sum((a - b) ** 2 for a, b in zip(p1, p2)))

    def connectivity_threshold(self, n: int, dim: int = 2) -> float:
        """
        è®¡ç®—è¿é€šæ€§é˜ˆå€¼åŠå¾„ã€‚

        Args:
            n: èŠ‚ç‚¹æ•°
            dim: ç©ºé—´ç»´åº¦

        Returns:
            é˜ˆå€¼åŠå¾„
        """
        if dim == 2:
            # 2D: r = sqrt((ln n + c) / (Ï€ * n))
            r = math.sqrt(math.log(n) / (math.pi * n))
        else:
            # 3D: r = ((ln n + c) / n)^(1/3)
            r = (math.log(n) / n) ** (1/3)

        return r

# å¤æ‚åº¦åˆ†æ
# geometric_graph: O(n^2) - éœ€è¦æ£€æŸ¥æ‰€æœ‰èŠ‚ç‚¹å¯¹çš„è·ç¦»
# connectivity_threshold: O(1)
```

### 5.2.3 æŒ‡æ•°éšæœºå›¾æ¨¡å‹ï¼ˆERGMï¼‰

**å®šä¹‰ 5.2.5** (æŒ‡æ•°éšæœºå›¾æ¨¡å‹ / Exponential Random Graph Model)

**ERGM** å®šä¹‰å›¾çš„æ¦‚ç‡åˆ†å¸ƒï¼š
$$P(G) = \frac{1}{Z(\theta)} \exp\left(\sum_{i} \theta_i s_i(G)\right)$$

å…¶ä¸­ï¼š

- $s_i(G)$ æ˜¯å›¾çš„ç»Ÿè®¡é‡ï¼ˆå¦‚è¾¹æ•°ã€ä¸‰è§’å½¢æ•°ç­‰ï¼‰
- $\theta_i$ æ˜¯å¯¹åº”å‚æ•°
- $Z(\theta) = \sum_{G'} \exp(\sum_i \theta_i s_i(G'))$ æ˜¯é…åˆ†å‡½æ•°ï¼ˆå½’ä¸€åŒ–å¸¸æ•°ï¼‰

**å¸¸è§çš„ç»Ÿè®¡é‡**ï¼š

- **è¾¹æ•°**ï¼š$s_1(G) = |E|$
- **ä¸‰è§’å½¢æ•°**ï¼š$s_2(G) = \text{number of triangles}$
- **æ˜Ÿå½¢ç»“æ„**ï¼š$s_3(G) = \text{number of k-stars}$
- **åº¦æ•°åˆ†å¸ƒ**ï¼š$s_4(G) = \text{degree distribution statistics}$

**å‚æ•°ä¼°è®¡**ï¼š

ä½¿ç”¨æœ€å¤§ä¼¼ç„¶ä¼°è®¡ï¼ˆMLEï¼‰æˆ–ä¼ªä¼¼ç„¶ä¼°è®¡ï¼ˆMPLEï¼‰ä¼°è®¡å‚æ•° $\theta$ã€‚

**ç®—æ³•å®ç°**ï¼š

```python
from typing import Dict, List, Tuple
import numpy as np
import itertools

class ERGMModel:
    """
    æŒ‡æ•°éšæœºå›¾æ¨¡å‹å®ç°ã€‚
    """

    def __init__(self, graph: Dict[int, List[int]]):
        """
        åˆå§‹åŒ–ERGMæ¨¡å‹ã€‚

        Args:
            graph: è§‚å¯Ÿåˆ°çš„å›¾
        """
        self.graph = graph
        self.nodes = sorted(set(graph.keys()) |
                           {n for neighbors in graph.values() for n in neighbors})
        self.n = len(self.nodes)

    def edge_count(self, graph: Dict[int, List[int]] = None) -> int:
        """è®¡ç®—è¾¹æ•°"""
        if graph is None:
            graph = self.graph
        return sum(len(neighbors) for neighbors in graph.values()) // 2

    def triangle_count(self, graph: Dict[int, List[int]] = None) -> int:
        """è®¡ç®—ä¸‰è§’å½¢æ•°"""
        if graph is None:
            graph = self.graph

        triangles = 0
        for i in self.nodes:
            neighbors_i = set(graph.get(i, []))
            for j in neighbors_i:
                if j > i:
                    neighbors_j = set(graph.get(j, []))
                    common = neighbors_i & neighbors_j
                    triangles += len(common)

        return triangles // 3

    def compute_statistics(self, graph: Dict[int, List[int]] = None) -> np.ndarray:
        """
        è®¡ç®—å›¾çš„ç»Ÿè®¡é‡å‘é‡ã€‚

        Args:
            graph: å›¾ï¼Œå¦‚æœä¸ºNoneåˆ™ä½¿ç”¨è§‚å¯Ÿå›¾

        Returns:
            ç»Ÿè®¡é‡å‘é‡ [è¾¹æ•°, ä¸‰è§’å½¢æ•°, ...]
        """
        if graph is None:
            graph = self.graph

        stats = np.array([
            self.edge_count(graph),
            self.triangle_count(graph)
        ])

        return stats

    def log_probability(self, graph: Dict[int, List[int]],
                       theta: np.ndarray) -> float:
        """
        è®¡ç®—å›¾çš„å¯¹æ•°æ¦‚ç‡ï¼ˆæœªå½’ä¸€åŒ–ï¼‰ã€‚

        Args:
            graph: å›¾
            theta: å‚æ•°å‘é‡

        Returns:
            å¯¹æ•°æ¦‚ç‡
        """
        stats = self.compute_statistics(graph)
        log_prob = np.dot(theta, stats)
        return log_prob

# å¤æ‚åº¦åˆ†æ
# edge_count: O(n + |E|)
# triangle_count: O(|E| * <d>) å…¶ä¸­<d>æ˜¯å¹³å‡åº¦æ•°
# compute_statistics: O(|E| * <d>)
```

### 5.2.4 å›¾ç”Ÿæˆå¯¹æŠ—ç½‘ç»œï¼ˆGraphGANï¼‰

**å®šä¹‰ 5.2.6** (GraphGAN / Graph Generative Adversarial Network)

**GraphGAN** ä½¿ç”¨ç”Ÿæˆå¯¹æŠ—ç½‘ç»œæ¡†æ¶ç”Ÿæˆå›¾ç»“æ„ã€‚

**æ¶æ„**ï¼š

- **ç”Ÿæˆå™¨** $G$ï¼šç”Ÿæˆå›¾ç»“æ„
- **åˆ¤åˆ«å™¨** $D$ï¼šåŒºåˆ†çœŸå®å›¾å’Œç”Ÿæˆå›¾

**ç›®æ ‡å‡½æ•°**ï¼š
$$\min_G \max_D V(D, G) = \mathbb{E}_{x \sim p_{data}}[\log D(x)] + \mathbb{E}_{z \sim p_z}[\log(1-D(G(z)))]$$

**å›¾è¡¨ç¤ºæ–¹æ³•**ï¼š

- **é‚»æ¥çŸ©é˜µè¡¨ç¤º**ï¼š$G \in \{0,1\}^{n \times n}$
- **èŠ‚ç‚¹åµŒå…¥è¡¨ç¤º**ï¼šä½¿ç”¨å›¾ç¥ç»ç½‘ç»œå­¦ä¹ èŠ‚ç‚¹è¡¨ç¤º

**ç®—æ³•æ¡†æ¶**ï¼š

1. **ç”Ÿæˆå™¨**ï¼šä»å™ªå£° $z$ ç”Ÿæˆé‚»æ¥çŸ©é˜µ $\hat{A} = G(z)$
2. **åˆ¤åˆ«å™¨**ï¼šåˆ¤æ–­è¾“å…¥çš„é‚»æ¥çŸ©é˜µæ˜¯çœŸå®çš„è¿˜æ˜¯ç”Ÿæˆçš„
3. **è®­ç»ƒ**ï¼šé€šè¿‡å¯¹æŠ—è®­ç»ƒä¼˜åŒ–ç”Ÿæˆå™¨å’Œåˆ¤åˆ«å™¨

**å®ç°æ¡†æ¶**ï¼ˆæ¦‚å¿µæ€§ä»£ç ï¼‰ï¼š

```python
import torch
import torch.nn as nn
from typing import Tuple

class GraphGenerator(nn.Module):
    """
    å›¾ç”Ÿæˆå™¨ï¼ˆç®€åŒ–ç‰ˆæ¦‚å¿µå®ç°ï¼‰ã€‚
    """

    def __init__(self, noise_dim: int = 10, hidden_dim: int = 64,
                 output_dim: int = 100):
        """
        åˆå§‹åŒ–ç”Ÿæˆå™¨ã€‚

        Args:
            noise_dim: å™ªå£°å‘é‡ç»´åº¦
            hidden_dim: éšè—å±‚ç»´åº¦
            output_dim: è¾“å‡ºç»´åº¦ï¼ˆé‚»æ¥çŸ©é˜µå¤§å°ï¼‰
        """
        super(GraphGenerator, self).__init__()
        self.fc1 = nn.Linear(noise_dim, hidden_dim)
        self.fc2 = nn.Linear(hidden_dim, hidden_dim * 2)
        self.fc3 = nn.Linear(hidden_dim * 2, output_dim * output_dim)
        self.output_dim = output_dim

    def forward(self, z: torch.Tensor) -> torch.Tensor:
        """
        ç”Ÿæˆå›¾ï¼ˆé‚»æ¥çŸ©é˜µï¼‰ã€‚

        Args:
            z: å™ªå£°å‘é‡

        Returns:
            é‚»æ¥çŸ©é˜µï¼ˆæ¦‚ç‡ï¼‰
        """
        x = torch.relu(self.fc1(z))
        x = torch.relu(self.fc2(x))
        x = torch.sigmoid(self.fc3(x))
        # é‡å¡‘ä¸ºé‚»æ¥çŸ©é˜µ
        adj = x.view(-1, self.output_dim, self.output_dim)
        # å¯¹ç§°åŒ–ï¼ˆæ— å‘å›¾ï¼‰
        adj = (adj + adj.transpose(1, 2)) / 2
        return adj

class GraphDiscriminator(nn.Module):
    """
    å›¾åˆ¤åˆ«å™¨ï¼ˆç®€åŒ–ç‰ˆæ¦‚å¿µå®ç°ï¼‰ã€‚
    """

    def __init__(self, input_dim: int = 100):
        """
        åˆå§‹åŒ–åˆ¤åˆ«å™¨ã€‚

        Args:
            input_dim: è¾“å…¥ç»´åº¦ï¼ˆé‚»æ¥çŸ©é˜µå¤§å°ï¼‰
        """
        super(GraphDiscriminator, self).__init__()
        self.fc1 = nn.Linear(input_dim * input_dim, 256)
        self.fc2 = nn.Linear(256, 128)
        self.fc3 = nn.Linear(128, 1)

    def forward(self, adj: torch.Tensor) -> torch.Tensor:
        """
        åˆ¤æ–­å›¾çš„çœŸå‡ã€‚

        Args:
            adj: é‚»æ¥çŸ©é˜µ

        Returns:
            çœŸå®æ¦‚ç‡
        """
        x = adj.view(adj.size(0), -1)
        x = torch.relu(self.fc1(x))
        x = torch.relu(self.fc2(x))
        x = torch.sigmoid(self.fc3(x))
        return x

# å¤æ‚åº¦åˆ†æ
# GraphGenerator: O(noise_dim * hidden_dim + hidden_dim^2 + output_dim^2)
# GraphDiscriminator: O(input_dim^2 * hidden_dim)
# å®é™…è®­ç»ƒå¤æ‚åº¦å–å†³äºå›¾çš„å¤§å°å’Œè®­ç»ƒè¿­ä»£æ¬¡æ•°
```

---

## 5.3 åº”ç”¨æ¡ˆä¾‹ / Application Cases

### 5.3.1 ä¼ æ’­åŠ¨åŠ›å­¦åº”ç”¨

#### 5.3.1.1 æµè¡Œç—…ä¼ æ’­å»ºæ¨¡

ä½¿ç”¨SIRæ¨¡å‹å»ºæ¨¡ç–¾ç—…åœ¨ç½‘ç»œä¸Šçš„ä¼ æ’­ï¼Œè¯„ä¼°ä¸åŒé˜²æ§ç­–ç•¥çš„æ•ˆæœã€‚

**åº”ç”¨åœºæ™¯**ï¼š

- COVID-19ä¼ æ’­å»ºæ¨¡
- ç–«è‹—æ¥ç§ç­–ç•¥ä¼˜åŒ–
- éš”ç¦»æªæ–½æ•ˆæœè¯„ä¼°

#### 5.3.1.2 ä¿¡æ¯ä¼ æ’­åˆ†æ

ä½¿ç”¨ç‹¬ç«‹çº§è”æ¨¡å‹å’Œçº¿æ€§é˜ˆå€¼æ¨¡å‹åˆ†æä¿¡æ¯åœ¨ç¤¾äº¤ç½‘ç»œä¸­çš„ä¼ æ’­ã€‚

**åº”ç”¨åœºæ™¯**ï¼š

- ç¤¾äº¤åª’ä½“ä¿¡æ¯ä¼ æ’­
- ç—…æ¯’å¼è¥é”€ç­–ç•¥
- è°£è¨€ä¼ æ’­æ§åˆ¶

### 5.3.2 åŒæ­¥åŠ¨åŠ›å­¦åº”ç”¨

#### 5.3.2.1 ç”µç½‘åŒæ­¥

ä½¿ç”¨Kuramotoæ¨¡å‹åˆ†æç”µåŠ›ç½‘ç»œçš„åŒæ­¥è¡Œä¸ºã€‚

**åº”ç”¨åœºæ™¯**ï¼š

- ç”µåŠ›ç½‘ç»œç¨³å®šæ€§åˆ†æ
- åˆ†å¸ƒå¼å‘ç”µç³»ç»ŸåŒæ­¥
- ç”µç½‘æ•…éšœæ¢å¤

#### 5.3.2.2 ç¥ç»å…ƒåŒæ­¥

åˆ†æå¤§è„‘ç¥ç»ç½‘ç»œçš„åŒæ­¥æ¨¡å¼ã€‚

**åº”ç”¨åœºæ™¯**ï¼š

- ç¥ç»ç§‘å­¦å»ºæ¨¡
- ç™«ç—«å‘ä½œæœºåˆ¶ç ”ç©¶
- è„‘æœºæ¥å£è®¾è®¡

### 5.3.3 ç½‘ç»œç”Ÿæˆæ¨¡å‹åº”ç”¨

#### 5.3.3.1 ç½‘ç»œä»¿çœŸ

ä½¿ç”¨å„ç§ç”Ÿæˆæ¨¡å‹åˆ›å»ºåˆæˆç½‘ç»œç”¨äºç®—æ³•æµ‹è¯•å’Œæ€§èƒ½è¯„ä¼°ã€‚

**åº”ç”¨åœºæ™¯**ï¼š

- è·¯ç”±ç®—æ³•æµ‹è¯•
- ç½‘ç»œåè®®éªŒè¯
- æ€§èƒ½åŸºå‡†æµ‹è¯•

#### 5.3.3.2 æ•°æ®å¢å¼º

ä½¿ç”¨GraphGANç”Ÿæˆåˆæˆç½‘ç»œæ•°æ®ç”¨äºæœºå™¨å­¦ä¹ æ¨¡å‹è®­ç»ƒã€‚

**åº”ç”¨åœºæ™¯**ï¼š

- å›¾ç¥ç»ç½‘ç»œè®­ç»ƒæ•°æ®å¢å¼º
- å°æ ·æœ¬å­¦ä¹ 
- éšç§ä¿æŠ¤æ•°æ®ç”Ÿæˆ

---

## 5.4 æ€»ç»“ä¸å±•æœ› / Summary and Future Directions

æœ¬æ–‡æ¡£ä»‹ç»äº†ç½‘ç»œæ‹“æ‰‘ä¸­çš„é«˜çº§ç†è®ºä¸»é¢˜ï¼š

1. **ç½‘ç»œåŠ¨åŠ›å­¦**ï¼šä¼ æ’­ã€åŒæ­¥ã€åšå¼ˆç­‰åŠ¨æ€è¿‡ç¨‹ï¼Œä¸ºç½‘ç»œè¡Œä¸ºåˆ†ææä¾›äº†ç†è®ºåŸºç¡€
   - ä¼ æ’­åŠ¨åŠ›å­¦ï¼šSIRæ¨¡å‹ã€ç‹¬ç«‹çº§è”ã€çº¿æ€§é˜ˆå€¼æ¨¡å‹
   - åŒæ­¥åŠ¨åŠ›å­¦ï¼šKuramotoæ¨¡å‹ã€åŒæ­¥æ¡ä»¶
   - åšå¼ˆåŠ¨åŠ›å­¦ï¼šæ¼”åŒ–åšå¼ˆã€å¤åˆ¶è€…åŠ¨æ€
   - ç½‘ç»œæ§åˆ¶ï¼šå¯æ§æ€§åˆ†æã€æœ€å°æ§åˆ¶èŠ‚ç‚¹é›†

2. **ç½‘ç»œç”Ÿæˆæ¨¡å‹**ï¼šå„ç§éšæœºå›¾æ¨¡å‹å’Œç”Ÿæˆæ–¹æ³•ï¼Œä¸ºç½‘ç»œä»¿çœŸå’Œå»ºæ¨¡æä¾›äº†å·¥å…·
   - éšæœºå›¾æ¨¡å‹ï¼šERã€WSã€BAæ¨¡å‹
   - å‡ ä½•éšæœºå›¾æ¨¡å‹
   - æŒ‡æ•°éšæœºå›¾æ¨¡å‹ï¼ˆERGMï¼‰
   - å›¾ç”Ÿæˆå¯¹æŠ—ç½‘ç»œï¼ˆGraphGANï¼‰

è¿™äº›é«˜çº§ç†è®ºä¸»é¢˜ä¸ºç½‘ç»œæ‹“æ‰‘çš„åˆ†æã€å»ºæ¨¡å’Œä¼˜åŒ–æä¾›äº†åšå®çš„ç†è®ºåŸºç¡€ã€‚

### æœªæ¥ç ”ç©¶æ–¹å‘

- **AIé©±åŠ¨çš„ç½‘ç»œåŠ¨åŠ›å­¦**ï¼šä½¿ç”¨æœºå™¨å­¦ä¹ é¢„æµ‹å’Œæ§åˆ¶ç½‘ç»œåŠ¨æ€
- **å¤§è§„æ¨¡ç½‘ç»œç”Ÿæˆ**ï¼šé«˜æ•ˆç”Ÿæˆè¶…å¤§è§„æ¨¡ç½‘ç»œçš„æ–¹æ³•
- **å¤šå±‚ç½‘ç»œåŠ¨åŠ›å­¦**ï¼šå¤šå±‚ç½‘ç»œä¸Šçš„ä¼ æ’­å’ŒåŒæ­¥
- **å®æ—¶ç½‘ç»œæ§åˆ¶**ï¼šå®æ—¶ç›‘æ§å’Œæ§åˆ¶ç³»ç»Ÿ

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âš™ï¸ æŒç»­æ›´æ–°ä¸­

*æœ¬æ–‡æ¡£æ˜¯é˜¶æ®µäºŒï¼šé«˜çº§ç†è®ºè¡¥å……çš„ä¸€éƒ¨åˆ†ï¼Œå°†æŒç»­æ›´æ–°å®Œå–„ã€‚*
