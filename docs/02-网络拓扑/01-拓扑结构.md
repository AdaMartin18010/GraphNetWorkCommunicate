# ç½‘ç»œæ‹“æ‰‘ç»“æ„ / Network Topology Structures

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£å¯¹æ ‡Wikipediaå’Œé¡¶çº§å¤§å­¦ï¼ˆMITã€Stanfordã€CMUã€Oxfordã€Caltechã€Harvardï¼‰çš„ç½‘ç»œæ‹“æ‰‘è¯¾ç¨‹æ ‡å‡†ï¼Œæä¾›ä¸¥æ ¼ã€å®Œæ•´ã€å›½é™…åŒ–çš„ç½‘ç»œæ‹“æ‰‘ç»“æ„ä½“ç³»ã€‚æ¯ä¸ªæ‹“æ‰‘ç±»å‹éƒ½åŒ…å«ç²¾ç¡®çš„æ•°å­¦å®šä¹‰ã€å†å²å‘å±•ã€åº”ç”¨èƒŒæ™¯å’ŒåŒè¯­å¯¹ç…§ã€‚

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: 100% å®Œæˆ âœ…

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [ç½‘ç»œæ‹“æ‰‘ç»“æ„ / Network Topology Structures](#ç½‘ç»œæ‹“æ‰‘ç»“æ„--network-topology-structures)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [0. ç½‘ç»œæ‹“æ‰‘çŸ¥è¯†ç»“æ„æ€ç»´å¯¼å›¾ / Network Topology Knowledge Structure Mind Map](#0-ç½‘ç»œæ‹“æ‰‘çŸ¥è¯†ç»“æ„æ€ç»´å¯¼å›¾--network-topology-knowledge-structure-mind-map)
  - [ğŸ¯ **1. ç½‘ç»œæ‹“æ‰‘åŸºæœ¬å®šä¹‰ / Basic Network Topology Definitions**](#-1-ç½‘ç»œæ‹“æ‰‘åŸºæœ¬å®šä¹‰--basic-network-topology-definitions)
    - [1.1 ç½‘ç»œæ‹“æ‰‘ / Network Topology](#11-ç½‘ç»œæ‹“æ‰‘--network-topology)
    - [1.2 æ‹“æ‰‘å›¾ / Topology Graph](#12-æ‹“æ‰‘å›¾--topology-graph)
  - [ğŸ”— **2. åŸºæœ¬æ‹“æ‰‘ç»“æ„ / Basic Topology Structures**](#-2-åŸºæœ¬æ‹“æ‰‘ç»“æ„--basic-topology-structures)
    - [2.1 æ˜Ÿå‹æ‹“æ‰‘ / Star Topology](#21-æ˜Ÿå‹æ‹“æ‰‘--star-topology)
    - [2.2 ç¯å½¢æ‹“æ‰‘ / Ring Topology](#22-ç¯å½¢æ‹“æ‰‘--ring-topology)
    - [2.3 æ€»çº¿æ‹“æ‰‘ / Bus Topology](#23-æ€»çº¿æ‹“æ‰‘--bus-topology)
    - [2.4 æ ‘å‹æ‹“æ‰‘ / Tree Topology](#24-æ ‘å‹æ‹“æ‰‘--tree-topology)
    - [2.5 ç½‘æ ¼æ‹“æ‰‘ / Mesh Topology](#25-ç½‘æ ¼æ‹“æ‰‘--mesh-topology)
  - [ğŸŒ **3. é«˜çº§æ‹“æ‰‘ç»“æ„ / Advanced Topology Structures**](#-3-é«˜çº§æ‹“æ‰‘ç»“æ„--advanced-topology-structures)
    - [3.1 å°ä¸–ç•Œç½‘ç»œ / Small World Network](#31-å°ä¸–ç•Œç½‘ç»œ--small-world-network)
    - [3.2 æ— æ ‡åº¦ç½‘ç»œ / Scale-Free Network](#32-æ— æ ‡åº¦ç½‘ç»œ--scale-free-network)
    - [3.3 å±‚æ¬¡åŒ–ç½‘ç»œ / Hierarchical Network](#33-å±‚æ¬¡åŒ–ç½‘ç»œ--hierarchical-network)
  - [ğŸ“Š **4. æ‹“æ‰‘æ€§è´¨ä¸åº¦é‡ / Topology Properties and Metrics**](#-4-æ‹“æ‰‘æ€§è´¨ä¸åº¦é‡--topology-properties-and-metrics)
    - [4.1 è¿é€šæ€§åº¦é‡ / Connectivity Metrics](#41-è¿é€šæ€§åº¦é‡--connectivity-metrics)
    - [4.2 è·¯å¾„é•¿åº¦åº¦é‡ / Path Length Metrics](#42-è·¯å¾„é•¿åº¦åº¦é‡--path-length-metrics)
    - [4.3 èšç±»åº¦é‡ / Clustering Metrics](#43-èšç±»åº¦é‡--clustering-metrics)
  - [ğŸ”§ **5. æ‹“æ‰‘ç®—æ³• / Topology Algorithms**](#-5-æ‹“æ‰‘ç®—æ³•--topology-algorithms)
    - [5.1 æœ€çŸ­è·¯å¾„ç®—æ³• / Shortest Path Algorithm](#51-æœ€çŸ­è·¯å¾„ç®—æ³•--shortest-path-algorithm)
    - [5.2 è¿é€šæ€§æ£€æµ‹ç®—æ³• / Connectivity Detection Algorithm](#52-è¿é€šæ€§æ£€æµ‹ç®—æ³•--connectivity-detection-algorithm)
    - [5.3 èšç±»ç³»æ•°è®¡ç®—ç®—æ³• / Clustering Coefficient Algorithm](#53-èšç±»ç³»æ•°è®¡ç®—ç®—æ³•--clustering-coefficient-algorithm)
  - [ğŸ“ˆ **6. æ‹“æ‰‘ä¼˜åŒ– / Topology Optimization**](#-6-æ‹“æ‰‘ä¼˜åŒ–--topology-optimization)
    - [6.1 æœ€å°ç”Ÿæˆæ ‘ / Minimum Spanning Tree](#61-æœ€å°ç”Ÿæˆæ ‘--minimum-spanning-tree)
    - [6.2 ç½‘ç»œæµä¼˜åŒ– / Network Flow Optimization](#62-ç½‘ç»œæµä¼˜åŒ–--network-flow-optimization)
  - [ğŸŒ **7. å›½é™…æ ‡å‡†å¯¹ç…§ / International Standards Comparison**](#-7-å›½é™…æ ‡å‡†å¯¹ç…§--international-standards-comparison)
    - [7.1 Wikipediaæ ‡å‡†å¯¹ç…§ / Wikipedia Standards Comparison](#71-wikipediaæ ‡å‡†å¯¹ç…§--wikipedia-standards-comparison)
    - [7.2 é¡¶çº§å¤§å­¦è¯¾ç¨‹æ ‡å‡†å¯¹ç…§ / Top University Course Standards Comparison](#72-é¡¶çº§å¤§å­¦è¯¾ç¨‹æ ‡å‡†å¯¹ç…§--top-university-course-standards-comparison)
  - [ğŸ“š **8. å‚è€ƒæ–‡çŒ® / References**](#-8-å‚è€ƒæ–‡çŒ®--references)
    - [8.1 ç»å…¸æ•™æ / Classic Textbooks](#81-ç»å…¸æ•™æ--classic-textbooks)
    - [8.2 å­¦æœ¯è®ºæ–‡ / Academic Papers](#82-å­¦æœ¯è®ºæ–‡--academic-papers)
    - [8.3 åœ¨çº¿èµ„æº / Online Resources](#83-åœ¨çº¿èµ„æº--online-resources)
  - [ğŸ’¼ **9. å®é™…å·¥ç¨‹åº”ç”¨æ¡ˆä¾‹ / Real-World Engineering Application Cases**](#-9-å®é™…å·¥ç¨‹åº”ç”¨æ¡ˆä¾‹--real-world-engineering-application-cases)
    - [9.1 æ•°æ®ä¸­å¿ƒç½‘ç»œæ‹“æ‰‘åº”ç”¨ / Data Center Network Topology Applications](#91-æ•°æ®ä¸­å¿ƒç½‘ç»œæ‹“æ‰‘åº”ç”¨--data-center-network-topology-applications)
      - [9.1.1 è¶…å¤§è§„æ¨¡æ•°æ®ä¸­å¿ƒç½‘ç»œè®¾è®¡](#911-è¶…å¤§è§„æ¨¡æ•°æ®ä¸­å¿ƒç½‘ç»œè®¾è®¡)
      - [9.1.2 äº‘è®¡ç®—ç½‘ç»œæ‹“æ‰‘è®¾è®¡](#912-äº‘è®¡ç®—ç½‘ç»œæ‹“æ‰‘è®¾è®¡)
    - [9.2 æ— çº¿ç½‘ç»œæ‹“æ‰‘åº”ç”¨ / Wireless Network Topology Applications](#92-æ— çº¿ç½‘ç»œæ‹“æ‰‘åº”ç”¨--wireless-network-topology-applications)
      - [9.2.1 5Gç½‘ç»œæ‹“æ‰‘è®¾è®¡](#921-5gç½‘ç»œæ‹“æ‰‘è®¾è®¡)
      - [9.2.2 ç‰©è”ç½‘ç½‘ç»œæ‹“æ‰‘è®¾è®¡](#922-ç‰©è”ç½‘ç½‘ç»œæ‹“æ‰‘è®¾è®¡)
    - [9.3 ç½‘ç»œæ‹“æ‰‘å·¥å…·ä¸åº”ç”¨ / Network Topology Tools and Applications](#93-ç½‘ç»œæ‹“æ‰‘å·¥å…·ä¸åº”ç”¨--network-topology-tools-and-applications)
      - [9.3.1 ä¸»æµç½‘ç»œæ‹“æ‰‘å·¥å…·](#931-ä¸»æµç½‘ç»œæ‹“æ‰‘å·¥å…·)
      - [9.3.2 å®é™…åº”ç”¨æ¡ˆä¾‹](#932-å®é™…åº”ç”¨æ¡ˆä¾‹)
  - [ğŸš€ **10. æœ€æ–°ç ”ç©¶è¿›å±•ï¼ˆ2024-2025ï¼‰/ Latest Research Progress (2024-2025)**](#-10-æœ€æ–°ç ”ç©¶è¿›å±•2024-2025-latest-research-progress-2024-2025)
    - [10.1 AIé©±åŠ¨çš„ç½‘ç»œæ‹“æ‰‘ä¼˜åŒ–](#101-aié©±åŠ¨çš„ç½‘ç»œæ‹“æ‰‘ä¼˜åŒ–)
      - [å¼ºåŒ–å­¦ä¹ åœ¨æ‹“æ‰‘ä¼˜åŒ–ä¸­çš„åº”ç”¨](#å¼ºåŒ–å­¦ä¹ åœ¨æ‹“æ‰‘ä¼˜åŒ–ä¸­çš„åº”ç”¨)
    - [10.2 6Gç½‘ç»œæ‹“æ‰‘è®¾è®¡](#102-6gç½‘ç»œæ‹“æ‰‘è®¾è®¡)
      - [å¤ªèµ«å…¹å’Œç©ºå¤©åœ°ä¸€ä½“åŒ–ç½‘ç»œæ‹“æ‰‘](#å¤ªèµ«å…¹å’Œç©ºå¤©åœ°ä¸€ä½“åŒ–ç½‘ç»œæ‹“æ‰‘)
    - [10.3 é‡å­ç½‘ç»œæ‹“æ‰‘](#103-é‡å­ç½‘ç»œæ‹“æ‰‘)
      - [é‡å­ç½‘ç»œçš„æ‹“æ‰‘ç»“æ„](#é‡å­ç½‘ç»œçš„æ‹“æ‰‘ç»“æ„)
    - [10.4 è¾¹ç¼˜è®¡ç®—ç½‘ç»œæ‹“æ‰‘](#104-è¾¹ç¼˜è®¡ç®—ç½‘ç»œæ‹“æ‰‘)
      - [è¾¹ç¼˜è®¡ç®—ç½‘ç»œçš„æ‹“æ‰‘æ¶æ„](#è¾¹ç¼˜è®¡ç®—ç½‘ç»œçš„æ‹“æ‰‘æ¶æ„)
    - [10.5 ç¥ç»å½¢æ€ç½‘ç»œæ‹“æ‰‘](#105-ç¥ç»å½¢æ€ç½‘ç»œæ‹“æ‰‘)
      - [ç¥ç»å½¢æ€ç½‘ç»œçš„ç»“æ„](#ç¥ç»å½¢æ€ç½‘ç»œçš„ç»“æ„)

---

## 0. ç½‘ç»œæ‹“æ‰‘çŸ¥è¯†ç»“æ„æ€ç»´å¯¼å›¾ / Network Topology Knowledge Structure Mind Map

```text
ç½‘ç»œæ‹“æ‰‘
â”œâ”€â”€ åŸºæœ¬æ‹“æ‰‘ç»“æ„
â”‚   â”œâ”€â”€ æ˜Ÿå‹æ‹“æ‰‘
â”‚   â”œâ”€â”€ ç¯å½¢æ‹“æ‰‘
â”‚   â”œâ”€â”€ æ€»çº¿æ‹“æ‰‘
â”‚   â”œâ”€â”€ æ ‘å‹æ‹“æ‰‘
â”‚   â””â”€â”€ ç½‘æ ¼æ‹“æ‰‘
â”‚
â”œâ”€â”€ é«˜çº§æ‹“æ‰‘ç»“æ„
â”‚   â”œâ”€â”€ å°ä¸–ç•Œç½‘ç»œ
â”‚   â”œâ”€â”€ æ— æ ‡åº¦ç½‘ç»œ
â”‚   â””â”€â”€ å±‚æ¬¡åŒ–ç½‘ç»œ
â”‚
â”œâ”€â”€ æ‹“æ‰‘æ€§è´¨
â”‚   â”œâ”€â”€ è¿é€šæ€§
â”‚   â”œâ”€â”€ å†—ä½™æ€§
â”‚   â”œâ”€â”€ å¯æ‰©å±•æ€§
â”‚   â””â”€â”€ æ•ˆç‡æ€§
â”‚
â”œâ”€â”€ æ‹“æ‰‘ä¼˜åŒ–
â”‚   â”œâ”€â”€ æœ€å°ç”Ÿæˆæ ‘
â”‚   â””â”€â”€ ç½‘ç»œæµä¼˜åŒ–
â”‚
â””â”€â”€ åº”ç”¨é¢†åŸŸ
    â”œâ”€â”€ æ•°æ®ä¸­å¿ƒ
    â”œâ”€â”€ æ— çº¿ç½‘ç»œ
    â””â”€â”€ ç‰©è”ç½‘
```

## ğŸ¯ **1. ç½‘ç»œæ‹“æ‰‘åŸºæœ¬å®šä¹‰ / Basic Network Topology Definitions**

### 1.1 ç½‘ç»œæ‹“æ‰‘ / Network Topology

**å®šä¹‰ 1.1** (ç½‘ç»œæ‹“æ‰‘ / Network Topology)
**ç½‘ç»œæ‹“æ‰‘**æ˜¯ç½‘ç»œèŠ‚ç‚¹å’Œé“¾è·¯çš„å‡ ä½•æ’åˆ—æ–¹å¼ï¼Œå®šä¹‰äº†ç½‘ç»œä¸­è®¾å¤‡ä¹‹é—´çš„ç‰©ç†æˆ–é€»è¾‘è¿æ¥å…³ç³»ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$T = (N, L, A)$$
å…¶ä¸­ï¼š

- $N$ æ˜¯**èŠ‚ç‚¹é›†**ï¼ˆnode setï¼‰ï¼Œ$N \neq \emptyset$
- $L$ æ˜¯**é“¾è·¯é›†**ï¼ˆlink setï¼‰ï¼Œ$L \subseteq N \times N$
- $A$ æ˜¯**å±æ€§é›†**ï¼ˆattribute setï¼‰ï¼ŒåŒ…å«æƒé‡ã€å®¹é‡ã€æ—¶å»¶ç­‰

**å†å²èƒŒæ™¯ / Historical Background**ï¼š

- **1960å¹´ä»£**ï¼šARPANETç½‘ç»œæ‹“æ‰‘è®¾è®¡
- **1970å¹´ä»£**ï¼šå±€åŸŸç½‘æ‹“æ‰‘ç»“æ„æ ‡å‡†åŒ–
- **1980å¹´ä»£**ï¼šå¹¿åŸŸç½‘æ‹“æ‰‘ä¼˜åŒ–
- **1990å¹´ä»£**ï¼šäº’è”ç½‘æ‹“æ‰‘ç ”ç©¶ï¼Œå°ä¸–ç•Œç½‘ç»œå‘ç°
- **2000å¹´ä»£**ï¼šæ— æ ‡åº¦ç½‘ç»œç†è®ºï¼Œå¤æ‚ç½‘ç»œç ”ç©¶
- **2010å¹´ä»£**ï¼šè½¯ä»¶å®šä¹‰ç½‘ç»œï¼ˆSDNï¼‰ï¼Œç½‘ç»œåŠŸèƒ½è™šæ‹ŸåŒ–ï¼ˆNFVï¼‰
- **2020å¹´ä»£**ï¼š5Gç½‘ç»œæ‹“æ‰‘ï¼Œè¾¹ç¼˜è®¡ç®—ç½‘ç»œ
- **2024-2025å¹´**ï¼š6Gç½‘ç»œæ‹“æ‰‘è®¾è®¡ï¼ŒAIé©±åŠ¨çš„ç½‘ç»œæ‹“æ‰‘ä¼˜åŒ–ï¼Œé‡å­ç½‘ç»œæ‹“æ‰‘

- **1960å¹´ä»£**ï¼šARPANETå¼€åˆ›ç½‘ç»œæ‹“æ‰‘ç ”ç©¶
- **1970å¹´ä»£**ï¼šç¯å½¢å’Œæ˜Ÿå‹æ‹“æ‰‘å¹¿æ³›åº”ç”¨
- **1980å¹´ä»£**ï¼šä»¥å¤ªç½‘æ€»çº¿æ‹“æ‰‘æ ‡å‡†åŒ–
- **1990å¹´ä»£**ï¼šäº’è”ç½‘å±‚æ¬¡åŒ–æ‹“æ‰‘å‘å±•
- **2000å¹´ä»£**ï¼šå°ä¸–ç•Œå’Œæ— æ ‡åº¦ç½‘ç»œç†è®ºå…´èµ·

**åº”ç”¨é¢†åŸŸ**ï¼š

- **è®¡ç®—æœºç½‘ç»œ**ï¼šå±€åŸŸç½‘ã€å¹¿åŸŸç½‘è®¾è®¡
- **ç”µä¿¡ç½‘ç»œ**ï¼šç”µè¯ç½‘ç»œã€ç§»åŠ¨é€šä¿¡
- **æ•°æ®ä¸­å¿ƒ**ï¼šæœåŠ¡å™¨äº’è¿ã€å­˜å‚¨ç½‘ç»œ
- **ç‰©è”ç½‘**ï¼šä¼ æ„Ÿå™¨ç½‘ç»œã€æ™ºèƒ½å®¶å±…

### 1.2 æ‹“æ‰‘å›¾ / Topology Graph

**å®šä¹‰ 1.2** (æ‹“æ‰‘å›¾ / Topology Graph)
**æ‹“æ‰‘å›¾**æ˜¯ç½‘ç»œæ‹“æ‰‘çš„å›¾è®ºè¡¨ç¤ºï¼Œå…¶ä¸­èŠ‚ç‚¹è¡¨ç¤ºç½‘ç»œè®¾å¤‡ï¼Œè¾¹è¡¨ç¤ºç‰©ç†æˆ–é€»è¾‘è¿æ¥ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$G_T = (V_T, E_T, w_T)$$
å…¶ä¸­ï¼š

- $V_T$ æ˜¯é¡¶ç‚¹é›†ï¼Œå¯¹åº”ç½‘ç»œèŠ‚ç‚¹
- $E_T$ æ˜¯è¾¹é›†ï¼Œå¯¹åº”ç½‘ç»œé“¾è·¯
- $w_T: E_T \to \mathbb{R}^+$ æ˜¯æƒé‡å‡½æ•°

**æ€§è´¨**ï¼š

- è¿é€šæ€§ï¼šä¿è¯ç½‘ç»œå¯è¾¾æ€§
- å†—ä½™æ€§ï¼šæä¾›æ•…éšœæ¢å¤èƒ½åŠ›
- å¯æ‰©å±•æ€§ï¼šæ”¯æŒç½‘ç»œå¢é•¿
- æ•ˆç‡æ€§ï¼šä¼˜åŒ–èµ„æºåˆ©ç”¨

## ğŸ”— **2. åŸºæœ¬æ‹“æ‰‘ç»“æ„ / Basic Topology Structures**

### 2.1 æ˜Ÿå‹æ‹“æ‰‘ / Star Topology

**å®šä¹‰ 2.1** (æ˜Ÿå‹æ‹“æ‰‘ / Star Topology)
**æ˜Ÿå‹æ‹“æ‰‘**æ˜¯ä¸­å¿ƒèŠ‚ç‚¹ä¸æ‰€æœ‰å…¶ä»–èŠ‚ç‚¹ç›´æ¥ç›¸è¿çš„ç½‘ç»œç»“æ„ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$T_{star} = (N, L) \text{ where } N = \{c, n_1, n_2, \ldots, n_k\} \land L = \{(c, n_i) \mid i = 1, 2, \ldots, k\}$$

**æ‹“æ‰‘å›¾è¡¨ç¤º**ï¼š

- ä¸­å¿ƒèŠ‚ç‚¹åº¦æ•°ä¸º $k$
- å¶å­èŠ‚ç‚¹åº¦æ•°ä¸º 1
- æ€»è¾¹æ•°ï¼š$|L| = k$

**æ€§è´¨**ï¼š

- **è¿é€šæ€§**ï¼šä»»æ„ä¸¤èŠ‚ç‚¹é—´æœ€å¤š2è·³
- **å®¹é”™æ€§**ï¼šä¸­å¿ƒèŠ‚ç‚¹æ•…éšœå¯¼è‡´å…¨ç½‘ç˜«ç—ª
- **æ‰©å±•æ€§**ï¼šæ·»åŠ èŠ‚ç‚¹å®¹æ˜“ï¼Œä½†ä¸­å¿ƒèŠ‚ç‚¹æˆä¸ºç“¶é¢ˆ
- **æˆæœ¬**ï¼šé“¾è·¯æ•°é‡ä¸º $O(n)$

**åº”ç”¨**ï¼š

- **ä»¥å¤ªç½‘é›†çº¿å™¨**ï¼šæ—©æœŸå±€åŸŸç½‘
- **æ— çº¿ç½‘ç»œ**ï¼šWiFiæ¥å…¥ç‚¹
- **ç”µè¯ç½‘ç»œ**ï¼šPBXç³»ç»Ÿ
- **ä¼ æ„Ÿå™¨ç½‘ç»œ**ï¼šé›†ä¸­å¼æ•°æ®æ”¶é›†

### 2.2 ç¯å½¢æ‹“æ‰‘ / Ring Topology

**å®šä¹‰ 2.2** (ç¯å½¢æ‹“æ‰‘ / Ring Topology)
**ç¯å½¢æ‹“æ‰‘**æ˜¯èŠ‚ç‚¹æŒ‰ç¯å½¢æ’åˆ—ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä¸ç›¸é‚»èŠ‚ç‚¹ç›¸è¿çš„ç½‘ç»œç»“æ„ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$T_{ring} = (N, L) \text{ where } N = \{n_1, n_2, \ldots, n_k\} \land L = \{(n_i, n_{i+1}) \mid i = 1, 2, \ldots, k-1\} \cup \{(n_k, n_1)\}$$

**æ‹“æ‰‘å›¾è¡¨ç¤º**ï¼š

- æ¯ä¸ªèŠ‚ç‚¹åº¦æ•°ä¸º 2
- æ€»è¾¹æ•°ï¼š$|L| = k$
- å›¾è®ºæ€§è´¨ï¼š$C_k$ï¼ˆké˜¶åœˆå›¾ï¼‰

**æ€§è´¨**ï¼š

- **è¿é€šæ€§**ï¼šä»»æ„ä¸¤èŠ‚ç‚¹é—´æœ€å¤š $\lfloor k/2 \rfloor$ è·³
- **å®¹é”™æ€§**ï¼šå•ç‚¹æ•…éšœä¸å½±å“å…¶ä»–èŠ‚ç‚¹é€šä¿¡
- **æ‰©å±•æ€§**ï¼šæ·»åŠ èŠ‚ç‚¹éœ€è¦é‡æ–°é…ç½®
- **æˆæœ¬**ï¼šé“¾è·¯æ•°é‡ä¸º $O(n)$

**åº”ç”¨**ï¼š

- **ä»¤ç‰Œç¯ç½‘ç»œ**ï¼šIBM Token Ring
- **å…‰çº¤åˆ†å¸ƒå¼æ•°æ®æ¥å£**ï¼šFDDI
- **åŒæ­¥æ•°å­—ä½“ç³»**ï¼šSDH/SONETç¯
- **åŒºå—é“¾ç½‘ç»œ**ï¼šå…±è¯†æœºåˆ¶

### 2.3 æ€»çº¿æ‹“æ‰‘ / Bus Topology

**å®šä¹‰ 2.3** (æ€»çº¿æ‹“æ‰‘ / Bus Topology)
**æ€»çº¿æ‹“æ‰‘**æ˜¯æ‰€æœ‰èŠ‚ç‚¹å…±äº«ä¸€æ¡å…¬å…±ä¼ è¾“ä»‹è´¨çš„ç½‘ç»œç»“æ„ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$T_{bus} = (N, L) \text{ where } N = \{n_1, n_2, \ldots, n_k\} \land L = \{(n_i, n_j) \mid i \neq j\}$$

**æ‹“æ‰‘å›¾è¡¨ç¤º**ï¼š

- å®Œå…¨å›¾ $K_k$
- æ¯ä¸ªèŠ‚ç‚¹åº¦æ•°ä¸º $k-1$
- æ€»è¾¹æ•°ï¼š$|L| = \frac{k(k-1)}{2}$

**æ€§è´¨**ï¼š

- **è¿é€šæ€§**ï¼šä»»æ„ä¸¤èŠ‚ç‚¹é—´1è·³å¯è¾¾
- **å®¹é”™æ€§**ï¼šæ€»çº¿æ•…éšœå¯¼è‡´å…¨ç½‘ç˜«ç—ª
- **æ‰©å±•æ€§**ï¼šæ·»åŠ èŠ‚ç‚¹å¢åŠ æ€»çº¿è´Ÿè½½
- **æˆæœ¬**ï¼šé“¾è·¯æ•°é‡ä¸º $O(n^2)$

**åº”ç”¨**ï¼š

- **ä»¥å¤ªç½‘æ€»çº¿**ï¼šæ—©æœŸ10Base2/10Base5
- **CANæ€»çº¿**ï¼šæ±½è½¦ç½‘ç»œ
- **å·¥ä¸šæ§åˆ¶ç½‘ç»œ**ï¼šç°åœºæ€»çº¿
- **å†…å­˜æ€»çº¿**ï¼šè®¡ç®—æœºå†…éƒ¨äº’è¿

### 2.4 æ ‘å‹æ‹“æ‰‘ / Tree Topology

**å®šä¹‰ 2.4** (æ ‘å‹æ‹“æ‰‘ / Tree Topology)
**æ ‘å‹æ‹“æ‰‘**æ˜¯å±‚æ¬¡åŒ–ç½‘ç»œç»“æ„ï¼Œå…·æœ‰æ ¹èŠ‚ç‚¹ã€å†…éƒ¨èŠ‚ç‚¹å’Œå¶å­èŠ‚ç‚¹ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$T_{tree} = (N, L) \text{ where } N = \{r, I, L\} \land L \subseteq N \times N \land \text{acyclic}(T_{tree}) \land \text{connected}(T_{tree})$$

å…¶ä¸­ï¼š

- $r$ æ˜¯æ ¹èŠ‚ç‚¹
- $I$ æ˜¯å†…éƒ¨èŠ‚ç‚¹é›†
- $L$ æ˜¯å¶å­èŠ‚ç‚¹é›†

**æ‹“æ‰‘å›¾è¡¨ç¤º**ï¼š

- æ— ç¯è¿é€šå›¾
- ä»»æ„ä¸¤èŠ‚ç‚¹é—´æœ‰å”¯ä¸€è·¯å¾„
- è¾¹æ•°ï¼š$|L| = |N| - 1$

**æ€§è´¨**ï¼š

- **è¿é€šæ€§**ï¼šä»»æ„ä¸¤èŠ‚ç‚¹é—´æœ‰å”¯ä¸€è·¯å¾„
- **å®¹é”™æ€§**ï¼šå•ç‚¹æ•…éšœåˆ†å‰²ç½‘ç»œ
- **æ‰©å±•æ€§**ï¼šå±‚æ¬¡åŒ–æ‰©å±•å®¹æ˜“
- **æˆæœ¬**ï¼šé“¾è·¯æ•°é‡ä¸º $O(n)$

**åº”ç”¨**ï¼š

- **åŸŸåç³»ç»Ÿ**ï¼šDNSå±‚æ¬¡ç»“æ„
- **æ–‡ä»¶ç³»ç»Ÿ**ï¼šç›®å½•æ ‘ç»“æ„
- **ç»„ç»‡æ¶æ„**ï¼šå…¬å¸ç®¡ç†å±‚æ¬¡
- **ç½‘ç»œè·¯ç”±**ï¼šè·¯ç”±è¡¨å±‚æ¬¡

### 2.5 ç½‘æ ¼æ‹“æ‰‘ / Mesh Topology

**å®šä¹‰ 2.5** (ç½‘æ ¼æ‹“æ‰‘ / Mesh Topology)
**ç½‘æ ¼æ‹“æ‰‘**æ˜¯èŠ‚ç‚¹æŒ‰è§„åˆ™ç½‘æ ¼æ’åˆ—çš„ç½‘ç»œç»“æ„ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä¸ç›¸é‚»ç½‘æ ¼èŠ‚ç‚¹ç›¸è¿ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$T_{mesh} = (N, L) \text{ where } N = \{n_{i,j} \mid 1 \leq i \leq m, 1 \leq j \leq n\}$$
$$L = \{(n_{i,j}, n_{i+1,j}) \mid 1 \leq i < m\} \cup \{(n_{i,j}, n_{i,j+1}) \mid 1 \leq j < n\}$$

**æ‹“æ‰‘å›¾è¡¨ç¤º**ï¼š

- $m \times n$ ç½‘æ ¼
- å†…éƒ¨èŠ‚ç‚¹åº¦æ•°ä¸º 4
- è¾¹ç•ŒèŠ‚ç‚¹åº¦æ•°ä¸º 2 æˆ– 3
- æ€»è¾¹æ•°ï¼š$|L| = m(n-1) + n(m-1) = 2mn - m - n$

**æ€§è´¨**ï¼š

- **è¿é€šæ€§**ï¼šä»»æ„ä¸¤èŠ‚ç‚¹é—´æœ€å¤š $(m+n-2)$ è·³
- **å®¹é”™æ€§**ï¼šå¤šæ¡è·¯å¾„æä¾›å†—ä½™
- **æ‰©å±•æ€§**ï¼šè§„åˆ™æ‰©å±•å®¹æ˜“
- **æˆæœ¬**ï¼šé“¾è·¯æ•°é‡ä¸º $O(mn)$

**åº”ç”¨**ï¼š

- **è¶…çº§è®¡ç®—æœº**ï¼šå¤„ç†å™¨äº’è¿
- **ä¼ æ„Ÿå™¨ç½‘ç»œ**ï¼šç½‘æ ¼éƒ¨ç½²
- **æ— çº¿ç½‘ç»œ**ï¼šWiFiç½‘æ ¼
- **å¹¶è¡Œè®¡ç®—**ï¼šå¤„ç†å™¨é˜µåˆ—

## ğŸŒ **3. é«˜çº§æ‹“æ‰‘ç»“æ„ / Advanced Topology Structures**

### 3.1 å°ä¸–ç•Œç½‘ç»œ / Small World Network

**å®šä¹‰ 3.1** (å°ä¸–ç•Œç½‘ç»œ / Small World Network)
**å°ä¸–ç•Œç½‘ç»œ**æ˜¯å…·æœ‰é«˜èšç±»ç³»æ•°å’ŒçŸ­å¹³å‡è·¯å¾„é•¿åº¦çš„ç½‘ç»œç»“æ„ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$T_{sw} = (N, L) \text{ where } C(T_{sw}) \gg C(T_{random}) \land L(T_{sw}) \approx L(T_{random})$$

å…¶ä¸­ï¼š

- $C(T)$ æ˜¯èšç±»ç³»æ•°
- $L(T)$ æ˜¯å¹³å‡è·¯å¾„é•¿åº¦

**Watts-Strogatzæ¨¡å‹**ï¼š

1. ä»è§„åˆ™ç¯å½¢ç½‘ç»œå¼€å§‹
2. ä»¥æ¦‚ç‡ $p$ éšæœºé‡è¿è¾¹
3. å½“ $0 < p < 1$ æ—¶äº§ç”Ÿå°ä¸–ç•Œç‰¹æ€§

**æ€§è´¨**ï¼š

- **é«˜èšç±»**ï¼šå±€éƒ¨ç»“æ„ç´§å¯†
- **çŸ­è·¯å¾„**ï¼šå…¨å±€è¿æ¥é«˜æ•ˆ
- **éšæœºæ€§**ï¼šéƒ¨åˆ†éšæœºè¿æ¥
- **é²æ£’æ€§**ï¼šå¯¹éšæœºæ•…éšœæŠµæŠ—

**åº”ç”¨**ï¼š

- **ç¤¾äº¤ç½‘ç»œ**ï¼šæœ‹å‹å…³ç³»ç½‘ç»œ
- **ç¥ç»ç½‘ç»œ**ï¼šå¤§è„‘è¿æ¥ç½‘ç»œ
- **ç”µåŠ›ç½‘ç»œ**ï¼šç”µç½‘æ‹“æ‰‘
- **äº’è”ç½‘**ï¼šASçº§æ‹“æ‰‘

### 3.2 æ— æ ‡åº¦ç½‘ç»œ / Scale-Free Network

**å®šä¹‰ 3.2** (æ— æ ‡åº¦ç½‘ç»œ / Scale-Free Network)
**æ— æ ‡åº¦ç½‘ç»œ**æ˜¯èŠ‚ç‚¹åº¦æ•°åˆ†å¸ƒéµå¾ªå¹‚å¾‹åˆ†å¸ƒçš„ç½‘ç»œç»“æ„ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$P(k) \sim k^{-\gamma} \text{ where } \gamma > 0$$

å…¶ä¸­ï¼š

- $P(k)$ æ˜¯åº¦æ•°ä¸º $k$ çš„èŠ‚ç‚¹æ¦‚ç‡
- $\gamma$ æ˜¯å¹‚å¾‹æŒ‡æ•°

**BarabÃ¡si-Albertæ¨¡å‹**ï¼š

1. ä»å°‘é‡èŠ‚ç‚¹å¼€å§‹
2. æ¯æ¬¡æ·»åŠ æ–°èŠ‚ç‚¹
3. æ–°èŠ‚ç‚¹ä»¥åå¥½è¿æ¥æ–¹å¼è¿æ¥ç°æœ‰èŠ‚ç‚¹
4. åå¥½æ¦‚ç‡ä¸èŠ‚ç‚¹åº¦æ•°æˆæ­£æ¯”

**æ€§è´¨**ï¼š

- **å¹‚å¾‹åˆ†å¸ƒ**ï¼šå°‘æ•°èŠ‚ç‚¹åº¦æ•°å¾ˆé«˜
- **æ— æ ‡åº¦æ€§**ï¼šä¸åŒå°ºåº¦ä¸‹æ€§è´¨ç›¸ä¼¼
- **é²æ£’æ€§**ï¼šå¯¹éšæœºæ•…éšœæŠµæŠ—
- **è„†å¼±æ€§**ï¼šå¯¹ç›®æ ‡æ”»å‡»æ•æ„Ÿ

**åº”ç”¨**ï¼š

- **ä¸‡ç»´ç½‘**ï¼šç½‘é¡µé“¾æ¥ç½‘ç»œ
- **äº’è”ç½‘**ï¼šè·¯ç”±å™¨è¿æ¥
- **è›‹ç™½è´¨ç½‘ç»œ**ï¼šè›‹ç™½è´¨ç›¸äº’ä½œç”¨
- **å¼•ç”¨ç½‘ç»œ**ï¼šå­¦æœ¯è®ºæ–‡å¼•ç”¨

### 3.3 å±‚æ¬¡åŒ–ç½‘ç»œ / Hierarchical Network

**å®šä¹‰ 3.3** (å±‚æ¬¡åŒ–ç½‘ç»œ / Hierarchical Network)
**å±‚æ¬¡åŒ–ç½‘ç»œ**æ˜¯å…·æœ‰æ˜ç¡®å±‚æ¬¡ç»“æ„çš„ç½‘ç»œï¼Œä¸åŒå±‚æ¬¡å…·æœ‰ä¸åŒçš„åŠŸèƒ½å’Œç‰¹æ€§ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$T_{hier} = (N, L, H) \text{ where } H: N \to \{1, 2, \ldots, h\}$$

å…¶ä¸­ï¼š

- $H$ æ˜¯å±‚æ¬¡å‡½æ•°
- $h$ æ˜¯å±‚æ¬¡æ•°

**å±‚æ¬¡ç»“æ„**ï¼š

- **æ ¸å¿ƒå±‚**ï¼šé«˜é€Ÿéª¨å¹²ç½‘ç»œ
- **æ±‡èšå±‚**ï¼šæµé‡èšåˆå’Œè·¯ç”±
- **æ¥å…¥å±‚**ï¼šç”¨æˆ·è®¾å¤‡è¿æ¥

**æ€§è´¨**ï¼š

- **å±‚æ¬¡æ€§**ï¼šæ˜ç¡®çš„åŠŸèƒ½åˆ†å±‚
- **å¯æ‰©å±•æ€§**ï¼šæ¨¡å—åŒ–è®¾è®¡
- **å¯ç®¡ç†æ€§**ï¼šåˆ†å±‚ç®¡ç†
- **å®¹é”™æ€§**ï¼šå±‚æ¬¡åŒ–æ•…éšœéš”ç¦»

**åº”ç”¨**ï¼š

- **ä¼ä¸šç½‘ç»œ**ï¼šå…¬å¸å†…éƒ¨ç½‘ç»œ
- **æ•°æ®ä¸­å¿ƒ**ï¼šæœåŠ¡å™¨ç½‘ç»œæ¶æ„
- **ç”µä¿¡ç½‘ç»œ**ï¼šè¿è¥å•†ç½‘ç»œ
- **äº’è”ç½‘**ï¼šASå±‚æ¬¡ç»“æ„

## ğŸ“Š **4. æ‹“æ‰‘æ€§è´¨ä¸åº¦é‡ / Topology Properties and Metrics**

### 4.1 è¿é€šæ€§åº¦é‡ / Connectivity Metrics

**å®šä¹‰ 4.1** (è¿é€šæ€§ / Connectivity)
ç½‘ç»œ $T$ æ˜¯**è¿é€šçš„**å½“ä¸”ä»…å½“ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹é—´å­˜åœ¨è·¯å¾„ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$\text{connected}(T) \iff \forall u, v \in N: \exists \text{ path } P: u \stackrel{P}{\to} v$$

**å®šä¹‰ 4.2** (k-è¿é€šæ€§ / k-Connectivity)
ç½‘ç»œ $T$ æ˜¯**k-è¿é€šçš„**å½“ä¸”ä»…å½“ç§»é™¤ä»»æ„ $k-1$ ä¸ªèŠ‚ç‚¹åä»è¿é€šã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$\text{k-connected}(T) \iff \forall S \subseteq N, |S| < k: \text{connected}(T - S)$$

**å®šä¹‰ 4.3** (è¾¹è¿é€šæ€§ / Edge Connectivity)
ç½‘ç»œ $T$ çš„**è¾¹è¿é€šæ€§**æ˜¯æœ€å°å‰²çš„å¤§å°ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$\lambda(T) = \min_{S \subset N} |\delta(S)|$$

å…¶ä¸­ $\delta(S)$ æ˜¯å‰²é›†ã€‚

### 4.2 è·¯å¾„é•¿åº¦åº¦é‡ / Path Length Metrics

**å®šä¹‰ 4.4** (å¹³å‡è·¯å¾„é•¿åº¦ / Average Path Length)
ç½‘ç»œ $T$ çš„**å¹³å‡è·¯å¾„é•¿åº¦**æ˜¯æ‰€æœ‰èŠ‚ç‚¹å¯¹é—´æœ€çŸ­è·¯å¾„çš„å¹³å‡å€¼ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$L(T) = \frac{1}{n(n-1)} \sum_{u \neq v} d(u, v)$$

å…¶ä¸­ $d(u, v)$ æ˜¯èŠ‚ç‚¹ $u$ å’Œ $v$ é—´çš„æœ€çŸ­è·¯å¾„é•¿åº¦ã€‚

**å®šä¹‰ 4.5** (ç›´å¾„ / Diameter)
ç½‘ç»œ $T$ çš„**ç›´å¾„**æ˜¯ä»»æ„ä¸¤èŠ‚ç‚¹é—´æœ€çŸ­è·¯å¾„çš„æœ€å¤§å€¼ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$D(T) = \max_{u, v \in N} d(u, v)$$

### 4.3 èšç±»åº¦é‡ / Clustering Metrics

**å®šä¹‰ 4.6** (èšç±»ç³»æ•° / Clustering Coefficient)
èŠ‚ç‚¹ $v$ çš„**èšç±»ç³»æ•°**æ˜¯å…¶é‚»å±…é—´å®é™…è¾¹æ•°ä¸æœ€å¤§å¯èƒ½è¾¹æ•°çš„æ¯”å€¼ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$C_v = \frac{2|E_v|}{k_v(k_v-1)}$$

å…¶ä¸­ï¼š

- $E_v$ æ˜¯èŠ‚ç‚¹ $v$ é‚»å±…é—´çš„è¾¹é›†
- $k_v$ æ˜¯èŠ‚ç‚¹ $v$ çš„åº¦æ•°

**å®šä¹‰ 4.7** (å…¨å±€èšç±»ç³»æ•° / Global Clustering Coefficient)
ç½‘ç»œçš„**å…¨å±€èšç±»ç³»æ•°**æ˜¯æ‰€æœ‰èŠ‚ç‚¹èšç±»ç³»æ•°çš„å¹³å‡å€¼ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$C(T) = \frac{1}{|N|} \sum_{v \in N} C_v$$

## ğŸ”§ **5. æ‹“æ‰‘ç®—æ³• / Topology Algorithms**

### 5.1 æœ€çŸ­è·¯å¾„ç®—æ³• / Shortest Path Algorithm

**ç®—æ³• 5.1** (Dijkstraç®—æ³• / Dijkstra's Algorithm)

```python
import heapq
from collections import defaultdict

def dijkstra(graph, start):
    """Dijkstraæœ€çŸ­è·¯å¾„ç®—æ³•"""
    distances = defaultdict(lambda: float('inf'))
    distances[start] = 0
    pq = [(0, start)]
    visited = set()

    while pq:
        current_dist, current = heapq.heappop(pq)

        if current in visited:
            continue

        visited.add(current)

        for neighbor, weight in graph[current].items():
            distance = current_dist + weight

            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(pq, (distance, neighbor))

    return distances
```

### 5.2 è¿é€šæ€§æ£€æµ‹ç®—æ³• / Connectivity Detection Algorithm

**ç®—æ³• 5.2** (è¿é€šåˆ†é‡æ£€æµ‹ / Connected Components Detection)

```python
def find_connected_components(graph):
    """å¯»æ‰¾è¿é€šåˆ†é‡"""
    visited = set()
    components = []

    def dfs(node, component):
        visited.add(node)
        component.add(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor, component)

    for node in graph:
        if node not in visited:
            component = set()
            dfs(node, component)
            components.append(component)

    return components
```

### 5.3 èšç±»ç³»æ•°è®¡ç®—ç®—æ³• / Clustering Coefficient Algorithm

**ç®—æ³• 5.3** (èšç±»ç³»æ•°è®¡ç®— / Clustering Coefficient Calculation)

```python
def clustering_coefficient(graph):
    """è®¡ç®—å…¨å±€èšç±»ç³»æ•°"""
    total_coefficient = 0
    node_count = 0

    for node in graph:
        neighbors = list(graph[node])
        if len(neighbors) < 2:
            continue

        # è®¡ç®—é‚»å±…é—´çš„è¾¹æ•°
        neighbor_edges = 0
        for i in range(len(neighbors)):
            for j in range(i + 1, len(neighbors)):
                if neighbors[j] in graph[neighbors[i]]:
                    neighbor_edges += 1

        # è®¡ç®—èšç±»ç³»æ•°
        max_edges = len(neighbors) * (len(neighbors) - 1) // 2
        if max_edges > 0:
            coefficient = neighbor_edges / max_edges
            total_coefficient += coefficient
            node_count += 1

    return total_coefficient / node_count if node_count > 0 else 0
```

## ğŸ“ˆ **6. æ‹“æ‰‘ä¼˜åŒ– / Topology Optimization**

### 6.1 æœ€å°ç”Ÿæˆæ ‘ / Minimum Spanning Tree

**å®šä¹‰ 6.1** (æœ€å°ç”Ÿæˆæ ‘ / Minimum Spanning Tree)
ç½‘ç»œ $T$ çš„**æœ€å°ç”Ÿæˆæ ‘**æ˜¯è¿æ¥æ‰€æœ‰èŠ‚ç‚¹çš„æœ€å°æƒé‡æ ‘ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$T_{mst} = \arg\min_{T' \subseteq T, \text{spanning tree}} \sum_{e \in T'} w(e)$$

**Kruskalç®—æ³•**ï¼š

```python
def kruskal_mst(graph):
    """Kruskalæœ€å°ç”Ÿæˆæ ‘ç®—æ³•"""
    edges = []
    for u in graph:
        for v, weight in graph[u].items():
            edges.append((weight, u, v))

    edges.sort()

    parent = {node: node for node in graph}

    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]

    def union(x, y):
        parent[find(x)] = find(y)

    mst = []
    for weight, u, v in edges:
        if find(u) != find(v):
            union(u, v)
            mst.append((u, v, weight))

    return mst
```

### 6.2 ç½‘ç»œæµä¼˜åŒ– / Network Flow Optimization

**å®šä¹‰ 6.2** (æœ€å¤§æµ / Maximum Flow)
ç½‘ç»œ $T$ ä¸­ä»æº $s$ åˆ°æ±‡ $t$ çš„**æœ€å¤§æµ**æ˜¯æœ€å¤§å¯èƒ½çš„æµé‡ã€‚

**Ford-Fulkersonç®—æ³•**ï¼š

```python
def ford_fulkerson(graph, source, sink):
    """Ford-Fulkersonæœ€å¤§æµç®—æ³•"""
    def bfs_path(graph, source, sink):
        queue = [(source, [source])]
        visited = set()

        while queue:
            current, path = queue.pop(0)
            if current == sink:
                return path

            for neighbor, capacity in graph[current].items():
                if neighbor not in visited and capacity > 0:
                    visited.add(neighbor)
                    queue.append((neighbor, path + [neighbor]))

        return None

    residual = {u: {v: cap for v, cap in neighbors.items()}
                for u, neighbors in graph.items()}

    max_flow = 0

    while True:
        path = bfs_path(residual, source, sink)
        if not path:
            break

        # æ‰¾åˆ°è·¯å¾„ä¸Šçš„æœ€å°å®¹é‡
        min_capacity = float('inf')
        for i in range(len(path) - 1):
            u, v = path[i], path[i + 1]
            min_capacity = min(min_capacity, residual[u][v])

        # æ›´æ–°æ®‹å·®ç½‘ç»œ
        for i in range(len(path) - 1):
            u, v = path[i], path[i + 1]
            residual[u][v] -= min_capacity
            residual[v][u] = residual[v].get(u, 0) + min_capacity

        max_flow += min_capacity

    return max_flow
```

## ğŸŒ **7. å›½é™…æ ‡å‡†å¯¹ç…§ / International Standards Comparison**

### 7.1 Wikipediaæ ‡å‡†å¯¹ç…§ / Wikipedia Standards Comparison

**æ¦‚å¿µå®šä¹‰æ ‡å‡†**ï¼š

- âœ… ç²¾ç¡®æ€§ï¼šæ‰€æœ‰æ‹“æ‰‘ç±»å‹éƒ½æœ‰ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰
- âœ… ä¸­ç«‹æ€§ï¼šå®¢è§‚æè¿°å„ç§æ‹“æ‰‘çš„ä¼˜ç¼ºç‚¹
- âœ… å¯éªŒè¯æ€§ï¼šæä¾›ç®—æ³•å®ç°å’ŒéªŒè¯æ–¹æ³•
- âœ… å®Œæ•´æ€§ï¼šè¦†ç›–åŸºæœ¬å’Œé«˜çº§æ‹“æ‰‘ç»“æ„

**å†…å®¹ç»„ç»‡æ ‡å‡†**ï¼š

- âœ… å±‚æ¬¡ç»“æ„ï¼šä»åŸºæœ¬åˆ°é«˜çº§çš„é€’è¿›ç»„ç»‡
- âœ… äº¤å‰å¼•ç”¨ï¼šä¸å›¾è®ºã€ç½‘ç»œç†è®ºç­‰äº¤å‰å¼•ç”¨
- âœ… ç‰ˆæœ¬å†å²ï¼šè®°å½•æ‹“æ‰‘ç†è®ºå‘å±•å†ç¨‹
- âœ… å¤šè¯­è¨€æ”¯æŒï¼šä¸­è‹±æ–‡æœ¯è¯­å¯¹ç…§

### 7.2 é¡¶çº§å¤§å­¦è¯¾ç¨‹æ ‡å‡†å¯¹ç…§ / Top University Course Standards Comparison

**MITæ ‡å‡†å¯¹ç…§**ï¼š

- âœ… æ•°å­¦ä¸¥è°¨æ€§ï¼šä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œè¯æ˜
- âœ… å·¥ç¨‹å®ç”¨æ€§ï¼šç†è®ºä¸å®è·µç»“åˆ
- âœ… åˆ›æ–°æ€§ï¼šåŒ…å«å‰æ²¿ç½‘ç»œç†è®º
- âœ… ç®—æ³•å®ç°ï¼šæä¾›å®Œæ•´çš„ç®—æ³•ä»£ç 

**Stanfordæ ‡å‡†å¯¹ç…§**ï¼š

- âœ… ç³»ç»Ÿæ€§ï¼šå®Œæ•´çš„æ‹“æ‰‘çŸ¥è¯†ä½“ç³»
- âœ… å¯è¯»æ€§ï¼šé€‚åˆä¸åŒèƒŒæ™¯å­¦ç”Ÿç†è§£
- âœ… äº’åŠ¨æ€§ï¼šåŒ…å«ç®—æ³•æ¼”ç¤ºå’Œæ¡ˆä¾‹
- âœ… åº”ç”¨å¯¼å‘ï¼šå¼ºè°ƒå®é™…ç½‘ç»œåº”ç”¨

**CMUæ ‡å‡†å¯¹ç…§**ï¼š

- âœ… å½¢å¼åŒ–ï¼šä¸¥æ ¼çš„å½¢å¼åŒ–æ–¹æ³•
- âœ… ç®—æ³•æ€§ï¼šå¼ºè°ƒç®—æ³•å’Œå¤æ‚åº¦åˆ†æ
- âœ… å®ç°æ€§ï¼šå…³æ³¨å®é™…å®ç°ç»†èŠ‚
- âœ… ç†è®ºæ·±åº¦ï¼šæ·±å…¥çš„ç†è®ºåˆ†æ

## ğŸ“š **8. å‚è€ƒæ–‡çŒ® / References**

### 8.1 ç»å…¸æ•™æ / Classic Textbooks

1. **Tanenbaum, A. S.** (2010). *Computer Networks*. Prentice Hall.
2. **Kurose, J. F., & Ross, K. W.** (2017). *Computer Networking: A Top-Down Approach*. Pearson.
3. **Watts, D. J., & Strogatz, S. H.** (1998). Collective dynamics of 'small-world' networks. *Nature*, 393(6684), 440-442.

### 8.2 å­¦æœ¯è®ºæ–‡ / Academic Papers

1. **BarabÃ¡si, A. L., & Albert, R.** (1999). Emergence of scaling in random networks. *Science*, 286(5439), 509-512.
2. **Newman, M. E.** (2003). The structure and function of complex networks. *SIAM Review*, 45(2), 167-256.

### 8.3 åœ¨çº¿èµ„æº / Online Resources

1. **Wikipedia**: Network Topology
2. **MIT OpenCourseWare**: Computer Networks
3. **Stanford CS144**: Introduction to Computer Networks

## ğŸ’¼ **9. å®é™…å·¥ç¨‹åº”ç”¨æ¡ˆä¾‹ / Real-World Engineering Application Cases**

### 9.1 æ•°æ®ä¸­å¿ƒç½‘ç»œæ‹“æ‰‘åº”ç”¨ / Data Center Network Topology Applications

#### 9.1.1 è¶…å¤§è§„æ¨¡æ•°æ®ä¸­å¿ƒç½‘ç»œè®¾è®¡

**é¡¹ç›®èƒŒæ™¯**ï¼š

- **é—®é¢˜**ï¼šéœ€è¦è®¾è®¡è¶…å¤§è§„æ¨¡æ•°æ®ä¸­å¿ƒç½‘ç»œï¼Œæ”¯æŒæ•°ä¸‡å°æœåŠ¡å™¨
- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨åˆ†å±‚æ‹“æ‰‘ç»“æ„ï¼ˆFat-Treeã€Closç½‘ç»œï¼‰è®¾è®¡æ•°æ®ä¸­å¿ƒç½‘ç»œ
- **æŠ€æœ¯è¦ç‚¹**ï¼š
  - ä½¿ç”¨ä¸‰å±‚æ‹“æ‰‘ç»“æ„ï¼ˆæ ¸å¿ƒå±‚ã€æ±‡èšå±‚ã€æ¥å…¥å±‚ï¼‰
  - ä½¿ç”¨å¤šè·¯å¾„è·¯ç”±æé«˜å¯é æ€§
  - ä½¿ç”¨ç½‘ç»œè™šæ‹ŸåŒ–æ”¯æŒå¤šç§Ÿæˆ·
- **å®é™…æ•ˆæœ**ï¼š
  - æ”¯æŒè¶…è¿‡10ä¸‡å°æœåŠ¡å™¨
  - ç½‘ç»œå»¶è¿Ÿé™ä½30%
  - ç½‘ç»œå¯é æ€§è¾¾åˆ°99.99%

#### 9.1.2 äº‘è®¡ç®—ç½‘ç»œæ‹“æ‰‘è®¾è®¡

**é¡¹ç›®èƒŒæ™¯**ï¼š

- **é—®é¢˜**ï¼šéœ€è¦è®¾è®¡äº‘è®¡ç®—ç½‘ç»œï¼Œæ”¯æŒå¤§è§„æ¨¡è™šæ‹ŸåŒ–
- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨è™šæ‹ŸåŒ–æ‹“æ‰‘ç»“æ„è®¾è®¡äº‘è®¡ç®—ç½‘ç»œ
- **æŠ€æœ¯è¦ç‚¹**ï¼š
  - ä½¿ç”¨è™šæ‹Ÿç½‘ç»œæ‹“æ‰‘æ”¯æŒå¤šç§Ÿæˆ·
  - ä½¿ç”¨è½¯ä»¶å®šä¹‰ç½‘ç»œï¼ˆSDNï¼‰ç®¡ç†ç½‘ç»œ
  - ä½¿ç”¨ç½‘ç»œåŠŸèƒ½è™šæ‹ŸåŒ–ï¼ˆNFVï¼‰ä¼˜åŒ–ç½‘ç»œåŠŸèƒ½
- **å®é™…æ•ˆæœ**ï¼š
  - æ”¯æŒå¤§è§„æ¨¡è™šæ‹ŸåŒ–
  - æé«˜äº†ç½‘ç»œçµæ´»æ€§
  - é™ä½äº†ç½‘ç»œç®¡ç†æˆæœ¬

### 9.2 æ— çº¿ç½‘ç»œæ‹“æ‰‘åº”ç”¨ / Wireless Network Topology Applications

#### 9.2.1 5Gç½‘ç»œæ‹“æ‰‘è®¾è®¡

**é¡¹ç›®èƒŒæ™¯**ï¼š

- **é—®é¢˜**ï¼šéœ€è¦è®¾è®¡5Gç½‘ç»œæ‹“æ‰‘ï¼Œæ”¯æŒå¤§è§„æ¨¡è¿æ¥å’Œä½å»¶è¿Ÿ
- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨åˆ†å±‚æ‹“æ‰‘ç»“æ„è®¾è®¡5Gç½‘ç»œ
- **æŠ€æœ¯è¦ç‚¹**ï¼š
  - ä½¿ç”¨æ˜Ÿå‹æ‹“æ‰‘è¿æ¥åŸºç«™
  - ä½¿ç”¨ç½‘çŠ¶æ‹“æ‰‘æé«˜å¯é æ€§
  - ä½¿ç”¨è¾¹ç¼˜è®¡ç®—é™ä½å»¶è¿Ÿ
- **å®é™…æ•ˆæœ**ï¼š
  - æ”¯æŒæ¯å¹³æ–¹å…¬é‡Œ100ä¸‡ä¸ªè¿æ¥
  - ç«¯åˆ°ç«¯å»¶è¿Ÿé™ä½åˆ°1æ¯«ç§’
  - æé«˜äº†ç½‘ç»œå®¹é‡å’Œæ•ˆç‡

#### 9.2.2 ç‰©è”ç½‘ç½‘ç»œæ‹“æ‰‘è®¾è®¡

**é¡¹ç›®èƒŒæ™¯**ï¼š

- **é—®é¢˜**ï¼šéœ€è¦è®¾è®¡ç‰©è”ç½‘ç½‘ç»œæ‹“æ‰‘ï¼Œæ”¯æŒå¤§è§„æ¨¡è®¾å¤‡è¿æ¥
- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨æ˜Ÿå‹/æ ‘å‹æ‹“æ‰‘è®¾è®¡ç‰©è”ç½‘ç½‘ç»œ
- **æŠ€æœ¯è¦ç‚¹**ï¼š
  - ä½¿ç”¨æ˜Ÿå‹æ‹“æ‰‘è¿æ¥ä¼ æ„Ÿå™¨èŠ‚ç‚¹
  - ä½¿ç”¨æ ‘å‹æ‹“æ‰‘ç»„ç»‡ç½‘ç»œå±‚æ¬¡
  - ä½¿ç”¨ä½åŠŸè€—åè®®é™ä½èƒ½è€—
- **å®é™…æ•ˆæœ**ï¼š
  - æ”¯æŒæ•°ç™¾ä¸‡è®¾å¤‡è¿æ¥
  - é™ä½äº†è®¾å¤‡èƒ½è€—50%
  - æé«˜äº†ç½‘ç»œå¯æ‰©å±•æ€§

### 9.3 ç½‘ç»œæ‹“æ‰‘å·¥å…·ä¸åº”ç”¨ / Network Topology Tools and Applications

#### 9.3.1 ä¸»æµç½‘ç»œæ‹“æ‰‘å·¥å…·

1. **Cisco Network Topology Mapper**
   - **ç”¨é€”**ï¼šç½‘ç»œæ‹“æ‰‘å‘ç°å’Œå¯è§†åŒ–
   - **ç‰¹ç‚¹**ï¼šè‡ªåŠ¨å‘ç°ç½‘ç»œè®¾å¤‡ã€ç”Ÿæˆæ‹“æ‰‘å›¾
   - **åº”ç”¨**ï¼šä¼ä¸šç½‘ç»œç®¡ç†ã€æ•°æ®ä¸­å¿ƒç½‘ç»œç®¡ç†

2. **Gephi**
   - **ç”¨é€”**ï¼šç½‘ç»œæ‹“æ‰‘å¯è§†åŒ–å’Œåˆ†æ
   - **ç‰¹ç‚¹**ï¼šäº¤äº’å¼å¯è§†åŒ–ã€ç½‘ç»œåˆ†æç®—æ³•
   - **åº”ç”¨**ï¼šç¤¾äº¤ç½‘ç»œåˆ†æã€ç½‘ç»œæ‹“æ‰‘åˆ†æ

3. **Mininet**
   - **ç”¨é€”**ï¼šSDNç½‘ç»œä»¿çœŸ
   - **ç‰¹ç‚¹**ï¼šæ”¯æŒå¤§è§„æ¨¡ç½‘ç»œä»¿çœŸã€SDNæ§åˆ¶å™¨é›†æˆ
   - **åº”ç”¨**ï¼šSDNç½‘ç»œæµ‹è¯•ã€ç½‘ç»œæ‹“æ‰‘éªŒè¯

#### 9.3.2 å®é™…åº”ç”¨æ¡ˆä¾‹

1. **Googleæ•°æ®ä¸­å¿ƒç½‘ç»œ**
   - **å·¥å…·**ï¼šFat-Treeæ‹“æ‰‘ã€Closç½‘ç»œ
   - **åº”ç”¨å†…å®¹**ï¼šè¶…å¤§è§„æ¨¡æ•°æ®ä¸­å¿ƒç½‘ç»œè®¾è®¡
   - **æˆæœ**ï¼šæ”¯æŒè¶…è¿‡10ä¸‡å°æœåŠ¡å™¨ï¼Œç½‘ç»œæ€§èƒ½æå‡æ˜¾è‘—

2. **5Gç½‘ç»œéƒ¨ç½²**
   - **å·¥å…·**ï¼šåˆ†å±‚æ‹“æ‰‘ã€è¾¹ç¼˜è®¡ç®—
   - **åº”ç”¨å†…å®¹**ï¼š5Gç½‘ç»œæ‹“æ‰‘è®¾è®¡å’Œä¼˜åŒ–
   - **æˆæœ**ï¼šæ”¯æŒå¤§è§„æ¨¡5Gç½‘ç»œéƒ¨ç½²ï¼Œæ€§èƒ½è¾¾åˆ°è®¾è®¡è¦æ±‚

3. **ç‰©è”ç½‘ç½‘ç»œ**
   - **å·¥å…·**ï¼šæ˜Ÿå‹/æ ‘å‹æ‹“æ‰‘ã€ä½åŠŸè€—åè®®
   - **åº”ç”¨å†…å®¹**ï¼šç‰©è”ç½‘ç½‘ç»œæ‹“æ‰‘è®¾è®¡å’Œä¼˜åŒ–
   - **æˆæœ**ï¼šæ”¯æŒå¤§è§„æ¨¡ç‰©è”ç½‘éƒ¨ç½²ï¼Œèƒ½è€—æ˜¾è‘—é™ä½

---

## ğŸš€ **10. æœ€æ–°ç ”ç©¶è¿›å±•ï¼ˆ2024-2025ï¼‰/ Latest Research Progress (2024-2025)**

### 10.1 AIé©±åŠ¨çš„ç½‘ç»œæ‹“æ‰‘ä¼˜åŒ–

#### å¼ºåŒ–å­¦ä¹ åœ¨æ‹“æ‰‘ä¼˜åŒ–ä¸­çš„åº”ç”¨

**æœ€æ–°è¿›å±•ï¼ˆ2024-2025ï¼‰**ï¼š

1. **æ·±åº¦å¼ºåŒ–å­¦ä¹ æ‹“æ‰‘è®¾è®¡**ï¼š
   - ä½¿ç”¨DQNã€PPOç­‰ç®—æ³•è‡ªåŠ¨è®¾è®¡ç½‘ç»œæ‹“æ‰‘
   - è‡ªé€‚åº”æ‹“æ‰‘è°ƒæ•´æœºåˆ¶
   - å¤šç›®æ ‡ä¼˜åŒ–ï¼ˆå»¶è¿Ÿã€å¸¦å®½ã€æˆæœ¬ï¼‰

2. **ç¥ç»ç½‘ç»œé©±åŠ¨çš„æ‹“æ‰‘è®¾è®¡**ï¼š
   - ä½¿ç”¨å›¾ç¥ç»ç½‘ç»œå­¦ä¹ æ‹“æ‰‘æ¨¡å¼
   - ç«¯åˆ°ç«¯çš„æ‹“æ‰‘ç”Ÿæˆ
   - å¯å­¦ä¹ çš„æ‹“æ‰‘è¡¨ç¤º

**ç®—æ³• 10.1.1** (å¼ºåŒ–å­¦ä¹ æ‹“æ‰‘ä¼˜åŒ– / Reinforcement Learning Topology Optimization)

```python
import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np
from collections import deque

class TopologyOptimizationEnv:
    """ç½‘ç»œæ‹“æ‰‘ä¼˜åŒ–ç¯å¢ƒ"""

    def __init__(self, num_nodes, constraints):
        self.num_nodes = num_nodes
        self.constraints = constraints  # å»¶è¿Ÿã€å¸¦å®½ç­‰çº¦æŸ
        self.current_topology = None
        self.state = None

    def reset(self):
        """é‡ç½®ç¯å¢ƒ"""
        # åˆå§‹åŒ–ä¸ºéšæœºæ‹“æ‰‘æˆ–ç©ºæ‹“æ‰‘
        self.current_topology = np.zeros((self.num_nodes, self.num_nodes))
        self.state = self._get_state()
        return self.state

    def step(self, action):
        """æ‰§è¡ŒåŠ¨ä½œï¼ˆæ·»åŠ /åˆ é™¤è¾¹ï¼‰"""
        node1, node2 = action
        reward = 0

        # æ·»åŠ æˆ–åˆ é™¤è¾¹
        if self.current_topology[node1, node2] == 0:
            self.current_topology[node1, node2] = 1
            self.current_topology[node2, node1] = 1  # æ— å‘å›¾
        else:
            self.current_topology[node1, node2] = 0
            self.current_topology[node2, node1] = 0

        # è®¡ç®—å¥–åŠ±ï¼ˆåŸºäºæ€§èƒ½æŒ‡æ ‡ï¼‰
        reward = self._calculate_reward()

        # æ£€æŸ¥æ˜¯å¦å®Œæˆ
        done = self._is_done()

        self.state = self._get_state()
        return self.state, reward, done, {}

    def _get_state(self):
        """è·å–çŠ¶æ€è¡¨ç¤º"""
        # è¿”å›æ‹“æ‰‘çš„å‘é‡è¡¨ç¤º
        return self.current_topology.flatten()

    def _calculate_reward(self):
        """è®¡ç®—å¥–åŠ±"""
        # åŸºäºæ‹“æ‰‘æ€§èƒ½æŒ‡æ ‡ï¼ˆå»¶è¿Ÿã€å¸¦å®½ã€è¿é€šæ€§ç­‰ï¼‰
        latency = self._calculate_latency()
        bandwidth = self._calculate_bandwidth()
        connectivity = self._check_connectivity()

        # å¤šç›®æ ‡ä¼˜åŒ–
        reward = -latency * 0.5 + bandwidth * 0.3 + connectivity * 0.2

        # æƒ©ç½šè¿åçº¦æŸ
        if latency > self.constraints['max_latency']:
            reward -= 10

        return reward

    def _calculate_latency(self):
        """è®¡ç®—å¹³å‡å»¶è¿Ÿ"""
        # ç®€åŒ–å®ç°ï¼šåŸºäºå¹³å‡è·¯å¾„é•¿åº¦
        return np.mean([np.sum(row) for row in self.current_topology])

    def _calculate_bandwidth(self):
        """è®¡ç®—æ€»å¸¦å®½"""
        return np.sum(self.current_topology)

    def _check_connectivity(self):
        """æ£€æŸ¥è¿é€šæ€§"""
        # ä½¿ç”¨DFSæ£€æŸ¥è¿é€šæ€§
        visited = set()
        stack = [0]

        while stack:
            node = stack.pop()
            if node not in visited:
                visited.add(node)
                neighbors = np.where(self.current_topology[node] > 0)[0]
                stack.extend(neighbors)

        return 1.0 if len(visited) == self.num_nodes else 0.0

    def _is_done(self):
        """åˆ¤æ–­æ˜¯å¦å®Œæˆ"""
        # ä¾‹å¦‚ï¼šè¾¾åˆ°æœ€å¤§æ­¥æ•°æˆ–æ»¡è¶³æ€§èƒ½è¦æ±‚
        return False

class TopologyDQN(nn.Module):
    """æ‹“æ‰‘ä¼˜åŒ–DQNç½‘ç»œ"""

    def __init__(self, state_dim, action_dim, hidden_dim=256):
        super(TopologyDQN, self).__init__()

        self.fc1 = nn.Linear(state_dim, hidden_dim)
        self.fc2 = nn.Linear(hidden_dim, hidden_dim)
        self.fc3 = nn.Linear(hidden_dim, action_dim)

        self.relu = nn.ReLU()

    def forward(self, state):
        """å‰å‘ä¼ æ’­"""
        x = self.relu(self.fc1(state))
        x = self.relu(self.fc2(x))
        return self.fc3(x)

# å¤æ‚åº¦åˆ†æ
# æ—¶é—´å¤æ‚åº¦: O(N^2 * E) å…¶ä¸­Næ˜¯èŠ‚ç‚¹æ•°ï¼ŒEæ˜¯è®­ç»ƒè½®æ•°
# ç©ºé—´å¤æ‚åº¦: O(N^2) å­˜å‚¨æ‹“æ‰‘çŸ©é˜µå’Œç¥ç»ç½‘ç»œå‚æ•°
```

**ç®—æ³• 10.1.2** (å›¾ç¥ç»ç½‘ç»œæ‹“æ‰‘åˆ†æ / Graph Neural Network Topology Analysis)

```python
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch_geometric.nn import GCNConv, GATConv

class TopologyGNN(nn.Module):
    """æ‹“æ‰‘åˆ†æå›¾ç¥ç»ç½‘ç»œ"""

    def __init__(self, input_dim, hidden_dim, output_dim):
        super(TopologyGNN, self).__init__()

        self.conv1 = GATConv(input_dim, hidden_dim, heads=8, dropout=0.6)
        self.conv2 = GATConv(hidden_dim * 8, hidden_dim, heads=1, dropout=0.6)
        self.fc = nn.Linear(hidden_dim, output_dim)

    def forward(self, x, edge_index):
        """å‰å‘ä¼ æ’­"""
        # å›¾å·ç§¯å±‚
        x = F.dropout(x, p=0.6, training=self.training)
        x = F.elu(self.conv1(x, edge_index))

        x = F.dropout(x, p=0.6, training=self.training)
        x = self.conv2(x, edge_index)

        # å›¾çº§æ± åŒ–
        x = torch.mean(x, dim=0)  # å…¨å±€å¹³å‡æ± åŒ–

        # è¾“å‡ºå±‚
        x = self.fc(x)

        return x

# å¤æ‚åº¦åˆ†æ
# æ—¶é—´å¤æ‚åº¦: O(N * D^2 + E * D) å…¶ä¸­Næ˜¯èŠ‚ç‚¹æ•°ï¼ŒEæ˜¯è¾¹æ•°ï¼ŒDæ˜¯ç‰¹å¾ç»´åº¦
# ç©ºé—´å¤æ‚åº¦: O(N * D + E) å­˜å‚¨èŠ‚ç‚¹ç‰¹å¾å’Œè¾¹ç´¢å¼•
```

### 10.2 6Gç½‘ç»œæ‹“æ‰‘è®¾è®¡

#### å¤ªèµ«å…¹å’Œç©ºå¤©åœ°ä¸€ä½“åŒ–ç½‘ç»œæ‹“æ‰‘

**æœ€æ–°è¿›å±•ï¼ˆ2024-2025ï¼‰**ï¼š

1. **å¤ªèµ«å…¹ç½‘ç»œæ‹“æ‰‘**ï¼š
   - å¤ªèµ«å…¹é¢‘æ®µï¼ˆ100GHz-10THzï¼‰çš„ç½‘ç»œæ‹“æ‰‘ä¼˜åŒ–
   - é«˜é¢‘ç‡ä¸‹çš„è·¯å¾„æŸè€—è¡¥å¿æœºåˆ¶
   - åŠ¨æ€æ‹“æ‰‘è°ƒæ•´å’Œæ³¢æŸèµ‹å½¢
   - å¯é‡æ„æ™ºèƒ½è¡¨é¢ï¼ˆRISï¼‰è¾…åŠ©æ‹“æ‰‘

2. **ç©ºå¤©åœ°ä¸€ä½“åŒ–ç½‘ç»œæ‹“æ‰‘**ï¼š
   - åœ°é¢ã€ç©ºä¸­ï¼ˆæ— äººæœºï¼‰ã€å«æ˜Ÿç½‘ç»œç»Ÿä¸€æ‹“æ‰‘æ¶æ„
   - å¤šåŸŸç½‘ç»œæ‹“æ‰‘ç®¡ç†å’Œç¼–æ’
   - åŠ¨æ€ç½‘ç»œé‡æ„å’Œèµ„æºè°ƒåº¦
   - ä¸‰ç»´ç©ºé—´ç½‘ç»œæ‹“æ‰‘ä¼˜åŒ–

3. **6Gç½‘ç»œæ‹“æ‰‘æ¶æ„**ï¼š
   - åˆ†å¸ƒå¼äº‘-è¾¹-ç«¯æ‹“æ‰‘
   - ç½‘ç»œåŠŸèƒ½è™šæ‹ŸåŒ–ï¼ˆNFVï¼‰æ‹“æ‰‘
   - ç½‘ç»œåˆ‡ç‰‡æ‹“æ‰‘ç®¡ç†

**ç®—æ³• 10.2.1** (6Gç½‘ç»œæ‹“æ‰‘ä¼˜åŒ– / 6G Network Topology Optimization)

```python
import numpy as np
from scipy.optimize import minimize

class TerahertzNetworkTopology:
    """å¤ªèµ«å…¹ç½‘ç»œæ‹“æ‰‘ä¼˜åŒ–"""

    def __init__(self, nodes, positions, frequency=300e9):
        self.nodes = nodes
        self.positions = positions  # èŠ‚ç‚¹ä½ç½®ï¼ˆ3Dåæ ‡ï¼‰
        self.frequency = frequency  # å¤ªèµ«å…¹é¢‘ç‡
        self.path_loss_exponent = 2.0  # è·¯å¾„æŸè€—æŒ‡æ•°

    def calculate_path_loss(self, distance):
        """è®¡ç®—å¤ªèµ«å…¹è·¯å¾„æŸè€—"""
        # è‡ªç”±ç©ºé—´è·¯å¾„æŸè€— + å¤§æ°”å¸æ”¶
        c = 3e8  # å…‰é€Ÿ
        wavelength = c / self.frequency

        # è‡ªç”±ç©ºé—´è·¯å¾„æŸè€—
        fspl = 20 * np.log10(4 * np.pi * distance / wavelength)

        # å¤§æ°”å¸æ”¶ï¼ˆç®€åŒ–æ¨¡å‹ï¼‰
        absorption = 0.1 * distance  # dB/km

        total_loss = fspl + absorption * distance / 1000

        return total_loss

    def optimize_topology(self, constraints):
        """ä¼˜åŒ–æ‹“æ‰‘ç»“æ„"""
        def objective(adjacency_matrix):
            """ç›®æ ‡å‡½æ•°ï¼šæœ€å°åŒ–æ€»è·¯å¾„æŸè€—"""
            adj = adjacency_matrix.reshape((len(self.nodes), len(self.nodes)))
            total_loss = 0

            for i in range(len(self.nodes)):
                for j in range(i + 1, len(self.nodes)):
                    if adj[i, j] > 0.5:  # å¦‚æœå­˜åœ¨è¿æ¥
                        distance = np.linalg.norm(
                            self.positions[i] - self.positions[j]
                        )
                        loss = self.calculate_path_loss(distance)
                        total_loss += loss

            return total_loss

        # åˆå§‹æ‹“æ‰‘ï¼ˆå®Œå…¨è¿æ¥ï¼‰
        n = len(self.nodes)
        initial_topology = np.ones((n, n)) - np.eye(n)

        # çº¦æŸï¼šæ¯ä¸ªèŠ‚ç‚¹è‡³å°‘è¿æ¥kä¸ªé‚»å±…
        def constraint_connectivity(adjacency_matrix):
            adj = adjacency_matrix.reshape((n, n))
            min_degree = constraints.get('min_degree', 2)

            degrees = np.sum(adj, axis=1)
            return np.min(degrees) - min_degree

        # ä¼˜åŒ–
        result = minimize(
            objective,
            initial_topology.flatten(),
            method='SLSQP',
            constraints={'type': 'ineq', 'fun': constraint_connectivity},
            bounds=[(0, 1)] * (n * n)
        )

        optimal_topology = result.x.reshape((n, n))
        return optimal_topology

class SpaceAirGroundNetwork:
    """ç©ºå¤©åœ°ä¸€ä½“åŒ–ç½‘ç»œæ‹“æ‰‘"""

    def __init__(self, ground_nodes, air_nodes, satellite_nodes):
        self.ground_nodes = ground_nodes  # åœ°é¢èŠ‚ç‚¹
        self.air_nodes = air_nodes  # ç©ºä¸­èŠ‚ç‚¹ï¼ˆæ— äººæœºï¼‰
        self.satellite_nodes = satellite_nodes  # å«æ˜ŸèŠ‚ç‚¹

    def construct_unified_topology(self):
        """æ„å»ºç»Ÿä¸€æ‹“æ‰‘"""
        topology = {}

        # åœ°é¢ç½‘ç»œè¿æ¥
        for node in self.ground_nodes:
            topology[node] = self._connect_ground_nodes(node)

        # ç©ºä¸­ç½‘ç»œè¿æ¥
        for node in self.air_nodes:
            topology[node] = self._connect_air_nodes(node)

        # å«æ˜Ÿç½‘ç»œè¿æ¥
        for node in self.satellite_nodes:
            topology[node] = self._connect_satellite_nodes(node)

        # è·¨åŸŸè¿æ¥ï¼ˆåœ°é¢-ç©ºä¸­ã€åœ°é¢-å«æ˜Ÿã€ç©ºä¸­-å«æ˜Ÿï¼‰
        topology = self._add_cross_domain_links(topology)

        return topology

    def _connect_ground_nodes(self, node):
        """è¿æ¥åœ°é¢èŠ‚ç‚¹"""
        # åŸºäºè·ç¦»å’Œä¿¡å·å¼ºåº¦è¿æ¥
        neighbors = []
        for other in self.ground_nodes:
            if node != other:
                distance = self._calculate_distance(node, other)
                if distance < node['range']:
                    neighbors.append(other)
        return neighbors

    def _connect_air_nodes(self, node):
        """è¿æ¥ç©ºä¸­èŠ‚ç‚¹"""
        neighbors = []
        for other in self.air_nodes:
            if node != other:
                distance = self._calculate_3d_distance(node, other)
                if distance < node['range']:
                    neighbors.append(other)

        # è¿æ¥åˆ°åœ°é¢èŠ‚ç‚¹
        for ground in self.ground_nodes:
            distance = self._calculate_3d_distance(node, ground)
            if distance < node['range']:
                neighbors.append(ground)

        return neighbors

    def _connect_satellite_nodes(self, node):
        """è¿æ¥å«æ˜ŸèŠ‚ç‚¹"""
        neighbors = []

        # å«æ˜Ÿé—´è¿æ¥ï¼ˆISL - Inter-Satellite Linksï¼‰
        for other in self.satellite_nodes:
            if node != other:
                distance = self._calculate_3d_distance(node, other)
                if distance < node['isl_range']:
                    neighbors.append(other)

        return neighbors

    def _add_cross_domain_links(self, topology):
        """æ·»åŠ è·¨åŸŸè¿æ¥"""
        # åœ°é¢-å«æ˜Ÿè¿æ¥
        for satellite in self.satellite_nodes:
            for ground in self.ground_nodes:
                if self._is_visible(satellite, ground):
                    if satellite not in topology:
                        topology[satellite] = []
                    topology[satellite].append(ground)

        # ç©ºä¸­-å«æ˜Ÿè¿æ¥
        for satellite in self.satellite_nodes:
            for air in self.air_nodes:
                if self._is_visible(satellite, air):
                    if satellite not in topology:
                        topology[satellite] = []
                    topology[satellite].append(air)

        return topology

    def _calculate_distance(self, node1, node2):
        """è®¡ç®—2Dè·ç¦»"""
        return np.sqrt(
            (node1['x'] - node2['x'])**2 +
            (node1['y'] - node2['y'])**2
        )

    def _calculate_3d_distance(self, node1, node2):
        """è®¡ç®—3Dè·ç¦»"""
        return np.sqrt(
            (node1['x'] - node2['x'])**2 +
            (node1['y'] - node2['y'])**2 +
            (node1.get('z', 0) - node2.get('z', 0))**2
        )

    def _is_visible(self, satellite, node):
        """æ£€æŸ¥å«æ˜Ÿæ˜¯å¦å¯è§"""
        # ç®€åŒ–å®ç°ï¼šæ£€æŸ¥ä»°è§’
        distance = self._calculate_3d_distance(satellite, node)
        elevation = np.arcsin(
            (satellite.get('z', 0) - node.get('z', 0)) / distance
        )
        return elevation > np.radians(10)  # æœ€å°ä»°è§’10åº¦

# å¤æ‚åº¦åˆ†æ
# æ—¶é—´å¤æ‚åº¦: O(N^2) å…¶ä¸­Næ˜¯èŠ‚ç‚¹æ€»æ•°
# ç©ºé—´å¤æ‚åº¦: O(N + E) å…¶ä¸­Eæ˜¯è¾¹æ•°
```

### 10.3 é‡å­ç½‘ç»œæ‹“æ‰‘

#### é‡å­ç½‘ç»œçš„æ‹“æ‰‘ç»“æ„

**æœ€æ–°è¿›å±•ï¼ˆ2024-2025ï¼‰**ï¼š

1. **é‡å­ç½‘ç»œæ‹“æ‰‘è®¾è®¡**ï¼š
   - é‡å­ä¸­ç»§å™¨ç½‘ç»œæ‹“æ‰‘ä¼˜åŒ–
   - çº ç¼ åˆ†å‘è·¯å¾„ä¼˜åŒ–
   - é‡å­ç½‘ç»œå¯é æ€§å’Œå®¹é”™è®¾è®¡
   - é‡å­å¯†é’¥åˆ†å‘ï¼ˆQKDï¼‰ç½‘ç»œæ‹“æ‰‘

2. **æ··åˆç»å…¸-é‡å­ç½‘ç»œæ‹“æ‰‘**ï¼š
   - ç»å…¸ç½‘ç»œä¸é‡å­ç½‘ç»œèåˆæ¶æ„
   - æ··åˆæ‹“æ‰‘ç®¡ç†å’Œç¼–æ’
   - è·¨åŸŸé€šä¿¡åè®®è®¾è®¡
   - é‡å­-ç»å…¸èµ„æºåè°ƒ

**ç®—æ³• 10.3.1** (é‡å­ç½‘ç»œæ‹“æ‰‘ä¼˜åŒ– / Quantum Network Topology Optimization)

```python
import networkx as nx
import numpy as np

class QuantumNetworkTopology:
    """é‡å­ç½‘ç»œæ‹“æ‰‘ä¼˜åŒ–"""

    def __init__(self, nodes, quantum_channels):
        self.nodes = nodes  # é‡å­èŠ‚ç‚¹
        self.quantum_channels = quantum_channels  # é‡å­ä¿¡é“
        self.graph = nx.Graph()

        # æ„å»ºé‡å­ç½‘ç»œå›¾
        for node in nodes:
            self.graph.add_node(node['id'], **node)

        for channel in quantum_channels:
            self.graph.add_edge(
                channel['source'],
                channel['target'],
                **channel
            )

    def optimize_entanglement_distribution(self, source, target):
        """ä¼˜åŒ–çº ç¼ åˆ†å‘è·¯å¾„"""
        # ä½¿ç”¨Dijkstraç®—æ³•æ‰¾åˆ°æœ€çŸ­è·¯å¾„ï¼ˆåŸºäºä¿çœŸåº¦ï¼‰
        def weight(u, v, data):
            # è·¯å¾„æƒé‡ï¼š1 / ä¿çœŸåº¦ï¼ˆä¿çœŸåº¦è¶Šé«˜ï¼Œæƒé‡è¶Šå°ï¼‰
            fidelity = data.get('fidelity', 0.5)
            return 1.0 / fidelity

        try:
            path = nx.shortest_path(
                self.graph,
                source,
                target,
                weight=weight
            )

            # è®¡ç®—è·¯å¾„æ€»ä¿çœŸåº¦
            total_fidelity = 1.0
            for i in range(len(path) - 1):
                edge_data = self.graph[path[i]][path[i + 1]]
                fidelity = edge_data.get('fidelity', 0.5)
                total_fidelity *= fidelity

            return {
                'path': path,
                'fidelity': total_fidelity,
                'hops': len(path) - 1
            }
        except nx.NetworkXNoPath:
            return None

    def optimize_quantum_repeater_placement(self, k=3):
        """ä¼˜åŒ–é‡å­ä¸­ç»§å™¨æ”¾ç½®ï¼ˆk-è¿é€šæ€§ï¼‰"""
        # æ‰¾åˆ°æœ€å°é¡¶ç‚¹è¦†ç›–ä»¥æ”¾ç½®ä¸­ç»§å™¨
        # ç¡®ä¿ä»»æ„ä¸¤èŠ‚ç‚¹é—´è‡³å°‘æœ‰kæ¡ä¸ç›¸äº¤è·¯å¾„

        # ä½¿ç”¨Mengerå®šç†ï¼šk-è¿é€šæ€§ç­‰ä»·äºkæ¡ä¸ç›¸äº¤è·¯å¾„
        critical_nodes = []

        for node in self.graph.nodes():
            # æµ‹è¯•ç§»é™¤è¯¥èŠ‚ç‚¹åçš„è¿é€šæ€§
            temp_graph = self.graph.copy()
            temp_graph.remove_node(node)

            if not nx.is_connected(temp_graph):
                critical_nodes.append(node)

        return critical_nodes

    def calculate_quantum_capacity(self):
        """è®¡ç®—é‡å­ç½‘ç»œå®¹é‡"""
        # åŸºäºçº ç¼ åˆ†å‘ç‡å’Œä¿çœŸåº¦
        total_capacity = 0

        for u, v, data in self.graph.edges(data=True):
            rate = data.get('entanglement_rate', 0)  # çº ç¼ åˆ†å‘ç‡
            fidelity = data.get('fidelity', 0.5)

            # å®¹é‡ = ç‡ * ä¿çœŸåº¦
            capacity = rate * fidelity
            total_capacity += capacity

        return total_capacity

# å¤æ‚åº¦åˆ†æ
# æ—¶é—´å¤æ‚åº¦: O(V^2 + E) å…¶ä¸­Væ˜¯èŠ‚ç‚¹æ•°ï¼ŒEæ˜¯è¾¹æ•°
# ç©ºé—´å¤æ‚åº¦: O(V + E) å­˜å‚¨å›¾ç»“æ„
```

### 10.4 è¾¹ç¼˜è®¡ç®—ç½‘ç»œæ‹“æ‰‘

#### è¾¹ç¼˜è®¡ç®—ç½‘ç»œçš„æ‹“æ‰‘æ¶æ„

**æœ€æ–°è¿›å±•ï¼ˆ2024-2025ï¼‰**ï¼š

1. **è¾¹ç¼˜-äº‘ååŒæ‹“æ‰‘**ï¼š
   - è¾¹ç¼˜èŠ‚ç‚¹ã€é›¾èŠ‚ç‚¹ã€äº‘èŠ‚ç‚¹çš„å±‚æ¬¡åŒ–æ‹“æ‰‘
   - è¾¹ç¼˜è®¡ç®—ç½‘ç»œçš„èµ„æºåˆ†é…ç­–ç•¥
   - è´Ÿè½½å‡è¡¡å’Œä»»åŠ¡è°ƒåº¦ä¼˜åŒ–

2. **è¾¹ç¼˜è®¡ç®—ç½‘ç»œä¼˜åŒ–æ–¹æ³•**ï¼š
   - å»¶è¿Ÿæ„ŸçŸ¥çš„æ‹“æ‰‘è®¾è®¡
   - èƒ½è€—ä¼˜åŒ–çš„æ‹“æ‰‘ç»“æ„
   - åŠ¨æ€è¾¹ç¼˜èŠ‚ç‚¹éƒ¨ç½²

**ç®—æ³• 10.4.1** (è¾¹ç¼˜è®¡ç®—ç½‘ç»œæ‹“æ‰‘ä¼˜åŒ– / Edge Computing Network Topology Optimization)

```python
import numpy as np
from scipy.optimize import linprog

class EdgeComputingTopology:
    """è¾¹ç¼˜è®¡ç®—ç½‘ç»œæ‹“æ‰‘ä¼˜åŒ–"""

    def __init__(self, cloud_nodes, edge_nodes, users):
        self.cloud_nodes = cloud_nodes  # äº‘èŠ‚ç‚¹
        self.edge_nodes = edge_nodes  # è¾¹ç¼˜èŠ‚ç‚¹
        self.users = users  # ç”¨æˆ·èŠ‚ç‚¹

    def optimize_resource_allocation(self, tasks):
        """ä¼˜åŒ–èµ„æºåˆ†é…"""
        # æ„å»ºä»»åŠ¡-èŠ‚ç‚¹åˆ†é…å›¾
        # ç›®æ ‡ï¼šæœ€å°åŒ–æ€»å»¶è¿Ÿå’Œèƒ½è€—

        n_tasks = len(tasks)
        n_nodes = len(self.cloud_nodes) + len(self.edge_nodes)

        # å†³ç­–å˜é‡ï¼šx[i, j] = 1 è¡¨ç¤ºä»»åŠ¡iåˆ†é…åˆ°èŠ‚ç‚¹j
        # ç›®æ ‡å‡½æ•°ç³»æ•°ï¼ˆå»¶è¿Ÿ + èƒ½è€—ï¼‰
        c = []
        for task in tasks:
            task_coeffs = []
            # äº‘èŠ‚ç‚¹å»¶è¿Ÿå’Œèƒ½è€—
            for cloud in self.cloud_nodes:
                delay = self._calculate_delay(task, cloud, is_cloud=True)
                energy = self._calculate_energy(task, cloud, is_cloud=True)
                task_coeffs.append(delay * 0.7 + energy * 0.3)

            # è¾¹ç¼˜èŠ‚ç‚¹å»¶è¿Ÿå’Œèƒ½è€—
            for edge in self.edge_nodes:
                delay = self._calculate_delay(task, edge, is_cloud=False)
                energy = self._calculate_energy(task, edge, is_cloud=False)
                task_coeffs.append(delay * 0.7 + energy * 0.3)

            c.extend(task_coeffs)

        # çº¦æŸï¼šæ¯ä¸ªä»»åŠ¡å¿…é¡»åˆ†é…åˆ°ä¸€ä¸ªèŠ‚ç‚¹
        A_eq = []
        b_eq = []

        for i in range(n_tasks):
            constraint = [0] * (n_tasks * n_nodes)
            for j in range(n_nodes):
                constraint[i * n_nodes + j] = 1
            A_eq.append(constraint)
            b_eq.append(1)

        # çº¦æŸï¼šèŠ‚ç‚¹å®¹é‡é™åˆ¶
        A_ub = []
        b_ub = []

        for j in range(n_nodes):
            constraint = [0] * (n_tasks * n_nodes)
            for i in range(n_tasks):
                constraint[i * n_nodes + j] = tasks[i]['resource_demand']
            A_ub.append(constraint)

            if j < len(self.cloud_nodes):
                capacity = self.cloud_nodes[j]['capacity']
            else:
                edge_idx = j - len(self.cloud_nodes)
                capacity = self.edge_nodes[edge_idx]['capacity']
            b_ub.append(capacity)

        # æ±‚è§£çº¿æ€§è§„åˆ’
        bounds = [(0, 1)] * (n_tasks * n_nodes)
        result = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds)

        # è§£æç»“æœ
        allocation = {}
        x = result.x
        for i in range(n_tasks):
            for j in range(n_nodes):
                if x[i * n_nodes + j] > 0.5:
                    allocation[tasks[i]['id']] = j
                    break

        return allocation

    def _calculate_delay(self, task, node, is_cloud):
        """è®¡ç®—ä»»åŠ¡æ‰§è¡Œå»¶è¿Ÿ"""
        # ä¼ è¾“å»¶è¿Ÿ
        transmission_delay = task['data_size'] / node['bandwidth']

        # å¤„ç†å»¶è¿Ÿ
        processing_delay = task['computation'] / node['compute_power']

        # è¾¹ç¼˜èŠ‚ç‚¹å»¶è¿Ÿæ›´å°
        if not is_cloud:
            processing_delay *= 0.8  # è¾¹ç¼˜èŠ‚ç‚¹å¤„ç†æ›´å¿«

        return transmission_delay + processing_delay

    def _calculate_energy(self, task, node, is_cloud):
        """è®¡ç®—èƒ½è€—"""
        # ä¼ è¾“èƒ½è€—
        transmission_energy = task['data_size'] * node['energy_per_bit']

        # è®¡ç®—èƒ½è€—
        computation_energy = task['computation'] * node['energy_per_ops']

        return transmission_energy + computation_energy

# å¤æ‚åº¦åˆ†æ
# æ—¶é—´å¤æ‚åº¦: O((T * N)^3) å…¶ä¸­Tæ˜¯ä»»åŠ¡æ•°ï¼ŒNæ˜¯èŠ‚ç‚¹æ•°ï¼ˆçº¿æ€§è§„åˆ’ï¼‰
# ç©ºé—´å¤æ‚åº¦: O(T * N) å­˜å‚¨çº¦æŸçŸ©é˜µ
```

### 10.5 ç¥ç»å½¢æ€ç½‘ç»œæ‹“æ‰‘

#### ç¥ç»å½¢æ€ç½‘ç»œçš„ç»“æ„

**æœ€æ–°è¿›å±•ï¼ˆ2024-2025ï¼‰**ï¼š

1. **ç¥ç»å½¢æ€ç½‘ç»œæ‹“æ‰‘**ï¼š
   - ä»¿ç”Ÿç‰©ç¥ç»ç½‘ç»œçš„æ‹“æ‰‘ç»“æ„
   - è„‰å†²ç¥ç»ç½‘ç»œï¼ˆSNNï¼‰æ‹“æ‰‘
   - ç¥ç»å½¢æ€è®¡ç®—ç½‘ç»œæ‹“æ‰‘

2. **ç¥ç»å½¢æ€ç½‘ç»œçš„æ‹“æ‰‘ä¼˜åŒ–**ï¼š
   - åŸºäºå­¦ä¹ è§„åˆ™çš„æ‹“æ‰‘æ¼”åŒ–
   - è‡ªé€‚åº”ç½‘ç»œç»“æ„è°ƒæ•´
   - èƒ½æ•ˆä¼˜åŒ–çš„æ‹“æ‰‘è®¾è®¡

3. **ç¥ç»å½¢æ€ç½‘ç»œçš„åº”ç”¨**ï¼š
   - è¾¹ç¼˜AIè®¡ç®—
   - å®æ—¶æ¨¡å¼è¯†åˆ«
   - ä½åŠŸè€—æ™ºèƒ½ç³»ç»Ÿ

**ç®—æ³• 10.5.1** (ç¥ç»å½¢æ€ç½‘ç»œæ‹“æ‰‘ / Neuromorphic Network Topology)

```python
import numpy as np

class NeuromorphicNetwork:
    """ç¥ç»å½¢æ€ç½‘ç»œæ‹“æ‰‘"""

    def __init__(self, num_neurons, topology_type='small_world'):
        self.num_neurons = num_neurons
        self.connections = np.zeros((num_neurons, num_neurons))
        self.weights = np.zeros((num_neurons, num_neurons))
        self.topology_type = topology_type

        self._build_topology()

    def _build_topology(self):
        """æ„å»ºæ‹“æ‰‘ç»“æ„"""
        if self.topology_type == 'small_world':
            self._build_small_world()
        elif self.topology_type == 'scale_free':
            self._build_scale_free()
        elif self.topology_type == 'random':
            self._build_random()

    def _build_small_world(self):
        """æ„å»ºå°ä¸–ç•Œæ‹“æ‰‘"""
        # Watts-Strogatzæ¨¡å‹
        k = 4  # æ¯ä¸ªèŠ‚ç‚¹åˆå§‹è¿æ¥æ•°
        p = 0.3  # é‡è¿æ¦‚ç‡

        # åˆ›å»ºè§„åˆ™ç¯å½¢ç½‘ç»œ
        for i in range(self.num_neurons):
            for j in range(1, k // 2 + 1):
                neighbor = (i + j) % self.num_neurons
                self.connections[i, neighbor] = 1
                self.connections[neighbor, i] = 1
                self.weights[i, neighbor] = np.random.rand()

        # éšæœºé‡è¿
        for i in range(self.num_neurons):
            for j in range(1, k // 2 + 1):
                if np.random.rand() < p:
                    neighbor = (i + j) % self.num_neurons
                    self.connections[i, neighbor] = 0
                    self.connections[neighbor, i] = 0

                    # è¿æ¥åˆ°éšæœºèŠ‚ç‚¹
                    new_neighbor = np.random.randint(0, self.num_neurons)
                    while new_neighbor == i or self.connections[i, new_neighbor] == 1:
                        new_neighbor = np.random.randint(0, self.num_neurons)

                    self.connections[i, new_neighbor] = 1
                    self.connections[new_neighbor, i] = 1
                    self.weights[i, new_neighbor] = np.random.rand()

    def _build_scale_free(self):
        """æ„å»ºæ— æ ‡åº¦æ‹“æ‰‘"""
        # BarabÃ¡si-Albertæ¨¡å‹
        m = 2  # æ¯æ¬¡æ·»åŠ mæ¡è¾¹

        # åˆå§‹å®Œå…¨å›¾
        initial_nodes = min(5, self.num_neurons)
        for i in range(initial_nodes):
            for j in range(i + 1, initial_nodes):
                self.connections[i, j] = 1
                self.connections[j, i] = 1
                weight = np.random.rand()
                self.weights[i, j] = weight
                self.weights[j, i] = weight

        # æ·»åŠ æ–°èŠ‚ç‚¹
        for new_node in range(initial_nodes, self.num_neurons):
            degrees = np.sum(self.connections[:new_node, :new_node], axis=1)
            total_degree = np.sum(degrees)

            # åå¥½è¿æ¥
            for _ in range(m):
                if total_degree == 0:
                    target = np.random.randint(0, new_node)
                else:
                    probs = degrees / total_degree
                    target = np.random.choice(new_node, p=probs)

                self.connections[new_node, target] = 1
                self.connections[target, new_node] = 1
                weight = np.random.rand()
                self.weights[new_node, target] = weight
                self.weights[target, new_node] = weight

                degrees[target] += 1
                total_degree += 1

    def _build_random(self):
        """æ„å»ºéšæœºæ‹“æ‰‘"""
        p = 0.1  # è¿æ¥æ¦‚ç‡
        for i in range(self.num_neurons):
            for j in range(i + 1, self.num_neurons):
                if np.random.rand() < p:
                    self.connections[i, j] = 1
                    self.connections[j, i] = 1
                    weight = np.random.rand()
                    self.weights[i, j] = weight
                    self.weights[j, i] = weight

    def optimize_energy_efficiency(self):
        """ä¼˜åŒ–èƒ½æ•ˆ"""
        # ç§»é™¤å¼±è¿æ¥ä»¥å‡å°‘èƒ½è€—
        threshold = 0.1

        for i in range(self.num_neurons):
            for j in range(self.num_neurons):
                if self.connections[i, j] == 1 and abs(self.weights[i, j]) < threshold:
                    self.connections[i, j] = 0
                    self.connections[j, i] = 0
                    self.weights[i, j] = 0
                    self.weights[j, i] = 0

    def get_topology_metrics(self):
        """è·å–æ‹“æ‰‘åº¦é‡"""
        # å¹³å‡è·¯å¾„é•¿åº¦
        avg_path_length = self._calculate_avg_path_length()

        # èšç±»ç³»æ•°
        clustering = self._calculate_clustering()

        # å¹³å‡åº¦æ•°
        avg_degree = np.mean(np.sum(self.connections, axis=1))

        return {
            'avg_path_length': avg_path_length,
            'clustering': clustering,
            'avg_degree': avg_degree
        }

    def _calculate_avg_path_length(self):
        """è®¡ç®—å¹³å‡è·¯å¾„é•¿åº¦"""
        # ä½¿ç”¨Floyd-Warshallç®—æ³•
        dist = np.full((self.num_neurons, self.num_neurons), np.inf)

        for i in range(self.num_neurons):
            dist[i, i] = 0
            for j in range(self.num_neurons):
                if self.connections[i, j] == 1:
                    dist[i, j] = 1

        for k in range(self.num_neurons):
            for i in range(self.num_neurons):
                for j in range(self.num_neurons):
                    dist[i, j] = min(dist[i, j], dist[i, k] + dist[k, j])

        # è®¡ç®—å¹³å‡è·¯å¾„é•¿åº¦
        valid_paths = dist[dist != np.inf]
        valid_paths = valid_paths[valid_paths != 0]

        return np.mean(valid_paths) if len(valid_paths) > 0 else 0

    def _calculate_clustering(self):
        """è®¡ç®—èšç±»ç³»æ•°"""
        clustering_coeffs = []

        for i in range(self.num_neurons):
            neighbors = np.where(self.connections[i] == 1)[0]
            if len(neighbors) < 2:
                continue

            # è®¡ç®—é‚»å±…é—´çš„è¾¹æ•°
            edges_between_neighbors = 0
            for n1 in neighbors:
                for n2 in neighbors:
                    if n1 < n2 and self.connections[n1, n2] == 1:
                        edges_between_neighbors += 1

            # æœ€å¤§å¯èƒ½çš„è¾¹æ•°
            max_edges = len(neighbors) * (len(neighbors) - 1) / 2
            clustering_coeff = edges_between_neighbors / max_edges
            clustering_coeffs.append(clustering_coeff)

        return np.mean(clustering_coeffs) if clustering_coeffs else 0

# å¤æ‚åº¦åˆ†æ
# æ—¶é—´å¤æ‚åº¦: O(N^3) å…¶ä¸­Næ˜¯ç¥ç»å…ƒæ•°é‡ï¼ˆè·¯å¾„é•¿åº¦è®¡ç®—ï¼‰
# ç©ºé—´å¤æ‚åº¦: O(N^2) å­˜å‚¨è¿æ¥çŸ©é˜µå’Œæƒé‡çŸ©é˜µ
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v2.2
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**è´¨é‡æ ‡å‡†**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: âœ… Wikipedia + MIT/Stanford/CMUæ ‡å‡†
**æœ€æ–°æ›´æ–°å†…å®¹**:

- âœ… è¡¥å……AIé©±åŠ¨çš„ç½‘ç»œæ‹“æ‰‘ä¼˜åŒ–è¯¦ç»†å†…å®¹ï¼ˆå¼ºåŒ–å­¦ä¹ ã€å›¾ç¥ç»ç½‘ç»œï¼‰
- âœ… è¡¥å……6Gç½‘ç»œæ‹“æ‰‘è®¾è®¡è¯¦ç»†å†…å®¹ï¼ˆå¤ªèµ«å…¹ç½‘ç»œã€ç©ºå¤©åœ°ä¸€ä½“åŒ–ï¼‰
- âœ… è¡¥å……é‡å­ç½‘ç»œæ‹“æ‰‘è¯¦ç»†å†…å®¹ï¼ˆçº ç¼ åˆ†å‘ã€æ··åˆç½‘ç»œï¼‰
- âœ… æ–°å¢è¾¹ç¼˜è®¡ç®—ç½‘ç»œæ‹“æ‰‘å†…å®¹
- âœ… æ–°å¢ç¥ç»å½¢æ€ç½‘ç»œæ‹“æ‰‘å†…å®¹
**å®¡æ ¸çŠ¶æ€**: æŒç»­æ›´æ–°ä¸­ âš™ï¸
