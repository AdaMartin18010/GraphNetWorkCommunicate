# ç½‘ç»œæ‹“æ‰‘åº”ç”¨æ¨¡å¼å·¥å…·é›†æˆæŒ‡å— / Tool Integration Guide

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£æä¾›ç½‘ç»œæ‹“æ‰‘åˆ†æä¸ä¼˜åŒ–åº”ç”¨æ¨¡å¼æ‰€éœ€å·¥å…·çš„é›†æˆé…ç½®æŒ‡å—ï¼Œæ¶µç›–æ‹“æ‰‘å‘ç°ã€å¯è§†åŒ–ã€æ¨¡æ‹Ÿä»¿çœŸã€ä¼˜åŒ–ç®—æ³•ç­‰æ ¸å¿ƒå·¥å…·ã€‚

**åˆ›å»ºæ—¶é—´**: 2025å¹´2æœˆ
**çŠ¶æ€**: âœ… å®Œæˆ

---

## ä¸€ã€å·¥å…·æ ˆæ€»è§ˆ / Tool Stack Overview

| ç±»åˆ« | å·¥å…· | ç‰ˆæœ¬ | ç”¨é€” |
|------|------|------|------|
| æ‹“æ‰‘åˆ†æ | NetworkX | 3.x | åŸºç¡€å›¾ç®—æ³• |
| æ‹“æ‰‘åˆ†æ | igraph | 0.11+ | é«˜æ€§èƒ½åˆ†æ |
| å¯è§†åŒ– | D3.js | 7.x | Web å¯è§†åŒ– |
| å¯è§†åŒ– | Graphviz | 9.x | é™æ€å¯è§†åŒ– |
| ç½‘ç»œæ¨¡æ‹Ÿ | Mininet | 2.3+ | SDN æ¨¡æ‹Ÿ |
| ç½‘ç»œæ¨¡æ‹Ÿ | GNS3 | 2.2+ | ç½‘ç»œä»¿çœŸ |
| æ•°æ®ä¸­å¿ƒ | fat-tree | - | æ•°æ®ä¸­å¿ƒæ‹“æ‰‘ |
| ç›‘æ§ | Prometheus | 2.x | æŒ‡æ ‡é‡‡é›† |

---

## äºŒã€NetworkX æ‹“æ‰‘åˆ†æ / NetworkX Integration

### 2.1 æ‹“æ‰‘ç”Ÿæˆ

```python
import networkx as nx
import numpy as np

class TopologyGenerator:
    """æ‹“æ‰‘ç”Ÿæˆå™¨"""

    @staticmethod
    def star(n: int) -> nx.Graph:
        """æ˜Ÿå‹æ‹“æ‰‘"""
        return nx.star_graph(n - 1)

    @staticmethod
    def ring(n: int) -> nx.Graph:
        """ç¯å½¢æ‹“æ‰‘"""
        return nx.cycle_graph(n)

    @staticmethod
    def mesh(m: int, n: int) -> nx.Graph:
        """ç½‘æ ¼æ‹“æ‰‘"""
        return nx.grid_2d_graph(m, n)

    @staticmethod
    def fat_tree(k: int) -> nx.Graph:
        """Fat-tree æ•°æ®ä¸­å¿ƒæ‹“æ‰‘"""
        G = nx.Graph()

        # æ ¸å¿ƒå±‚: (k/2)^2 ä¸ªäº¤æ¢æœº
        core_switches = [(f"core_{i}", {"layer": "core"})
                        for i in range((k // 2) ** 2)]
        G.add_nodes_from(core_switches)

        # èšåˆå±‚å’Œæ¥å…¥å±‚: k ä¸ª podï¼Œæ¯ä¸ª pod æœ‰ k ä¸ªäº¤æ¢æœº
        for pod in range(k):
            # èšåˆå±‚
            agg_switches = [f"agg_{pod}_{i}" for i in range(k // 2)]
            G.add_nodes_from([(s, {"layer": "aggregation"}) for s in agg_switches])

            # æ¥å…¥å±‚
            edge_switches = [f"edge_{pod}_{i}" for i in range(k // 2)]
            G.add_nodes_from([(s, {"layer": "edge"}) for s in edge_switches])

            # èšåˆ-æ ¸å¿ƒè¿æ¥
            for i, agg in enumerate(agg_switches):
                for j in range(k // 2):
                    core = f"core_{i * (k // 2) + j}"
                    G.add_edge(agg, core)

            # èšåˆ-æ¥å…¥è¿æ¥
            for agg in agg_switches:
                for edge in edge_switches:
                    G.add_edge(agg, edge)

            # ä¸»æœº
            for edge_idx, edge in enumerate(edge_switches):
                for host in range(k // 2):
                    host_id = f"host_{pod}_{edge_idx}_{host}"
                    G.add_node(host_id, layer="host")
                    G.add_edge(edge, host_id)

        return G

    @staticmethod
    def small_world(n: int, k: int, p: float) -> nx.Graph:
        """å°ä¸–ç•Œç½‘ç»œ"""
        return nx.watts_strogatz_graph(n, k, p)

    @staticmethod
    def scale_free(n: int, m: int) -> nx.Graph:
        """æ— æ ‡åº¦ç½‘ç»œ"""
        return nx.barabasi_albert_graph(n, m)
```

### 2.2 æ‹“æ‰‘åˆ†æ

```python
class TopologyAnalyzer:
    """æ‹“æ‰‘åˆ†æå™¨"""

    def __init__(self, graph: nx.Graph):
        self.G = graph

    def basic_metrics(self) -> dict:
        """åŸºç¡€æ‹“æ‰‘æŒ‡æ ‡"""
        return {
            "nodes": self.G.number_of_nodes(),
            "edges": self.G.number_of_edges(),
            "density": nx.density(self.G),
            "diameter": nx.diameter(self.G) if nx.is_connected(self.G) else float('inf'),
            "avg_path_length": nx.average_shortest_path_length(self.G)
                              if nx.is_connected(self.G) else float('inf'),
            "clustering_coefficient": nx.average_clustering(self.G)
        }

    def connectivity_analysis(self) -> dict:
        """è¿é€šæ€§åˆ†æ"""
        return {
            "is_connected": nx.is_connected(self.G),
            "num_components": nx.number_connected_components(self.G),
            "node_connectivity": nx.node_connectivity(self.G),
            "edge_connectivity": nx.edge_connectivity(self.G),
            "articulation_points": list(nx.articulation_points(self.G)),
            "bridges": list(nx.bridges(self.G))
        }

    def robustness_analysis(self, attack_type: str = "random") -> list:
        """é²æ£’æ€§åˆ†æ"""
        G_copy = self.G.copy()
        results = []

        nodes = list(G_copy.nodes())
        if attack_type == "targeted":
            # æŒ‰åº¦æ’åºï¼Œä¼˜å…ˆç§»é™¤é«˜åº¦èŠ‚ç‚¹
            nodes = sorted(nodes, key=lambda n: G_copy.degree(n), reverse=True)
        else:
            np.random.shuffle(nodes)

        for i, node in enumerate(nodes):
            G_copy.remove_node(node)

            if G_copy.number_of_nodes() == 0:
                break

            # è®¡ç®—æœ€å¤§è¿é€šåˆ†é‡æ¯”ä¾‹
            largest_cc = max(nx.connected_components(G_copy), key=len)
            gc_ratio = len(largest_cc) / self.G.number_of_nodes()

            results.append({
                "removed_fraction": (i + 1) / self.G.number_of_nodes(),
                "giant_component_ratio": gc_ratio
            })

        return results

    def find_critical_nodes(self, top_k: int = 10) -> list:
        """æ‰¾å‡ºå…³é”®èŠ‚ç‚¹"""
        betweenness = nx.betweenness_centrality(self.G)
        sorted_nodes = sorted(betweenness.items(), key=lambda x: x[1], reverse=True)
        return sorted_nodes[:top_k]
```

---

## ä¸‰ã€Mininet SDN æ¨¡æ‹Ÿ / Mininet Integration

### 3.1 å®‰è£…é…ç½®

```bash
# Ubuntu
sudo apt-get install mininet

# æˆ–ä»æºç å®‰è£…
git clone https://github.com/mininet/mininet
cd mininet
sudo ./util/install.sh -a
```

### 3.2 æ‹“æ‰‘æ„å»º

```python
from mininet.net import Mininet
from mininet.node import Controller, OVSSwitch
from mininet.topo import Topo
from mininet.link import TCLink

class FatTreeTopo(Topo):
    """Fat-tree æ‹“æ‰‘"""

    def build(self, k: int = 4):
        # æ ¸å¿ƒå±‚
        core_switches = []
        for i in range((k // 2) ** 2):
            core = self.addSwitch(f's_core_{i}')
            core_switches.append(core)

        # Pod
        for pod in range(k):
            agg_switches = []
            edge_switches = []

            # èšåˆå±‚
            for i in range(k // 2):
                agg = self.addSwitch(f's_agg_{pod}_{i}')
                agg_switches.append(agg)

                # è¿æ¥åˆ°æ ¸å¿ƒ
                for j in range(k // 2):
                    core_idx = i * (k // 2) + j
                    self.addLink(agg, core_switches[core_idx],
                               bw=1000, delay='1ms')

            # æ¥å…¥å±‚
            for i in range(k // 2):
                edge = self.addSwitch(f's_edge_{pod}_{i}')
                edge_switches.append(edge)

                # è¿æ¥åˆ°èšåˆ
                for agg in agg_switches:
                    self.addLink(edge, agg, bw=1000, delay='1ms')

                # æ·»åŠ ä¸»æœº
                for j in range(k // 2):
                    host = self.addHost(f'h_{pod}_{i}_{j}')
                    self.addLink(host, edge, bw=100, delay='1ms')

class MininetController:
    """Mininet æ§åˆ¶å™¨"""

    def __init__(self, topo: Topo):
        self.net = Mininet(topo=topo, controller=Controller,
                          switch=OVSSwitch, link=TCLink)

    def start(self):
        """å¯åŠ¨ç½‘ç»œ"""
        self.net.start()

    def stop(self):
        """åœæ­¢ç½‘ç»œ"""
        self.net.stop()

    def run_iperf(self, src: str, dst: str) -> dict:
        """è¿è¡Œ iperf æµ‹è¯•"""
        src_host = self.net.get(src)
        dst_host = self.net.get(dst)

        # å¯åŠ¨æœåŠ¡å™¨
        dst_host.cmd('iperf -s &')

        # è¿è¡Œå®¢æˆ·ç«¯
        result = src_host.cmd(f'iperf -c {dst_host.IP()} -t 10')

        return {"output": result}

    def ping_all(self) -> float:
        """å…¨è¿æ¥ ping æµ‹è¯•"""
        return self.net.pingAll()
```

---

## å››ã€å¯è§†åŒ–å·¥å…· / Visualization Tools

### 4.1 Graphviz é›†æˆ

```python
import graphviz

class TopologyVisualizer:
    """æ‹“æ‰‘å¯è§†åŒ–å™¨"""

    def __init__(self, graph: nx.Graph):
        self.G = graph

    def to_graphviz(self, output_path: str = "topology"):
        """å¯¼å‡ºä¸º Graphviz"""
        dot = graphviz.Graph(comment='Network Topology')

        # æ·»åŠ èŠ‚ç‚¹
        for node, attrs in self.G.nodes(data=True):
            layer = attrs.get('layer', 'default')
            colors = {
                'core': 'red',
                'aggregation': 'orange',
                'edge': 'yellow',
                'host': 'lightblue'
            }
            dot.node(str(node), color=colors.get(layer, 'white'), style='filled')

        # æ·»åŠ è¾¹
        for src, dst in self.G.edges():
            dot.edge(str(src), str(dst))

        dot.render(output_path, format='png', cleanup=True)
        return f"{output_path}.png"

    def to_d3_json(self) -> dict:
        """å¯¼å‡ºä¸º D3.js JSON æ ¼å¼"""
        nodes = [{"id": str(n), **self.G.nodes[n]} for n in self.G.nodes()]
        links = [{"source": str(u), "target": str(v)} for u, v in self.G.edges()]
        return {"nodes": nodes, "links": links}
```

### 4.2 D3.js å¯è§†åŒ–æ¨¡æ¿

```html
<!DOCTYPE html>
<html>
<head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .node { stroke: #fff; stroke-width: 1.5px; }
        .link { stroke: #999; stroke-opacity: 0.6; }
    </style>
</head>
<body>
    <svg width="960" height="600"></svg>
    <script>
        const svg = d3.select("svg");
        const width = +svg.attr("width");
        const height = +svg.attr("height");

        d3.json("topology.json").then(graph => {
            const simulation = d3.forceSimulation(graph.nodes)
                .force("link", d3.forceLink(graph.links).id(d => d.id))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(width / 2, height / 2));

            const link = svg.append("g")
                .selectAll("line")
                .data(graph.links)
                .enter().append("line")
                .attr("class", "link");

            const node = svg.append("g")
                .selectAll("circle")
                .data(graph.nodes)
                .enter().append("circle")
                .attr("class", "node")
                .attr("r", 10)
                .attr("fill", d => {
                    const colors = {
                        core: "red",
                        aggregation: "orange",
                        edge: "yellow",
                        host: "lightblue"
                    };
                    return colors[d.layer] || "gray";
                })
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);
            });
        });
    </script>
</body>
</html>
```

---

## äº”ã€æ‹“æ‰‘ä¼˜åŒ–ç®—æ³• / Topology Optimization

### 5.1 æœ€å°ç”Ÿæˆæ ‘

```python
class TopologyOptimizer:
    """æ‹“æ‰‘ä¼˜åŒ–å™¨"""

    def __init__(self, graph: nx.Graph):
        self.G = graph

    def minimum_spanning_tree(self) -> nx.Graph:
        """æœ€å°ç”Ÿæˆæ ‘"""
        return nx.minimum_spanning_tree(self.G)

    def steiner_tree(self, terminal_nodes: list) -> nx.Graph:
        """Steiner æ ‘ï¼ˆè¿‘ä¼¼ï¼‰"""
        return nx.algorithms.approximation.steiner_tree(self.G, terminal_nodes)

    def optimize_for_latency(self) -> nx.Graph:
        """ä¼˜åŒ–å»¶è¿Ÿï¼ˆæ·»åŠ å¿«æ·è¾¹ï¼‰"""
        G_opt = self.G.copy()

        # æ‰¾å‡ºé«˜ä»‹æ•°èŠ‚ç‚¹å¯¹
        betweenness = nx.edge_betweenness_centrality(self.G)
        high_load_paths = sorted(betweenness.items(), key=lambda x: x[1], reverse=True)

        # ä¸ºé«˜è´Ÿè½½è·¯å¾„æ·»åŠ å¿«æ·è¾¹
        for (u, v), load in high_load_paths[:5]:
            # æ‰¾å‡º u å’Œ v ä¹‹é—´çš„ä¸­é—´èŠ‚ç‚¹
            path = nx.shortest_path(self.G, u, v)
            if len(path) > 2:
                # æ·»åŠ ç›´è¿è¾¹
                G_opt.add_edge(u, v, type='shortcut')

        return G_opt

    def optimize_for_resilience(self, redundancy: int = 2) -> nx.Graph:
        """ä¼˜åŒ–éŸ§æ€§ï¼ˆå¢åŠ å†—ä½™è·¯å¾„ï¼‰"""
        G_opt = self.G.copy()

        # æ‰¾å‡ºå…³é”®è¾¹ï¼ˆæ¡¥ï¼‰
        bridges = list(nx.bridges(self.G))

        for u, v in bridges:
            # ä¸ºæ¯æ¡æ¡¥è¾¹æ·»åŠ å†—ä½™è·¯å¾„
            # æ‰¾å‡º u å’Œ v çš„å…¶ä»–é‚»å±…
            u_neighbors = set(self.G.neighbors(u)) - {v}
            v_neighbors = set(self.G.neighbors(v)) - {u}

            # æ·»åŠ å¤‡ç”¨è¿æ¥
            for un in list(u_neighbors)[:redundancy]:
                for vn in list(v_neighbors)[:redundancy]:
                    if not G_opt.has_edge(un, vn):
                        G_opt.add_edge(un, vn, type='redundant')

        return G_opt
```

---

## å…­ã€ç›‘æ§é›†æˆ / Monitoring Integration

### 6.1 Prometheus æŒ‡æ ‡é‡‡é›†

```python
from prometheus_client import Gauge, Counter, start_http_server

class TopologyMonitor:
    """æ‹“æ‰‘ç›‘æ§å™¨"""

    def __init__(self, graph: nx.Graph):
        self.G = graph

        # å®šä¹‰æŒ‡æ ‡
        self.node_count = Gauge('topology_nodes_total', 'Total number of nodes')
        self.edge_count = Gauge('topology_edges_total', 'Total number of edges')
        self.diameter = Gauge('topology_diameter', 'Network diameter')
        self.connectivity = Gauge('topology_connectivity', 'Node connectivity')

        self.link_failures = Counter('topology_link_failures_total',
                                    'Total link failures', ['src', 'dst'])

    def start_metrics_server(self, port: int = 8000):
        """å¯åŠ¨æŒ‡æ ‡æœåŠ¡å™¨"""
        start_http_server(port)

    def update_metrics(self):
        """æ›´æ–°æŒ‡æ ‡"""
        self.node_count.set(self.G.number_of_nodes())
        self.edge_count.set(self.G.number_of_edges())

        if nx.is_connected(self.G):
            self.diameter.set(nx.diameter(self.G))
            self.connectivity.set(nx.node_connectivity(self.G))

    def record_link_failure(self, src: str, dst: str):
        """è®°å½•é“¾è·¯æ•…éšœ"""
        self.link_failures.labels(src=src, dst=dst).inc()
```

---

## ä¸ƒã€å®Œæ•´é›†æˆç¤ºä¾‹ / Complete Integration

```python
class NetworkTopologyPlatform:
    """ç½‘ç»œæ‹“æ‰‘å¹³å°"""

    def __init__(self):
        self.generator = TopologyGenerator()
        self.analyzer = None
        self.optimizer = None
        self.visualizer = None
        self.monitor = None

    def create_datacenter(self, k: int = 4) -> nx.Graph:
        """åˆ›å»ºæ•°æ®ä¸­å¿ƒæ‹“æ‰‘"""
        G = self.generator.fat_tree(k)

        self.analyzer = TopologyAnalyzer(G)
        self.optimizer = TopologyOptimizer(G)
        self.visualizer = TopologyVisualizer(G)
        self.monitor = TopologyMonitor(G)

        return G

    def full_analysis(self) -> dict:
        """å®Œæ•´åˆ†æ"""
        return {
            "basic": self.analyzer.basic_metrics(),
            "connectivity": self.analyzer.connectivity_analysis(),
            "critical_nodes": self.analyzer.find_critical_nodes(),
            "robustness": self.analyzer.robustness_analysis()
        }

    def optimize_and_visualize(self, output_dir: str) -> dict:
        """ä¼˜åŒ–å¹¶å¯è§†åŒ–"""
        # ä¼˜åŒ–
        mst = self.optimizer.minimum_spanning_tree()
        resilient = self.optimizer.optimize_for_resilience()

        # å¯è§†åŒ–
        original_viz = self.visualizer.to_graphviz(f"{output_dir}/original")

        self.visualizer = TopologyVisualizer(mst)
        mst_viz = self.visualizer.to_graphviz(f"{output_dir}/mst")

        return {
            "original": original_viz,
            "mst": mst_viz,
            "mst_edges": mst.number_of_edges(),
            "resilient_edges": resilient.number_of_edges()
        }
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´2æœˆ
**æœ€åæ›´æ–°**: 2025å¹´2æœˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
