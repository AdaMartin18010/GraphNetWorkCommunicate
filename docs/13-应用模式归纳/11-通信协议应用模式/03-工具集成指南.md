# é€šä¿¡åè®®åº”ç”¨æ¨¡å¼å·¥å…·é›†æˆæŒ‡å— / Tool Integration Guide

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£æä¾›é€šä¿¡åè®®åˆ†æä¸éªŒè¯åº”ç”¨æ¨¡å¼æ‰€éœ€å·¥å…·çš„é›†æˆé…ç½®æŒ‡å—ï¼Œæ¶µç›–åè®®åˆ†æã€å½¢å¼åŒ–éªŒè¯ã€æ€§èƒ½æµ‹è¯•ã€å®‰å…¨å®¡è®¡ç­‰æ ¸å¿ƒå·¥å…·ã€‚

**åˆ›å»ºæ—¶é—´**: 2025å¹´2æœˆ
**çŠ¶æ€**: âœ… å®Œæˆ

---

## ä¸€ã€å·¥å…·æ ˆæ€»è§ˆ / Tool Stack Overview

| ç±»åˆ« | å·¥å…· | ç‰ˆæœ¬ | ç”¨é€” |
|------|------|------|------|
| åè®®åˆ†æ | Wireshark | 4.x | ç½‘ç»œæŠ“åŒ…åˆ†æ |
| åè®®åˆ†æ | Scapy | 2.5+ | åè®®æ„é€ ä¸è§£æ |
| å½¢å¼åŒ–éªŒè¯ | SPIN | 6.x | æ¨¡å‹æ£€æµ‹ |
| å½¢å¼åŒ–éªŒè¯ | ProVerif | 2.x | å®‰å…¨åè®®éªŒè¯ |
| å½¢å¼åŒ–éªŒè¯ | Tamarin | 1.8+ | å®‰å…¨åè®®éªŒè¯ |
| æ€§èƒ½æµ‹è¯• | iperf3 | 3.x | å¸¦å®½æµ‹è¯• |
| æ€§èƒ½æµ‹è¯• | wrk | 4.x | HTTP å‹æµ‹ |
| å®‰å…¨å®¡è®¡ | Nmap | 7.x | ç«¯å£æ‰«æ |
| æ¨¡æ‹Ÿ | ns-3 | 3.x | ç½‘ç»œæ¨¡æ‹Ÿ |

---

## äºŒã€Scapy åè®®åˆ†æ / Scapy Integration

### 2.1 å®‰è£…ä¸åŸºç¡€ä½¿ç”¨

```bash
pip install scapy
```

```python
from scapy.all import *

class ProtocolAnalyzer:
    """åè®®åˆ†æå™¨"""

    def __init__(self):
        pass

    def capture_packets(self, interface: str, count: int = 100,
                       filter_expr: str = None) -> list:
        """æŠ“å–æ•°æ®åŒ…"""
        packets = sniff(iface=interface, count=count, filter=filter_expr)
        return packets

    def analyze_tcp_session(self, packets: list) -> dict:
        """åˆ†æ TCP ä¼šè¯"""
        sessions = {}

        for pkt in packets:
            if TCP in pkt:
                src = f"{pkt[IP].src}:{pkt[TCP].sport}"
                dst = f"{pkt[IP].dst}:{pkt[TCP].dport}"
                session_key = tuple(sorted([src, dst]))

                if session_key not in sessions:
                    sessions[session_key] = {
                        "packets": [],
                        "bytes": 0,
                        "start_time": float(pkt.time)
                    }

                sessions[session_key]["packets"].append(pkt)
                sessions[session_key]["bytes"] += len(pkt)

        return sessions

    def detect_handshake(self, packets: list) -> list:
        """æ£€æµ‹ TCP ä¸‰æ¬¡æ¡æ‰‹"""
        handshakes = []
        syn_packets = {}

        for pkt in packets:
            if TCP in pkt:
                flags = pkt[TCP].flags
                key = (pkt[IP].src, pkt[TCP].sport, pkt[IP].dst, pkt[TCP].dport)
                rev_key = (pkt[IP].dst, pkt[TCP].dport, pkt[IP].src, pkt[TCP].sport)

                if flags == 'S':  # SYN
                    syn_packets[key] = pkt
                elif flags == 'SA':  # SYN-ACK
                    if rev_key in syn_packets:
                        syn_packets[rev_key + ('SA',)] = pkt
                elif flags == 'A':  # ACK
                    sa_key = rev_key + ('SA',)
                    if sa_key in syn_packets and rev_key in syn_packets:
                        handshakes.append({
                            "client": rev_key[0],
                            "server": rev_key[2],
                            "port": rev_key[3]
                        })

        return handshakes
```

### 2.2 åè®®æ„é€ 

```python
class ProtocolBuilder:
    """åè®®æ„é€ å™¨"""

    def build_custom_packet(self, src_ip: str, dst_ip: str,
                           src_port: int, dst_port: int,
                           payload: bytes) -> Packet:
        """æ„é€ è‡ªå®šä¹‰æ•°æ®åŒ…"""
        pkt = IP(src=src_ip, dst=dst_ip) / \
              TCP(sport=src_port, dport=dst_port) / \
              Raw(load=payload)
        return pkt

    def build_tls_client_hello(self, dst_ip: str, dst_port: int = 443) -> Packet:
        """æ„é€  TLS Client Hello"""
        from scapy.layers.tls.handshake import TLSClientHello
        from scapy.layers.tls.extensions import TLS_Ext_ServerName

        pkt = IP(dst=dst_ip) / TCP(dport=dst_port) / TLSClientHello(
            ciphers=[0x1301, 0x1302, 0x1303],  # TLS 1.3 cipher suites
            ext=[TLS_Ext_ServerName(servernames=[dst_ip])]
        )
        return pkt

    def send_and_receive(self, packet: Packet, timeout: int = 5) -> Packet:
        """å‘é€å¹¶æ¥æ”¶å“åº”"""
        response = sr1(packet, timeout=timeout)
        return response
```

---

## ä¸‰ã€SPIN æ¨¡å‹æ£€æµ‹ / SPIN Integration

### 3.1 å®‰è£…é…ç½®

```bash
# Ubuntu
sudo apt-get install spin

# æˆ–ä»æºç ç¼–è¯‘
wget http://spinroot.com/spin/Src/spin654.tar.gz
tar -xzf spin654.tar.gz
cd Spin/Src
make
```

### 3.2 Promela åè®®å»ºæ¨¡

```promela
/* TCP ä¸‰æ¬¡æ¡æ‰‹æ¨¡å‹ */

mtype = { SYN, SYNACK, ACK, DATA, FIN };

chan c2s = [1] of { mtype };  /* å®¢æˆ·ç«¯åˆ°æœåŠ¡å™¨ */
chan s2c = [1] of { mtype };  /* æœåŠ¡å™¨åˆ°å®¢æˆ·ç«¯ */

active proctype Client() {
    /* çŠ¶æ€æœº */
    byte state = 0;

    /* CLOSED -> SYN_SENT */
    c2s ! SYN;
    state = 1;

    /* ç­‰å¾… SYN-ACK */
    s2c ? SYNACK;
    state = 2;

    /* å‘é€ ACK */
    c2s ! ACK;
    state = 3;  /* ESTABLISHED */

    /* å‘é€æ•°æ® */
    c2s ! DATA;

    printf("Client: Connection established\n");
}

active proctype Server() {
    byte state = 0;

    /* ç­‰å¾… SYN */
    c2s ? SYN;
    state = 1;  /* SYN_RCVD */

    /* å‘é€ SYN-ACK */
    s2c ! SYNACK;
    state = 2;

    /* ç­‰å¾… ACK */
    c2s ? ACK;
    state = 3;  /* ESTABLISHED */

    /* æ¥æ”¶æ•°æ® */
    c2s ? DATA;

    printf("Server: Connection established\n");
}

/* å®‰å…¨æ€§å±æ€§ï¼šä¸ä¼šè¿›å…¥æ­»é” */
ltl safety { [] !timeout }

/* æ´»æ€§å±æ€§ï¼šæœ€ç»ˆå»ºç«‹è¿æ¥ */
ltl liveness { <> (Client@end && Server@end) }
```

### 3.3 Python é›†æˆ

```python
import subprocess
import tempfile
import os

class SPINVerifier:
    """SPIN éªŒè¯å™¨å°è£…"""

    def __init__(self, spin_path: str = "spin"):
        self.spin = spin_path

    def verify(self, promela_code: str, ltl_property: str = None) -> dict:
        """éªŒè¯ Promela æ¨¡å‹"""
        # å†™å…¥ä¸´æ—¶æ–‡ä»¶
        with tempfile.NamedTemporaryFile(mode='w', suffix='.pml', delete=False) as f:
            f.write(promela_code)
            pml_file = f.name

        try:
            # ç”ŸæˆéªŒè¯å™¨
            result = subprocess.run(
                [self.spin, "-a", pml_file],
                capture_output=True, text=True
            )

            # ç¼–è¯‘
            subprocess.run(["gcc", "-o", "pan", "pan.c"], capture_output=True)

            # è¿è¡ŒéªŒè¯
            verify_result = subprocess.run(
                ["./pan", "-a"],
                capture_output=True, text=True
            )

            return {
                "success": "errors: 0" in verify_result.stdout,
                "output": verify_result.stdout,
                "errors": verify_result.stderr
            }
        finally:
            os.unlink(pml_file)
            for f in ["pan", "pan.c", "pan.h", "pan.b", "pan.m", "pan.t"]:
                if os.path.exists(f):
                    os.unlink(f)
```

---

## å››ã€ProVerif å®‰å…¨éªŒè¯ / ProVerif Integration

### 4.1 å®‰è£…é…ç½®

```bash
# Ubuntu
sudo apt-get install proverif

# æˆ–é€šè¿‡ opam
opam install proverif
```

### 4.2 åè®®å»ºæ¨¡ç¤ºä¾‹

```proverif
(* TLS 1.3 æ¡æ‰‹ç®€åŒ–æ¨¡å‹ *)

free c: channel.

type key.
type nonce.

(* åŠ å¯†åŸè¯­ *)
fun senc(bitstring, key): bitstring.
reduc forall m: bitstring, k: key; sdec(senc(m, k), k) = m.

fun pk(key): key.
fun aenc(bitstring, key): bitstring.
reduc forall m: bitstring, k: key; adec(aenc(m, pk(k)), k) = m.

fun sign(bitstring, key): bitstring.
reduc forall m: bitstring, k: key; verify(sign(m, k), pk(k)) = m.

(* å¯†é’¥æ´¾ç”Ÿ *)
fun kdf(nonce, nonce, key): key.

(* å®‰å…¨å±æ€§ *)
free s: bitstring [private].
query attacker(s).

(* å®¢æˆ·ç«¯è¿›ç¨‹ *)
let Client(sk_c: key, pk_s: key) =
    new nc: nonce;
    out(c, nc);
    in(c, (ns: nonce, cert: bitstring));
    let pk_server = verify(cert, pk_s) in
    let k = kdf(nc, ns, sk_c) in
    out(c, senc(s, k)).

(* æœåŠ¡å™¨è¿›ç¨‹ *)
let Server(sk_s: key) =
    in(c, nc: nonce);
    new ns: nonce;
    out(c, (ns, sign(pk(sk_s), sk_s)));
    in(c, enc_msg: bitstring);
    let k = kdf(nc, ns, sk_s) in
    let msg = sdec(enc_msg, k) in
    0.

(* ä¸»è¿›ç¨‹ *)
process
    new sk_s: key;
    new sk_c: key;
    (Client(sk_c, pk(sk_s)) | Server(sk_s))
```

### 4.3 Python é›†æˆ

```python
class ProVerifAnalyzer:
    """ProVerif åˆ†æå™¨"""

    def __init__(self, proverif_path: str = "proverif"):
        self.proverif = proverif_path

    def analyze(self, pv_code: str) -> dict:
        """åˆ†æå®‰å…¨åè®®"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.pv', delete=False) as f:
            f.write(pv_code)
            pv_file = f.name

        try:
            result = subprocess.run(
                [self.proverif, pv_file],
                capture_output=True, text=True
            )

            # è§£æç»“æœ
            output = result.stdout
            queries = self._parse_queries(output)

            return {
                "secure": all(q["result"] for q in queries),
                "queries": queries,
                "output": output
            }
        finally:
            os.unlink(pv_file)

    def _parse_queries(self, output: str) -> list:
        """è§£ææŸ¥è¯¢ç»“æœ"""
        queries = []
        for line in output.split('\n'):
            if "Query" in line:
                result = "true" in line.lower()
                queries.append({
                    "query": line,
                    "result": result
                })
        return queries
```

---

## äº”ã€æ€§èƒ½æµ‹è¯•å·¥å…· / Performance Testing

### 5.1 iperf3 é›†æˆ

```python
import subprocess
import json

class NetworkBenchmark:
    """ç½‘ç»œæ€§èƒ½åŸºå‡†æµ‹è¯•"""

    def run_iperf_server(self, port: int = 5201):
        """å¯åŠ¨ iperf3 æœåŠ¡å™¨"""
        return subprocess.Popen(
            ["iperf3", "-s", "-p", str(port)],
            stdout=subprocess.PIPE
        )

    def run_iperf_client(self, server: str, port: int = 5201,
                        duration: int = 10) -> dict:
        """è¿è¡Œ iperf3 å®¢æˆ·ç«¯"""
        result = subprocess.run(
            ["iperf3", "-c", server, "-p", str(port), "-t", str(duration), "-J"],
            capture_output=True, text=True
        )

        return json.loads(result.stdout)

    def analyze_results(self, results: dict) -> dict:
        """åˆ†ææµ‹è¯•ç»“æœ"""
        end = results.get("end", {})
        return {
            "bandwidth_mbps": end.get("sum_received", {}).get("bits_per_second", 0) / 1e6,
            "jitter_ms": end.get("sum", {}).get("jitter_ms", 0),
            "lost_packets": end.get("sum", {}).get("lost_packets", 0),
            "retransmits": end.get("sum_sent", {}).get("retransmits", 0)
        }
```

### 5.2 HTTP å‹æµ‹

```python
class HTTPBenchmark:
    """HTTP å‹åŠ›æµ‹è¯•"""

    def run_wrk(self, url: str, threads: int = 4,
               connections: int = 100, duration: int = 30) -> dict:
        """è¿è¡Œ wrk å‹æµ‹"""
        result = subprocess.run(
            ["wrk", "-t", str(threads), "-c", str(connections),
             "-d", f"{duration}s", "--latency", url],
            capture_output=True, text=True
        )

        return self._parse_wrk_output(result.stdout)

    def _parse_wrk_output(self, output: str) -> dict:
        """è§£æ wrk è¾“å‡º"""
        metrics = {}
        for line in output.split('\n'):
            if "Requests/sec" in line:
                metrics["rps"] = float(line.split(':')[1].strip())
            elif "Latency" in line and "Avg" not in line:
                parts = line.split()
                metrics["latency_avg"] = parts[1]
                metrics["latency_max"] = parts[3]
        return metrics
```

---

## å…­ã€å®‰å…¨å®¡è®¡å·¥å…· / Security Auditing

### 6.1 ç«¯å£æ‰«æ

```python
import nmap

class SecurityScanner:
    """å®‰å…¨æ‰«æå™¨"""

    def __init__(self):
        self.scanner = nmap.PortScanner()

    def scan_ports(self, target: str, ports: str = "1-1024") -> dict:
        """æ‰«æç«¯å£"""
        self.scanner.scan(target, ports, arguments="-sV")

        results = []
        for host in self.scanner.all_hosts():
            for proto in self.scanner[host].all_protocols():
                for port in self.scanner[host][proto].keys():
                    service = self.scanner[host][proto][port]
                    results.append({
                        "port": port,
                        "state": service["state"],
                        "service": service["name"],
                        "version": service.get("version", "")
                    })

        return {"host": target, "ports": results}

    def detect_vulnerabilities(self, target: str) -> list:
        """æ£€æµ‹å·²çŸ¥æ¼æ´"""
        self.scanner.scan(target, arguments="--script vuln")

        vulnerabilities = []
        for host in self.scanner.all_hosts():
            if "hostscript" in self.scanner[host]:
                for script in self.scanner[host]["hostscript"]:
                    if "VULNERABLE" in script.get("output", ""):
                        vulnerabilities.append({
                            "script": script["id"],
                            "output": script["output"]
                        })

        return vulnerabilities
```

---

## ä¸ƒã€å®Œæ•´é›†æˆç¤ºä¾‹ / Complete Integration

```python
class ProtocolAnalysisPipeline:
    """åè®®åˆ†æå®Œæ•´æµæ°´çº¿"""

    def __init__(self):
        self.packet_analyzer = ProtocolAnalyzer()
        self.spin_verifier = SPINVerifier()
        self.proverif = ProVerifAnalyzer()
        self.benchmark = NetworkBenchmark()
        self.security = SecurityScanner()

    def full_analysis(self, target: str, interface: str) -> dict:
        """å®Œæ•´åè®®åˆ†æ"""
        results = {}

        # 1. æŠ“åŒ…åˆ†æ
        packets = self.packet_analyzer.capture_packets(interface, count=1000)
        results["sessions"] = self.packet_analyzer.analyze_tcp_session(packets)
        results["handshakes"] = self.packet_analyzer.detect_handshake(packets)

        # 2. å½¢å¼åŒ–éªŒè¯ï¼ˆå¦‚æœ‰æ¨¡å‹ï¼‰
        # results["verification"] = self.spin_verifier.verify(model)

        # 3. æ€§èƒ½æµ‹è¯•
        results["performance"] = self.benchmark.run_iperf_client(target)

        # 4. å®‰å…¨æ‰«æ
        results["security"] = self.security.scan_ports(target)

        return results
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´2æœˆ
**æœ€åæ›´æ–°**: 2025å¹´2æœˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
