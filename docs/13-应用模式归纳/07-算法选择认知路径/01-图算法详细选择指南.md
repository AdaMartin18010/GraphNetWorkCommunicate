# å›¾ç®—æ³•è¯¦ç»†é€‰æ‹©æŒ‡å— / Detailed Graph Algorithm Selection Guide

## ğŸ“š **æ¦‚è¿° / Overview**

**æ–‡æ¡£ç›®çš„**: æä¾›å›¾ç®—æ³•çš„è¯¦ç»†é€‰æ‹©æŒ‡å—ï¼ŒåŒ…æ‹¬ç®—æ³•åŸç†ã€å¤æ‚åº¦åˆ†æã€é€‚ç”¨åœºæ™¯ã€å®ç°ç¤ºä¾‹ã€‚

**é€‚ç”¨å¯¹è±¡**: ç®—æ³•å·¥ç¨‹å¸ˆã€ç³»ç»Ÿæ¶æ„å¸ˆã€ç ”ç©¶äººå‘˜

---

## ğŸ¯ **ä¸€ã€è·¯å¾„ç®—æ³•é€‰æ‹© / Part 1: Path Algorithm Selection**

### 1.1 æœ€çŸ­è·¯å¾„ç®—æ³•

#### Dijkstraç®—æ³•

**ç®—æ³•åŸç†**:

- å•æºæœ€çŸ­è·¯å¾„ç®—æ³•
- é€‚ç”¨äºéè´Ÿæƒå›¾
- ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå †ï¼‰å®ç°

**å¤æ‚åº¦**:

- æ—¶é—´å¤æ‚åº¦: O((V+E)logV)ï¼ˆä½¿ç”¨äºŒå‰å †ï¼‰
- ç©ºé—´å¤æ‚åº¦: O(V)

**é€‚ç”¨åœºæ™¯**:

- å°åˆ°ä¸­ç­‰è§„æ¨¡å›¾ï¼ˆV < 10^6ï¼‰
- éè´Ÿæƒè¾¹
- å•æºæœ€çŸ­è·¯å¾„

**å®ç°ç¤ºä¾‹**:

```python
import heapq

def dijkstra(graph, source):
    """
    Dijkstraç®—æ³•å®ç°
    """
    dist = {node: float('inf') for node in graph.nodes()}
    dist[source] = 0
    pq = [(0, source)]
    visited = set()

    while pq:
        current_dist, current = heapq.heappop(pq)

        if current in visited:
            continue

        visited.add(current)

        for neighbor, weight in graph[current].items():
            new_dist = current_dist + weight['weight']

            if new_dist < dist[neighbor]:
                dist[neighbor] = new_dist
                heapq.heappush(pq, (new_dist, neighbor))

    return dist
```

#### A*ç®—æ³•

**ç®—æ³•åŸç†**:

- Dijkstraçš„å¯å‘å¼æ”¹è¿›
- ä½¿ç”¨å¯å‘å‡½æ•°h(n)ä¼°è®¡åˆ°ç›®æ ‡è·ç¦»
- é€‚ç”¨äºæœ‰æ˜ç¡®ç›®æ ‡çš„æœ€çŸ­è·¯å¾„

**å¤æ‚åº¦**:

- æ—¶é—´å¤æ‚åº¦: O(b^d)ï¼ˆbä¸ºåˆ†æ”¯å› å­ï¼Œdä¸ºæ·±åº¦ï¼‰
- ç©ºé—´å¤æ‚åº¦: O(b^d)

**é€‚ç”¨åœºæ™¯**:

- æœ‰æ˜ç¡®èµ·ç‚¹å’Œç»ˆç‚¹
- æœ‰è‰¯å¥½çš„å¯å‘å‡½æ•°
- è·¯å¾„è§„åˆ’ã€æ¸¸æˆAI

**å®ç°ç¤ºä¾‹**:

```python
def astar(graph, start, goal, heuristic):
    """
    A*ç®—æ³•å®ç°
    """
    open_set = [(0, start)]
    came_from = {}
    g_score = {node: float('inf') for node in graph.nodes()}
    g_score[start] = 0
    f_score = {node: float('inf') for node in graph.nodes()}
    f_score[start] = heuristic(start, goal)

    while open_set:
        current = heapq.heappop(open_set)[1]

        if current == goal:
            return reconstruct_path(came_from, current)

        for neighbor in graph[current]:
            tentative_g_score = g_score[current] + graph[current][neighbor]['weight']

            if tentative_g_score < g_score[neighbor]:
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, goal)
                heapq.heappush(open_set, (f_score[neighbor], neighbor))

    return None
```

#### Bellman-Fordç®—æ³•

**ç®—æ³•åŸç†**:

- å•æºæœ€çŸ­è·¯å¾„ç®—æ³•
- å¯ä»¥å¤„ç†è´Ÿæƒè¾¹
- å¯ä»¥æ£€æµ‹è´Ÿæƒç¯

**å¤æ‚åº¦**:

- æ—¶é—´å¤æ‚åº¦: O(VE)
- ç©ºé—´å¤æ‚åº¦: O(V)

**é€‚ç”¨åœºæ™¯**:

- æœ‰è´Ÿæƒè¾¹
- éœ€è¦æ£€æµ‹è´Ÿæƒç¯
- å°è§„æ¨¡å›¾

**å®ç°ç¤ºä¾‹**:

```python
def bellman_ford(graph, source):
    """
    Bellman-Fordç®—æ³•å®ç°
    """
    dist = {node: float('inf') for node in graph.nodes()}
    dist[source] = 0

    # æ¾å¼›V-1æ¬¡
    for _ in range(len(graph.nodes()) - 1):
        for u, v, weight in graph.edges(data='weight'):
            if dist[u] != float('inf') and dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight

    # æ£€æµ‹è´Ÿæƒç¯
    for u, v, weight in graph.edges(data='weight'):
        if dist[u] != float('inf') and dist[u] + weight < dist[v]:
            return None, "Negative cycle detected"

    return dist, None
```

### 1.2 æ‰€æœ‰å¯¹æœ€çŸ­è·¯å¾„

#### Floyd-Warshallç®—æ³•

**ç®—æ³•åŸç†**:

- åŠ¨æ€è§„åˆ’ç®—æ³•
- è®¡ç®—æ‰€æœ‰å¯¹æœ€çŸ­è·¯å¾„
- å¯ä»¥å¤„ç†è´Ÿæƒè¾¹ï¼ˆæ— è´Ÿæƒç¯ï¼‰

**å¤æ‚åº¦**:

- æ—¶é—´å¤æ‚åº¦: O(VÂ³)
- ç©ºé—´å¤æ‚åº¦: O(VÂ²)

**é€‚ç”¨åœºæ™¯**:

- å°è§„æ¨¡å›¾ï¼ˆV < 500ï¼‰
- éœ€è¦æ‰€æœ‰å¯¹æœ€çŸ­è·¯å¾„
- å¯†é›†å›¾

**å®ç°ç¤ºä¾‹**:

```python
def floyd_warshall(graph):
    """
    Floyd-Warshallç®—æ³•å®ç°
    """
    nodes = list(graph.nodes())
    n = len(nodes)
    dist = [[float('inf')] * n for _ in range(n)]

    # åˆå§‹åŒ–
    for i in range(n):
        dist[i][i] = 0

    for u, v, weight in graph.edges(data='weight'):
        i, j = nodes.index(u), nodes.index(v)
        dist[i][j] = weight

    # åŠ¨æ€è§„åˆ’
    for k in range(n):
        for i in range(n):
            for j in range(n):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    return dist
```

---

## ğŸ“Š **äºŒã€ä¸­å¿ƒæ€§ç®—æ³•é€‰æ‹© / Part 2: Centrality Algorithm Selection**

### 2.1 åº¦ä¸­å¿ƒæ€§

**ç®—æ³•åŸç†**:

- èŠ‚ç‚¹çš„åº¦ï¼ˆè¿æ¥æ•°ï¼‰
- æœ€ç®€å•ç›´è§‚çš„ä¸­å¿ƒæ€§åº¦é‡

**å¤æ‚åº¦**:

- æ—¶é—´å¤æ‚åº¦: O(V)
- ç©ºé—´å¤æ‚åº¦: O(1)

**é€‚ç”¨åœºæ™¯**:

- å¿«é€Ÿä¸­å¿ƒæ€§ä¼°è®¡
- å¤§è§„æ¨¡å›¾
- å±€éƒ¨é‡è¦æ€§è¯„ä¼°

**å®ç°ç¤ºä¾‹**:

```python
def degree_centrality(graph):
    """
    åº¦ä¸­å¿ƒæ€§è®¡ç®—
    """
    n = len(graph.nodes())
    centrality = {}

    for node in graph.nodes():
        centrality[node] = graph.degree(node) / (n - 1) if n > 1 else 0

    return centrality
```

### 2.2 ä»‹æ•°ä¸­å¿ƒæ€§

**ç®—æ³•åŸç†**:

- èŠ‚ç‚¹åœ¨æ‰€æœ‰æœ€çŸ­è·¯å¾„ä¸­å‡ºç°çš„é¢‘ç‡
- è¡¡é‡èŠ‚ç‚¹çš„"æ¡¥æ¢"ä½œç”¨

**å¤æ‚åº¦**:

- æ—¶é—´å¤æ‚åº¦: O(VE)ï¼ˆBrandesç®—æ³•ï¼‰
- ç©ºé—´å¤æ‚åº¦: O(V+E)

**é€‚ç”¨åœºæ™¯**:

- ä¸­ç­‰è§„æ¨¡å›¾ï¼ˆV < 10^5ï¼‰
- éœ€è¦è¯†åˆ«å…³é”®èŠ‚ç‚¹
- ç½‘ç»œåˆ†æ

**å®ç°ç¤ºä¾‹**:

```python
import networkx as nx

def betweenness_centrality(graph):
    """
    ä»‹æ•°ä¸­å¿ƒæ€§è®¡ç®—ï¼ˆä½¿ç”¨NetworkXï¼‰
    """
    return nx.betweenness_centrality(graph)
```

### 2.3 PageRank

**ç®—æ³•åŸç†**:

- åŸºäºéšæœºæ¸¸èµ°çš„ä¸­å¿ƒæ€§åº¦é‡
- è€ƒè™‘èŠ‚ç‚¹çš„è¿æ¥è´¨é‡

**å¤æ‚åº¦**:

- æ—¶é—´å¤æ‚åº¦: O(kE)ï¼ˆkä¸ºè¿­ä»£æ¬¡æ•°ï¼‰
- ç©ºé—´å¤æ‚åº¦: O(V)

**é€‚ç”¨åœºæ™¯**:

- å¤§è§„æ¨¡å›¾
- æœ‰å‘å›¾
- Webæ’åã€ç¤¾äº¤ç½‘ç»œåˆ†æ

**å®ç°ç¤ºä¾‹**:

```python
def pagerank(graph, damping=0.85, max_iter=100, tol=1e-6):
    """
    PageRankç®—æ³•å®ç°
    """
    nodes = list(graph.nodes())
    n = len(nodes)

    # åˆå§‹åŒ–
    pr = {node: 1.0 / n for node in nodes}

    # è¿­ä»£
    for _ in range(max_iter):
        new_pr = {}
        for node in nodes:
            new_pr[node] = (1 - damping) / n

            for neighbor in graph.predecessors(node):
                out_degree = graph.out_degree(neighbor)
                if out_degree > 0:
                    new_pr[node] += damping * pr[neighbor] / out_degree

        # æ£€æŸ¥æ”¶æ•›
        if sum(abs(new_pr[node] - pr[node]) for node in nodes) < tol:
            break

        pr = new_pr

    return pr
```

---

## ğŸ”§ **ä¸‰ã€ç¤¾åŒºæ£€æµ‹ç®—æ³•é€‰æ‹© / Part 3: Community Detection Algorithm Selection**

### 3.1 Louvainç®—æ³•

**ç®—æ³•åŸç†**:

- åŸºäºæ¨¡å—åº¦ä¼˜åŒ–çš„ç¤¾åŒºæ£€æµ‹
- å±‚æ¬¡èšç±»æ–¹æ³•
- å¿«é€Ÿä¸”é«˜æ•ˆ

**å¤æ‚åº¦**:

- æ—¶é—´å¤æ‚åº¦: O(n log n)
- ç©ºé—´å¤æ‚åº¦: O(n)

**é€‚ç”¨åœºæ™¯**:

- å¤§è§„æ¨¡å›¾ï¼ˆn > 10^6ï¼‰
- éœ€è¦å¿«é€Ÿç¤¾åŒºæ£€æµ‹
- æ— å‘å›¾

**å®ç°ç¤ºä¾‹**:

```python
import networkx as nx
from networkx.algorithms import community

def louvain_communities(graph):
    """
    Louvainç¤¾åŒºæ£€æµ‹
    """
    communities = community.louvain_communities(graph)
    return communities
```

### 3.2 æ ‡ç­¾ä¼ æ’­ç®—æ³•ï¼ˆLPAï¼‰

**ç®—æ³•åŸç†**:

- åŸºäºæ ‡ç­¾ä¼ æ’­çš„ç¤¾åŒºæ£€æµ‹
- å¿«é€Ÿä¸”ç®€å•
- é€‚åˆå¤§è§„æ¨¡å›¾

**å¤æ‚åº¦**:

- æ—¶é—´å¤æ‚åº¦: O(n + m)
- ç©ºé—´å¤æ‚åº¦: O(n)

**é€‚ç”¨åœºæ™¯**:

- è¶…å¤§è§„æ¨¡å›¾ï¼ˆn > 10^7ï¼‰
- éœ€è¦å¿«é€Ÿç»“æœ
- æ— å‘å›¾

**å®ç°ç¤ºä¾‹**:

```python
def label_propagation(graph, max_iter=100):
    """
    æ ‡ç­¾ä¼ æ’­ç®—æ³•
    """
    nodes = list(graph.nodes())
    labels = {node: i for i, node in enumerate(nodes)}

    for _ in range(max_iter):
        new_labels = {}

        for node in nodes:
            # ç»Ÿè®¡é‚»å±…æ ‡ç­¾
            neighbor_labels = [labels[neighbor] for neighbor in graph.neighbors(node)]

            if neighbor_labels:
                # é€‰æ‹©æœ€å¸¸è§çš„æ ‡ç­¾
                new_labels[node] = max(set(neighbor_labels), key=neighbor_labels.count)
            else:
                new_labels[node] = labels[node]

        if new_labels == labels:
            break

        labels = new_labels

    return labels
```

---

## ğŸ”¬ **å››ã€å›¾åµŒå…¥ç®—æ³•é€‰æ‹© / Part 4: Graph Embedding Algorithm Selection**

### 4.1 DeepWalk

**ç®—æ³•åŸç†**:

- åŸºäºéšæœºæ¸¸èµ°çš„å›¾åµŒå…¥
- ä½¿ç”¨Word2Vecå­¦ä¹ èŠ‚ç‚¹è¡¨ç¤º
- æ— ç›‘ç£å­¦ä¹ 

**å¤æ‚åº¦**:

- æ—¶é—´å¤æ‚åº¦: O(n Ã— d Ã— w)ï¼ˆnä¸ºèŠ‚ç‚¹æ•°ï¼Œdä¸ºç»´åº¦ï¼Œwä¸ºçª—å£å¤§å°ï¼‰
- ç©ºé—´å¤æ‚åº¦: O(n Ã— d)

**é€‚ç”¨åœºæ™¯**:

- å¤§è§„æ¨¡å›¾
- æ— ç›‘ç£å­¦ä¹ 
- èŠ‚ç‚¹åˆ†ç±»ã€é“¾æ¥é¢„æµ‹

**å®ç°ç¤ºä¾‹**:

```python
from gensim.models import Word2Vec
import networkx as nx
import random

def deepwalk(graph, walk_length=80, num_walks=10, dimensions=128):
    """
    DeepWalkç®—æ³•å®ç°
    """
    def random_walk(node, length):
        walk = [node]
        for _ in range(length - 1):
            neighbors = list(graph.neighbors(node))
            if neighbors:
                node = random.choice(neighbors)
                walk.append(node)
            else:
                break
        return walk

    # ç”Ÿæˆéšæœºæ¸¸èµ°åºåˆ—
    walks = []
    for _ in range(num_walks):
        for node in graph.nodes():
            walks.append([str(n) for n in random_walk(node, walk_length)])

    # è®­ç»ƒWord2Vecæ¨¡å‹
    model = Word2Vec(walks, vector_size=dimensions, window=5, min_count=0, sg=1)

    # æå–èŠ‚ç‚¹åµŒå…¥
    embeddings = {node: model.wv[str(node)] for node in graph.nodes()}

    return embeddings
```

### 4.2 Node2Vec

**ç®—æ³•åŸç†**:

- DeepWalkçš„æ”¹è¿›
- ä½¿ç”¨æœ‰åéšæœºæ¸¸èµ°
- å¹³è¡¡å±€éƒ¨å’Œå…¨å±€ç»“æ„

**å¤æ‚åº¦**:

- æ—¶é—´å¤æ‚åº¦: O(n Ã— d Ã— w)
- ç©ºé—´å¤æ‚åº¦: O(n Ã— d)

**é€‚ç”¨åœºæ™¯**:

- éœ€è¦å¹³è¡¡å±€éƒ¨å’Œå…¨å±€ç»“æ„
- èŠ‚ç‚¹åˆ†ç±»ã€é“¾æ¥é¢„æµ‹
- å¤§è§„æ¨¡å›¾

---

## ğŸ“ˆ **äº”ã€ç®—æ³•é€‰æ‹©å†³ç­–è¡¨ / Part 5: Algorithm Selection Decision Table**

### 5.1 è·¯å¾„ç®—æ³•é€‰æ‹©è¡¨

| åœºæ™¯ | å›¾è§„æ¨¡ | è¾¹æƒé‡ | æ¨èç®—æ³• | ç†ç”± |
|------|--------|--------|----------|------|
| å•æºæœ€çŸ­è·¯å¾„ | å°(<10^4) | éè´Ÿ | Dijkstra | é«˜æ•ˆ |
| å•æºæœ€çŸ­è·¯å¾„ | ä¸­(10^4-10^6) | éè´Ÿ | A* | å¯å‘å¼åŠ é€Ÿ |
| å•æºæœ€çŸ­è·¯å¾„ | ä»»æ„ | æœ‰è´Ÿæƒ | Bellman-Ford | æ”¯æŒè´Ÿæƒ |
| æ‰€æœ‰å¯¹æœ€çŸ­è·¯å¾„ | å°(<500) | ä»»æ„ | Floyd-Warshall | ç®€å•ç›´æ¥ |
| æ‰€æœ‰å¯¹æœ€çŸ­è·¯å¾„ | ä¸­ | éè´Ÿ | å¤šæ¬¡Dijkstra | æ›´é«˜æ•ˆ |

### 5.2 ä¸­å¿ƒæ€§ç®—æ³•é€‰æ‹©è¡¨

| åœºæ™¯ | å›¾è§„æ¨¡ | éœ€æ±‚ | æ¨èç®—æ³• | ç†ç”± |
|------|--------|------|----------|------|
| å¿«é€Ÿä¸­å¿ƒæ€§ | ä»»æ„ | å±€éƒ¨é‡è¦æ€§ | åº¦ä¸­å¿ƒæ€§ | O(V)å¤æ‚åº¦ |
| å…³é”®èŠ‚ç‚¹è¯†åˆ« | ä¸­(<10^5) | æ¡¥æ¢ä½œç”¨ | ä»‹æ•°ä¸­å¿ƒæ€§ | è¯†åˆ«å…³é”®èŠ‚ç‚¹ |
| å½±å“åŠ›æ’å | å¤§è§„æ¨¡ | è¿æ¥è´¨é‡ | PageRank | è€ƒè™‘è¿æ¥è´¨é‡ |

### 5.3 ç¤¾åŒºæ£€æµ‹ç®—æ³•é€‰æ‹©è¡¨

| åœºæ™¯ | å›¾è§„æ¨¡ | ç²¾åº¦è¦æ±‚ | æ¨èç®—æ³• | ç†ç”± |
|------|--------|----------|----------|------|
| å¿«é€Ÿç¤¾åŒºæ£€æµ‹ | å¤§è§„æ¨¡(>10^6) | ä¸­ç­‰ | Louvain | å¿«é€Ÿé«˜æ•ˆ |
| è¶…å¤§è§„æ¨¡å›¾ | è¶…å¤§è§„æ¨¡(>10^7) | ä½ | LPA | çº¿æ€§å¤æ‚åº¦ |
| ç²¾ç¡®ç¤¾åŒºæ£€æµ‹ | å°è§„æ¨¡(<10^4) | é«˜ | æ¨¡å—åº¦ä¼˜åŒ– | ç²¾ç¡®ä½†æ…¢ |

---

## ğŸ’¡ **å…­ã€æœ€ä½³å®è·µå»ºè®® / Part 6: Best Practice Recommendations**

### 6.1 ç®—æ³•é€‰æ‹©åŸåˆ™

1. **è§„æ¨¡ä¼˜å…ˆ**: æ ¹æ®å›¾è§„æ¨¡é€‰æ‹©ç®—æ³•
2. **ç²¾åº¦æƒè¡¡**: åœ¨ç²¾åº¦å’Œæ•ˆç‡é—´æƒè¡¡
3. **å·¥å…·åˆ©ç”¨**: ä½¿ç”¨æˆç†Ÿçš„å›¾åº“ï¼ˆNetworkXã€igraphï¼‰

### 6.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **å¹¶è¡ŒåŒ–**: å¯¹äºå¤§è§„æ¨¡å›¾ï¼Œä½¿ç”¨å¹¶è¡Œç®—æ³•
2. **è¿‘ä¼¼ç®—æ³•**: åœ¨ç²¾åº¦è¦æ±‚ä¸é«˜æ—¶ä½¿ç”¨è¿‘ä¼¼ç®—æ³•
3. **å¢é‡æ›´æ–°**: å¯¹äºåŠ¨æ€å›¾ï¼Œä½¿ç”¨å¢é‡ç®—æ³•

---

## ğŸ“š **ä¸ƒã€å‚è€ƒæ–‡æ¡£ / Part 7: Reference Documents**

### 7.1 ç›¸å…³æ–‡æ¡£

- [ç®—æ³•é€‰æ‹©è®¤çŸ¥è·¯å¾„æ¦‚è¿°](./00-ç®—æ³•é€‰æ‹©è®¤çŸ¥è·¯å¾„æ¦‚è¿°.md)
- [å›¾è®ºåŸºç¡€æ¨¡å—](../../01-å›¾è®ºåŸºç¡€/README.md)

### 7.2 å·¥å…·å‚è€ƒ

- [NetworkXæ–‡æ¡£](https://networkx.org/documentation/)
- [igraphæ–‡æ¡£](https://igraph.org/python/)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**çŠ¶æ€**: âœ… å®Œæˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
