# æ‹“æ‰‘ç®—æ³•è¯¦ç»†é€‰æ‹©æŒ‡å— / Detailed Topological Algorithm Selection Guide

## ğŸ“š **æ¦‚è¿° / Overview**

**æ–‡æ¡£ç›®çš„**: æä¾›æ‹“æ‰‘æ•°æ®åˆ†æï¼ˆTDAï¼‰ç®—æ³•çš„è¯¦ç»†é€‰æ‹©æŒ‡å—ï¼ŒåŒ…æ‹¬ç®—æ³•åŸç†ã€å¤æ‚åº¦åˆ†æã€é€‚ç”¨åœºæ™¯ã€å®ç°ç¤ºä¾‹ã€‚

**é€‚ç”¨å¯¹è±¡**: ç®—æ³•å·¥ç¨‹å¸ˆã€æ•°æ®ç§‘å­¦å®¶ã€æ‹“æ‰‘æ•°æ®åˆ†æç ”ç©¶äººå‘˜

---

## ğŸ¯ **ä¸€ã€æŒä¹…åŒè°ƒç®—æ³•é€‰æ‹© / Part 1: Persistent Homology Algorithm Selection**

### 1.1 Ripserç®—æ³•

**ç®—æ³•åŸç†**:

- è®¡ç®—Vietoris-Ripså¤å½¢çš„æŒä¹…åŒè°ƒ
- ä½¿ç”¨çŸ©é˜µçº¦åŒ–æ–¹æ³•
- æ”¯æŒç¨€ç–çŸ©é˜µä¼˜åŒ–

**å¤æ‚åº¦**:

- æ—¶é—´å¤æ‚åº¦: O(nÂ³) ~ O(n^Ï‰)ï¼ˆÏ‰ä¸ºçŸ©é˜µä¹˜æ³•æŒ‡æ•°ï¼‰
- ç©ºé—´å¤æ‚åº¦: O(nÂ²)

**é€‚ç”¨åœºæ™¯**:

- ä¸­å°è§„æ¨¡ç‚¹äº‘ï¼ˆn < 10^5ï¼‰
- éœ€è¦ç²¾ç¡®æŒä¹…åŒè°ƒ
- ä½ç»´æ•°æ®ï¼ˆd < 5ï¼‰

**å®ç°ç¤ºä¾‹**:

```python
from ripser import ripser
import numpy as np

def compute_persistent_homology_ripser(points, max_dim=2):
    """
    ä½¿ç”¨Ripserè®¡ç®—æŒä¹…åŒè°ƒ
    """
    # è®¡ç®—æŒä¹…åŒè°ƒ
    result = ripser(points, maxdim=max_dim)

    # æå–æŒä¹…å›¾
    diagrams = result['dgms']

    # æå–æŒä¹…ç‰¹å¾
    persistent_features = {}
    for dim, diagram in enumerate(diagrams):
        if len(diagram) > 0:
            # è¿‡æ»¤æŒä¹…ç‰¹å¾ï¼ˆæ­»äº¡å€¼ä¸ä¸ºæ— ç©·å¤§ï¼‰
            persistent = diagram[diagram[:, 1] != np.inf]
            persistent_features[dim] = persistent

    return persistent_features, result
```

### 1.2 GUDHIç®—æ³•

**ç®—æ³•åŸç†**:

- æ”¯æŒå¤šç§å¤å½¢æ„é€ ï¼ˆRipsã€Alphaã€Witnessç­‰ï¼‰
- ä½¿ç”¨é«˜æ•ˆçš„çŸ©é˜µçº¦åŒ–
- æ”¯æŒå¹¶è¡Œè®¡ç®—

**å¤æ‚åº¦**:

- æ—¶é—´å¤æ‚åº¦: O(nÂ³) ~ O(n^Ï‰)
- ç©ºé—´å¤æ‚åº¦: O(nÂ²)

**é€‚ç”¨åœºæ™¯**:

- ä¸­å¤§è§„æ¨¡ç‚¹äº‘ï¼ˆn < 10^6ï¼‰
- éœ€è¦å¤šç§å¤å½¢ç±»å‹
- éœ€è¦å¹¶è¡ŒåŠ é€Ÿ

**å®ç°ç¤ºä¾‹**:

```python
from gudhi import RipsComplex, SimplexTree
import numpy as np

def compute_persistent_homology_gudhi(points, max_edge_length=1.0, max_dim=2):
    """
    ä½¿ç”¨GUDHIè®¡ç®—æŒä¹…åŒè°ƒ
    """
    # æ„å»ºRipså¤å½¢
    rips_complex = RipsComplex(points=points, max_edge_length=max_edge_length)

    # åˆ›å»ºå•çº¯å¤å½¢æ ‘
    simplex_tree = rips_complex.create_simplex_tree(max_dimension=max_dim)

    # è®¡ç®—æŒä¹…åŒè°ƒ
    persistence = simplex_tree.persistence()

    # æå–æŒä¹…ç‰¹å¾
    persistent_features = {}
    for dim, (birth, death) in persistence:
        if dim not in persistent_features:
            persistent_features[dim] = []
        if death != float('inf'):
            persistent_features[dim].append((birth, death))

    return persistent_features, simplex_tree
```

### 1.3 ç¨€ç–Ripsç®—æ³•

**ç®—æ³•åŸç†**:

- Ripserçš„ç¨€ç–ä¼˜åŒ–ç‰ˆæœ¬
- ä½¿ç”¨é‡‡æ ·å’Œè¿‘ä¼¼
- å¤§å¹…é™ä½è®¡ç®—å¤æ‚åº¦

**å¤æ‚åº¦**:

- æ—¶é—´å¤æ‚åº¦: O(n log n)
- ç©ºé—´å¤æ‚åº¦: O(n)

**é€‚ç”¨åœºæ™¯**:

- å¤§è§„æ¨¡ç‚¹äº‘ï¼ˆn > 10^5ï¼‰
- å¯ä»¥æ¥å—è¿‘ä¼¼ç»“æœ
- éœ€è¦å¿«é€Ÿè®¡ç®—

**å®ç°ç¤ºä¾‹**:

```python
from ripser import ripser
from sklearn.utils import resample

def compute_sparse_rips(points, sample_size=1000, max_dim=2):
    """
    ä½¿ç”¨ç¨€ç–Ripsè®¡ç®—æŒä¹…åŒè°ƒ
    """
    # é‡‡æ ·
    if len(points) > sample_size:
        sampled_points = resample(points, n_samples=sample_size, random_state=42)
    else:
        sampled_points = points

    # è®¡ç®—æŒä¹…åŒè°ƒ
    result = ripser(sampled_points, maxdim=max_dim, sparse=True)

    return result
```

---

## ğŸ“Š **äºŒã€Mapperç®—æ³•é€‰æ‹© / Part 2: Mapper Algorithm Selection**

### 2.1 KeplerMapper

**ç®—æ³•åŸç†**:

- åŸºäºè¦†ç›–å’Œèšç±»çš„æ•°æ®æ‘˜è¦
- ä½¿ç”¨æ»¤æ³¢å™¨å‡½æ•°å’Œèšç±»ç®—æ³•
- ç”Ÿæˆç½‘ç»œå›¾è¡¨ç¤º

**å¤æ‚åº¦**:

- æ—¶é—´å¤æ‚åº¦: O(nÂ²) ~ O(n log n)ï¼ˆå–å†³äºèšç±»ç®—æ³•ï¼‰
- ç©ºé—´å¤æ‚åº¦: O(n)

**é€‚ç”¨åœºæ™¯**:

- ä¸­å¤§è§„æ¨¡æ•°æ®ï¼ˆn < 10^6ï¼‰
- éœ€è¦æ•°æ®å¯è§†åŒ–
- éœ€è¦æ•°æ®æ‘˜è¦

**å®ç°ç¤ºä¾‹**:

```python
import kmapper as km
from sklearn import cluster
from sklearn.manifold import TSNE
import numpy as np

def mapper_analysis(data, n_cubes=10, overlap=0.2):
    """
    ä½¿ç”¨KeplerMapperè¿›è¡ŒMapperåˆ†æ
    """
    # åˆ›å»ºMapper
    mapper = km.KeplerMapper(verbose=1)

    # æŠ•å½±åˆ°ä½ç»´ç©ºé—´ï¼ˆä½¿ç”¨t-SNEï¼‰
    projected_data = mapper.fit_transform(
        data,
        projection=TSNE(n_components=2, random_state=42)
    )

    # æ„å»ºè¦†ç›–
    cover = km.Cover(n_cubes=n_cubes, perc_overlap=overlap)

    # èšç±»
    graph = mapper.map(
        projected_data,
        data,
        clusterer=cluster.DBSCAN(eps=0.5, min_samples=5),
        cover=cover
    )

    # å¯è§†åŒ–
    mapper.visualize(
        graph,
        path_html="mapper_output.html",
        title="Mapper Analysis"
    )

    return graph, mapper
```

### 2.2 è‡ªå®šä¹‰Mapper

**ç®—æ³•åŸç†**:

- è‡ªå®šä¹‰æ»¤æ³¢å™¨å‡½æ•°
- è‡ªå®šä¹‰èšç±»ç®—æ³•
- æ›´çµæ´»çš„æ§åˆ¶

**å¤æ‚åº¦**:

- æ—¶é—´å¤æ‚åº¦: O(nÂ²) ~ O(n log n)
- ç©ºé—´å¤æ‚åº¦: O(n)

**é€‚ç”¨åœºæ™¯**:

- éœ€è¦ç‰¹å®šæ»¤æ³¢å™¨
- éœ€è¦ç‰¹å®šèšç±»ç®—æ³•
- éœ€è¦ç²¾ç»†æ§åˆ¶

**å®ç°ç¤ºä¾‹**:

```python
def custom_mapper(data, filter_func, clusterer, n_cubes=10, overlap=0.2):
    """
    è‡ªå®šä¹‰Mapperå®ç°
    """
    mapper = km.KeplerMapper(verbose=1)

    # ä½¿ç”¨è‡ªå®šä¹‰æ»¤æ³¢å™¨
    filtered_data = filter_func(data)

    # æ„å»ºè¦†ç›–
    cover = km.Cover(n_cubes=n_cubes, perc_overlap=overlap)

    # ä½¿ç”¨è‡ªå®šä¹‰èšç±»å™¨
    graph = mapper.map(
        filtered_data,
        data,
        clusterer=clusterer,
        cover=cover
    )

    return graph
```

---

## ğŸ”§ **ä¸‰ã€å¤å½¢æ„é€ ç®—æ³•é€‰æ‹© / Part 3: Complex Construction Algorithm Selection**

### 3.1 Vietoris-Ripså¤å½¢

**ç®—æ³•åŸç†**:

- åŸºäºè·ç¦»é˜ˆå€¼çš„å¤å½¢æ„é€ 
- ç®€å•ç›´è§‚
- è®¡ç®—ç›¸å¯¹é«˜æ•ˆ

**å¤æ‚åº¦**:

- æ—¶é—´å¤æ‚åº¦: O(nÂ²) ~ O(2^n)ï¼ˆå–å†³äºé˜ˆå€¼ï¼‰
- ç©ºé—´å¤æ‚åº¦: O(2^n)

**é€‚ç”¨åœºæ™¯**:

- å°åˆ°ä¸­ç­‰è§„æ¨¡æ•°æ®
- éœ€è¦ç®€å•å¤å½¢
- è·ç¦»ä¿¡æ¯å¯ç”¨

**å®ç°ç¤ºä¾‹**:

```python
from gudhi import RipsComplex

def build_rips_complex(points, max_edge_length=1.0):
    """
    æ„å»ºVietoris-Ripså¤å½¢
    """
    rips_complex = RipsComplex(points=points, max_edge_length=max_edge_length)
    simplex_tree = rips_complex.create_simplex_tree(max_dimension=2)

    return simplex_tree
```

### 3.2 Alphaå¤å½¢

**ç®—æ³•åŸç†**:

- åŸºäºVoronoiå›¾çš„å¤å½¢æ„é€ 
- æ›´ç²¾ç¡®çš„æ‹“æ‰‘è¡¨ç¤º
- è®¡ç®—å¤æ‚åº¦è¾ƒé«˜

**å¤æ‚åº¦**:

- æ—¶é—´å¤æ‚åº¦: O(n^âŒˆd/2âŒ‰)ï¼ˆdä¸ºç»´åº¦ï¼‰
- ç©ºé—´å¤æ‚åº¦: O(n^âŒˆd/2âŒ‰)

**é€‚ç”¨åœºæ™¯**:

- ä½ç»´æ•°æ®ï¼ˆd â‰¤ 3ï¼‰
- éœ€è¦ç²¾ç¡®æ‹“æ‰‘
- å°åˆ°ä¸­ç­‰è§„æ¨¡

**å®ç°ç¤ºä¾‹**:

```python
from gudhi import AlphaComplex

def build_alpha_complex(points):
    """
    æ„å»ºAlphaå¤å½¢
    """
    alpha_complex = AlphaComplex(points=points)
    simplex_tree = alpha_complex.create_simplex_tree()

    return simplex_tree
```

### 3.3 Witnesså¤å½¢

**ç®—æ³•åŸç†**:

- åŸºäºlandmarkç‚¹çš„å¤å½¢æ„é€ 
- å¯æ‰©å±•åˆ°å¤§è§„æ¨¡æ•°æ®
- è¿‘ä¼¼ä½†é«˜æ•ˆ

**å¤æ‚åº¦**:

- æ—¶é—´å¤æ‚åº¦: O(knÂ²)ï¼ˆkä¸ºlandmarkæ•°ï¼‰
- ç©ºé—´å¤æ‚åº¦: O(kn)

**é€‚ç”¨åœºæ™¯**:

- å¤§è§„æ¨¡æ•°æ®ï¼ˆn > 10^5ï¼‰
- å¯ä»¥æ¥å—è¿‘ä¼¼
- éœ€è¦å¿«é€Ÿè®¡ç®—

**å®ç°ç¤ºä¾‹**:

```python
from gudhi import WitnessComplex

def build_witness_complex(landmarks, witnesses):
    """
    æ„å»ºWitnesså¤å½¢
    """
    witness_complex = WitnessComplex(landmarks=landmarks, witnesses=witnesses)
    simplex_tree = witness_complex.create_simplex_tree()

    return simplex_tree
```

---

## ğŸ”¬ **å››ã€æŒä¹…å›¾åŒ¹é…ç®—æ³•é€‰æ‹© / Part 4: Persistence Diagram Matching Algorithm Selection**

### 4.1 Wassersteinè·ç¦»

**ç®—æ³•åŸç†**:

- è®¡ç®—ä¸¤ä¸ªæŒä¹…å›¾ä¹‹é—´çš„Wassersteinè·ç¦»
- è€ƒè™‘æ‰€æœ‰ç‰¹å¾ç‚¹
- ç²¾ç¡®ä½†è®¡ç®—æ˜‚è´µ

**å¤æ‚åº¦**:

- æ—¶é—´å¤æ‚åº¦: O(nÂ³)ï¼ˆnä¸ºç‰¹å¾ç‚¹æ•°ï¼‰
- ç©ºé—´å¤æ‚åº¦: O(nÂ²)

**é€‚ç”¨åœºæ™¯**:

- å°è§„æ¨¡æŒä¹…å›¾ï¼ˆn < 1000ï¼‰
- éœ€è¦ç²¾ç¡®è·ç¦»
- å½¢çŠ¶æ¯”è¾ƒ

**å®ç°ç¤ºä¾‹**:

```python
from gudhi import wasserstein_distance
import numpy as np

def compute_wasserstein_distance(diagram1, diagram2, order=2):
    """
    è®¡ç®—ä¸¤ä¸ªæŒä¹…å›¾çš„Wassersteinè·ç¦»
    """
    # è½¬æ¢ä¸ºnumpyæ•°ç»„
    dgm1 = np.array(diagram1)
    dgm2 = np.array(diagram2)

    # è®¡ç®—Wassersteinè·ç¦»
    distance = wasserstein_distance(diagram1=dgm1, diagram2=dgm2, order=order)

    return distance
```

### 4.2 æŒä¹…æ™¯è§‚ï¼ˆPersistence Landscapeï¼‰

**ç®—æ³•åŸç†**:

- å°†æŒä¹…å›¾è½¬æ¢ä¸ºå‡½æ•°
- ä½¿ç”¨LÂ²è·ç¦»æ¯”è¾ƒ
- è®¡ç®—æ›´é«˜æ•ˆ

**å¤æ‚åº¦**:

- æ—¶é—´å¤æ‚åº¦: O(n log n)
- ç©ºé—´å¤æ‚åº¦: O(n)

**é€‚ç”¨åœºæ™¯**:

- ä¸­å¤§è§„æ¨¡æŒä¹…å›¾
- éœ€è¦å¿«é€Ÿæ¯”è¾ƒ
- æœºå™¨å­¦ä¹ åº”ç”¨

**å®ç°ç¤ºä¾‹**:

```python
from gudhi.representations import Landscape

def compute_persistence_landscape(diagram, num_landscapes=5, resolution=100):
    """
    è®¡ç®—æŒä¹…æ™¯è§‚
    """
    landscape = Landscape(num_landscapes=num_landscapes, resolution=resolution)
    landscape_vector = landscape.fit_transform([diagram])

    return landscape_vector[0]
```

### 4.3 è´è’‚æ›²çº¿ï¼ˆBetti Curveï¼‰

**ç®—æ³•åŸç†**:

- è®¡ç®—æ¯ä¸ªç»´åº¦çš„è´è’‚æ•°éšé˜ˆå€¼çš„å˜åŒ–
- ç®€å•ç›´è§‚
- è®¡ç®—é«˜æ•ˆ

**å¤æ‚åº¦**:

- æ—¶é—´å¤æ‚åº¦: O(n log n)
- ç©ºé—´å¤æ‚åº¦: O(n)

**é€‚ç”¨åœºæ™¯**:

- å¿«é€Ÿå½¢çŠ¶æ¯”è¾ƒ
- éœ€è¦å¯è§†åŒ–
- å¤§è§„æ¨¡æ•°æ®

**å®ç°ç¤ºä¾‹**:

```python
from gudhi.representations import BettiCurve

def compute_betti_curve(diagram, resolution=100):
    """
    è®¡ç®—è´è’‚æ›²çº¿
    """
    betti_curve = BettiCurve(resolution=resolution)
    curve = betti_curve.fit_transform([diagram])

    return curve[0]
```

---

## ğŸ“ˆ **äº”ã€ç®—æ³•é€‰æ‹©å†³ç­–è¡¨ / Part 5: Algorithm Selection Decision Table**

### 5.1 æŒä¹…åŒè°ƒç®—æ³•é€‰æ‹©è¡¨

| åœºæ™¯ | æ•°æ®è§„æ¨¡ | ç²¾åº¦è¦æ±‚ | æ¨èç®—æ³• | ç†ç”± |
|------|--------|----------|----------|------|
| ç²¾ç¡®æŒä¹…åŒè°ƒ | å°(<10^4) | é«˜ | Ripser | ç²¾ç¡®é«˜æ•ˆ |
| ç²¾ç¡®æŒä¹…åŒè°ƒ | ä¸­(10^4-10^5) | é«˜ | GUDHI | æ”¯æŒå¹¶è¡Œ |
| è¿‘ä¼¼æŒä¹…åŒè°ƒ | å¤§(>10^5) | ä¸­ | ç¨€ç–Rips | å¿«é€Ÿè¿‘ä¼¼ |
| å¤šç§å¤å½¢ | ä¸­ | é«˜ | GUDHI | æ”¯æŒå¤šç§å¤å½¢ |

### 5.2 å¤å½¢æ„é€ ç®—æ³•é€‰æ‹©è¡¨

| åœºæ™¯ | æ•°æ®è§„æ¨¡ | ç»´åº¦ | æ¨èç®—æ³• | ç†ç”± |
|------|--------|------|----------|------|
| ç®€å•å¤å½¢ | å°ä¸­ | ä»»æ„ | Vietoris-Rips | ç®€å•ç›´è§‚ |
| ç²¾ç¡®å¤å½¢ | å°ä¸­ | â‰¤3 | Alpha | ç²¾ç¡®æ‹“æ‰‘ |
| å¤§è§„æ¨¡æ•°æ® | å¤§(>10^5) | ä»»æ„ | Witness | å¯æ‰©å±• |

### 5.3 æŒä¹…å›¾åŒ¹é…ç®—æ³•é€‰æ‹©è¡¨

| åœºæ™¯ | æŒä¹…å›¾è§„æ¨¡ | ç²¾åº¦è¦æ±‚ | æ¨èç®—æ³• | ç†ç”± |
|------|-----------|----------|----------|------|
| ç²¾ç¡®åŒ¹é… | å°(<1000) | é«˜ | Wasserstein | ç²¾ç¡®è·ç¦» |
| å¿«é€Ÿæ¯”è¾ƒ | ä¸­ | ä¸­ | æŒä¹…æ™¯è§‚ | é«˜æ•ˆè®¡ç®— |
| å¯è§†åŒ– | ä»»æ„ | ä½ | è´è’‚æ›²çº¿ | ç®€å•ç›´è§‚ |

---

## ğŸ’¡ **å…­ã€æœ€ä½³å®è·µå»ºè®® / Part 6: Best Practice Recommendations**

### 6.1 ç®—æ³•é€‰æ‹©åŸåˆ™

1. **è§„æ¨¡ä¼˜å…ˆ**: æ ¹æ®æ•°æ®è§„æ¨¡é€‰æ‹©ç®—æ³•
2. **ç²¾åº¦æƒè¡¡**: åœ¨ç²¾åº¦å’Œæ•ˆç‡é—´æƒè¡¡
3. **å·¥å…·åˆ©ç”¨**: ä½¿ç”¨æˆç†Ÿçš„TDAåº“ï¼ˆGUDHIã€Ripserï¼‰

### 6.2 æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **é‡‡æ ·**: å¯¹äºå¤§è§„æ¨¡æ•°æ®ï¼Œä½¿ç”¨é‡‡æ ·
2. **ç¨€ç–åŒ–**: ä½¿ç”¨ç¨€ç–çŸ©é˜µä¼˜åŒ–
3. **å¹¶è¡ŒåŒ–**: ä½¿ç”¨å¹¶è¡Œè®¡ç®—åŠ é€Ÿ

---

## ğŸ“š **ä¸ƒã€å‚è€ƒæ–‡æ¡£ / Part 7: Reference Documents**

### 7.1 ç›¸å…³æ–‡æ¡£

- [ç®—æ³•é€‰æ‹©è®¤çŸ¥è·¯å¾„æ¦‚è¿°](./00-ç®—æ³•é€‰æ‹©è®¤çŸ¥è·¯å¾„æ¦‚è¿°.md)
- [ç½‘ç»œæ‹“æ‰‘æ¨¡å—](../../02-ç½‘ç»œæ‹“æ‰‘/README.md)

### 7.2 å·¥å…·å‚è€ƒ

- [GUDHIæ–‡æ¡£](https://gudhi.inria.fr/documentation/)
- [Ripseræ–‡æ¡£](https://ripser.scikit-tda.org/)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**çŠ¶æ€**: âœ… å®Œæˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
