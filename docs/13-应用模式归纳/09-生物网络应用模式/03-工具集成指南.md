# ç”Ÿç‰©ç½‘ç»œåº”ç”¨æ¨¡å¼å·¥å…·é›†æˆæŒ‡å— / Biological Networks Tools Integration Guide

## ğŸ“š **æ¦‚è¿° / Overview**

**æ–‡æ¡£ç›®çš„**: æä¾›ç”Ÿç‰©ç½‘ç»œé¢†åŸŸåº”ç”¨æ¨¡å¼çš„å®Œæ•´å·¥å…·é›†æˆæŒ‡å—ã€‚

**ç›¸å…³æ–‡æ¡£**:
- [ç”Ÿç‰©ç½‘ç»œåº”ç”¨æ¨¡å¼æ¸…å•](ç”Ÿç‰©ç½‘ç»œåº”ç”¨æ¨¡å¼æ¸…å•.md)
- [å·¥å…·é›†æˆä¸é…ç½®æŒ‡å—](../å·¥å…·é›†æˆä¸é…ç½®æŒ‡å—.md)

---

## ğŸ¯ **ä¸€ã€Petriç½‘å·¥å…·é›†æˆ / Part 1: Petri Net Tools Integration**

### 1.1 COPASIé›†æˆï¼ˆä»£è°¢ç½‘ç»œå»ºæ¨¡ï¼‰

**å®‰è£…**:
```bash
wget http://copasi.org/Download/COPASI-4.40-Linux-x86_64.tar.gz
tar -xzf COPASI-4.40-Linux-x86_64.tar.gz
```

**Pythoné›†æˆ**:
```python
import subprocess

class COPASIIntegration:
    def simulate_metabolic_network(self, model_file: str):
        """ä»¿çœŸä»£è°¢ç½‘ç»œ"""
        cmd = ['copasi', '-i', model_file, '-s']
        result = subprocess.run(cmd, capture_output=True, text=True)
        return result.stdout
```

### 1.2 COBRApyé›†æˆï¼ˆé€šé‡å¹³è¡¡åˆ†æï¼‰

**å®‰è£…**:
```bash
pip install cobra
```

**Pythoné›†æˆ**:
```python
from cobra import Model, Reaction

class COBRApyIntegration:
    def __init__(self, model_file: str):
        self.model = Model.read_sbml_model(model_file)
    
    def flux_balance_analysis(self, objective_reaction: str):
        """é€šé‡å¹³è¡¡åˆ†æ"""
        self.model.objective = objective_reaction
        solution = self.model.optimize()
        return solution.fluxes
```

### 1.3 CPN Toolsé›†æˆï¼ˆä¿¡å·è½¬å¯¼ç½‘ç»œï¼‰

**Pythoné›†æˆ**:
```python
class SignalTransductionModeler:
    def model_signal_pathway(self, pathway_steps: list):
        """å»ºæ¨¡ä¿¡å·é€šè·¯"""
        # CPN Toolså»ºæ¨¡
        pass
```

---

## ğŸ”§ **äºŒã€åŠ¨æ€å›¾è®ºå·¥å…·é›†æˆ / Part 2: Dynamic Graph Tools Integration**

### 2.1 NetworkXé›†æˆï¼ˆPPIç½‘ç»œåˆ†æï¼‰

**Pythoné›†æˆ**:
```python
import networkx as nx
from networkx.algorithms import community

class PPINetworkAnalyzer:
    def __init__(self):
        self.graph = nx.Graph()
    
    def add_protein_interaction(self, protein1: str, protein2: str, confidence: float):
        """æ·»åŠ è›‹ç™½è´¨ç›¸äº’ä½œç”¨"""
        self.graph.add_edge(protein1, protein2, confidence=confidence)
    
    def identify_functional_modules(self):
        """è¯†åˆ«åŠŸèƒ½æ¨¡å—"""
        communities = community.louvain_communities(self.graph, weight='confidence')
        return [list(comm) for comm in communities]
    
    def identify_key_proteins(self):
        """è¯†åˆ«å…³é”®è›‹ç™½"""
        betweenness = nx.betweenness_centrality(self.graph)
        return sorted(betweenness.items(), key=lambda x: x[1], reverse=True)[:10]
```

### 2.2 Cytoscapeé›†æˆï¼ˆç½‘ç»œå¯è§†åŒ–ï¼‰

**å®‰è£…**:
```bash
wget https://github.com/cytoscape/cytoscape/releases/download/3.10.1/Cytoscape_3_10_1_unix.sh
chmod +x Cytoscape_3_10_1_unix.sh
./Cytoscape_3_10_1_unix.sh
```

**Pythoné›†æˆï¼ˆé€šè¿‡Cytoscape Automationï¼‰**:
```python
import requests

class CytoscapeIntegration:
    def __init__(self, base_url: str = 'http://localhost:1234'):
        self.base_url = base_url
    
    def create_network(self, nodes: list, edges: list):
        """åˆ›å»ºç½‘ç»œ"""
        network_data = {
            'nodes': nodes,
            'edges': edges
        }
        response = requests.post(f'{self.base_url}/v1/networks', json=network_data)
        return response.json()
```

---

## ğŸ”¬ **ä¸‰ã€æ‹“æ‰‘åˆ†æå·¥å…·é›†æˆ / Part 3: Topological Analysis Tools Integration**

### 3.1 GUDHIé›†æˆï¼ˆå•ç»†èƒè½¨è¿¹åˆ†æï¼‰

**Pythoné›†æˆ**:
```python
from gudhi import RipsComplex

class SingleCellTrajectoryAnalyzer:
    def analyze_trajectory(self, cell_embeddings: np.ndarray):
        """åˆ†æç»†èƒåˆ†åŒ–è½¨è¿¹"""
        rips_complex = RipsComplex(points=cell_embeddings, max_edge_length=5.0)
        persistence = rips_complex.create_simplex_tree(max_dimension=2).persistence()
        
        # H1ç‰¹å¾è¡¨ç¤ºåˆ†æ”¯ç‚¹
        h1_features = [p for dim, p in persistence if dim == 1]
        return {'branch_points': len(h1_features), 'persistence': persistence}
```

### 3.2 Scanpyé›†æˆï¼ˆå•ç»†èƒåˆ†æï¼‰

**å®‰è£…**:
```bash
pip install scanpy
```

**Pythoné›†æˆ**:
```python
import scanpy as sc

class ScanpyIntegration:
    def analyze_single_cell(self, adata):
        """å•ç»†èƒåˆ†æ"""
        # é¢„å¤„ç†
        sc.pp.filter_cells(adata, min_genes=200)
        sc.pp.filter_genes(adata, min_cells=3)
        
        # å½’ä¸€åŒ–
        sc.pp.normalize_total(adata, target_sum=1e4)
        sc.pp.log1p(adata)
        
        # é™ç»´
        sc.tl.pca(adata, svd_solver='arpack')
        sc.pp.neighbors(adata)
        sc.tl.umap(adata)
        
        # èšç±»
        sc.tl.leiden(adata)
        
        return adata
```

---

## ğŸš€ **å››ã€Graph Transformerå’ŒPGNNå·¥å…·é›†æˆï¼ˆ2025æœ€æ–°ï¼‰/ Part 4: Graph Transformer and PGNN Tools Integration (2025 Latest)**

### 4.1 PyTorch Geometricé›†æˆï¼ˆGraph Transformerï¼‰

**å®‰è£…**:
```bash
pip install torch torch-geometric
```

**Pythoné›†æˆ**:
```python
import torch
import torch.nn as nn
from torch_geometric.data import Data
from torch_geometric.nn import TransformerConv

class ProteinStructureGraphTransformerIntegration:
    """è›‹ç™½è´¨ç»“æ„Graph Transformeré›†æˆ"""
    
    def __init__(self, input_dim, hidden_dim=256, num_layers=6, num_heads=8):
        self.model = self._build_model(input_dim, hidden_dim, num_layers, num_heads)
        self.ss_head = nn.Sequential(
            nn.Linear(hidden_dim, hidden_dim // 2),
            nn.ReLU(),
            nn.Linear(hidden_dim // 2, 3)  # [helix, sheet, coil]
        )
        self.coord_head = nn.Sequential(
            nn.Linear(hidden_dim, hidden_dim // 2),
            nn.ReLU(),
            nn.Linear(hidden_dim // 2, 3)  # [x, y, z]
        )
    
    def _build_model(self, input_dim, hidden_dim, num_layers, num_heads):
        """æ„å»ºGraph Transformeræ¨¡å‹"""
        layers = []
        layers.append(TransformerConv(input_dim, hidden_dim, heads=num_heads))
        
        for _ in range(num_layers - 1):
            layers.append(TransformerConv(hidden_dim, hidden_dim, heads=num_heads))
        
        return nn.Sequential(*layers)
    
    def predict_protein_structure(self, node_features, edge_index):
        """é¢„æµ‹è›‹ç™½è´¨ç»“æ„"""
        data = Data(x=node_features, edge_index=edge_index)
        node_embeddings = self.model(data.x, data.edge_index)
        
        secondary_structure = self.ss_head(node_embeddings)
        coordinates = self.coord_head(node_embeddings)
        
        return {
            'secondary_structure': secondary_structure,
            'coordinates': coordinates
        }
```

### 4.2 PyTorché›†æˆï¼ˆPGNNï¼‰

**Pythoné›†æˆ**:
```python
import torch
import torch.nn as nn
import networkx as nx

class MultiOmicsRegulatoryNetworkPGNNIntegration:
    """å¤šç»„å­¦åŸºå› è°ƒæ§ç½‘ç»œPGNNé›†æˆ"""
    
    def __init__(self, num_genes, num_tfs, num_epigenetic, num_proteins, hidden_dim=128):
        self.gene_embedding = nn.Embedding(num_genes, hidden_dim)
        self.tf_embedding = nn.Embedding(num_tfs, hidden_dim)
        self.epigenetic_embedding = nn.Embedding(num_epigenetic, hidden_dim)
        self.protein_embedding = nn.Embedding(num_proteins, hidden_dim)
        
        self.propagation_layers = nn.ModuleList([
            nn.Linear(hidden_dim, hidden_dim) for _ in range(3)
        ])
        
        self.regulation_head = nn.Sequential(
            nn.Linear(hidden_dim * 2, hidden_dim),
            nn.ReLU(),
            nn.Linear(hidden_dim, 1),
            nn.Sigmoid()
        )
    
    def predict_regulation(self, regulatory_petri_net, gene_features, tf_features,
                          epigenetic_features, protein_features, tf_node, target_gene):
        """é¢„æµ‹è°ƒæ§å…³ç³»"""
        embeddings = {}
        for node in regulatory_petri_net.nodes():
            node_type = regulatory_petri_net.nodes[node]['type']
            node_idx = regulatory_petri_net.nodes[node]['index']
            
            if node_type == 'gene':
                embeddings[node] = self.gene_embedding(node_idx) + gene_features[node_idx]
            elif node_type == 'tf':
                embeddings[node] = self.tf_embedding(node_idx) + tf_features[node_idx]
            elif node_type == 'epigenetic':
                embeddings[node] = self.epigenetic_embedding(node_idx) + epigenetic_features[node_idx]
            else:  # protein
                embeddings[node] = self.protein_embedding(node_idx) + protein_features[node_idx]
        
        # PGNNä¼ æ’­
        for layer in self.propagation_layers:
            new_embeddings = {}
            for node in regulatory_petri_net.nodes():
                neighbor_embeddings = [embeddings[n] for n in regulatory_petri_net.neighbors(node)]
                if neighbor_embeddings:
                    aggregated = torch.stack(neighbor_embeddings).mean(dim=0)
                    new_embeddings[node] = layer(aggregated)
                else:
                    new_embeddings[node] = embeddings[node]
            embeddings = new_embeddings
        
        # é¢„æµ‹è°ƒæ§å…³ç³»
        tf_emb = embeddings[tf_node]
        gene_emb = embeddings[target_gene]
        pair_feat = torch.cat([tf_emb, gene_emb], dim=-1)
        regulation_prob = self.regulation_head(pair_feat)
        
        return regulation_prob
```

### 4.3 GINtoSPNé›†æˆï¼ˆè‡ªåŠ¨åŒ–Petriç½‘æ¨¡å‹æ„å»ºï¼‰

**å®‰è£…**:
```r
# RåŒ…å®‰è£…
install.packages("devtools")
devtools::install_github("GINtoSPN/GINtoSPN")
```

**Ré›†æˆ**:
```r
library(GINtoSPN)

# ä»å¤šç»„å­¦æ•°æ®æ„å»ºPetriç½‘æ¨¡å‹
build_petri_net_from_omics <- function(expression_data, protein_data, epigenetic_data) {
    # æ„å»ºåˆ†å­ç›¸äº’ä½œç”¨ç½‘ç»œ
    interaction_network <- build_interaction_network(
        expression_data, 
        protein_data, 
        epigenetic_data
    )
    
    # è½¬æ¢ä¸ºPetriç½‘æ¨¡å‹
    petri_net <- convert_to_petri_net(interaction_network)
    
    return(petri_net)
}
```

---

## ğŸ”„ **äº”ã€ç”Ÿç‰©ä¿¡æ¯å­¦ä¸“ç”¨å·¥å…·é›†æˆ / Part 5: Bioinformatics Tools Integration**

### 4.1 ARACNeé›†æˆï¼ˆåŸºå› è°ƒæ§ç½‘ç»œæ¨æ–­ï¼‰

**å®‰è£…**:
```bash
wget https://github.com/califano-lab/ARACNe-AP/releases/download/v1.1/ARACNe-AP.jar
```

**Pythoné›†æˆ**:
```python
import subprocess

class ARACNeIntegration:
    def infer_regulatory_network(self, expression_file: str, output_file: str):
        """æ¨æ–­åŸºå› è°ƒæ§ç½‘ç»œ"""
        cmd = [
            'java', '-jar', 'ARACNe-AP.jar',
            '-e', expression_file,
            '-o', output_file
        ]
        result = subprocess.run(cmd, capture_output=True, text=True)
        return result.stdout
```

### 4.2 pySCENICé›†æˆï¼ˆè½¬å½•å› å­åˆ†æï¼‰

**å®‰è£…**:
```bash
pip install pyscenic
```

**Pythoné›†æˆ**:
```python
from pyscenic import ctx, grn, aucell

class PySCENICIntegration:
    def infer_grn(self, expression_matrix, tf_list):
        """æ¨æ–­åŸºå› è°ƒæ§ç½‘ç»œ"""
        # æ„å»ºGRN
        adjacencies = grn.infer_adjacencies(expression_matrix, tf_list)
        modules = ctx.regulons(adjacencies, expression_matrix)
        auc_mtx = aucell(expression_matrix, modules)
        return {'adjacencies': adjacencies, 'modules': modules, 'auc': auc_mtx}
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ  
**çŠ¶æ€**: âœ… å®Œæˆ
