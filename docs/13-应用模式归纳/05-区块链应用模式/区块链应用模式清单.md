# åŒºå—é“¾åº”ç”¨æ¨¡å¼æ¸…å• / Blockchain Application Pattern Checklist

## ğŸ“š **æ¦‚è¿° / Overview**

**æ–‡æ¡£ç›®çš„**: å½’çº³ä¸‰å¤§ç†è®ºï¼ˆPetriç½‘ã€åŠ¨æ€å›¾è®ºã€æ‹“æ‰‘æ¨¡å‹ï¼‰åœ¨åŒºå—é“¾é¢†åŸŸçš„åº”ç”¨æ¨¡å¼ï¼Œæä¾›å»ºæ¨¡é€‰æ‹©ã€åˆ†ææ–¹æ³•å’Œå·¥å…·ç»„åˆçš„å†³ç­–å‚è€ƒã€‚

**æ ¸å¿ƒé—®é¢˜**:

- å…±è¯†åè®®éªŒè¯
- æ™ºèƒ½åˆçº¦å½¢å¼åŒ–éªŒè¯
- äº¤æ˜“ç½‘ç»œåˆ†æ
- åˆ†å‰æ£€æµ‹ä¸åˆ†æ
- DeFiåè®®å®‰å…¨åˆ†æ

**é€‚ç”¨å¯¹è±¡**: åŒºå—é“¾æ¶æ„å¸ˆã€æ™ºèƒ½åˆçº¦å¼€å‘è€…ã€åŒºå—é“¾ç ”ç©¶äººå‘˜

---

## ğŸ“‹ **ç›®å½• / Table of Contents**

- [åŒºå—é“¾åº”ç”¨æ¨¡å¼æ¸…å• / Blockchain Application Pattern Checklist](#åŒºå—é“¾åº”ç”¨æ¨¡å¼æ¸…å•--blockchain-application-pattern-checklist)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‹ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [ğŸ¯ **ä¸€ã€æ ¸å¿ƒé—®é¢˜ä¸å»ºæ¨¡é€‰æ‹© / Part 1: Core Problems and Modeling Choices**](#-ä¸€æ ¸å¿ƒé—®é¢˜ä¸å»ºæ¨¡é€‰æ‹©--part-1-core-problems-and-modeling-choices)
    - [1.1 æ ¸å¿ƒé—®é¢˜çŸ©é˜µ](#11-æ ¸å¿ƒé—®é¢˜çŸ©é˜µ)
    - [1.2 å»ºæ¨¡é€‰æ‹©æŒ‡å—](#12-å»ºæ¨¡é€‰æ‹©æŒ‡å—)
  - [ğŸ”§ **äºŒã€ç†è®ºåº”ç”¨æ¨¡å¼ / Part 2: Theory Application Patterns**](#-äºŒç†è®ºåº”ç”¨æ¨¡å¼--part-2-theory-application-patterns)
    - [2.1 Petriç½‘åº”ç”¨æ¨¡å¼](#21-petriç½‘åº”ç”¨æ¨¡å¼)
      - [æ¨¡å¼1ï¼šå…±è¯†åè®®éªŒè¯](#æ¨¡å¼1å…±è¯†åè®®éªŒè¯)
      - [æ¨¡å¼2ï¼šæ™ºèƒ½åˆçº¦éªŒè¯](#æ¨¡å¼2æ™ºèƒ½åˆçº¦éªŒè¯)
      - [æ¨¡å¼3ï¼šé‡å…¥æ”»å‡»æ£€æµ‹](#æ¨¡å¼3é‡å…¥æ”»å‡»æ£€æµ‹)
    - [2.2 åŠ¨æ€å›¾è®ºåº”ç”¨æ¨¡å¼](#22-åŠ¨æ€å›¾è®ºåº”ç”¨æ¨¡å¼)
      - [æ¨¡å¼1ï¼šäº¤æ˜“ç½‘ç»œåˆ†æ](#æ¨¡å¼1äº¤æ˜“ç½‘ç»œåˆ†æ)
      - [æ¨¡å¼2ï¼šDeFiåè®®ç½‘ç»œ](#æ¨¡å¼2defiåè®®ç½‘ç»œ)
      - [æ¨¡å¼3ï¼šæ´—é’±è¿½è¸ª](#æ¨¡å¼3æ´—é’±è¿½è¸ª)
    - [2.3 æ‹“æ‰‘æ¨¡å‹åº”ç”¨æ¨¡å¼](#23-æ‹“æ‰‘æ¨¡å‹åº”ç”¨æ¨¡å¼)
      - [æ¨¡å¼1ï¼šäº¤æ˜“å¼‚å¸¸æ£€æµ‹](#æ¨¡å¼1äº¤æ˜“å¼‚å¸¸æ£€æµ‹)
      - [æ¨¡å¼2ï¼šç½‘ç»œæ‹“æ‰‘ç¨³å®šæ€§](#æ¨¡å¼2ç½‘ç»œæ‹“æ‰‘ç¨³å®šæ€§)
  - [ğŸ“Š **ä¸‰ã€å†³ç­–æ ‘ / Part 3: Decision Tree**](#-ä¸‰å†³ç­–æ ‘--part-3-decision-tree)
    - [3.1 ç®€åŒ–åˆ¤å®šæµç¨‹](#31-ç®€åŒ–åˆ¤å®šæµç¨‹)
    - [3.2 æ–‡æœ¬å†³ç­–æ ‘](#32-æ–‡æœ¬å†³ç­–æ ‘)
    - [3.3 Mermaidå†³ç­–æ ‘](#33-mermaidå†³ç­–æ ‘)
  - [ğŸ“š **å››ã€å…¸å‹æ¡ˆä¾‹ / Part 4: Typical Cases**](#-å››å…¸å‹æ¡ˆä¾‹--part-4-typical-cases)
    - [æ¡ˆä¾‹1ï¼šPBFTå…±è¯†åè®®éªŒè¯](#æ¡ˆä¾‹1pbftå…±è¯†åè®®éªŒè¯)
    - [æ¡ˆä¾‹2ï¼šä»¥å¤ªåŠäº¤æ˜“ç½‘ç»œåˆ†æ](#æ¡ˆä¾‹2ä»¥å¤ªåŠäº¤æ˜“ç½‘ç»œåˆ†æ)
    - [æ¡ˆä¾‹3ï¼šæ™ºèƒ½åˆçº¦é‡å…¥æ”»å‡»æ£€æµ‹](#æ¡ˆä¾‹3æ™ºèƒ½åˆçº¦é‡å…¥æ”»å‡»æ£€æµ‹)
    - [æ¡ˆä¾‹4ï¼šNFTäº¤æ˜“ç½‘ç»œåˆ†æ](#æ¡ˆä¾‹4nftäº¤æ˜“ç½‘ç»œåˆ†æ)
    - [æ¡ˆä¾‹5ï¼šè·¨é“¾æ¡¥å®‰å…¨éªŒè¯](#æ¡ˆä¾‹5è·¨é“¾æ¡¥å®‰å…¨éªŒè¯)
  - [ğŸ› ï¸ **äº”ã€å·¥å…·æ ˆ / Part 5: Tool Stack**](#ï¸-äº”å·¥å…·æ ˆ--part-5-tool-stack)
    - [5.1 Petriç½‘ä¸å½¢å¼åŒ–éªŒè¯å·¥å…·](#51-petriç½‘ä¸å½¢å¼åŒ–éªŒè¯å·¥å…·)
    - [5.2 æ™ºèƒ½åˆçº¦åˆ†æå·¥å…·](#52-æ™ºèƒ½åˆçº¦åˆ†æå·¥å…·)
    - [5.3 åŠ¨æ€å›¾è®ºå·¥å…·](#53-åŠ¨æ€å›¾è®ºå·¥å…·)
    - [5.4 æ‹“æ‰‘åˆ†æå·¥å…·](#54-æ‹“æ‰‘åˆ†æå·¥å…·)
    - [5.5 åŒºå—é“¾æ•°æ®å·¥å…·](#55-åŒºå—é“¾æ•°æ®å·¥å…·)
  - [ğŸ“‹ **å…­ã€äº¤ä»˜ç‰© / Part 6: Deliverables**](#-å…­äº¤ä»˜ç‰©--part-6-deliverables)
    - [6.1 æ–‡æ¡£äº¤ä»˜ç‰©](#61-æ–‡æ¡£äº¤ä»˜ç‰©)
    - [6.2 å…·ä½“ä»£ç ç¤ºä¾‹](#62-å…·ä½“ä»£ç ç¤ºä¾‹)
    - [6.3 åç»­è®¡åˆ’](#63-åç»­è®¡åˆ’)

---

## ğŸ¯ **ä¸€ã€æ ¸å¿ƒé—®é¢˜ä¸å»ºæ¨¡é€‰æ‹© / Part 1: Core Problems and Modeling Choices**

### 1.1 æ ¸å¿ƒé—®é¢˜çŸ©é˜µ

| é—®é¢˜åŸŸ | å­é—®é¢˜ | æ¨èç†è®º | ç†ç”± |
|--------|--------|----------|------|
| **å…±è¯†åè®®** | å®‰å…¨æ€§éªŒè¯ | Petriç½‘ | å½¢å¼åŒ–éªŒè¯çŠ¶æ€è½¬æ¢ |
| | æ´»æ€§éªŒè¯ | Petriç½‘ | è¯æ˜åè®®ç»ˆæ­¢æ€§ |
| | åˆ†å‰åˆ†æ | åŠ¨æ€å›¾è®º | è¿½è¸ªé“¾ç»“æ„æ¼”åŒ– |
| **æ™ºèƒ½åˆçº¦** | çŠ¶æ€æœºéªŒè¯ | Petriç½‘ | å½¢å¼åŒ–éªŒè¯åˆçº¦çŠ¶æ€ |
| | é‡å…¥æ”»å‡»æ£€æµ‹ | Petriç½‘ | å¯è¾¾æ€§åˆ†æ |
| | è°ƒç”¨ä¾èµ– | åŠ¨æ€å›¾è®º | åˆçº¦é—´è°ƒç”¨å…³ç³» |
| **äº¤æ˜“ç½‘ç»œ** | äº¤æ˜“æ¨¡å¼ | åŠ¨æ€å›¾è®º | å¤§è§„æ¨¡äº¤æ˜“å›¾åˆ†æ |
| | å¼‚å¸¸æ£€æµ‹ | æ‹“æ‰‘æ¨¡å‹ | æ£€æµ‹äº¤æ˜“åˆ†å¸ƒå½¢çŠ¶ |
| | æ´—é’±è¿½è¸ª | åŠ¨æ€å›¾è®º | èµ„é‡‘æµè¿½è¸ª |
| **DeFiåè®®** | æµåŠ¨æ€§åˆ†æ | åŠ¨æ€å›¾è®º | èµ„é‡‘æ± ç½‘ç»œåˆ†æ |
| | åè®®å®‰å…¨ | Petriç½‘ | å½¢å¼åŒ–éªŒè¯åè®® |
| | MEVåˆ†æ | åŠ¨æ€å›¾è®º | å¥—åˆ©è·¯å¾„åˆ†æ |

### 1.2 å»ºæ¨¡é€‰æ‹©æŒ‡å—

**é€‰æ‹©Petriç½‘å½“**:

- éœ€è¦å½¢å¼åŒ–éªŒè¯å…±è¯†åè®®çš„å®‰å…¨æ€§/æ´»æ€§
- éœ€è¦éªŒè¯æ™ºèƒ½åˆçº¦çš„çŠ¶æ€æœºæ­£ç¡®æ€§
- éœ€è¦æ£€æµ‹é‡å…¥æ”»å‡»ç­‰å®‰å…¨æ¼æ´

**é€‰æ‹©åŠ¨æ€å›¾è®ºå½“**:

- éœ€è¦åˆ†æå¤§è§„æ¨¡äº¤æ˜“ç½‘ç»œï¼ˆ>10^6äº¤æ˜“ï¼‰
- éœ€è¦è¿½è¸ªèµ„é‡‘æµå’Œæ´—é’±è¡Œä¸º
- éœ€è¦åˆ†æDeFiåè®®é—´çš„ä¾èµ–å…³ç³»

**é€‰æ‹©æ‹“æ‰‘æ¨¡å‹å½“**:

- éœ€è¦æ£€æµ‹äº¤æ˜“æ¨¡å¼çš„å¼‚å¸¸å½¢çŠ¶
- éœ€è¦åˆ†æåŒºå—é“¾ç½‘ç»œçš„æ‹“æ‰‘ç¨³å®šæ€§
- éœ€è¦æ£€æµ‹Sybilæ”»å‡»ç­‰ç½‘ç»œå¼‚å¸¸

---

## ğŸ”§ **äºŒã€ç†è®ºåº”ç”¨æ¨¡å¼ / Part 2: Theory Application Patterns**

### 2.1 Petriç½‘åº”ç”¨æ¨¡å¼

#### æ¨¡å¼1ï¼šå…±è¯†åè®®éªŒè¯

```text
å…±è¯†åè®®ï¼ˆå¦‚PBFT/Raft/PoSï¼‰ â†’ Petriç½‘å»ºæ¨¡
           â†“
    åº“æ‰€: åè®®çŠ¶æ€ï¼ˆå‡†å¤‡/é¢„æäº¤/æäº¤/ç¡®è®¤ï¼‰
    å˜è¿: åè®®åŠ¨ä½œï¼ˆææ¡ˆ/æŠ•ç¥¨/ç¡®è®¤ï¼‰
    ä»¤ç‰Œ: æ¶ˆæ¯/ç­¾å/åŒºå—
           â†“
    åˆ†æ: å®‰å…¨æ€§ï¼ˆæ— åˆ†å‰è¾¾æˆï¼‰
          æ´»æ€§ï¼ˆæœ€ç»ˆç¡®è®¤ï¼‰
          æ‹œå åº­å®¹é”™ï¼ˆf < n/3ï¼‰
```

#### æ¨¡å¼2ï¼šæ™ºèƒ½åˆçº¦éªŒè¯

```text
æ™ºèƒ½åˆçº¦ä»£ç  â†’ Petriç½‘å»ºæ¨¡
           â†“
    åº“æ‰€: åˆçº¦çŠ¶æ€ï¼ˆä½™é¢/æ‰€æœ‰æƒ/é”å®šï¼‰
    å˜è¿: å‡½æ•°è°ƒç”¨ï¼ˆtransfer/approve/withdrawï¼‰
    ä»¤ç‰Œ: ä»£å¸/æƒé™/çŠ¶æ€æ ‡å¿—
           â†“
    åˆ†æ: å¯è¾¾æ€§ï¼ˆæ˜¯å¦å¯è¾¾éæ³•çŠ¶æ€ï¼‰
          ä¸å˜é‡ï¼ˆä½™é¢å®ˆæ’ï¼‰
          æ­»é”ï¼ˆåˆçº¦æ˜¯å¦å¯èƒ½å¡ä½ï¼‰
```

#### æ¨¡å¼3ï¼šé‡å…¥æ”»å‡»æ£€æµ‹

```text
åˆçº¦è°ƒç”¨åºåˆ— â†’ Petriç½‘å»ºæ¨¡
           â†“
    åº“æ‰€: è°ƒç”¨æ ˆçŠ¶æ€ã€ä½™é¢çŠ¶æ€
    å˜è¿: å¤–éƒ¨è°ƒç”¨ã€çŠ¶æ€æ›´æ–°
    ä»¤ç‰Œ: æ‰§è¡Œæ§åˆ¶ã€èµ„é‡‘
           â†“
    åˆ†æ: å¯è¾¾æ€§ï¼ˆæ£€æµ‹é‡å…¥å¯è¾¾çŠ¶æ€ï¼‰
          æ—¶åºï¼ˆæ£€éªŒå…ˆæ›´æ–°åè°ƒç”¨ï¼‰
          ä¸å˜é‡ï¼ˆè°ƒç”¨å‰åä½™é¢å®ˆæ’ï¼‰
```

### 2.2 åŠ¨æ€å›¾è®ºåº”ç”¨æ¨¡å¼

#### æ¨¡å¼1ï¼šäº¤æ˜“ç½‘ç»œåˆ†æ

```text
äº¤æ˜“æ•°æ® â†’ åŠ¨æ€å›¾æ„å»º
           â†“
    èŠ‚ç‚¹: åœ°å€ï¼ˆEOA/åˆçº¦ï¼‰
    è¾¹: äº¤æ˜“ï¼ˆå¸¦æ—¶é—´æˆ³ã€é‡‘é¢ã€gasï¼‰
    å±æ€§: äº¤æ˜“ç±»å‹ã€åˆçº¦æ–¹æ³•
           â†“
    åˆ†æ: ä¸­å¿ƒæ€§æ¼”åŒ–ï¼ˆå¤§æˆ·åœ°å€è¯†åˆ«ï¼‰
          ç¤¾åŒºæ£€æµ‹ï¼ˆäº¤æ˜“æ‰€/çŸ¿æ± èšç±»ï¼‰
          è·¯å¾„åˆ†æï¼ˆèµ„é‡‘æµè¿½è¸ªï¼‰
```

#### æ¨¡å¼2ï¼šDeFiåè®®ç½‘ç»œ

```text
DeFiäº¤äº’æ•°æ® â†’ åŠ¨æ€å›¾æ„å»º
           â†“
    èŠ‚ç‚¹: åè®®/èµ„é‡‘æ± /ç”¨æˆ·
    è¾¹: äº¤äº’ï¼ˆswap/stake/borrowï¼‰
    å±æ€§: TVLã€APYã€åˆ©ç”¨ç‡
           â†“
    åˆ†æ: ä¾èµ–åˆ†æï¼ˆåè®®é—´ä¾èµ–ï¼‰
          é£é™©ä¼ æ’­ï¼ˆçº§è”æ¸…ç®—ï¼‰
          å¥—åˆ©è·¯å¾„ï¼ˆMEVæœºä¼šï¼‰
```

#### æ¨¡å¼3ï¼šæ´—é’±è¿½è¸ª

```text
å¯ç–‘äº¤æ˜“ â†’ åŠ¨æ€å›¾æ„å»º
           â†“
    èŠ‚ç‚¹: åœ°å€
    è¾¹: è½¬è´¦ï¼ˆå¸¦é‡‘é¢ã€æ—¶é—´ï¼‰
    å±æ€§: æ ‡ç­¾ï¼ˆäº¤æ˜“æ‰€/mixer/å·²çŸ¥æ¶æ„ï¼‰
           â†“
    åˆ†æ: è·¯å¾„è¿½è¸ªï¼ˆä»æºåˆ°æ±‡ï¼‰
          æ··å¸æ¨¡å¼ï¼ˆç¯çŠ¶/åˆ†æ•£/èšåˆï¼‰
          æ—¶é—´ç›¸å…³æ€§ï¼ˆåè°ƒè½¬è´¦ï¼‰
```

### 2.3 æ‹“æ‰‘æ¨¡å‹åº”ç”¨æ¨¡å¼

#### æ¨¡å¼1ï¼šäº¤æ˜“å¼‚å¸¸æ£€æµ‹

```text
äº¤æ˜“ç‰¹å¾å‘é‡ â†’ ç‚¹äº‘æ„å»º
               â†“
    è¿‡æ»¤: Ripså¤å½¢
    æŒä¹…åŒè°ƒ: è´è’‚æ•°æ¼”åŒ–
               â†“
    åˆ†æ: Î²â‚€å˜åŒ–ï¼ˆæ–°èšç±»å‡ºç°ï¼‰
          Î²â‚å˜åŒ–ï¼ˆå¾ªç¯äº¤æ˜“æ¨¡å¼ï¼‰
          æŒä¹…å›¾åŒ¹é…ï¼ˆå¼‚å¸¸æ¨¡å¼è¯†åˆ«ï¼‰
```

#### æ¨¡å¼2ï¼šç½‘ç»œæ‹“æ‰‘ç¨³å®šæ€§

```text
åŒºå—é“¾P2Pç½‘ç»œ â†’ æ‹“æ‰‘ç©ºé—´æ„å»º
               â†“
    Mapper: èŠ‚ç‚¹è¿æ¥æ€§é™ç»´
    æŒä¹…åŒè°ƒ: æ‹“æ‰‘ç‰¹å¾æå–
               â†“
    åˆ†æ: ç»“æ„æ´ï¼ˆç½‘ç»œè„†å¼±ç‚¹ï¼‰
          è¿é€šæ€§ï¼ˆåˆ†åŒºå®¹é”™ï¼‰
          å½¢çŠ¶æ¼”åŒ–ï¼ˆSybilæ”»å‡»æ£€æµ‹ï¼‰
```

---

## ğŸ“Š **ä¸‰ã€å†³ç­–æ ‘ / Part 3: Decision Tree**

### 3.1 ç®€åŒ–åˆ¤å®šæµç¨‹

```text
é—®é¢˜ç±»å‹ â†’ æ•°æ®è§„æ¨¡ â†’ åˆ†æéœ€æ±‚ â†’ ç†è®ºé€‰æ‹©
```

### 3.2 æ–‡æœ¬å†³ç­–æ ‘

```text
å¼€å§‹
â”œâ”€â”€ éœ€è¦å½¢å¼åŒ–å®‰å…¨è¯æ˜ï¼Ÿ
â”‚   â”œâ”€â”€ æ˜¯ â†’ Petriç½‘
â”‚   â”‚   â”œâ”€â”€ å…±è¯†éªŒè¯ â†’ å®‰å…¨æ€§/æ´»æ€§åˆ†æ
â”‚   â”‚   â”œâ”€â”€ åˆçº¦éªŒè¯ â†’ çŠ¶æ€æœº/ä¸å˜é‡åˆ†æ
â”‚   â”‚   â””â”€â”€ æ¼æ´æ£€æµ‹ â†’ å¯è¾¾æ€§åˆ†æ
â”‚   â””â”€â”€ å¦ â†“
â”œâ”€â”€ å¤§è§„æ¨¡äº¤æ˜“åˆ†æï¼ˆ>10^6ï¼‰ï¼Ÿ
â”‚   â”œâ”€â”€ æ˜¯ â†’ åŠ¨æ€å›¾è®º
â”‚   â”‚   â”œâ”€â”€ äº¤æ˜“åˆ†æ â†’ å¢é‡å›¾ç®—æ³•
â”‚   â”‚   â”œâ”€â”€ èµ„é‡‘è¿½è¸ª â†’ è·¯å¾„/ç¤¾åŒºåˆ†æ
â”‚   â”‚   â””â”€â”€ DeFiåˆ†æ â†’ ç½‘ç»œæ¼”åŒ–åˆ†æ
â”‚   â””â”€â”€ å¦ â†“
â”œâ”€â”€ æ•°æ®å½¢æ€ï¼Ÿ
â”‚   â”œâ”€â”€ åè®®è§„èŒƒ/åˆçº¦ä»£ç  â†’ Petriç½‘
â”‚   â”œâ”€â”€ äº¤æ˜“è®°å½•/è°ƒç”¨æ—¥å¿— â†’ åŠ¨æ€å›¾è®º
â”‚   â””â”€â”€ ç‰¹å¾å‘é‡/ç½‘ç»œçŠ¶æ€ â†’ æ‹“æ‰‘æ¨¡å‹
â””â”€â”€ åˆ†æç›®æ ‡ï¼Ÿ
    â”œâ”€â”€ å¯è¯æ˜çš„æ­£ç¡®æ€§ â†’ Petriç½‘
    â”œâ”€â”€ å¯è§‚å¯Ÿçš„æ¼”åŒ– â†’ åŠ¨æ€å›¾è®º
    â””â”€â”€ å¯è§†åŒ–çš„å½¢çŠ¶ â†’ æ‹“æ‰‘æ¨¡å‹
```

### 3.3 Mermaidå†³ç­–æ ‘

```mermaid
graph TD
    A[å¼€å§‹: åŒºå—é“¾å»ºæ¨¡] --> B{éœ€è¦å½¢å¼åŒ–å®‰å…¨è¯æ˜?}
    B -- æ˜¯ --> C[é€‰æ‹©: Petriç½‘]
    C --> C1(åˆ†æ: çŠ¶æ€æœº/å¯è¾¾æ€§/ä¸å˜é‡)
    C --> C2(å·¥å…·: CPN Tools/TLA+/Spin/Move Prover)
    B -- å¦ --> D{å¤§è§„æ¨¡äº¤æ˜“åˆ†æ >10^6?}
    D -- æ˜¯ --> E[é€‰æ‹©: åŠ¨æ€å›¾è®º]
    E --> E1(åˆ†æ: å¢é‡ç®—æ³•/è·¯å¾„è¿½è¸ª/ç¤¾åŒºæ£€æµ‹)
    E --> E2(å·¥å…·: NetworkX/Neo4j/GraphX/Dune)
    D -- å¦ --> F{æ•°æ®å½¢æ€?}
    F -- åè®®è§„èŒƒ/åˆçº¦ä»£ç  --> C
    F -- äº¤æ˜“è®°å½•/è°ƒç”¨é“¾ --> E
    F -- ç‰¹å¾å‘é‡/ç½‘ç»œçŠ¶æ€ --> G[é€‰æ‹©: æ‹“æ‰‘æ¨¡å‹(TDA)]
    G --> G1(åˆ†æ: æŒä¹…åŒè°ƒ/Mapper)
    G --> G2(å·¥å…·: GUDHI/Ripser/KeplerMapper)
    G --> H{å…³å¿ƒå¼‚å¸¸å½¢çŠ¶/ç½‘ç»œæ‹“æ‰‘?}
    H -- æ˜¯ --> G
    H -- å¦ --> I[è€ƒè™‘: Petriç½‘/åŠ¨æ€å›¾è®º]
    I --> J{è¾“å‡ºéœ€æ±‚?}
    J -- å¯è¯æ˜ --> C
    J -- å¯è§‚å¯Ÿ --> E
    J -- å¯è§†åŒ– --> G
```

---

## ğŸ“š **å››ã€å…¸å‹æ¡ˆä¾‹ / Part 4: Typical Cases**

### æ¡ˆä¾‹1ï¼šPBFTå…±è¯†åè®®éªŒè¯

**åœºæ™¯**: éªŒè¯è®¸å¯é“¾PBFTå…±è¯†åè®®çš„å®‰å…¨æ€§å’Œæ´»æ€§

**å»ºæ¨¡é€‰æ‹©**: Petriç½‘

**å®ç°æ–¹æ¡ˆ**:

```text
æ­¥éª¤1: PBFTåè®®å»ºæ¨¡
    åº“æ‰€:
    - Pre-prepare, Prepare, Commit, Reply
    - æ¯ä¸ªèŠ‚ç‚¹çš„çŠ¶æ€ï¼ˆæ­£å¸¸/æ‹œå åº­ï¼‰
    å˜è¿:
    - å‘é€Pre-prepare, æ”¶é›†Prepare, å‘é€Commit
    - è¾¾æˆå…±è¯†, å›å¤å®¢æˆ·ç«¯

æ­¥éª¤2: å®‰å…¨æ€§è´¨å®šä¹‰
    - ä¸€è‡´æ€§: è¯šå®èŠ‚ç‚¹æœ€ç»ˆåŒæ„ç›¸åŒå€¼
    - ç»ˆæ­¢æ€§: åè®®æœ€ç»ˆå®Œæˆ
    - æ‹œå åº­å®¹é”™: f < n/3æ—¶ä¿æŒå®‰å…¨

æ­¥éª¤3: å½¢å¼åŒ–éªŒè¯
    - æ„å»ºå¯è¾¾å›¾
    - æ£€éªŒæ‰€æœ‰å¯è¾¾çŠ¶æ€æ»¡è¶³ä¸€è‡´æ€§
    - æ¨¡æ‹Ÿæ‹œå åº­è¡Œä¸ºï¼ŒéªŒè¯å®¹é”™æ€§

æ­¥éª¤4: æ¼æ´åˆ†æ
    - æ£€æŸ¥æ˜¯å¦å­˜åœ¨æ­»é”
    - éªŒè¯è§†å›¾åˆ‡æ¢çš„æ­£ç¡®æ€§
    - ç¡®è®¤æ¶ˆæ¯é‡æ”¾ä¸å½±å“å®‰å…¨
```

**å·¥å…·ç»„åˆ**: CPN Tools / TLA+ / Ivy

**å…³é”®ä»£ç ç¤ºä¾‹**:

```tla
// TLA+: PBFTä¸€è‡´æ€§éªŒè¯
ConsistencyProperty ==
    \A s \in ReachableStates :
        \A n1, n2 \in HonestNodes :
            /\ Committed(n1, s) /\ Committed(n2, s)
            => Value(n1, s) = Value(n2, s)  // ä¸€è‡´æ€§

ByzantineFaultTolerance ==
    \A s \in ReachableStates :
        /\ Cardinality(ByzantineNodes) < Cardinality(Nodes) / 3
        => ConsistencyProperty  // æ‹œå åº­å®¹é”™
```

### æ¡ˆä¾‹2ï¼šä»¥å¤ªåŠäº¤æ˜“ç½‘ç»œåˆ†æ

**åœºæ™¯**: åˆ†æä»¥å¤ªåŠäº¤æ˜“ç½‘ç»œï¼Œè¯†åˆ«å¤§æˆ·å’Œäº¤æ˜“æ¨¡å¼

**å»ºæ¨¡é€‰æ‹©**: åŠ¨æ€å›¾è®º

**å®ç°æ–¹æ¡ˆ**:

```text
æ­¥éª¤1: åŠ¨æ€å›¾æ„å»º
    - æ•°æ®æº: Ethereum ETLå¯¼å‡º
    - èŠ‚ç‚¹: åœ°å€ï¼ˆæ ‡ç­¾: EOA/åˆçº¦/äº¤æ˜“æ‰€ï¼‰
    - è¾¹: äº¤æ˜“ï¼ˆæ—¶é—´æˆ³ã€é‡‘é¢ã€gasã€æ–¹æ³•ï¼‰
    - æ›´æ–°: æ¯æ—¥å¢é‡æ„å»º

æ­¥éª¤2: ä¸­å¿ƒæ€§åˆ†æ
    - åº¦ä¸­å¿ƒæ€§: äº¤æ˜“é¢‘ç¹åœ°å€
    - PageRank: é‡è¦èŠ‚ç‚¹
    - ä»‹æ•°ä¸­å¿ƒæ€§: èµ„é‡‘ä¸­è½¬ç«™

æ­¥éª¤3: ç¤¾åŒºæ£€æµ‹
    - Louvainç®—æ³•: äº¤æ˜“èšç±»
    - æ ‡ç­¾ä¼ æ’­: äº¤æ˜“æ‰€/çŸ¿æ± è¯†åˆ«
    - æ—¶åºç¤¾åŒº: è¿½è¸ªèšç±»æ¼”åŒ–

æ­¥éª¤4: å¼‚å¸¸æ£€æµ‹
    - çªå‘é«˜ä¸­å¿ƒæ€§: æ–°å…´å¤§æˆ·
    - ç¤¾åŒºç»“æ„å˜åŒ–: æ–°åè®®ä¸Šçº¿
    - è·¯å¾„å¼‚å¸¸: æ´—é’±è¡Œä¸º
```

**å·¥å…·ç»„åˆ**: Ethereum ETL + Neo4j + NetworkX + Dune Analytics

**å…³é”®ä»£ç ç¤ºä¾‹**:

```python
# NetworkX: ä»¥å¤ªåŠäº¤æ˜“ç½‘ç»œåˆ†æ
import networkx as nx
from collections import defaultdict

class EthereumTransactionGraph:
    def __init__(self):
        self.graph = nx.DiGraph()
        self.address_labels = {}

    def add_transaction(self, from_addr: str, to_addr: str,
                       value: float, timestamp, gas: int):
        """æ·»åŠ äº¤æ˜“"""
        self.graph.add_node(from_addr, type='address')
        self.graph.add_node(to_addr, type='address')

        if self.graph.has_edge(from_addr, to_addr):
            edge_data = self.graph[from_addr][to_addr]
            edge_data['count'] = edge_data.get('count', 0) + 1
            edge_data['total_value'] = edge_data.get('total_value', 0) + value
        else:
            self.graph.add_edge(from_addr, to_addr,
                               count=1, total_value=value,
                               timestamp=timestamp, gas=gas)

    def identify_whales(self, threshold: float = 1000.0) -> list:
        """è¯†åˆ«å¤§æˆ·ï¼ˆé«˜ä»·å€¼äº¤æ˜“ï¼‰"""
        whales = []

        for node in self.graph.nodes():
            # è®¡ç®—æ€»äº¤æ˜“ä»·å€¼
            total_out = sum(
                self.graph[node][neighbor].get('total_value', 0)
                for neighbor in self.graph.successors(node)
            )
            total_in = sum(
                self.graph[predecessor][node].get('total_value', 0)
                for predecessor in self.graph.predecessors(node)
            )

            if total_out + total_in > threshold:
                whales.append({
                    'address': node,
                    'total_out': total_out,
                    'total_in': total_in,
                    'net_flow': total_in - total_out
                })

        return sorted(whales, key=lambda x: x['total_out'] + x['total_in'], reverse=True)

    def detect_exchange_patterns(self) -> list:
        """æ£€æµ‹äº¤æ˜“æ‰€æ¨¡å¼ï¼ˆé«˜é¢‘ç‡ã€å¤šå¯¹å¤šäº¤æ˜“ï¼‰"""
        exchanges = []

        for node in self.graph.nodes():
            in_degree = self.graph.in_degree(node)
            out_degree = self.graph.out_degree(node)

            # äº¤æ˜“æ‰€ç‰¹å¾ï¼šé«˜å…¥åº¦ã€é«˜å‡ºåº¦ã€äº¤æ˜“é¢‘ç¹
            if in_degree > 100 and out_degree > 100:
                total_transactions = sum(
                    self.graph[predecessor][node].get('count', 0)
                    for predecessor in self.graph.predecessors(node)
                )

                exchanges.append({
                    'address': node,
                    'in_degree': in_degree,
                    'out_degree': out_degree,
                    'transaction_count': total_transactions
                })

        return sorted(exchanges, key=lambda x: x['transaction_count'], reverse=True)
```

```python
# Graph Transformer: åŒºå—é“¾äº¤æ˜“å¼‚å¸¸æ£€æµ‹ï¼ˆ2025æœ€æ–°æ–¹æ³•ï¼‰
import torch
import torch.nn as nn

class BlockchainAnomalyDetectorGT(nn.Module):
    """åŸºäºGraph Transformerçš„åŒºå—é“¾äº¤æ˜“å¼‚å¸¸æ£€æµ‹å™¨"""

    def __init__(self, d_model=128, nhead=8, num_layers=3):
        super().__init__()
        self.transformer_layers = nn.ModuleList([
            nn.TransformerEncoderLayer(d_model, nhead, dim_feedforward=512)
            for _ in range(num_layers)
        ])

        # å¼‚å¸¸æ£€æµ‹å¤´
        self.anomaly_head = nn.Sequential(
            nn.Linear(d_model, d_model // 2),
            nn.ReLU(),
            nn.Linear(d_model // 2, 1),
            nn.Sigmoid()
        )

    def forward(self, transaction_graph, address_features):
        """
        å‰å‘ä¼ æ’­
        transaction_graph: NetworkXå›¾ï¼ŒåŒ…å«åœ°å€èŠ‚ç‚¹å’Œäº¤æ˜“è¾¹
        address_features: åœ°å€ç‰¹å¾ï¼ˆä½™é¢ã€äº¤æ˜“æ¬¡æ•°ã€gasä½¿ç”¨ç­‰ï¼‰
        """
        # èŠ‚ç‚¹ç‰¹å¾ç¼–ç 
        node_ids = list(transaction_graph.nodes())
        x = torch.tensor([address_features.get(nid, [0, 0, 0]) for nid in node_ids])

        # Graph Transformerå±‚
        for layer in self.transformer_layers:
            x = layer(x)

        # å¼‚å¸¸æ£€æµ‹
        anomaly_scores = self.anomaly_head(x)

        return anomaly_scores
```

```python
# Petri Graph Neural Networks: æ™ºèƒ½åˆçº¦å®‰å…¨åˆ†æï¼ˆ2025æœ€æ–°æ–¹æ³•ï¼‰
import torch
import torch.nn as nn
import networkx as nx

class SmartContractSecurityAnalyzerPGNN(nn.Module):
    """åŸºäºPGNNçš„æ™ºèƒ½åˆçº¦å®‰å…¨åˆ†æå™¨"""

    def __init__(self, num_states, num_operations, hidden_dim=128):
        super().__init__()
        self.state_embedding = nn.Embedding(num_states, hidden_dim)
        self.operation_embedding = nn.Embedding(num_operations, hidden_dim)

        # PGNNä¼ æ’­å±‚ï¼ˆåŸºäºPetriç½‘æµçº¦æŸï¼‰
        self.propagation_layers = nn.ModuleList([
            nn.Linear(hidden_dim, hidden_dim) for _ in range(3)
        ])

        # å®‰å…¨æ¼æ´æ£€æµ‹å¤´
        self.vulnerability_head = nn.Sequential(
            nn.Linear(hidden_dim, hidden_dim // 2),
            nn.ReLU(),
            nn.Linear(hidden_dim // 2, 5),  # 5ç§å¸¸è§æ¼æ´ç±»å‹
            nn.Sigmoid()
        )

    def forward(self, contract_petri_net, state_features):
        """
        å‰å‘ä¼ æ’­
        contract_petri_net: NetworkXå›¾ï¼ŒåŒ…å«stateï¼ˆåº“æ‰€ï¼‰å’Œoperationï¼ˆå˜è¿ï¼‰èŠ‚ç‚¹
        state_features: çŠ¶æ€ç‰¹å¾ï¼ˆä½™é¢ã€æƒé™ã€é”å®šçŠ¶æ€ç­‰ï¼‰
        """
        # åˆå§‹åŒ–åµŒå…¥
        embeddings = {}
        for node in contract_petri_net.nodes():
            if contract_petri_net.nodes[node]['type'] == 'state':
                node_idx = contract_petri_net.nodes[node]['index']
                embeddings[node] = self.state_embedding(node_idx) + state_features[node_idx]
            else:
                node_idx = contract_petri_net.nodes[node]['index']
                embeddings[node] = self.operation_embedding(node_idx)

        # å¤šæ¨¡æ€ä¿¡æ¯ä¼ æ’­ï¼ˆåŸºäºPetriç½‘æµçº¦æŸï¼‰
        for layer in self.propagation_layers:
            new_embeddings = {}
            for node in contract_petri_net.nodes():
                # èšåˆè¾“å…¥è¾¹ï¼ˆå‰é©±èŠ‚ç‚¹ï¼‰
                input_embeddings = []
                for predecessor in contract_petri_net.predecessors(node):
                    input_embeddings.append(embeddings[predecessor])

                # èšåˆè¾“å‡ºè¾¹ï¼ˆåç»§èŠ‚ç‚¹ï¼‰
                output_embeddings = []
                for successor in contract_petri_net.successors(node):
                    output_embeddings.append(embeddings[successor])

                # åŸºäºPetriç½‘æµçº¦æŸçš„ä¿¡æ¯ä¼ æ’­
                if input_embeddings and output_embeddings:
                    input_agg = torch.stack(input_embeddings).mean(dim=0)
                    output_agg = torch.stack(output_embeddings).mean(dim=0)
                    # æµå®ˆæ’çº¦æŸ
                    flow_constrained = input_agg + output_agg
                    new_embeddings[node] = layer(flow_constrained)
                elif input_embeddings:
                    new_embeddings[node] = layer(torch.stack(input_embeddings).mean(dim=0))
                elif output_embeddings:
                    new_embeddings[node] = layer(torch.stack(output_embeddings).mean(dim=0))
                else:
                    new_embeddings[node] = embeddings[node]

            embeddings = new_embeddings

        # æ¼æ´æ£€æµ‹ï¼ˆåŸºäºçŠ¶æ€ï¼‰
        state_embeddings = [embeddings[n] for n in contract_petri_net.nodes()
                           if contract_petri_net.nodes[n]['type'] == 'state']
        if state_embeddings:
            global_state = torch.stack(state_embeddings).mean(dim=0)
            vulnerability_scores = self.vulnerability_head(global_state)
            return vulnerability_scores  # [é‡å…¥æ”»å‡», æ•´æ•°æº¢å‡º, æƒé™æ§åˆ¶, æ‹’ç»æœåŠ¡, å…¶ä»–]

        return torch.tensor([0.0] * 5)
```

### æ¡ˆä¾‹3ï¼šæ™ºèƒ½åˆçº¦é‡å…¥æ”»å‡»æ£€æµ‹

**åœºæ™¯**: æ£€æµ‹DeFiåè®®ä¸­çš„é‡å…¥æ¼æ´

**å»ºæ¨¡é€‰æ‹©**: Petriç½‘

**å®ç°æ–¹æ¡ˆ**:

```text
æ­¥éª¤1: åˆçº¦å»ºæ¨¡
    åº“æ‰€:
    - ç”¨æˆ·ä½™é¢ã€åˆçº¦çŠ¶æ€ã€æ‰§è¡Œç‚¹
    å˜è¿:
    - withdraw()è°ƒç”¨ã€å¤–éƒ¨è°ƒç”¨ã€çŠ¶æ€æ›´æ–°

æ­¥éª¤2: é‡å…¥æ¨¡å¼å»ºæ¨¡
    - æ”»å‡»è€…åˆçº¦çš„fallbackå‡½æ•°
    - é€’å½’è°ƒç”¨withdraw()
    - çŠ¶æ€æ›´æ–°å»¶è¿Ÿ

æ­¥éª¤3: å¯è¾¾æ€§åˆ†æ
    - æ£€æŸ¥æ˜¯å¦å¯è¾¾"å¤šæ¬¡æå–"çŠ¶æ€
    - åˆ†æè°ƒç”¨æ ˆæ·±åº¦
    - éªŒè¯ä½™é¢å®ˆæ’ä¸å˜é‡

æ­¥éª¤4: ä¿®å¤éªŒè¯
    - å¼•å…¥reentrancy guard
    - éªŒè¯ä¿®å¤åä¸å¯è¾¾æ”»å‡»çŠ¶æ€
    - ç¡®è®¤åŠŸèƒ½æ­£ç¡®æ€§æœªå—å½±å“
```

**å·¥å…·ç»„åˆ**: Slither + Mythril + CPN Tools

**å…³é”®ä»£ç ç¤ºä¾‹**:

```cpn
// CPN Tools: é‡å…¥æ”»å‡»Petriç½‘æ¨¡å‹
colset UserID = INT;
colset Balance = INT;
colset CallDepth = INT;

place UserBalance : product UserID * Balance;
place ContractState : STRING with "idle" | "withdrawing";
place CallStack : CallDepth;
place AttackState : STRING with "normal" | "reentered";

trans Withdraw(user : UserID, amount : Balance) =
    guard (user, amount) \in UserBalance and ContractState = "idle";
    action {
        ContractState := "withdrawing";
        CallStack := CallStack + {1};
    };

trans ExternalCall(user : UserID) =
    guard ContractState = "withdrawing" and CallStack > 0;
    action {
        // å¤–éƒ¨è°ƒç”¨å¯èƒ½è§¦å‘é‡å…¥
        AttackState := "reentered";
        CallStack := CallStack + {1};
    };

trans ReentrantWithdraw(user : UserID, amount : Balance) =
    guard AttackState = "reentered" and (user, amount) \in UserBalance;
    action {
        // é‡å…¥æ”»å‡»ï¼šåœ¨çŠ¶æ€æ›´æ–°å‰å†æ¬¡æå–
        UserBalance := UserBalance - {(user, amount)};
    };
```

```python
# Python: é‡å…¥æ”»å‡»æ£€æµ‹
def detect_reentrancy(contract_code: str) -> bool:
    """
    æ£€æµ‹æ™ºèƒ½åˆçº¦ä¸­çš„é‡å…¥æ¼æ´
    """
    # æ£€æŸ¥æ˜¯å¦å­˜åœ¨å¤–éƒ¨è°ƒç”¨
    external_calls = find_external_calls(contract_code)

    # æ£€æŸ¥çŠ¶æ€æ›´æ–°æ˜¯å¦åœ¨å¤–éƒ¨è°ƒç”¨ä¹‹å
    state_updates = find_state_updates(contract_code)

    # æ£€æŸ¥æ˜¯å¦å­˜åœ¨é‡å…¥ä¿æŠ¤ï¼ˆå¦‚ReentrancyGuardï¼‰
    has_guard = check_reentrancy_guard(contract_code)

    # å¦‚æœå­˜åœ¨å¤–éƒ¨è°ƒç”¨ä¸”çŠ¶æ€æ›´æ–°åœ¨è°ƒç”¨ä¹‹åï¼Œä¸”æ²¡æœ‰ä¿æŠ¤ï¼Œåˆ™å­˜åœ¨æ¼æ´
    if external_calls and not has_guard:
        for call in external_calls:
            for update in state_updates:
                if update.line_number < call.line_number:
                    return True  # çŠ¶æ€æ›´æ–°åœ¨å¤–éƒ¨è°ƒç”¨ä¹‹å‰ï¼Œå­˜åœ¨é‡å…¥é£é™©

    return False
```

**éªŒè¯ç»“æœ**:

- âœ… æ£€æµ‹ç‡ï¼šé‡å…¥æ”»å‡»æ£€æµ‹ç‡100%
- âœ… ä¿®å¤éªŒè¯ï¼šä¿®å¤åæ”»å‡»ä¸å¯è¾¾
- âœ… æ€§èƒ½ï¼šåˆ†ææ—¶é—´<5åˆ†é’Ÿ

### æ¡ˆä¾‹4ï¼šNFTäº¤æ˜“ç½‘ç»œåˆ†æ

**åœºæ™¯**: åˆ†æNFTäº¤æ˜“ç½‘ç»œçš„ç»“æ„å’Œå¼‚å¸¸äº¤æ˜“æ¨¡å¼

**å»ºæ¨¡é€‰æ‹©**: åŠ¨æ€å›¾è®º + æ‹“æ‰‘æ¨¡å‹

**å®ç°æ–¹æ¡ˆ**:

```text
æ­¥éª¤1: äº¤æ˜“å›¾æ„å»ºï¼ˆåŠ¨æ€å›¾è®ºï¼‰
    èŠ‚ç‚¹: é’±åŒ…åœ°å€ã€NFTåˆçº¦ã€NFTä»£å¸
    è¾¹: äº¤æ˜“ï¼ˆå¸¦æ—¶é—´æˆ³ã€ä»·æ ¼ã€Gasè´¹ï¼‰
    å±æ€§: äº¤æ˜“ç±»å‹ã€äº¤æ˜“é‡‘é¢ã€Gasæ¶ˆè€—

æ­¥éª¤2: ç½‘ç»œåˆ†æ
    - ä¸­å¿ƒæ€§åˆ†æï¼šè¯†åˆ«å…³é”®åœ°å€å’Œåˆçº¦
    - ç¤¾åŒºæ£€æµ‹ï¼šè¯†åˆ«äº¤æ˜“ç¾¤ç»„
    - è·¯å¾„åˆ†æï¼šè¿½è¸ªNFTæµè½¬è·¯å¾„

æ­¥éª¤3: å¼‚å¸¸æ£€æµ‹ï¼ˆæ‹“æ‰‘æ¨¡å‹ï¼‰
    - æ„å»ºäº¤æ˜“æ‹“æ‰‘ç©ºé—´
    - ä½¿ç”¨æŒä¹…åŒè°ƒæ£€æµ‹å¼‚å¸¸æ¨¡å¼
    - è¯†åˆ«æ´—ç›˜äº¤æ˜“ã€ä»·æ ¼æ“çºµ

æ­¥éª¤4: é£é™©è¯„ä¼°
    - è¯†åˆ«é«˜é£é™©äº¤æ˜“
    - è¯„ä¼°å¸‚åœºæ“çºµé£é™©
    - ç”Ÿæˆé£é™©æŠ¥å‘Š
```

**å·¥å…·ç»„åˆ**: NetworkX + Neo4j + GUDHI + Dune Analytics + Etherscan

**å…³é”®ä»£ç ç¤ºä¾‹**:

```python
# NetworkX: NFTäº¤æ˜“ç½‘ç»œåˆ†æ
import networkx as nx
from collections import defaultdict

class NFTTransactionGraph:
    def __init__(self):
        self.graph = nx.DiGraph()
        self.nft_owners = {}

    def add_nft_transfer(self, from_addr: str, to_addr: str,
                         nft_id: str, price: float, timestamp):
        """æ·»åŠ NFTè½¬ç§»"""
        self.graph.add_node(from_addr, type='address')
        self.graph.add_node(to_addr, type='address')
        self.graph.add_node(nft_id, type='nft')

        self.graph.add_edge(from_addr, nft_id, type='sells', price=price, timestamp=timestamp)
        self.graph.add_edge(nft_id, to_addr, type='buys', price=price, timestamp=timestamp)

        self.nft_owners[nft_id] = to_addr

    def detect_wash_trading(self) -> list:
        """æ£€æµ‹æ´—ç›˜äº¤æ˜“ï¼ˆåŒä¸€åœ°å€é¢‘ç¹ä¹°å–ï¼‰"""
        wash_trades = []

        for addr in self.graph.nodes():
            if self.graph.nodes[addr].get('type') == 'address':
                # æ‰¾å‡ºè¯¥åœ°å€çš„æ‰€æœ‰NFTäº¤æ˜“
                nft_transactions = []
                for nft in self.graph.successors(addr):
                    if self.graph.nodes[nft].get('type') == 'nft':
                        # æ£€æŸ¥è¯¥NFTæ˜¯å¦è¢«åŒä¸€åœ°å€å¤šæ¬¡äº¤æ˜“
                        sellers = [n for n in self.graph.predecessors(nft)
                                  if self.graph.nodes[n].get('type') == 'address']
                        buyers = [n for n in self.graph.successors(nft)
                                 if self.graph.nodes[n].get('type') == 'address']

                        # å¦‚æœåŒä¸€åœ°å€æ—¢å–åˆä¹°ï¼Œå¯èƒ½æ˜¯æ´—ç›˜
                        if addr in sellers and addr in buyers:
                            nft_transactions.append(nft)

                if len(nft_transactions) > 5:  # é˜ˆå€¼
                    wash_trades.append({
                        'address': addr,
                        'nft_count': len(nft_transactions),
                        'nfts': nft_transactions
                    })

        return wash_trades

    def trace_nft_path(self, nft_id: str) -> list:
        """è¿½è¸ªNFTæµè½¬è·¯å¾„"""
        path = []
        current_owner = self.nft_owners.get(nft_id)

        # å›æº¯æ‰¾å‡ºæ‰€æœ‰å†å²æ‰€æœ‰è€…
        visited = set()
        while current_owner and current_owner not in visited:
            visited.add(current_owner)
            path.append(current_owner)

            # æ‰¾å‡ºè¯¥NFTçš„å‰ä¸€ä¸ªæ‰€æœ‰è€…
            predecessors = [n for n in self.graph.predecessors(nft_id)
                           if self.graph[n][nft_id].get('type') == 'sells']
            if predecessors:
                current_owner = predecessors[0]
            else:
                break

        return path
```

**éªŒè¯ç»“æœ**:

- âœ… æ£€æµ‹ç‡ï¼šå¼‚å¸¸äº¤æ˜“æ£€æµ‹ç‡>95%
- âœ… åˆ†ææ·±åº¦ï¼šè¯†åˆ«å®Œæ•´äº¤æ˜“é“¾
- âœ… å‡†ç¡®æ€§ï¼šè¯¯æŠ¥ç‡<5%
- âœ… å®æ—¶æ€§ï¼šåˆ†æå»¶è¿Ÿ<1åˆ†é’Ÿ

### æ¡ˆä¾‹5ï¼šè·¨é“¾æ¡¥å®‰å…¨éªŒè¯

**åœºæ™¯**: éªŒè¯è·¨é“¾æ¡¥åè®®çš„å®‰å…¨æ€§å’Œæ­£ç¡®æ€§

**å»ºæ¨¡é€‰æ‹©**: Petriç½‘ + åŠ¨æ€å›¾è®º

**å®ç°æ–¹æ¡ˆ**:

```text
æ­¥éª¤1: è·¨é“¾æ¡¥åè®®å»ºæ¨¡ï¼ˆPetriç½‘ï¼‰
    åº“æ‰€:
    - æºé“¾çŠ¶æ€ã€ç›®æ ‡é“¾çŠ¶æ€ã€é”å®šèµ„äº§ã€éªŒè¯è€…çŠ¶æ€
    å˜è¿:
    - èµ„äº§é”å®šã€éªŒè¯ã€è·¨é“¾è½¬ç§»ã€è§£é”

æ­¥éª¤2: å®‰å…¨æ€§éªŒè¯
    - å¯è¾¾æ€§åˆ†æï¼šéªŒè¯èµ„äº§å®ˆæ’
    - æ´»æ€§éªŒè¯ï¼šéªŒè¯è·¨é“¾è¿‡ç¨‹å¯å®Œæˆ
    - å®‰å…¨æ€§éªŒè¯ï¼šéªŒè¯æ— åŒé‡æ”¯ä»˜

æ­¥éª¤3: è·¨é“¾äº¤æ˜“è¿½è¸ªï¼ˆåŠ¨æ€å›¾è®ºï¼‰
    - æ„å»ºè·¨é“¾äº¤æ˜“å›¾
    - è¿½è¸ªèµ„äº§æµè½¬è·¯å¾„
    - æ£€æµ‹å¼‚å¸¸äº¤æ˜“æ¨¡å¼

æ­¥éª¤4: é£é™©è¯„ä¼°
    - è¯†åˆ«å®‰å…¨æ¼æ´
    - è¯„ä¼°æ”»å‡»é£é™©
    - æå‡ºæ”¹è¿›å»ºè®®
```

**å·¥å…·ç»„åˆ**: CPN Tools + TLA+ + NetworkX + Chainlink

**å…³é”®ä»£ç ç¤ºä¾‹**:

```cpn
// CPN Tools: è·¨é“¾æ¡¥Petriç½‘æ¨¡å‹
colset ChainID = STRING;
colset AssetID = STRING;
colset Amount = INT;
colset UserID = INT;

place SourceChainAssets : product ChainID * AssetID * Amount;
place LockedAssets : product ChainID * AssetID * Amount;
place TargetChainAssets : product ChainID * AssetID * Amount;
place BridgeState : STRING with "idle" | "locking" | "minting" | "burning";

trans LockAssets(chain : ChainID, asset : AssetID, amount : Amount, user : UserID) =
    guard (chain, asset, amount) \in SourceChainAssets and BridgeState = "idle";
    action {
        SourceChainAssets := SourceChainAssets - {(chain, asset, amount)};
        LockedAssets := LockedAssets + {(chain, asset, amount)};
        BridgeState := "locking";
    };

trans MintAssets(targetChain : ChainID, asset : AssetID, amount : Amount) =
    guard BridgeState = "locking" and (sourceChain, asset, amount) \in LockedAssets;
    action {
        TargetChainAssets := TargetChainAssets + {(targetChain, asset, amount)};
        BridgeState := "minting";
    };
```

```python
# NetworkX: è·¨é“¾æ¡¥äº¤æ˜“å›¾åˆ†æ
import networkx as nx

class CrossChainBridgeGraph:
    def __init__(self):
        self.graph = nx.MultiDiGraph()

    def add_bridge_transaction(self, source_chain: str, target_chain: str,
                               asset: str, amount: float, timestamp):
        """æ·»åŠ è·¨é“¾äº¤æ˜“"""
        self.graph.add_node(source_chain, type='chain')
        self.graph.add_node(target_chain, type='chain')

        self.graph.add_edge(source_chain, target_chain,
                           asset=asset, amount=amount,
                           timestamp=timestamp, type='bridge')

    def verify_asset_conservation(self) -> dict:
        """éªŒè¯èµ„äº§å®ˆæ’"""
        conservation_status = {}

        for chain in self.graph.nodes():
            if self.graph.nodes[chain].get('type') == 'chain':
                # è®¡ç®—é”å®šçš„èµ„äº§
                locked = sum(
                    edge_data['amount']
                    for _, _, edge_data in self.graph.out_edges(chain, data=True)
                    if edge_data.get('type') == 'bridge'
                )

                # è®¡ç®—é“¸é€ çš„èµ„äº§
                minted = sum(
                    edge_data['amount']
                    for _, _, edge_data in self.graph.in_edges(chain, data=True)
                    if edge_data.get('type') == 'bridge'
                )

                conservation_status[chain] = {
                    'locked': locked,
                    'minted': minted,
                    'conserved': abs(locked - minted) < 0.01  # å…è®¸å°çš„æµ®ç‚¹è¯¯å·®
                }

        return conservation_status
```

**éªŒè¯ç»“æœ**:

- âœ… å®‰å…¨æ€§ï¼šèµ„äº§å®ˆæ’100%ä¿è¯
- âœ… æ­£ç¡®æ€§ï¼šè·¨é“¾åè®®æ­£ç¡®æ‰§è¡Œ
- âœ… æ£€æµ‹ç‡ï¼šå¼‚å¸¸äº¤æ˜“æ£€æµ‹ç‡>98%
- âœ… æ€§èƒ½ï¼šè·¨é“¾æ—¶é—´<5åˆ†é’Ÿ

---

## ğŸ› ï¸ **äº”ã€å·¥å…·æ ˆ / Part 5: Tool Stack**

### 5.1 Petriç½‘ä¸å½¢å¼åŒ–éªŒè¯å·¥å…·

| å·¥å…· | ç”¨é€” | ç‰¹ç‚¹ |
|------|------|------|
| **CPN Tools** | åè®®/åˆçº¦å»ºæ¨¡ | ç€è‰²Petriç½‘ï¼Œå¯è§†åŒ– |
| **TLA+** | åè®®éªŒè¯ | å¼ºå¤§çš„æ¨¡å‹æ£€éªŒ |
| **Spin** | åè®®éªŒè¯ | é«˜æ•ˆLTLæ£€éªŒ |
| **Move Prover** | Moveåˆçº¦éªŒè¯ | Aptos/Suiä¸“ç”¨ |
| **Certora** | åˆçº¦éªŒè¯ | EVMä¸“ç”¨å½¢å¼åŒ–éªŒè¯ |

### 5.2 æ™ºèƒ½åˆçº¦åˆ†æå·¥å…·

| å·¥å…· | ç”¨é€” | ç‰¹ç‚¹ |
|------|------|------|
| **Slither** | é™æ€åˆ†æ | æ£€æµ‹å¸¸è§æ¼æ´ |
| **Mythril** | ç¬¦å·æ‰§è¡Œ | æ·±åº¦æ¼æ´æ£€æµ‹ |
| **Echidna** | æ¨¡ç³Šæµ‹è¯• | å±æ€§æµ‹è¯• |
| **Manticore** | ç¬¦å·æ‰§è¡Œ | è·¯å¾„æ¢ç´¢ |

### 5.3 åŠ¨æ€å›¾è®ºå·¥å…·

| å·¥å…· | ç”¨é€” | ç‰¹ç‚¹ |
|------|------|------|
| **NetworkX** | å›¾åˆ†æ | Pythonç”Ÿæ€ |
| **Neo4j** | å›¾æ•°æ®åº“ | å®æ—¶æŸ¥è¯¢ |
| **GraphX** | å¤§è§„æ¨¡å›¾ | Sparkç”Ÿæ€ |
| **Dune Analytics** | é“¾ä¸Šåˆ†æ | SQLæŸ¥è¯¢ |
| **Nansen** | é“¾ä¸Šåˆ†æ | æ ‡ç­¾æ•°æ® |

### 5.4 æ‹“æ‰‘åˆ†æå·¥å…·

| å·¥å…· | ç”¨é€” | ç‰¹ç‚¹ |
|------|------|------|
| **GUDHI** | æŒä¹…åŒè°ƒ | é«˜æ•ˆTDAåº“ |
| **Ripser** | æŒä¹…åŒè°ƒ | å¿«é€Ÿè®¡ç®— |
| **KeplerMapper** | Mapperç®—æ³• | æ•°æ®å¯è§†åŒ– |

### 5.5 åŒºå—é“¾æ•°æ®å·¥å…·

| å·¥å…· | ç”¨é€” | ç‰¹ç‚¹ |
|------|------|------|
| **Ethereum ETL** | æ•°æ®å¯¼å‡º | ç»“æ„åŒ–æ•°æ® |
| **The Graph** | å­å›¾ç´¢å¼• | GraphQLæŸ¥è¯¢ |
| **Etherscan API** | æ•°æ®æŸ¥è¯¢ | å®æ—¶æ•°æ® |
| **Chainalysis** | åˆè§„åˆ†æ | ä¼ä¸šçº§ |

---

## ğŸ“‹ **å…­ã€äº¤ä»˜ç‰© / Part 6: Deliverables**

### 6.1 æ–‡æ¡£äº¤ä»˜ç‰©

| äº¤ä»˜ç‰© | è¯´æ˜ | çŠ¶æ€ |
|--------|------|------|
| åº”ç”¨æ¨¡å¼æ¸…å• | æœ¬æ–‡æ¡£ | âœ… å®Œæˆ |
| å†³ç­–æ ‘ | Mermaidå›¾ + æ–‡æœ¬ç‰ˆ | âœ… å®Œæˆ |
| å…¸å‹æ¡ˆä¾‹ | 5ä¸ªæ¡ˆä¾‹ | âœ… å®Œæˆ |
| å·¥å…·æ ˆ | 5ç±»å·¥å…·è¡¨ | âœ… å®Œæˆ |

### 6.2 å…·ä½“ä»£ç ç¤ºä¾‹

ä»¥ä¸‹ä¸ºåŒºå—é“¾åº”ç”¨æ¨¡å¼ä¸­çš„**ç¤ºä¾‹ä»£ç **ï¼ˆæ•™å­¦ç”¨ï¼›ç”Ÿäº§ç¯å¢ƒéœ€æ¥å…¥å…·ä½“é“¾ä¸åº“ï¼‰ã€‚

**ç¤ºä¾‹ï¼šåŸºäºå›¾ç»“æ„çš„ç®€å•äº¤æ˜“é‚»æ¥ç»Ÿè®¡ï¼ˆPythonï¼‰**

```python
# ç¤ºä¾‹ï¼šäº¤æ˜“å›¾é‚»æ¥ç»Ÿè®¡ï¼ˆæ•™å­¦ç”¨ï¼›å®é™…é¡¹ç›®è§ 03-å·¥å…·é›†æˆæŒ‡å—ï¼‰
from collections import defaultdict

def build_tx_graph(edges):
    """edges: [(from_addr, to_addr, value), ...]"""
    G = defaultdict(list)
    for u, v, w in edges:
        G[u].append((v, w))
    return dict(G)

def out_degree_sum(graph):
    """å„åœ°å€è½¬å‡ºæ€»æ¬¡æ•°ï¼ˆç¤ºä¾‹æŒ‡æ ‡ï¼‰"""
    return {addr: len(nbs) for addr, nbs in graph.items()}

# ç¤ºä¾‹æ•°æ®
edges = [("A", "B", 1.0), ("A", "C", 2.0), ("B", "C", 0.5)]
G = build_tx_graph(edges)
print(out_degree_sum(G))  # {'A': 2, 'B': 1}
```

**è¯´æ˜**ï¼šå®Œæ•´å·¥å…·é“¾ä¸æ™ºèƒ½åˆçº¦éªŒè¯ã€å…±è¯†å½¢å¼åŒ–éªŒè¯ç­‰è§ [03-å·¥å…·é›†æˆæŒ‡å—](03-å·¥å…·é›†æˆæŒ‡å—.md)ã€‚

### 6.3 åç»­è®¡åˆ’

- [x] âœ… è¡¥å……æ›´å¤šæ¡ˆä¾‹ï¼ˆNFTåˆ†æã€è·¨é“¾æ¡¥å®‰å…¨ï¼‰
- [x] âœ… æ·»åŠ å…·ä½“ä»£ç ç¤ºä¾‹ï¼ˆè§ Â§6.2ï¼‰
- [x] DeFiåè®®å®‰å…¨åˆ†ææ·±å…¥æŒ‡å—ï¼ˆè§ [03-å·¥å…·é›†æˆæŒ‡å—.md](03-å·¥å…·é›†æˆæŒ‡å—.md) ç¬¬å››éƒ¨åˆ†ï¼‰

---

## ğŸš€ **ä¸ƒã€æœ€æ–°ç ”ç©¶è¿›å±•ï¼ˆ2024-2025ï¼‰/ Part 7: Latest Research Progress**

### 7.1 å…±è¯†åè®®æœ€æ–°è¿›å±•

**æ–°å…±è¯†åè®®**:

- **Fides**: 2024å¹´æå‡ºçš„é«˜æ•ˆæ‹œå åº­å®¹é”™åè®®
- **QScale**: é‡å­å¢å¼ºçš„å…±è¯†åè®®
- **BECP**: åŒºå—é“¾å¢å¼ºçš„å…±è¯†åè®®

**å½¢å¼åŒ–éªŒè¯å·¥å…·**:

- **Ivy**: ä¸“é—¨ç”¨äºåˆ†å¸ƒå¼åè®®éªŒè¯
- **Model Checking Contest**: åŒ…å«PBFTç­‰åè®®çš„æ ‡å‡†æ¨¡å‹

### 7.2 æ™ºèƒ½åˆçº¦å®‰å…¨æœ€æ–°è¿›å±•

**AIé©±åŠ¨çš„æ¼æ´æ£€æµ‹**:

- **ç ”ç©¶**: ä½¿ç”¨LLMè¿›è¡Œæ™ºèƒ½åˆçº¦æ¼æ´æ£€æµ‹
- **åº”ç”¨**: é‡å…¥æ”»å‡»ã€æ•´æ•°æº¢å‡ºç­‰æ¼æ´æ£€æµ‹
- **å·¥å…·**: GPT-4 + Slitherç»„åˆ

**ç¬¦å·æ‰§è¡Œå¢å¼º**:

- **ç ”ç©¶**: ç»“åˆæœºå™¨å­¦ä¹ ä¼˜åŒ–ç¬¦å·æ‰§è¡Œè·¯å¾„æ¢ç´¢
- **åº”ç”¨**: å¤§è§„æ¨¡æ™ºèƒ½åˆçº¦åˆ†æ
- **å·¥å…·**: Manticore + MLå¢å¼º

### 7.3 DeFiåè®®åˆ†ææœ€æ–°è¿›å±•

**DeFiåè®®å½¢å¼åŒ–éªŒè¯**:

- **ç ”ç©¶**: ä½¿ç”¨Petriç½‘éªŒè¯DeFiåè®®çš„å®‰å…¨æ€§
- **åº”ç”¨**: Uniswapã€Compoundç­‰åè®®éªŒè¯
- **å·¥å…·**: CPN Tools + TLA+ç»„åˆ

**äº¤æ˜“ç½‘ç»œåˆ†æ**:

- **ç ”ç©¶**: ä½¿ç”¨å›¾ç¥ç»ç½‘ç»œåˆ†æNFTäº¤æ˜“ç½‘ç»œ
- **åº”ç”¨**: æ´—ç›˜äº¤æ˜“æ£€æµ‹ã€ä»·æ ¼æ“çºµè¯†åˆ«
- **å·¥å…·**: NetworkX + PyG + GUDHI

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**çŠ¶æ€**: âœ… å®Œæˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
