# ç¤¾ä¼šç½‘ç»œåº”ç”¨æ¨¡å¼å®ç°æŒ‡å— / Social Network Application Patterns Implementation Guide

## ğŸ“š **æ¦‚è¿° / Overview**

**æ–‡æ¡£ç›®çš„**: æä¾›ç¤¾ä¼šç½‘ç»œé¢†åŸŸåº”ç”¨æ¨¡å¼çš„è¯¦ç»†å®ç°æŒ‡å—ï¼ŒåŒ…æ‹¬å·¥å…·é…ç½®ã€ä»£ç ç¤ºä¾‹ã€æœ€ä½³å®è·µã€‚

**é€‚ç”¨å¯¹è±¡**: ç¤¾ä¼šç½‘ç»œåˆ†æå¸ˆã€æ•°æ®ç§‘å­¦å®¶ã€ç ”ç©¶äººå‘˜

---

## ğŸ¯ **ä¸€ã€ç¯å¢ƒå‡†å¤‡ / Part 1: Environment Setup**

### 1.1 åŠ¨æ€å›¾è®ºå·¥å…·å®‰è£…

#### NetworkX

**å®‰è£…æ­¥éª¤**:

```bash
pip install networkx
pip install matplotlib
pip install numpy
```

### 1.2 ç¤¾åŒºæ£€æµ‹å·¥å…·

#### python-louvain

**å®‰è£…æ­¥éª¤**:

```bash
pip install python-louvain
pip install networkx[community]
```

### 1.3 æ‹“æ‰‘åˆ†æå·¥å…·

#### GUDHI + Ripser

**å®‰è£…æ­¥éª¤**:

```bash
pip install gudhi
pip install ripser
```

---

## ğŸ”§ **äºŒã€ç¤¾åŒºæ£€æµ‹ä¸æ¼”åŒ–åˆ†æå®ç° / Part 2: Community Detection and Evolution Analysis Implementation**

### 2.1 æ—¶åºç½‘ç»œæ„å»º

**åŠ¨æ€å›¾å®ç°**:

```python
import networkx as nx
from collections import defaultdict
from datetime import datetime, timedelta
import numpy as np

class TemporalSocialNetwork:
    def __init__(self, window_size=86400):  # 1å¤©
        self.temporal_graphs = {}
        self.window_size = window_size
        self.community_history = []

    def add_interaction(self, user1, user2, timestamp, interaction_type='friend'):
        """
        æ·»åŠ ç¤¾äº¤äº’åŠ¨
        """
        window = self._get_window(timestamp)

        if window not in self.temporal_graphs:
            self.temporal_graphs[window] = nx.Graph()

        graph = self.temporal_graphs[window]
        graph.add_node(user1, type='user')
        graph.add_node(user2, type='user')

        if graph.has_edge(user1, user2):
            graph[user1][user2]['weight'] += 1
            graph[user1][user2]['last_seen'] = timestamp
        else:
            graph.add_edge(
                user1, user2,
                weight=1,
                type=interaction_type,
                first_seen=timestamp,
                last_seen=timestamp
            )

    def _get_window(self, timestamp):
        """
        è·å–æ—¶é—´çª—å£
        """
        if isinstance(timestamp, datetime):
            timestamp = timestamp.timestamp()

        window_start = int(timestamp // self.window_size) * self.window_size
        return window_start

    def get_snapshot(self, timestamp):
        """
        è·å–æ—¶é—´å¿«ç…§
        """
        window = self._get_window(timestamp)
        return self.temporal_graphs.get(window, nx.Graph())
```

### 2.2 ç¤¾åŒºæ¼”åŒ–è¿½è¸ª

**ç¤¾åŒºæ¼”åŒ–åˆ†æ**:

```python
from networkx.algorithms import community
from collections import defaultdict

class CommunityEvolutionAnalyzer:
    def __init__(self, temporal_network):
        self.temporal_network = temporal_network
        self.community_history = []
        self.evolution_events = []

    def track_community_evolution(self, timestamps):
        """
        è¿½è¸ªç¤¾åŒºæ¼”åŒ–
        """
        communities_over_time = []

        for timestamp in sorted(timestamps):
            snapshot = self.temporal_network.get_snapshot(timestamp)

            if snapshot.number_of_nodes() == 0:
                continue

            communities = community.louvain_communities(snapshot)

            communities_over_time.append({
                'timestamp': timestamp,
                'communities': communities,
                'num_communities': len(communities),
                'avg_community_size': np.mean([len(c) for c in communities])
            })

            if len(self.community_history) > 0:
                events = self._detect_evolution_events(
                    self.community_history[-1]['communities'],
                    communities,
                    timestamp
                )
                self.evolution_events.extend(events)

            self.community_history.append({
                'timestamp': timestamp,
                'communities': communities
            })

        return communities_over_time, self.evolution_events

    def _detect_evolution_events(self, prev_communities, curr_communities, timestamp):
        """
        æ£€æµ‹æ¼”åŒ–äº‹ä»¶
        """
        events = []

        # ç¤¾åŒºå½¢æˆæ£€æµ‹
        if len(curr_communities) > len(prev_communities):
            new_communities = self._find_new_communities(prev_communities, curr_communities)
            for comm in new_communities:
                events.append({
                    'type': 'formation',
                    'timestamp': timestamp,
                    'community': comm,
                    'size': len(comm)
                })

        # ç¤¾åŒºåˆ†è£‚æ£€æµ‹
        for prev_comm in prev_communities:
            matching_curr = self._find_matching_communities(prev_comm, curr_communities)
            if len(matching_curr) > 1:
                events.append({
                    'type': 'splitting',
                    'timestamp': timestamp,
                    'original_community': prev_comm,
                    'split_communities': matching_curr
                })

        # ç¤¾åŒºåˆå¹¶æ£€æµ‹
        for curr_comm in curr_communities:
            matching_prev = self._find_matching_communities(curr_comm, prev_communities)
            if len(matching_prev) > 1:
                events.append({
                    'type': 'merging',
                    'timestamp': timestamp,
                    'merged_communities': matching_prev,
                    'result_community': curr_comm
                })

        return events

    def _find_new_communities(self, prev_communities, curr_communities):
        """
        æ‰¾åˆ°æ–°å½¢æˆçš„ç¤¾åŒº
        """
        new_communities = []

        for curr_comm in curr_communities:
            is_new = True
            for prev_comm in prev_communities:
                overlap = len(set(curr_comm) & set(prev_comm)) / len(curr_comm)
                if overlap > 0.5:
                    is_new = False
                    break

            if is_new:
                new_communities.append(curr_comm)

        return new_communities

    def _find_matching_communities(self, target_comm, communities):
        """
        æ‰¾åˆ°ä¸ç›®æ ‡ç¤¾åŒºåŒ¹é…çš„ç¤¾åŒº
        """
        matching = []

        for comm in communities:
            overlap = len(set(target_comm) & set(comm)) / len(target_comm)
            if overlap > 0.3:
                matching.append(comm)

        return matching
```

---

## ğŸ”¬ **ä¸‰ã€æ‹“æ‰‘æ¼”åŒ–åˆ†æå®ç° / Part 3: Topological Evolution Analysis Implementation**

### 3.1 æ‹“æ‰‘ç‰¹å¾æå–

**æŒä¹…åŒè°ƒåˆ†æ**:

```python
from ripser import ripser
import numpy as np

class TopologicalEvolutionAnalyzer:
    def __init__(self, temporal_network):
        self.temporal_network = temporal_network
        self.topology_history = []

    def analyze_topological_evolution(self, timestamps):
        """
        åˆ†ææ‹“æ‰‘æ¼”åŒ–
        """
        topology_over_time = []

        for timestamp in sorted(timestamps):
            snapshot = self.temporal_network.get_snapshot(timestamp)

            if snapshot.number_of_nodes() < 3:
                continue

            embeddings = self._compute_node_embeddings(snapshot)
            result = ripser(embeddings, maxdim=1)

            topology_features = {
                'timestamp': timestamp,
                'betti_0': len([x for x in result['dgms'][0] if x[1] == np.inf]),
                'betti_1': len([x for x in result['dgms'][1] if x[1] != np.inf]),
                'persistence_diagrams': result['dgms']
            }

            topology_over_time.append(topology_features)

            if len(self.topology_history) > 0:
                topology_change = self._detect_topology_change(
                    self.topology_history[-1],
                    topology_features
                )
                topology_features['change'] = topology_change

            self.topology_history.append(topology_features)

        return topology_over_time

    def _compute_node_embeddings(self, graph):
        """
        è®¡ç®—èŠ‚ç‚¹åµŒå…¥
        """
        laplacian = nx.normalized_laplacian_matrix(graph)
        eigenvalues, eigenvectors = np.linalg.eigh(laplacian.toarray())

        k = min(10, len(eigenvalues))
        embeddings = eigenvectors[:, :k]

        return embeddings

    def _detect_topology_change(self, prev_topology, curr_topology):
        """
        æ£€æµ‹æ‹“æ‰‘å˜åŒ–
        """
        betti_change = {
            'betti_0_change': curr_topology['betti_0'] - prev_topology['betti_0'],
            'betti_1_change': curr_topology['betti_1'] - prev_topology['betti_1']
        }

        return betti_change
```

---

## ğŸ“‹ **å››ã€æœ€ä½³å®è·µ / Part 4: Best Practices**

### 4.1 æ•°æ®æ”¶é›†å®è·µ

1. **æ—¶é—´çª—å£**: æ ¹æ®æ•°æ®ç‰¹ç‚¹é€‰æ‹©åˆé€‚çš„æ—¶é—´çª—å£
2. **æ•°æ®è´¨é‡**: ç¡®ä¿æ•°æ®å®Œæ•´æ€§å’Œå‡†ç¡®æ€§
3. **æ•°æ®é¢„å¤„ç†**: æ¸…ç†å™ªå£°æ•°æ®

### 4.2 åˆ†æå®è·µ

1. **å¤šå°ºåº¦åˆ†æ**: ä»å±€éƒ¨åˆ°å…¨å±€åˆ†æ
2. **ç»Ÿè®¡éªŒè¯**: ä½¿ç”¨ç»Ÿè®¡æ–¹æ³•éªŒè¯ç»“æœ
3. **å¯è§†åŒ–**: ä½¿ç”¨å¯è§†åŒ–å·¥å…·å±•ç¤ºç»“æœ

---

## ğŸ“š **äº”ã€å‚è€ƒæ–‡æ¡£ / Part 5: Reference Documents**

### 5.1 ç›¸å…³æ–‡æ¡£

- [ç¤¾ä¼šç½‘ç»œåº”ç”¨æ¨¡å¼æ¸…å•](./ç¤¾ä¼šç½‘ç»œåº”ç”¨æ¨¡å¼æ¸…å•.md)
- [è¯¦ç»†æ¡ˆä¾‹ï¼šç¤¾åŒºæ£€æµ‹ä¸æ¼”åŒ–åˆ†æ](./01-è¯¦ç»†æ¡ˆä¾‹-ç¤¾åŒºæ£€æµ‹ä¸æ¼”åŒ–åˆ†æ.md)

### 5.2 å·¥å…·æ–‡æ¡£

- [NetworkXæ–‡æ¡£](https://networkx.org/documentation/)
- [GUDHIæ–‡æ¡£](https://gudhi.inria.fr/documentation/)
- [python-louvainæ–‡æ¡£](https://github.com/taynaud/python-louvain)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**çŠ¶æ€**: âœ… å®Œæˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
