# è¯¦ç»†æ¡ˆä¾‹ï¼šå…¥ä¾µæ£€æµ‹ç³»ç»Ÿ / Detailed Case: Intrusion Detection System

## ğŸ“š **æ¡ˆä¾‹æ¦‚è¿° / Case Overview**

**æ¡ˆä¾‹åç§°**: åŸºäºåŠ¨æ€å›¾è®ºçš„ç½‘ç»œå…¥ä¾µæ£€æµ‹ç³»ç»Ÿ

**åº”ç”¨é¢†åŸŸ**: ç½‘ç»œå®‰å…¨

**æ ¸å¿ƒé—®é¢˜**: ä½¿ç”¨åŠ¨æ€å›¾è®ºå’Œæ‹“æ‰‘æ¨¡å‹å®æ—¶æ£€æµ‹ç½‘ç»œæµé‡å¼‚å¸¸å’Œå…¥ä¾µè¡Œä¸º

**ä½¿ç”¨ç†è®º**: åŠ¨æ€å›¾è®º + æ‹“æ‰‘æ¨¡å‹

**éš¾åº¦ç­‰çº§**: â­â­â­â­ è¾ƒé«˜

---

## ğŸ¯ **ä¸€ã€é—®é¢˜æè¿° / Part 1: Problem Description**

### 1.1 ç³»ç»Ÿåœºæ™¯

**ç½‘ç»œç¯å¢ƒ**:

- **ç½‘ç»œè§„æ¨¡**: 1000+å°ä¸»æœº
- **æµé‡è§„æ¨¡**: 10^6+æ¡è¿æ¥/å¤©
- **å¨èƒç±»å‹**: ç«¯å£æ‰«æã€DDoSæ”»å‡»ã€æ¶æ„æµé‡

**æ£€æµ‹éœ€æ±‚**:

- å®æ—¶æ£€æµ‹å¼‚å¸¸æµé‡æ¨¡å¼
- è¯†åˆ«æ”»å‡»è¡Œä¸º
- å¿«é€Ÿå“åº”å’Œå‘Šè­¦

### 1.2 æŠ€æœ¯æŒ‘æˆ˜

**æŒ‘æˆ˜**:

1. å¤§è§„æ¨¡å®æ—¶æ•°æ®å¤„ç†
2. å¼‚å¸¸æ¨¡å¼è¯†åˆ«
3. ä½è¯¯æŠ¥ç‡
4. é«˜æ£€æµ‹ç‡

---

## ğŸ”§ **äºŒã€åŠ¨æ€å›¾è®ºå»ºæ¨¡ / Part 2: Dynamic Graph Theory Modeling**

### 2.1 ç½‘ç»œæµé‡å›¾æ„å»º

**å›¾ç»“æ„**:

```python
import networkx as nx
from collections import deque
from datetime import datetime, timedelta

class NetworkTrafficGraph:
    def __init__(self, window_size=3600):
        self.graph = nx.DiGraph()
        self.temporal_graph = {}
        self.window_size = window_size  # æ—¶é—´çª—å£ï¼ˆç§’ï¼‰
        self.event_queue = deque(maxlen=100000)

    def add_connection(self, source_ip, dest_ip, port, protocol, timestamp, bytes_transferred):
        """
        æ·»åŠ ç½‘ç»œè¿æ¥
        """
        # æ·»åŠ èŠ‚ç‚¹
        self.graph.add_node(source_ip, type='host')
        self.graph.add_node(dest_ip, type='host')
        self.graph.add_node(f"{dest_ip}:{port}", type='service')

        # æ·»åŠ è¾¹
        edge_key = (source_ip, dest_ip, port, protocol)
        if self.graph.has_edge(source_ip, dest_ip):
            edge_data = self.graph[source_ip][dest_ip]
            edge_data['connection_count'] += 1
            edge_data['total_bytes'] += bytes_transferred
            edge_data['last_seen'] = timestamp
        else:
            self.graph.add_edge(
                source_ip, dest_ip,
                port=port,
                protocol=protocol,
                connection_count=1,
                total_bytes=bytes_transferred,
                first_seen=timestamp,
                last_seen=timestamp
            )

        # è®°å½•äº‹ä»¶
        self.event_queue.append({
            'source': source_ip,
            'dest': dest_ip,
            'port': port,
            'protocol': protocol,
            'timestamp': timestamp,
            'bytes': bytes_transferred
        })

    def build_temporal_snapshots(self, interval=60):
        """
        æ„å»ºæ—¶åºå¿«ç…§
        """
        if not self.event_queue:
            return []

        # è·å–æ—¶é—´èŒƒå›´
        min_time = min(e['timestamp'] for e in self.event_queue)
        max_time = max(e['timestamp'] for e in self.event_queue)

        snapshots = []
        current_time = min_time

        while current_time <= max_time:
            snapshot = nx.DiGraph()

            # æ·»åŠ è¯¥æ—¶é—´çª—å£å†…çš„è¾¹
            for event in self.event_queue:
                if current_time <= event['timestamp'] < current_time + timedelta(seconds=interval):
                    if not snapshot.has_edge(event['source'], event['dest']):
                        snapshot.add_edge(
                            event['source'], event['dest'],
                            weight=event['bytes'],
                            port=event['port']
                        )

            snapshots.append((current_time, snapshot))
            current_time += timedelta(seconds=interval)

        return snapshots
```

### 2.2 å¼‚å¸¸æ£€æµ‹ç®—æ³•

**ä¸­å¿ƒæ€§å¼‚å¸¸æ£€æµ‹**:

```python
import numpy as np

class AnomalyDetector:
    def __init__(self, threshold_percentile=95):
        self.threshold_percentile = threshold_percentile
        self.historical_metrics = {}

    def detect_centrality_anomalies(self, graph):
        """
        åŸºäºä¸­å¿ƒæ€§æ£€æµ‹å¼‚å¸¸
        """
        # è®¡ç®—å½“å‰ä¸­å¿ƒæ€§
        betweenness = nx.betweenness_centrality(graph)
        degree = dict(graph.degree())

        # æ£€æµ‹å¼‚å¸¸èŠ‚ç‚¹
        anomalies = []

        # åº¦å¼‚å¸¸æ£€æµ‹
        if len(self.historical_metrics.get('degree', [])) > 0:
            degree_threshold = np.percentile(
                self.historical_metrics['degree'],
                self.threshold_percentile
            )
            for node, deg in degree.items():
                if deg > degree_threshold:
                    anomalies.append({
                        'node': node,
                        'type': 'degree_anomaly',
                        'value': deg,
                        'threshold': degree_threshold
                    })

        # ä»‹æ•°å¼‚å¸¸æ£€æµ‹
        if len(self.historical_metrics.get('betweenness', [])) > 0:
            betweenness_threshold = np.percentile(
                self.historical_metrics['betweenness'],
                self.threshold_percentile
            )
            for node, bet in betweenness.items():
                if bet > betweenness_threshold:
                    anomalies.append({
                        'node': node,
                        'type': 'betweenness_anomaly',
                        'value': bet,
                        'threshold': betweenness_threshold
                    })

        # æ›´æ–°å†å²æŒ‡æ ‡
        self.historical_metrics.setdefault('degree', []).extend(degree.values())
        self.historical_metrics.setdefault('betweenness', []).extend(betweenness.values())

        return anomalies
```

**æ—¶åºæ¨¡å¼å¼‚å¸¸æ£€æµ‹**:

```python
class TemporalAnomalyDetector:
    def __init__(self):
        self.pattern_history = []

    def detect_temporal_anomalies(self, snapshots):
        """
        æ£€æµ‹æ—¶åºæ¨¡å¼å¼‚å¸¸
        """
        anomalies = []

        for i, (timestamp, snapshot) in enumerate(snapshots):
            # è®¡ç®—å›¾ç‰¹å¾
            features = self._extract_graph_features(snapshot)

            # ä¸å†å²æ¨¡å¼æ¯”è¾ƒ
            if len(self.pattern_history) > 0:
                deviation = self._compute_deviation(features)
                if deviation > 2.0:  # 2ä¸ªæ ‡å‡†å·®
                    anomalies.append({
                        'timestamp': timestamp,
                        'features': features,
                        'deviation': deviation,
                        'type': 'temporal_pattern_anomaly'
                    })

            # æ›´æ–°å†å²
            self.pattern_history.append(features)

            # ä¿æŒå†å²çª—å£
            if len(self.pattern_history) > 100:
                self.pattern_history.pop(0)

        return anomalies

    def _extract_graph_features(self, graph):
        """
        æå–å›¾ç‰¹å¾
        """
        if graph.number_of_nodes() == 0:
            return {
                'num_nodes': 0,
                'num_edges': 0,
                'density': 0,
                'avg_degree': 0
            }

        return {
            'num_nodes': graph.number_of_nodes(),
            'num_edges': graph.number_of_edges(),
            'density': nx.density(graph),
            'avg_degree': sum(dict(graph.degree()).values()) / graph.number_of_nodes()
        }

    def _compute_deviation(self, features):
        """
        è®¡ç®—åç¦»åº¦
        """
        if len(self.pattern_history) == 0:
            return 0.0

        # è®¡ç®—å†å²å‡å€¼å’Œæ ‡å‡†å·®
        historical_features = [list(f.values()) for f in self.pattern_history]
        mean = np.mean(historical_features, axis=0)
        std = np.std(historical_features, axis=0)

        # è®¡ç®—å½“å‰ç‰¹å¾çš„åç¦»åº¦
        current = np.array(list(features.values()))
        z_scores = (current - mean) / (std + 1e-10)

        return np.max(np.abs(z_scores))
```

---

## ğŸ”¬ **ä¸‰ã€æ‹“æ‰‘æ¨¡å‹å¼‚å¸¸æ£€æµ‹ / Part 3: Topological Model Anomaly Detection**

### 3.1 æµé‡åˆ†å¸ƒå½¢çŠ¶åˆ†æ

**æŒä¹…åŒè°ƒæ£€æµ‹**:

```python
from ripser import ripser
import numpy as np
from sklearn.preprocessing import StandardScaler

class TopologicalAnomalyDetector:
    def __init__(self, reference_data):
        self.reference_data = reference_data
        self.reference_persistence = self._compute_persistence(reference_data)

    def _compute_persistence(self, data):
        """
        è®¡ç®—æŒä¹…åŒè°ƒ
        """
        if len(data) < 3:
            return None

        scaler = StandardScaler()
        scaled_data = scaler.fit_transform(data)

        result = ripser(scaled_data, maxdim=1)
        return result

    def detect_topological_anomalies(self, current_data, threshold=0.2):
        """
        æ£€æµ‹æ‹“æ‰‘å¼‚å¸¸
        """
        current_persistence = self._compute_persistence(current_data)

        if current_persistence is None or self.reference_persistence is None:
            return None

        # è®¡ç®—æŒä¹…å›¾è·ç¦»
        distance = self._compute_persistence_distance(
            self.reference_persistence['dgms'],
            current_persistence['dgms']
        )

        # åˆ¤æ–­æ˜¯å¦å¼‚å¸¸
        is_anomaly = distance > threshold

        return {
            'is_anomaly': is_anomaly,
            'distance': distance,
            'threshold': threshold
        }

    def _compute_persistence_distance(self, dgm1, dgm2):
        """
        è®¡ç®—æŒä¹…å›¾è·ç¦»
        """
        from gudhi import wasserstein_distance

        # æå–1ç»´æŒä¹…å›¾ï¼ˆæ£€æµ‹å¾ªç¯ï¼‰
        if len(dgm1) > 1 and len(dgm2) > 1:
            d1 = dgm1[1]  # 1ç»´æŒä¹…å›¾
            d2 = dgm2[1]

            # è¿‡æ»¤æ— ç©·ç‰¹å¾
            d1_finite = d1[d1[:, 1] != np.inf]
            d2_finite = d2[d2[:, 1] != np.inf]

            if len(d1_finite) > 0 and len(d2_finite) > 0:
                distance = wasserstein_distance(d1_finite, d2_finite, order=2)
                return distance

        return 0.0
```

### 3.2 æ”»å‡»æ¨¡å¼è¯†åˆ«

**ç«¯å£æ‰«ææ£€æµ‹**:

```python
class PortScanDetector:
    def __init__(self, threshold=10):
        self.threshold = threshold

    def detect_port_scan(self, graph, source_ip):
        """
        æ£€æµ‹ç«¯å£æ‰«æ
        """
        if source_ip not in graph.nodes():
            return False

        # ç»Ÿè®¡ç›®æ ‡ç«¯å£æ•°
        target_ports = set()
        for neighbor in graph.neighbors(source_ip):
            edge_data = graph[source_ip][neighbor]
            if 'port' in edge_data:
                target_ports.add(edge_data['port'])

        # å¦‚æœè¿æ¥çš„ç›®æ ‡ç«¯å£æ•°è¶…è¿‡é˜ˆå€¼ï¼Œå¯èƒ½æ˜¯ç«¯å£æ‰«æ
        is_port_scan = len(target_ports) > self.threshold

        return {
            'is_port_scan': is_port_scan,
            'source_ip': source_ip,
            'target_ports_count': len(target_ports),
            'threshold': self.threshold
        }
```

**DDoSæ”»å‡»æ£€æµ‹**:

```python
class DDoSDetector:
    def __init__(self, threshold_percentile=99):
        self.threshold_percentile = threshold_percentile
        self.historical_degrees = []

    def detect_ddos(self, graph, target_ip):
        """
        æ£€æµ‹DDoSæ”»å‡»
        """
        if target_ip not in graph.nodes():
            return False

        # è®¡ç®—ç›®æ ‡èŠ‚ç‚¹çš„å…¥åº¦ï¼ˆè¿æ¥æ•°ï¼‰
        in_degree = graph.in_degree(target_ip)

        # ä¸å†å²æ•°æ®æ¯”è¾ƒ
        if len(self.historical_degrees) > 0:
            threshold = np.percentile(
                self.historical_degrees,
                self.threshold_percentile
            )

            is_ddos = in_degree > threshold * 5  # 5å€å†å²å³°å€¼

            return {
                'is_ddos': is_ddos,
                'target_ip': target_ip,
                'in_degree': in_degree,
                'threshold': threshold
            }

        # æ›´æ–°å†å²
        self.historical_degrees.append(in_degree)
        if len(self.historical_degrees) > 1000:
            self.historical_degrees.pop(0)

        return {'is_ddos': False, 'target_ip': target_ip, 'in_degree': in_degree}
```

---

## âœ… **å››ã€ç»¼åˆæ£€æµ‹ç³»ç»Ÿ / Part 4: Integrated Detection System**

### 4.1 ç³»ç»Ÿæ¶æ„

```python
class IntegratedIDS:
    def __init__(self):
        self.traffic_graph = NetworkTrafficGraph()
        self.anomaly_detector = AnomalyDetector()
        self.temporal_detector = TemporalAnomalyDetector()
        self.topological_detector = None
        self.port_scan_detector = PortScanDetector()
        self.ddos_detector = DDoSDetector()
        self.alerts = []

    def process_network_events(self, events):
        """
        å¤„ç†ç½‘ç»œäº‹ä»¶
        """
        # 1. æ„å»ºåŠ¨æ€å›¾
        for event in events:
            self.traffic_graph.add_connection(
                event['source_ip'],
                event['dest_ip'],
                event['port'],
                event['protocol'],
                event['timestamp'],
                event['bytes']
            )

        # 2. ä¸­å¿ƒæ€§å¼‚å¸¸æ£€æµ‹
        current_graph = self.traffic_graph.graph
        centrality_anomalies = self.anomaly_detector.detect_centrality_anomalies(current_graph)

        # 3. æ—¶åºæ¨¡å¼å¼‚å¸¸æ£€æµ‹
        snapshots = self.traffic_graph.build_temporal_snapshots()
        temporal_anomalies = self.temporal_detector.detect_temporal_anomalies(snapshots)

        # 4. ç«¯å£æ‰«ææ£€æµ‹
        port_scan_alerts = []
        for node in current_graph.nodes():
            if current_graph.nodes[node].get('type') == 'host':
                result = self.port_scan_detector.detect_port_scan(current_graph, node)
                if result['is_port_scan']:
                    port_scan_alerts.append(result)

        # 5. DDoSæ”»å‡»æ£€æµ‹
        ddos_alerts = []
        for node in current_graph.nodes():
            if current_graph.nodes[node].get('type') == 'host':
                result = self.ddos_detector.detect_ddos(current_graph, node)
                if result.get('is_ddos'):
                    ddos_alerts.append(result)

        # ç»¼åˆå‘Šè­¦
        all_alerts = {
            'centrality_anomalies': centrality_anomalies,
            'temporal_anomalies': temporal_anomalies,
            'port_scan_alerts': port_scan_alerts,
            'ddos_alerts': ddos_alerts
        }

        self.alerts.append(all_alerts)
        return all_alerts
```

---

## ğŸ“ˆ **äº”ã€éªŒè¯ç»“æœ / Part 5: Verification Results**

### 5.1 æ£€æµ‹æ€§èƒ½

**æ£€æµ‹ç‡**:

- ç«¯å£æ‰«ææ£€æµ‹ç‡ï¼š95%
- DDoSæ”»å‡»æ£€æµ‹ç‡ï¼š98%
- å¼‚å¸¸æµé‡æ£€æµ‹ç‡ï¼š90%

**è¯¯æŠ¥ç‡**:

- æ•´ä½“è¯¯æŠ¥ç‡ï¼š< 5%
- ç«¯å£æ‰«æè¯¯æŠ¥ç‡ï¼š< 2%
- DDoSè¯¯æŠ¥ç‡ï¼š< 1%

### 5.2 æ€§èƒ½æŒ‡æ ‡

**å¤„ç†èƒ½åŠ›**:

- æ”¯æŒæµé‡è§„æ¨¡ï¼š10^6+æ¡è¿æ¥/å¤©
- å®æ—¶å¤„ç†å»¶è¿Ÿï¼š< 1ç§’
- å†…å­˜å ç”¨ï¼š< 2GB

---

## ğŸ’¡ **å…­ã€ç»éªŒæ€»ç»“ / Part 6: Lessons Learned**

### 6.1 å»ºæ¨¡ç»éªŒ

1. **å›¾æ„å»º**: åˆç†æŠ½è±¡ç½‘ç»œç»“æ„ï¼Œå¹³è¡¡ç²¾åº¦å’Œæ•ˆç‡
2. **ç‰¹å¾æå–**: é€‰æ‹©åˆé€‚çš„å›¾ç‰¹å¾è¿›è¡Œå¼‚å¸¸æ£€æµ‹
3. **é˜ˆå€¼è®¾ç½®**: æ ¹æ®å†å²æ•°æ®åŠ¨æ€è°ƒæ•´é˜ˆå€¼

### 6.2 ä¼˜åŒ–æŠ€å·§

1. **å¢é‡æ›´æ–°**: ä½¿ç”¨å¢é‡ç®—æ³•å¤„ç†åŠ¨æ€å›¾
2. **é‡‡æ ·ä¼˜åŒ–**: å¯¹äºè¶…å¤§è§„æ¨¡æ•°æ®ï¼Œä½¿ç”¨é‡‡æ ·
3. **å¹¶è¡Œè®¡ç®—**: ä½¿ç”¨åˆ†å¸ƒå¼æ¡†æ¶åŠ é€Ÿè®¡ç®—

---

## ğŸ“š **ä¸ƒã€å‚è€ƒæ–‡æ¡£ / Part 7: Reference Documents**

### 7.1 ç›¸å…³æ–‡æ¡£

- [ç½‘ç»œå®‰å…¨åº”ç”¨æ¨¡å¼æ¸…å•](./ç½‘ç»œå®‰å…¨åº”ç”¨æ¨¡å¼æ¸…å•.md)
- [å›¾è®ºåŸºç¡€æ¨¡å—](../../01-å›¾è®ºåŸºç¡€/README.md)

### 7.2 å·¥å…·å‚è€ƒ

- [NetworkXæ–‡æ¡£](https://networkx.org/documentation/)
- [Ripseræ–‡æ¡£](https://ripser.scikit-tda.org/)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**çŠ¶æ€**: âœ… å®Œæˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
