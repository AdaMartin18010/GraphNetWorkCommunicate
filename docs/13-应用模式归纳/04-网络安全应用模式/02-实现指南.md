# ç½‘ç»œå®‰å…¨åº”ç”¨æ¨¡å¼å®ç°æŒ‡å— / Network Security Application Patterns Implementation Guide

## ğŸ“š **æ¦‚è¿° / Overview**

**æ–‡æ¡£ç›®çš„**: æä¾›ç½‘ç»œå®‰å…¨é¢†åŸŸåº”ç”¨æ¨¡å¼çš„è¯¦ç»†å®ç°æŒ‡å—ï¼ŒåŒ…æ‹¬å·¥å…·é…ç½®ã€ä»£ç ç¤ºä¾‹ã€æœ€ä½³å®è·µã€‚

**é€‚ç”¨å¯¹è±¡**: å®‰å…¨æ¶æ„å¸ˆã€å®‰å…¨è¿ç»´å·¥ç¨‹å¸ˆã€å®‰å…¨ç ”ç©¶äººå‘˜

---

## ğŸ¯ **ä¸€ã€ç¯å¢ƒå‡†å¤‡ / Part 1: Environment Setup**

### 1.1 åŠ¨æ€å›¾è®ºå·¥å…·å®‰è£…

#### NetworkX + Neo4j

**å®‰è£…æ­¥éª¤**:

```bash
pip install networkx
pip install neo4j
pip install matplotlib
pip install numpy
```

#### Apache Flink

**å®‰è£…æ­¥éª¤**:

1. ä¸‹è½½Flinkï¼š<https://flink.apache.org/downloads.html>
2. é…ç½®ç¯å¢ƒå˜é‡
3. å¯åŠ¨Flinké›†ç¾¤

### 1.2 æ‹“æ‰‘åˆ†æå·¥å…·å®‰è£…

#### GUDHI + Ripser

**å®‰è£…æ­¥éª¤**:

```bash
pip install gudhi
pip install ripser
pip install giotto-tda
```

### 1.3 ç½‘ç»œå®‰å…¨ä¸“ç”¨å·¥å…·

#### Zeek (Bro)

**å®‰è£…æ­¥éª¤**:

```bash
# Ubuntu/Debian
sudo apt-get install zeek

# æˆ–ä»æºç ç¼–è¯‘
git clone --recursive https://github.com/zeek/zeek.git
cd zeek
./configure
make
sudo make install
```

---

## ğŸ”§ **äºŒã€ç½‘ç»œæµé‡å›¾æ„å»ºå®ç° / Part 2: Network Traffic Graph Construction Implementation**

### 2.1 å®æ—¶æµé‡å›¾æ„å»º

**Flinkæµå¤„ç†å®ç°**:

```python
from pyflink.datastream import StreamExecutionEnvironment
from pyflink.table import StreamTableEnvironment
from pyflink.datastream.functions import MapFunction, KeyedProcessFunction
import json

class NetworkEventMapper(MapFunction):
    def map(self, value):
        """
        è§£æç½‘ç»œäº‹ä»¶
        """
        event = json.loads(value)
        return {
            'source_ip': event['src_ip'],
            'dest_ip': event['dst_ip'],
            'port': event['dst_port'],
            'protocol': event['protocol'],
            'timestamp': event['timestamp'],
            'bytes': event['bytes']
        }

class TrafficGraphBuilder(KeyedProcessFunction):
    def __init__(self):
        self.graph = {}

    def process_element(self, value, ctx, out):
        """
        æ„å»ºæµé‡å›¾
        """
        source = value['source_ip']
        dest = value['dest_ip']

        # åˆå§‹åŒ–å›¾
        if source not in self.graph:
            self.graph[source] = {}
        if dest not in self.graph[source]:
            self.graph[source][dest] = {
                'connection_count': 0,
                'total_bytes': 0
            }

        # æ›´æ–°ç»Ÿè®¡
        self.graph[source][dest]['connection_count'] += 1
        self.graph[source][dest]['total_bytes'] += value['bytes']

        # è¾“å‡ºå›¾æ›´æ–°
        out.collect({
            'source': source,
            'dest': dest,
            'connection_count': self.graph[source][dest]['connection_count'],
            'total_bytes': self.graph[source][dest]['total_bytes']
        })

def build_realtime_traffic_graph():
    """
    æ„å»ºå®æ—¶æµé‡å›¾
    """
    env = StreamExecutionEnvironment.get_execution_environment()
    t_env = StreamTableEnvironment.create(env)

    # åˆ›å»ºç½‘ç»œäº‹ä»¶æµ
    event_stream = env.socket_text_stream("localhost", 9999)

    # è§£æäº‹ä»¶
    parsed_stream = event_stream.map(NetworkEventMapper())

    # æ„å»ºå›¾
    graph_stream = parsed_stream.key_by(lambda x: x['source_ip']).process(TrafficGraphBuilder())

    # è¾“å‡ºç»“æœ
    graph_stream.print()

    env.execute("Real-time Traffic Graph Building")
```

### 2.2 Neo4jå­˜å‚¨å®ç°

**Neo4jå›¾æ•°æ®åº“å­˜å‚¨**:

```python
from neo4j import GraphDatabase

class NetworkGraphNeo4j:
    def __init__(self, uri, user, password):
        self.driver = GraphDatabase.driver(uri, auth=(user, password))

    def close(self):
        self.driver.close()

    def create_connection(self, source_ip, dest_ip, port, protocol, timestamp, bytes_transferred):
        """
        åˆ›å»ºç½‘ç»œè¿æ¥
        """
        with self.driver.session() as session:
            session.write_transaction(
                self._create_connection,
                source_ip, dest_ip, port, protocol, timestamp, bytes_transferred
            )

    @staticmethod
    def _create_connection(tx, source_ip, dest_ip, port, protocol, timestamp, bytes_transferred):
        query = """
        MERGE (s:Host {ip: $source_ip})
        MERGE (d:Host {ip: $dest_ip})
        MERGE (s)-[r:CONNECTS_TO {
            port: $port,
            protocol: $protocol,
            timestamp: $timestamp,
            bytes: $bytes_transferred
        }]->(d)
        ON CREATE SET r.connection_count = 1, r.first_seen = $timestamp
        ON MATCH SET r.connection_count = r.connection_count + 1,
                     r.total_bytes = r.total_bytes + $bytes_transferred,
                     r.last_seen = $timestamp
        """
        tx.run(query, source_ip=source_ip, dest_ip=dest_ip, port=port,
              protocol=protocol, timestamp=timestamp, bytes_transferred=bytes_transferred)

    def detect_port_scan(self, source_ip, threshold=10):
        """
        æ£€æµ‹ç«¯å£æ‰«æ
        """
        with self.driver.session() as session:
            result = session.read_transaction(self._detect_port_scan, source_ip, threshold)
            return result

    @staticmethod
    def _detect_port_scan(tx, source_ip, threshold):
        query = """
        MATCH (s:Host {ip: $source_ip})-[r:CONNECTS_TO]->(d:Host)
        WITH s, collect(DISTINCT r.port) as ports
        WHERE size(ports) > $threshold
        RETURN s.ip as source_ip, size(ports) as port_count
        """
        result = tx.run(query, source_ip=source_ip, threshold=threshold)
        return [record for record in result]
```

---

## ğŸ”¬ **ä¸‰ã€æ‹“æ‰‘å¼‚å¸¸æ£€æµ‹å®ç° / Part 3: Topological Anomaly Detection Implementation**

### 3.1 æŒä¹…åŒè°ƒæ£€æµ‹

**å®ç°æ–¹æ¡ˆ**:

```python
from ripser import ripser
from gudhi import wasserstein_distance
import numpy as np
from sklearn.preprocessing import StandardScaler

class TopologicalAnomalyDetector:
    def __init__(self, reference_data, threshold=0.2):
        self.reference_data = reference_data
        self.threshold = threshold
        self.reference_persistence = self._compute_persistence(reference_data)

    def _compute_persistence(self, data):
        """
        è®¡ç®—æŒä¹…åŒè°ƒ
        """
        if len(data) < 3:
            return None

        scaler = StandardScaler()
        scaled_data = scaler.fit_transform(data)

        result = ripser(scaled_data, maxdim=1)
        return result

    def detect_anomaly(self, current_data):
        """
        æ£€æµ‹æ‹“æ‰‘å¼‚å¸¸
        """
        current_persistence = self._compute_persistence(current_data)

        if current_persistence is None or self.reference_persistence is None:
            return {'is_anomaly': False, 'distance': 0.0}

        # è®¡ç®—æŒä¹…å›¾è·ç¦»
        distance = self._compute_distance(
            self.reference_persistence['dgms'],
            current_persistence['dgms']
        )

        is_anomaly = distance > self.threshold

        return {
            'is_anomaly': is_anomaly,
            'distance': distance,
            'threshold': self.threshold
        }

    def _compute_distance(self, dgm1, dgm2):
        """
        è®¡ç®—æŒä¹…å›¾è·ç¦»
        """
        if len(dgm1) < 2 or len(dgm2) < 2:
            return 0.0

        # ä½¿ç”¨1ç»´æŒä¹…å›¾
        d1 = dgm1[1]
        d2 = dgm2[1]

        # è¿‡æ»¤æ— ç©·ç‰¹å¾
        d1_finite = d1[d1[:, 1] != np.inf]
        d2_finite = d2[d2[:, 1] != np.inf]

        if len(d1_finite) == 0 or len(d2_finite) == 0:
            return 0.0

        distance = wasserstein_distance(d1_finite, d2_finite, order=2)
        return distance
```

---

## ğŸ“Š **å››ã€æ”»å‡»å›¾åˆ†æå®ç° / Part 4: Attack Graph Analysis Implementation**

### 4.1 Petriç½‘æ”»å‡»çŠ¶æ€æœº

**CPN Toolsæ¨¡å‹**:

```cpn
// æ”»å‡»çŠ¶æ€æœºæ¨¡å‹
colset State = with initial | scanning | exploiting | compromised;
colset Host = INT;
colset Vulnerability = INT;

place AttackState : State;
place VulnerableHosts : Host;
place ExploitedHosts : Host;

trans ScanNetwork =
    guard AttackState = initial;
    action {
        AttackState := scanning;
    };

trans ExploitVulnerability =
    guard AttackState = scanning and VulnerableHosts > 0;
    action {
        AttackState := exploiting;
        VulnerableHosts := VulnerableHosts - 1;
        ExploitedHosts := ExploitedHosts + 1;
    };

trans CompromiseHost =
    guard AttackState = exploiting;
    action {
        AttackState := compromised;
    };
```

---

## ğŸ“‹ **äº”ã€æœ€ä½³å®è·µ / Part 5: Best Practices**

### 5.1 å»ºæ¨¡æœ€ä½³å®è·µ

1. **å›¾æ„å»º**: åˆç†æŠ½è±¡ç½‘ç»œç»“æ„ï¼Œå¹³è¡¡ç²¾åº¦å’Œæ•ˆç‡
2. **ç‰¹å¾æå–**: é€‰æ‹©åˆé€‚çš„å›¾ç‰¹å¾è¿›è¡Œå¼‚å¸¸æ£€æµ‹
3. **é˜ˆå€¼è®¾ç½®**: æ ¹æ®å†å²æ•°æ®åŠ¨æ€è°ƒæ•´é˜ˆå€¼

### 5.2 å·¥å…·é€‰æ‹©æŒ‡å—

| åœºæ™¯ | æ¨èå·¥å…· | ç†ç”± |
|------|----------|------|
| å®æ—¶æµé‡åˆ†æ | Flink + NetworkX | æµå¼å¤„ç† |
| å›¾æ•°æ®å­˜å‚¨ | Neo4j | å›¾æ•°æ®åº“ |
| æ‹“æ‰‘å¼‚å¸¸æ£€æµ‹ | GUDHI + Ripser | é«˜æ•ˆçš„TDAåº“ |
| æ”»å‡»å›¾å»ºæ¨¡ | CPN Tools | å¯è§†åŒ–å‹å¥½ |

### 5.3 æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **å¢é‡æ›´æ–°**: ä½¿ç”¨å¢é‡ç®—æ³•å¤„ç†åŠ¨æ€å›¾
2. **é‡‡æ ·ä¼˜åŒ–**: å¯¹äºè¶…å¤§è§„æ¨¡æ•°æ®ï¼Œä½¿ç”¨é‡‡æ ·
3. **åˆ†å¸ƒå¼è®¡ç®—**: ä½¿ç”¨åˆ†å¸ƒå¼æ¡†æ¶åŠ é€Ÿè®¡ç®—

---

## ğŸ“š **å…­ã€å‚è€ƒæ–‡æ¡£ / Part 6: Reference Documents**

### 6.1 ç›¸å…³æ–‡æ¡£

- [ç½‘ç»œå®‰å…¨åº”ç”¨æ¨¡å¼æ¸…å•](./ç½‘ç»œå®‰å…¨åº”ç”¨æ¨¡å¼æ¸…å•.md)
- [è¯¦ç»†æ¡ˆä¾‹ï¼šå…¥ä¾µæ£€æµ‹ç³»ç»Ÿ](./01-è¯¦ç»†æ¡ˆä¾‹-å…¥ä¾µæ£€æµ‹ç³»ç»Ÿ.md)

### 6.2 å·¥å…·æ–‡æ¡£

- [NetworkXæ–‡æ¡£](https://networkx.org/documentation/)
- [Neo4jæ–‡æ¡£](https://neo4j.com/docs/)
- [GUDHIæ–‡æ¡£](https://gudhi.inria.fr/documentation/)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**çŠ¶æ€**: âœ… å®Œæˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
