# é‡å­é€šä¿¡ - é‡å­å¯†é’¥åˆ†å‘ / Quantum Communication - Quantum Key Distribution

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä»‹ç»é‡å­å¯†é’¥åˆ†å‘çš„åŸºç¡€æ¦‚å¿µã€BB84åè®®ã€E91åè®®ã€BBM92åè®®ã€è¿ç»­å˜é‡QKDã€é‡å­å¯†é’¥åˆ†å‘ç½‘ç»œå’Œå®‰å…¨æ€§åˆ†æã€‚

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [é‡å­é€šä¿¡ - é‡å­å¯†é’¥åˆ†å‘ / Quantum Communication - Quantum Key Distribution](#é‡å­é€šä¿¡---é‡å­å¯†é’¥åˆ†å‘--quantum-communication---quantum-key-distribution)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [1. é‡å­å¯†é’¥åˆ†å‘åŸºç¡€](#1-é‡å­å¯†é’¥åˆ†å‘åŸºç¡€)
    - [1.1 åŸºæœ¬å®šä¹‰](#11-åŸºæœ¬å®šä¹‰)
    - [1.2 å®‰å…¨æ¨¡å‹](#12-å®‰å…¨æ¨¡å‹)
  - [2. BB84åè®®](#2-bb84åè®®)
    - [2.1 åè®®å®šä¹‰](#21-åè®®å®šä¹‰)
    - [2.2 åè®®åˆ†æ](#22-åè®®åˆ†æ)
  - [3. E91åè®®](#3-e91åè®®)
    - [3.1 åè®®å®šä¹‰](#31-åè®®å®šä¹‰)
    - [3.2 è´å°”ä¸ç­‰å¼éªŒè¯](#32-è´å°”ä¸ç­‰å¼éªŒè¯)
  - [4. BBM92åè®®](#4-bbm92åè®®)
    - [4.1 åè®®å®šä¹‰](#41-åè®®å®šä¹‰)
  - [5. è¿ç»­å˜é‡QKD](#5-è¿ç»­å˜é‡qkd)
    - [5.1 è¿ç»­å˜é‡å®šä¹‰](#51-è¿ç»­å˜é‡å®šä¹‰)
  - [6. é‡å­å¯†é’¥åˆ†å‘ç½‘ç»œ](#6-é‡å­å¯†é’¥åˆ†å‘ç½‘ç»œ)
    - [6.1 ç½‘ç»œæ‹“æ‰‘](#61-ç½‘ç»œæ‹“æ‰‘)
  - [7. å®‰å…¨æ€§åˆ†æ](#7-å®‰å…¨æ€§åˆ†æ)
    - [7.1 ä¿¡æ¯è®ºå®‰å…¨æ€§](#71-ä¿¡æ¯è®ºå®‰å…¨æ€§)
  - [8. å¤šæ¨¡æ€è¡¨è¾¾ä¸å¯è§†åŒ–](#8-å¤šæ¨¡æ€è¡¨è¾¾ä¸å¯è§†åŒ–)
    - [8.1 åè®®æµç¨‹å›¾](#81-åè®®æµç¨‹å›¾)
    - [8.2 é‡å­ç”µè·¯å›¾](#82-é‡å­ç”µè·¯å›¾)
    - [8.3 å®‰å…¨æ€§åˆ†æå›¾](#83-å®‰å…¨æ€§åˆ†æå›¾)
  - [9. è‡ªåŠ¨åŒ–è„šæœ¬å»ºè®®](#9-è‡ªåŠ¨åŒ–è„šæœ¬å»ºè®®)
    - [9.1 åè®®å®ç°è„šæœ¬](#91-åè®®å®ç°è„šæœ¬)
    - [9.2 å®‰å…¨æ€§åˆ†æè„šæœ¬](#92-å®‰å…¨æ€§åˆ†æè„šæœ¬)
    - [9.3 ç½‘ç»œä»¿çœŸè„šæœ¬](#93-ç½‘ç»œä»¿çœŸè„šæœ¬)
  - [10. å½¢å¼åŒ–è¯­ä¹‰ä¸æ¦‚å¿µè§£é‡Š](#10-å½¢å¼åŒ–è¯­ä¹‰ä¸æ¦‚å¿µè§£é‡Š)
    - [10.1 å½¢å¼åŒ–è¯­ä¹‰](#101-å½¢å¼åŒ–è¯­ä¹‰)
    - [10.2 å…¸å‹å®šç†ä¸è¯æ˜](#102-å…¸å‹å®šç†ä¸è¯æ˜)
    - [10.3 è‡ªåŠ¨åŒ–éªŒè¯å»ºè®®](#103-è‡ªåŠ¨åŒ–éªŒè¯å»ºè®®)
  - [ğŸ’¼ **11. å®é™…å·¥ç¨‹åº”ç”¨æ¡ˆä¾‹ / Real-World Engineering Application Cases**](#-11-å®é™…å·¥ç¨‹åº”ç”¨æ¡ˆä¾‹--real-world-engineering-application-cases)
    - [11.1 é‡å­å¯†é’¥åˆ†å‘ç½‘ç»œåº”ç”¨ / Quantum Key Distribution Network Applications](#111-é‡å­å¯†é’¥åˆ†å‘ç½‘ç»œåº”ç”¨--quantum-key-distribution-network-applications)
      - [11.1.1 ä¸­å›½é‡å­é€šä¿¡ç½‘ç»œ](#1111-ä¸­å›½é‡å­é€šä¿¡ç½‘ç»œ)
      - [11.1.2 æ¬§æ´²SECOQCç½‘ç»œ](#1112-æ¬§æ´²secoqcç½‘ç»œ)
    - [11.2 é‡å­å®‰å…¨åº”ç”¨ / Quantum Security Applications](#112-é‡å­å®‰å…¨åº”ç”¨--quantum-security-applications)
      - [11.2.1 é‡å­å®‰å…¨é“¶è¡Œç³»ç»Ÿ](#1121-é‡å­å®‰å…¨é“¶è¡Œç³»ç»Ÿ)
      - [11.2.2 é‡å­å®‰å…¨æ”¿åŠ¡ç³»ç»Ÿ](#1122-é‡å­å®‰å…¨æ”¿åŠ¡ç³»ç»Ÿ)
    - [11.3 é‡å­å¯†é’¥åˆ†å‘å·¥å…·ä¸åº”ç”¨ / Quantum Key Distribution Tools and Applications](#113-é‡å­å¯†é’¥åˆ†å‘å·¥å…·ä¸åº”ç”¨--quantum-key-distribution-tools-and-applications)
      - [11.3.1 ä¸»æµé‡å­å¯†é’¥åˆ†å‘å·¥å…·](#1131-ä¸»æµé‡å­å¯†é’¥åˆ†å‘å·¥å…·)
      - [11.3.2 å®é™…åº”ç”¨æ¡ˆä¾‹](#1132-å®é™…åº”ç”¨æ¡ˆä¾‹)

---

## 1. é‡å­å¯†é’¥åˆ†å‘åŸºç¡€

### 1.1 åŸºæœ¬å®šä¹‰

**å®šä¹‰ 1.1** (é‡å­å¯†é’¥åˆ†å‘ - Quantum Key Distribution)
**é‡å­å¯†é’¥åˆ†å‘**æ˜¯åˆ©ç”¨é‡å­åŠ›å­¦åŸç†åœ¨ä¸¤ä¸ªæˆ–å¤šä¸ªå‚ä¸æ–¹ä¹‹é—´å®‰å…¨åˆ†å‘å¯†é’¥çš„åè®®ï¼š
$$\mathcal{QKD} = \langle \mathcal{P}, \mathcal{Q}, \mathcal{M}, \mathcal{V}, \mathcal{K} \rangle$$

å…¶ä¸­ï¼š

- $\mathcal{P}$ æ˜¯åè®®å‚ä¸æ–¹é›†
- $\mathcal{Q}$ æ˜¯é‡å­ç³»ç»Ÿé›†
- $\mathcal{M}$ æ˜¯æµ‹é‡åŸºé›†
- $\mathcal{V}$ æ˜¯éªŒè¯æ–¹æ³•é›†
- $\mathcal{K}$ æ˜¯å¯†é’¥ç”Ÿæˆç®—æ³•é›†

**å®šä¹‰ 1.2** (é‡å­å¯†é’¥åˆ†å‘å®‰å…¨æ€§)
**é‡å­å¯†é’¥åˆ†å‘å®‰å…¨æ€§**æ˜¯æŒ‡åè®®åœ¨å­˜åœ¨çªƒå¬è€…çš„æƒ…å†µä¸‹ä»èƒ½ç”Ÿæˆå®‰å…¨å¯†é’¥ï¼š
$$\text{Security}(\mathcal{QKD}) = \text{Privacy} \land \text{Authenticity} \land \text{Completeness}$$

**å½¢å¼åŒ–è¯­ä¹‰**ï¼š

- é›†åˆè®ºè¯­ä¹‰ï¼š$\mathcal{P} \neq \emptyset, \mathcal{Q} \subseteq \mathcal{H}^{\otimes n}, \mathcal{M} \subseteq \mathcal{B}(\mathcal{H})$
- èŒƒç•´è®ºè¯­ä¹‰ï¼šQKDåè®®ä½œä¸ºé‡å­åè®®èŒƒç•´ä¸­çš„æ€å°„
- è‡ªåŠ¨æœºè¯­ä¹‰ï¼šQKDå¯å»ºæ¨¡ä¸ºé‡å­è‡ªåŠ¨æœº $A = (Q, \Sigma, \delta, q_0, F)$

### 1.2 å®‰å…¨æ¨¡å‹

**å®šä¹‰ 1.3** (çªƒå¬æ¨¡å‹)
**çªƒå¬æ¨¡å‹**æè¿°æ”»å‡»è€…çš„èƒ½åŠ›ï¼š
$$\mathcal{E} = \langle \mathcal{A}, \mathcal{C}, \mathcal{O}, \mathcal{Q} \rangle$$

å…¶ä¸­ï¼š

- $\mathcal{A}$ æ˜¯æ”»å‡»è€…ç±»å‹ï¼ˆå¦‚Eveï¼‰
- $\mathcal{C}$ æ˜¯è®¡ç®—èƒ½åŠ›
- $\mathcal{O}$ æ˜¯è§‚æµ‹èƒ½åŠ›
- $\mathcal{Q}$ æ˜¯é‡å­æ“ä½œèƒ½åŠ›

**å®šä¹‰ 1.4** (ä¸å¯å…‹éš†å®šç†)
**ä¸å¯å…‹éš†å®šç†**ï¼šæœªçŸ¥é‡å­æ€æ— æ³•è¢«å®Œç¾å¤åˆ¶ï¼š
$$\nexists U \text{ s.t. } U|\psi\rangle|0\rangle = |\psi\rangle|\psi\rangle \text{ for all } |\psi\rangle$$

**å®šç† 1.1** (ä¸å¯å…‹éš†å®šç†è¯æ˜)
**è¯æ˜**ï¼š

1. å‡è®¾å­˜åœ¨å¹ºæ­£ç®—ç¬¦ $U$ ä½¿å¾— $U|\psi\rangle|0\rangle = |\psi\rangle|\psi\rangle$
2. å¯¹ä»»æ„ $|\psi\rangle, |\phi\rangle$ï¼Œæœ‰ï¼š
   $$\langle\psi|\phi\rangle = \langle\psi|\phi\rangle^2$$
3. è¿™ä»…åœ¨ $|\psi\rangle = |\phi\rangle$ æˆ– $\langle\psi|\phi\rangle = 0$ æ—¶æˆç«‹
4. çŸ›ç›¾ï¼Œæ•…ä¸å­˜åœ¨è¿™æ ·çš„ $U$

$\boxed{\text{è¯æ¯•}}$

## 2. BB84åè®®

### 2.1 åè®®å®šä¹‰

**å®šä¹‰ 2.1** (BB84åè®®)
**BB84åè®®**æ˜¯ç¬¬ä¸€ä¸ªé‡å­å¯†é’¥åˆ†å‘åè®®ï¼Œç”±Bennettå’ŒBrassardäº1984å¹´æå‡ºï¼š
$$\text{BB84} = \langle \text{Preparation}, \text{Transmission}, \text{Measurement}, \text{Sifting}, \text{ErrorEstimation}, \text{PrivacyAmplification} \rangle$$

**ç®—æ³• 2.1** (BB84åè®®å®ç°)

```python
import numpy as np
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.quantum_info import Operator

class BB84Protocol:
    def __init__(self, key_length=1000):
        self.key_length = key_length
        self.alice_bits = []
        self.alice_bases = []
        self.bob_bits = []
        self.bob_bases = []
        self.shared_key = []

    def alice_prepare_qubits(self):
        """Aliceå‡†å¤‡é‡å­æ¯”ç‰¹"""
        for i in range(self.key_length):
            # éšæœºé€‰æ‹©æ¯”ç‰¹å’ŒåŸº
            bit = np.random.randint(0, 2)
            basis = np.random.randint(0, 2)  # 0: ZåŸº, 1: XåŸº

            self.alice_bits.append(bit)
            self.alice_bases.append(basis)

            # åˆ›å»ºé‡å­ç”µè·¯
            qc = QuantumCircuit(1, 1)

            if basis == 0:  # ZåŸº
                if bit == 1:
                    qc.x(0)
            else:  # XåŸº
                qc.h(0)
                if bit == 1:
                    qc.x(0)
                qc.h(0)

            yield qc

    def bob_measure_qubits(self, qubits):
        """Bobæµ‹é‡é‡å­æ¯”ç‰¹"""
        for i, qubit in enumerate(qubits):
            # éšæœºé€‰æ‹©æµ‹é‡åŸº
            basis = np.random.randint(0, 2)
            self.bob_bases.append(basis)

            # æµ‹é‡
            if basis == 0:  # ZåŸºæµ‹é‡
                result = qubit.measure_all(inplace=False)
            else:  # XåŸºæµ‹é‡
                qubit.h(0)
                result = qubit.measure_all(inplace=False)

            self.bob_bits.append(result.get_counts()['1'])

    def sifting(self):
        """ç­›é€‰ç›¸åŒåŸºçš„æµ‹é‡ç»“æœ"""
        for i in range(self.key_length):
            if self.alice_bases[i] == self.bob_bases[i]:
                self.shared_key.append(self.alice_bits[i])

        return len(self.shared_key)

    def estimate_error_rate(self, sample_size=100):
        """ä¼°è®¡é”™è¯¯ç‡"""
        if len(self.shared_key) < sample_size:
            return 1.0

        # éšæœºé€‰æ‹©æ ·æœ¬è¿›è¡Œé”™è¯¯ä¼°è®¡
        sample_indices = np.random.choice(
            len(self.shared_key),
            min(sample_size, len(self.shared_key)),
            replace=False
        )

        errors = 0
        for idx in sample_indices:
            if self.alice_bits[idx] != self.bob_bits[idx]:
                errors += 1

        return errors / len(sample_indices)

    def privacy_amplification(self, final_length=256):
        """éšç§æ”¾å¤§"""
        if len(self.shared_key) < final_length:
            return None

        # ä½¿ç”¨éšæœºçŸ©é˜µè¿›è¡Œéšç§æ”¾å¤§
        matrix = np.random.randint(0, 2, (final_length, len(self.shared_key)))
        final_key = np.dot(matrix, self.shared_key) % 2

        return final_key.tolist()
```

### 2.2 åè®®åˆ†æ

**å®šç† 2.1** (BB84å®‰å…¨æ€§)
BB84åè®®åœ¨å­˜åœ¨çªƒå¬è€…çš„æƒ…å†µä¸‹ï¼Œå¦‚æœé”™è¯¯ç‡ä½äº11%ï¼Œåˆ™èƒ½ç”Ÿæˆå®‰å…¨å¯†é’¥ã€‚

**è¯æ˜**ï¼š

1. çªƒå¬è€…Eveçš„å¹²æ‰°ä¼šå¼•å…¥é”™è¯¯
2. é”™è¯¯ç‡ $e$ ä¸çªƒå¬è€…è·å¾—çš„ä¿¡æ¯é‡ç›¸å…³
3. å½“ $e < 11\%$ æ—¶ï¼Œéšç§æ”¾å¤§èƒ½æ¶ˆé™¤Eveçš„ä¿¡æ¯
4. æœ€ç»ˆå¯†é’¥çš„å®‰å…¨æ€§ç”±ä¿¡æ¯è®ºä¿è¯

$\boxed{\text{è¯æ¯•}}$

**ç®—æ³• 2.2** (BB84å®‰å…¨æ€§åˆ†æ)

```python
def bb84_security_analysis(error_rate):
    """BB84å®‰å…¨æ€§åˆ†æ"""
    # è®¡ç®—çªƒå¬è€…è·å¾—çš„ä¿¡æ¯é‡
    if error_rate <= 0.11:
        # ä½¿ç”¨éšç§æ”¾å¤§æ¶ˆé™¤çªƒå¬è€…ä¿¡æ¯
        privacy_amplification_rate = 1 - 2 * error_rate
        return True, privacy_amplification_rate
    else:
        return False, 0.0

def calculate_secure_key_rate(error_rate, raw_key_rate):
    """è®¡ç®—å®‰å…¨å¯†é’¥ç‡"""
    if error_rate > 0.11:
        return 0.0

    # è€ƒè™‘é”™è¯¯çº æ­£å’Œéšç§æ”¾å¤§çš„å¼€é”€
    error_correction_rate = 1 - h(error_rate)  # h(x)æ˜¯äºŒè¿›åˆ¶ç†µå‡½æ•°
    privacy_amplification_rate = 1 - 2 * error_rate

    secure_rate = raw_key_rate * error_correction_rate * privacy_amplification_rate
    return secure_rate

def h(x):
    """äºŒè¿›åˆ¶ç†µå‡½æ•°"""
    if x == 0 or x == 1:
        return 0
    return -x * np.log2(x) - (1-x) * np.log2(1-x)
```

## 3. E91åè®®

### 3.1 åè®®å®šä¹‰

**å®šä¹‰ 3.1** (E91åè®®)
**E91åè®®**æ˜¯åŸºäºé‡å­çº ç¼ çš„å¯†é’¥åˆ†å‘åè®®ï¼š
$$\text{E91} = \langle \text{EntanglementDistribution}, \text{Measurement}, \text{CorrelationAnalysis}, \text{KeyGeneration} \rangle$$

**ç®—æ³• 3.1** (E91åè®®å®ç°)

```python
class E91Protocol:
    def __init__(self, key_length=1000):
        self.key_length = key_length
        self.alice_measurements = []
        self.bob_measurements = []
        self.alice_bases = []
        self.bob_bases = []
        self.shared_key = []

    def prepare_bell_pairs(self):
        """å‡†å¤‡Bellæ€å¯¹"""
        bell_pairs = []
        for i in range(self.key_length):
            # åˆ›å»ºBellæ€ |Î¦âºâŸ© = (|00âŸ© + |11âŸ©)/âˆš2
            qc = QuantumCircuit(2, 2)
            qc.h(0)
            qc.cx(0, 1)
            bell_pairs.append(qc)

        return bell_pairs

    def alice_measure(self, bell_pairs):
        """Aliceæµ‹é‡Bellæ€çš„ç¬¬ä¸€éƒ¨åˆ†"""
        for i, bell_pair in enumerate(bell_pairs):
            # éšæœºé€‰æ‹©æµ‹é‡åŸº
            basis = np.random.choice([0, 45, 90, 135])  # è§’åº¦
            self.alice_bases.append(basis)

            # åº”ç”¨æ—‹è½¬é—¨
            qc = bell_pair.copy()
            qc.rz(np.radians(basis), 0)
            qc.h(0)

            # æµ‹é‡
            result = qc.measure_all(inplace=False)
            self.alice_measurements.append(result.get_counts()['1'])

    def bob_measure(self, bell_pairs):
        """Bobæµ‹é‡Bellæ€çš„ç¬¬äºŒéƒ¨åˆ†"""
        for i, bell_pair in enumerate(bell_pairs):
            # éšæœºé€‰æ‹©æµ‹é‡åŸº
            basis = np.random.choice([0, 45, 90, 135])
            self.bob_bases.append(basis)

            # åº”ç”¨æ—‹è½¬é—¨
            qc = bell_pair.copy()
            qc.rz(np.radians(basis), 1)
            qc.h(1)

            # æµ‹é‡
            result = qc.measure_all(inplace=False)
            self.bob_measurements.append(result.get_counts()['1'])

    def analyze_correlations(self):
        """åˆ†ææµ‹é‡ç›¸å…³æ€§"""
        correlations = []
        for i in range(self.key_length):
            if self.alice_bases[i] == self.bob_bases[i]:
                # ç›¸åŒåŸºçš„æµ‹é‡ç»“æœåº”è¯¥ç›¸å…³
                correlation = self.alice_measurements[i] == self.bob_measurements[i]
                correlations.append(correlation)

        return correlations

    def generate_key(self, correlations):
        """åŸºäºç›¸å…³æ€§ç”Ÿæˆå¯†é’¥"""
        for i, correlation in enumerate(correlations):
            if correlation:
                # ç›¸å…³ç»“æœç”¨äºç”Ÿæˆå¯†é’¥
                self.shared_key.append(self.alice_measurements[i])

        return len(self.shared_key)
```

### 3.2 è´å°”ä¸ç­‰å¼éªŒè¯

**å®šä¹‰ 3.2** (è´å°”ä¸ç­‰å¼)
**è´å°”ä¸ç­‰å¼**æ˜¯åŒºåˆ†ç»å…¸ç›¸å…³æ€§å’Œé‡å­çº ç¼ çš„åˆ¤æ®ï¼š
$$|E(a,b) - E(a,b') + E(a',b) + E(a',b')| \leq 2$$

å…¶ä¸­ $E(a,b)$ æ˜¯æµ‹é‡åŸº $a$ å’Œ $b$ çš„ç›¸å…³æ€§ã€‚

**ç®—æ³• 3.2** (è´å°”ä¸ç­‰å¼éªŒè¯)

```python
def bell_inequality_test(measurements, bases):
    """è´å°”ä¸ç­‰å¼æµ‹è¯•"""
    # è®¡ç®—ä¸åŒåŸºç»„åˆçš„ç›¸å…³æ€§
    correlations = {}

    for a in [0, 45, 90, 135]:
        for b in [0, 45, 90, 135]:
            if a != b:
                # æ‰¾åˆ°ä½¿ç”¨åŸºaå’Œbçš„æµ‹é‡
                a_indices = [i for i, base in enumerate(bases) if base == a]
                b_indices = [i for i, base in enumerate(bases) if base == b]

                # è®¡ç®—ç›¸å…³æ€§
                if a_indices and b_indices:
                    common_indices = set(a_indices) & set(b_indices)
                    if common_indices:
                        correlation = sum(1 for i in common_indices
                                        if measurements[i] == measurements[i+1]) / len(common_indices)
                        correlations[(a, b)] = correlation

    # è®¡ç®—è´å°”ä¸ç­‰å¼
    bell_value = abs(correlations.get((0, 0), 0) - correlations.get((0, 45), 0) +
                    correlations.get((90, 0), 0) + correlations.get((90, 45), 0))

    return bell_value, bell_value > 2  # è¿åè´å°”ä¸ç­‰å¼è¡¨ç¤ºå­˜åœ¨é‡å­çº ç¼ 
```

## 4. BBM92åè®®

### 4.1 åè®®å®šä¹‰

**å®šä¹‰ 4.1** (BBM92åè®®)
**BBM92åè®®**æ˜¯BB84çš„æ”¹è¿›ç‰ˆæœ¬ï¼Œä½¿ç”¨çº ç¼ å…‰å­å¯¹ï¼š
$$\text{BBM92} = \langle \text{EntangledPairGeneration}, \text{Distribution}, \text{Measurement}, \text{KeyExtraction} \rangle$$

**ç®—æ³• 4.1** (BBM92åè®®å®ç°)

```python
class BBM92Protocol:
    def __init__(self, key_length=1000):
        self.key_length = key_length
        self.alice_results = []
        self.bob_results = []
        self.alice_bases = []
        self.bob_bases = []
        self.shared_key = []

    def generate_entangled_pairs(self):
        """ç”Ÿæˆçº ç¼ å…‰å­å¯¹"""
        entangled_pairs = []
        for i in range(self.key_length):
            # åˆ›å»ºçº ç¼ æ€ |Î¨â»âŸ© = (|01âŸ© - |10âŸ©)/âˆš2
            qc = QuantumCircuit(2, 2)
            qc.x(0)
            qc.h(0)
            qc.cx(0, 1)
            qc.z(1)
            entangled_pairs.append(qc)

        return entangled_pairs

    def alice_measure_entangled_qubit(self, entangled_pairs):
        """Aliceæµ‹é‡çº ç¼ å¯¹çš„ç¬¬ä¸€éƒ¨åˆ†"""
        for i, pair in enumerate(entangled_pairs):
            # éšæœºé€‰æ‹©æµ‹é‡åŸº
            basis = np.random.randint(0, 2)  # 0: ZåŸº, 1: XåŸº
            self.alice_bases.append(basis)

            # æµ‹é‡
            qc = pair.copy()
            if basis == 1:  # XåŸºæµ‹é‡
                qc.h(0)
            result = qc.measure_all(inplace=False)
            self.alice_results.append(result.get_counts()['1'])

    def bob_measure_entangled_qubit(self, entangled_pairs):
        """Bobæµ‹é‡çº ç¼ å¯¹çš„ç¬¬äºŒéƒ¨åˆ†"""
        for i, pair in enumerate(entangled_pairs):
            # éšæœºé€‰æ‹©æµ‹é‡åŸº
            basis = np.random.randint(0, 2)
            self.bob_bases.append(basis)

            # æµ‹é‡
            qc = pair.copy()
            if basis == 1:  # XåŸºæµ‹é‡
                qc.h(1)
            result = qc.measure_all(inplace=False)
            self.bob_results.append(result.get_counts()['1'])

    def extract_key(self):
        """æå–å¯†é’¥"""
        for i in range(self.key_length):
            if self.alice_bases[i] == self.bob_bases[i]:
                # ç›¸åŒåŸºçš„æµ‹é‡ç»“æœç”¨äºç”Ÿæˆå¯†é’¥
                self.shared_key.append(self.alice_results[i])

        return len(self.shared_key)
```

## 5. è¿ç»­å˜é‡QKD

### 5.1 è¿ç»­å˜é‡å®šä¹‰

**å®šä¹‰ 5.1** (è¿ç»­å˜é‡QKD)
**è¿ç»­å˜é‡QKD**ä½¿ç”¨è¿ç»­å˜é‡ï¼ˆå¦‚ä½ç½®å’ŒåŠ¨é‡ï¼‰è¿›è¡Œå¯†é’¥åˆ†å‘ï¼š
$$\text{CV-QKD} = \langle \text{CoherentStatePreparation}, \text{Modulation}, \text{HeterodyneDetection}, \text{PostProcessing} \rangle$$

**ç®—æ³• 5.1** (è¿ç»­å˜é‡QKDå®ç°)

```python
class ContinuousVariableQKD:
    def __init__(self, key_length=1000):
        self.key_length = key_length
        self.alice_modulations = []
        self.bob_measurements = []
        self.shared_key = []

    def prepare_coherent_states(self):
        """å‡†å¤‡ç›¸å¹²æ€"""
        coherent_states = []
        for i in range(self.key_length):
            # ç”Ÿæˆéšæœºå¤æ•°æŒ¯å¹…
            alpha = np.random.normal(0, 1) + 1j * np.random.normal(0, 1)
            self.alice_modulations.append(alpha)

            # ç›¸å¹²æ€ |Î±âŸ© = exp(-|Î±|Â²/2) Î£ (Î±â¿/âˆšn!) |nâŸ©
            coherent_states.append(alpha)

        return coherent_states

    def heterodyne_detection(self, coherent_states):
        """å¤–å·®æ£€æµ‹"""
        for i, alpha in enumerate(coherent_states):
            # æ·»åŠ å™ªå£°
            noise = np.random.normal(0, 0.1) + 1j * np.random.normal(0, 0.1)
            measurement = alpha + noise
            self.bob_measurements.append(measurement)

    def post_processing(self):
        """åå¤„ç†"""
        # é‡åŒ–è¿ç»­æµ‹é‡ç»“æœ
        for i in range(self.key_length):
            # å°†å¤æ•°æµ‹é‡ç»“æœé‡åŒ–ä¸ºæ¯”ç‰¹
            real_part = self.bob_measurements[i].real
            if real_part > 0:
                self.shared_key.append(1)
            else:
                self.shared_key.append(0)

        return len(self.shared_key)
```

## 6. é‡å­å¯†é’¥åˆ†å‘ç½‘ç»œ

### 6.1 ç½‘ç»œæ‹“æ‰‘

**å®šä¹‰ 6.1** (QKDç½‘ç»œ)
**QKDç½‘ç»œ**æ˜¯å¤šä¸ªQKDèŠ‚ç‚¹çš„äº’è”ç½‘ç»œï¼š
$$\mathcal{QKDN} = \langle \mathcal{N}, \mathcal{L}, \mathcal{P}, \mathcal{R} \rangle$$

å…¶ä¸­ï¼š

- $\mathcal{N}$ æ˜¯QKDèŠ‚ç‚¹é›†
- $\mathcal{L}$ æ˜¯é‡å­é“¾è·¯é›†
- $\mathcal{P}$ æ˜¯QKDåè®®é›†
- $\mathcal{R}$ æ˜¯è·¯ç”±ç®—æ³•é›†

**ç®—æ³• 6.1** (QKDç½‘ç»œè·¯ç”±)

```python
class QKDNetwork:
    def __init__(self, nodes, links):
        self.nodes = nodes
        self.links = links
        self.routing_table = {}

    def find_qkd_path(self, source, destination):
        """å¯»æ‰¾QKDè·¯å¾„"""
        # ä½¿ç”¨Dijkstraç®—æ³•å¯»æ‰¾æœ€çŸ­è·¯å¾„
        distances = {node: float('inf') for node in self.nodes}
        distances[source] = 0
        previous = {}
        unvisited = set(self.nodes)

        while unvisited:
            # æ‰¾åˆ°è·ç¦»æœ€å°çš„æœªè®¿é—®èŠ‚ç‚¹
            current = min(unvisited, key=lambda x: distances[x])
            unvisited.remove(current)

            if current == destination:
                break

            # æ›´æ–°é‚»å±…è·ç¦»
            for neighbor in self.get_neighbors(current):
                if neighbor in unvisited:
                    distance = distances[current] + self.get_link_distance(current, neighbor)
                    if distance < distances[neighbor]:
                        distances[neighbor] = distance
                        previous[neighbor] = current

        # é‡å»ºè·¯å¾„
        path = []
        current = destination
        while current in previous:
            path.append(current)
            current = previous[current]
        path.append(source)
        path.reverse()

        return path

    def establish_qkd_link(self, path):
        """å»ºç«‹QKDé“¾è·¯"""
        # æ²¿è·¯å¾„å»ºç«‹QKDè¿æ¥
        for i in range(len(path) - 1):
            node1, node2 = path[i], path[i+1]
            # æ‰§è¡ŒQKDåè®®
            key = self.perform_qkd(node1, node2)
            # å­˜å‚¨å¯†é’¥
            self.store_key(node1, node2, key)

    def perform_qkd(self, node1, node2):
        """æ‰§è¡ŒQKDåè®®"""
        # è¿™é‡Œå¯ä»¥è°ƒç”¨å…·ä½“çš„QKDåè®®å®ç°
        bb84 = BB84Protocol(key_length=100)
        # æ‰§è¡Œåè®®å¹¶è¿”å›ç”Ÿæˆçš„å¯†é’¥
        return bb84.generate_key()
```

## 7. å®‰å…¨æ€§åˆ†æ

### 7.1 ä¿¡æ¯è®ºå®‰å…¨æ€§

**å®šç† 7.1** (QKDä¿¡æ¯è®ºå®‰å…¨æ€§)
QKDåè®®åœ¨ä¿¡æ¯è®ºæ„ä¹‰ä¸‹æ˜¯å®‰å…¨çš„ï¼Œå³çªƒå¬è€…æ— æ³•è·å¾—ä»»ä½•å…³äºæœ€ç»ˆå¯†é’¥çš„ä¿¡æ¯ã€‚

**è¯æ˜**ï¼š

1. é‡å­åŠ›å­¦çš„ä¸ç¡®å®šæ€§åŸç†ä¿è¯çªƒå¬æ£€æµ‹
2. éšç§æ”¾å¤§æ¶ˆé™¤çªƒå¬è€…çš„éƒ¨åˆ†ä¿¡æ¯
3. æœ€ç»ˆå¯†é’¥çš„ç†µå¤§äºçªƒå¬è€…çš„ä¿¡æ¯é‡
4. å› æ­¤çªƒå¬è€…æ— æ³•è·å¾—å¯†é’¥ä¿¡æ¯

$\boxed{\text{è¯æ¯•}}$

**ç®—æ³• 7.1** (å®‰å…¨æ€§åˆ†æ)

```python
def qkd_security_analysis(error_rate, raw_key_length, final_key_length):
    """QKDå®‰å…¨æ€§åˆ†æ"""
    # è®¡ç®—çªƒå¬è€…è·å¾—çš„ä¿¡æ¯é‡
    eve_information = calculate_eve_information(error_rate, raw_key_length)

    # è®¡ç®—æœ€ç»ˆå¯†é’¥çš„ç†µ
    final_key_entropy = final_key_length

    # æ£€æŸ¥å®‰å…¨æ€§æ¡ä»¶
    if final_key_entropy > eve_information:
        security_level = final_key_entropy - eve_information
        return True, security_level
    else:
        return False, 0

def calculate_eve_information(error_rate, key_length):
    """è®¡ç®—çªƒå¬è€…ä¿¡æ¯é‡"""
    # åŸºäºé”™è¯¯ç‡ä¼°è®¡çªƒå¬è€…ä¿¡æ¯
    if error_rate <= 0.11:
        return key_length * (1 - 2 * error_rate)
    else:
        return key_length  # é”™è¯¯ç‡è¿‡é«˜ï¼Œçªƒå¬è€…å¯èƒ½è·å¾—å…¨éƒ¨ä¿¡æ¯
```

## 8. å¤šæ¨¡æ€è¡¨è¾¾ä¸å¯è§†åŒ–

### 8.1 åè®®æµç¨‹å›¾

```mermaid
sequenceDiagram
    participant A as Alice
    participant C as Channel
    participant B as Bob
    participant E as Eve

    A->>C: å‘é€é‡å­æ¯”ç‰¹
    C->>E: çªƒå¬å°è¯•
    E->>C: å¹²æ‰°ä¿¡å·
    C->>B: æ¥æ”¶é‡å­æ¯”ç‰¹
    A->>B: å…¬å¼€åŸºé€‰æ‹©
    B->>A: å…¬å¼€åŸºé€‰æ‹©
    A->>B: ç­›é€‰ç›¸åŒåŸº
    B->>A: é”™è¯¯ä¼°è®¡
    A->>B: éšç§æ”¾å¤§
    Note over A,B: ç”Ÿæˆå®‰å…¨å¯†é’¥
```

### 8.2 é‡å­ç”µè·¯å›¾

```python
# Qiskité‡å­ç”µè·¯å¯è§†åŒ–
def create_bb84_circuit():
    qc = QuantumCircuit(2, 2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure_all()
    return qc

# ç»˜åˆ¶ç”µè·¯
circuit = create_bb84_circuit()
circuit.draw(output='mpl')
```

### 8.3 å®‰å…¨æ€§åˆ†æå›¾

```python
import matplotlib.pyplot as plt
import numpy as np

def plot_qkd_security():
    error_rates = np.linspace(0, 0.2, 100)
    secure_rates = []

    for e in error_rates:
        if e <= 0.11:
            rate = 1 - 2 * e
            secure_rates.append(rate)
        else:
            secure_rates.append(0)

    plt.figure(figsize=(10, 6))
    plt.plot(error_rates, secure_rates, 'b-', linewidth=2)
    plt.axvline(x=0.11, color='r', linestyle='--', label='å®‰å…¨é˜ˆå€¼')
    plt.xlabel('é”™è¯¯ç‡')
    plt.ylabel('å®‰å…¨å¯†é’¥ç‡')
    plt.title('QKDå®‰å…¨æ€§åˆ†æ')
    plt.legend()
    plt.grid(True)
    plt.show()
```

## 9. è‡ªåŠ¨åŒ–è„šæœ¬å»ºè®®

### 9.1 åè®®å®ç°è„šæœ¬

- **`scripts/bb84_protocol.py`**ï¼šBB84åè®®å®Œæ•´å®ç°
- **`scripts/e91_protocol.py`**ï¼šE91åè®®å®ç°
- **`scripts/bbm92_protocol.py`**ï¼šBBM92åè®®å®ç°
- **`scripts/cv_qkd_protocol.py`**ï¼šè¿ç»­å˜é‡QKDå®ç°

### 9.2 å®‰å…¨æ€§åˆ†æè„šæœ¬

- **`scripts/qkd_security_analyzer.py`**ï¼šQKDå®‰å…¨æ€§åˆ†æ
- **`scripts/bell_inequality_tester.py`**ï¼šè´å°”ä¸ç­‰å¼æµ‹è¯•
- **`scripts/error_rate_estimator.py`**ï¼šé”™è¯¯ç‡ä¼°è®¡

### 9.3 ç½‘ç»œä»¿çœŸè„šæœ¬

- **`scripts/qkd_network_simulator.py`**ï¼šQKDç½‘ç»œä»¿çœŸ
- **`scripts/qkd_routing.py`**ï¼šQKDè·¯ç”±ç®—æ³•
- **`scripts/network_security_analyzer.py`**ï¼šç½‘ç»œå®‰å…¨åˆ†æ

## 10. å½¢å¼åŒ–è¯­ä¹‰ä¸æ¦‚å¿µè§£é‡Š

### 10.1 å½¢å¼åŒ–è¯­ä¹‰

- **é‡å­è¯­ä¹‰**ï¼šQKDåè®®åœ¨å¸Œå°”ä¼¯ç‰¹ç©ºé—´ä¸­çš„æ¼”åŒ–
- **ä¿¡æ¯è®ºè¯­ä¹‰**ï¼šå¯†é’¥ç†µä¸çªƒå¬è€…ä¿¡æ¯é‡çš„å…³ç³»
- **å¯†ç å­¦è¯­ä¹‰**ï¼šQKDä½œä¸ºå¯†ç å­¦åŸè¯­çš„å®‰å…¨æ€§

### 10.2 å…¸å‹å®šç†ä¸è¯æ˜

- **ä¸å¯å…‹éš†å®šç†**ï¼šé‡å­æ€æ— æ³•å®Œç¾å¤åˆ¶
- **BB84å®‰å…¨æ€§å®šç†**ï¼šé”™è¯¯ç‡é˜ˆå€¼ä¸å®‰å…¨æ€§å…³ç³»
- **è´å°”ä¸ç­‰å¼**ï¼šé‡å­çº ç¼ çš„åˆ¤æ®

### 10.3 è‡ªåŠ¨åŒ–éªŒè¯å»ºè®®

- ä½¿ç”¨Qiskitè¿›è¡Œé‡å­åè®®ä»¿çœŸ
- ä½¿ç”¨Coq/Leanå½¢å¼åŒ–QKDå®‰å…¨æ€§è¯æ˜
- ä½¿ç”¨Pythonå®ç°åè®®æ€§èƒ½åˆ†æ

## ğŸ’¼ **11. å®é™…å·¥ç¨‹åº”ç”¨æ¡ˆä¾‹ / Real-World Engineering Application Cases**

### 11.1 é‡å­å¯†é’¥åˆ†å‘ç½‘ç»œåº”ç”¨ / Quantum Key Distribution Network Applications

#### 11.1.1 ä¸­å›½é‡å­é€šä¿¡ç½‘ç»œ

**é¡¹ç›®èƒŒæ™¯**ï¼š

- **é—®é¢˜**ï¼šéœ€è¦å»ºç«‹å®‰å…¨çš„é‡å­é€šä¿¡ç½‘ç»œï¼Œå®ç°é•¿è·ç¦»é‡å­å¯†é’¥åˆ†å‘
- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨BB84åè®®æ„å»ºé‡å­é€šä¿¡ç½‘ç»œ
- **æŠ€æœ¯è¦ç‚¹**ï¼š
  - ä½¿ç”¨BB84åè®®å®ç°é‡å­å¯†é’¥åˆ†å‘
  - ä½¿ç”¨é‡å­ä¸­ç»§å™¨æ‰©å±•é€šä¿¡è·ç¦»
  - ä½¿ç”¨é‡å­å«æ˜Ÿå®ç°å…¨çƒè¦†ç›–
- **å®é™…æ•ˆæœ**ï¼š
  - äº¬æ²ªå¹²çº¿è¿æ¥åŒ—äº¬å’Œä¸Šæµ·ï¼Œæ€»é•¿åº¦è¶…è¿‡2000å…¬é‡Œ
  - å¢¨å­å·å«æ˜Ÿå®ç°æ˜Ÿåœ°é‡å­é€šä¿¡
  - å®ç°äº†å…¨çƒé¦–ä¸ªé‡å­é€šä¿¡ç½‘ç»œ

#### 11.1.2 æ¬§æ´²SECOQCç½‘ç»œ

**é¡¹ç›®èƒŒæ™¯**ï¼š

- **é—®é¢˜**ï¼šéœ€è¦å»ºç«‹æ¬§æ´²èŒƒå›´çš„é‡å­é€šä¿¡ç½‘ç»œï¼Œä¿æŠ¤å…³é”®åŸºç¡€è®¾æ–½
- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨å¤šç§QKDåè®®æ„å»ºæ¬§æ´²é‡å­é€šä¿¡ç½‘ç»œ
- **æŠ€æœ¯è¦ç‚¹**ï¼š
  - ä½¿ç”¨BB84ã€E91ç­‰å¤šç§QKDåè®®
  - ä½¿ç”¨é‡å­ä¸­ç»§å™¨è¿æ¥å¤šä¸ªåŸå¸‚
  - ä½¿ç”¨é‡å­è·¯ç”±å™¨å®ç°ç½‘ç»œè·¯ç”±
- **å®é™…æ•ˆæœ**ï¼š
  - è¿æ¥äº†å¤šä¸ªæ¬§æ´²åŸå¸‚
  - å®ç°äº†å®‰å…¨çš„é‡å­å¯†é’¥åˆ†å‘
  - ä¿æŠ¤äº†å…³é”®åŸºç¡€è®¾æ–½é€šä¿¡

### 11.2 é‡å­å®‰å…¨åº”ç”¨ / Quantum Security Applications

#### 11.2.1 é‡å­å®‰å…¨é“¶è¡Œç³»ç»Ÿ

**é¡¹ç›®èƒŒæ™¯**ï¼š

- **é—®é¢˜**ï¼šé“¶è¡Œç³»ç»Ÿéœ€è¦æœ€é«˜çº§åˆ«çš„å®‰å…¨é€šä¿¡
- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨é‡å­å¯†é’¥åˆ†å‘ä¿æŠ¤é“¶è¡Œé€šä¿¡
- **æŠ€æœ¯è¦ç‚¹**ï¼š
  - ä½¿ç”¨QKDåè®®ç”Ÿæˆå®‰å…¨å¯†é’¥
  - ä½¿ç”¨é‡å­éšæœºæ•°ç”Ÿæˆå™¨ç”Ÿæˆéšæœºæ•°
  - ä½¿ç”¨é‡å­åŠ å¯†ä¿æŠ¤æ•æ„Ÿæ•°æ®
- **å®é™…æ•ˆæœ**ï¼š
  - å®ç°äº†é“¶è¡Œé—´å®‰å…¨é€šä¿¡
  - ä¿æŠ¤äº†é‡‘èäº¤æ˜“æ•°æ®
  - æé«˜äº†é“¶è¡Œç³»ç»Ÿçš„å®‰å…¨æ€§

#### 11.2.2 é‡å­å®‰å…¨æ”¿åŠ¡ç³»ç»Ÿ

**é¡¹ç›®èƒŒæ™¯**ï¼š

- **é—®é¢˜**ï¼šæ”¿åŠ¡ç³»ç»Ÿéœ€è¦ä¿æŠ¤æ•æ„Ÿä¿¡æ¯ï¼Œé˜²æ­¢çªƒå¬
- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨é‡å­å¯†é’¥åˆ†å‘ä¿æŠ¤æ”¿åŠ¡é€šä¿¡
- **æŠ€æœ¯è¦ç‚¹**ï¼š
  - ä½¿ç”¨QKDåè®®ä¿æŠ¤æ”¿åŠ¡é€šä¿¡
  - ä½¿ç”¨é‡å­åŠ å¯†ä¿æŠ¤æ•æ„Ÿä¿¡æ¯
  - ä½¿ç”¨é‡å­éšæœºæ•°ç”Ÿæˆå™¨ä¿è¯éšæœºæ€§
- **å®é™…æ•ˆæœ**ï¼š
  - ä¿æŠ¤äº†æ”¿åŠ¡æ•æ„Ÿä¿¡æ¯
  - é˜²æ­¢äº†ä¿¡æ¯æ³„éœ²
  - æé«˜äº†æ”¿åŠ¡ç³»ç»Ÿå®‰å…¨æ€§

### 11.3 é‡å­å¯†é’¥åˆ†å‘å·¥å…·ä¸åº”ç”¨ / Quantum Key Distribution Tools and Applications

#### 11.3.1 ä¸»æµé‡å­å¯†é’¥åˆ†å‘å·¥å…·

1. **Qiskit**
   - **ç”¨é€”**ï¼šé‡å­è®¡ç®—å’Œé‡å­é€šä¿¡å¼€å‘æ¡†æ¶
   - **ç‰¹ç‚¹**ï¼šæ”¯æŒé‡å­ç”µè·¯è®¾è®¡ã€QKDåè®®å®ç°ã€é‡å­ç½‘ç»œä»¿çœŸ
   - **åº”ç”¨**ï¼šQKDåè®®å¼€å‘ã€é‡å­ç½‘ç»œä»¿çœŸã€é‡å­ç®—æ³•ç ”ç©¶

2. **QuTiP**
   - **ç”¨é€”**ï¼šé‡å­å·¥å…·åŒ…
   - **ç‰¹ç‚¹**ï¼šæ”¯æŒé‡å­ç³»ç»Ÿä»¿çœŸã€QKDåè®®åˆ†æã€é‡å­ä¿¡æ¯å¤„ç†
   - **åº”ç”¨**ï¼šQKDåè®®å»ºæ¨¡ã€å®‰å…¨æ€§åˆ†æã€é‡å­ä¿¡æ¯ç†è®ºç ”ç©¶

3. **QKD Simulator**
   - **ç”¨é€”**ï¼šé‡å­å¯†é’¥åˆ†å‘åè®®ä»¿çœŸ
   - **ç‰¹ç‚¹**ï¼šæ”¯æŒå¤šç§QKDåè®®ã€å®‰å…¨æ€§åˆ†æã€æ€§èƒ½è¯„ä¼°
   - **åº”ç”¨**ï¼šQKDåè®®è®¾è®¡ã€å®‰å…¨æ€§éªŒè¯ã€æ€§èƒ½ä¼˜åŒ–

#### 11.3.2 å®é™…åº”ç”¨æ¡ˆä¾‹

1. **ä¸­å›½é‡å­é€šä¿¡ç½‘ç»œ**
   - **å·¥å…·**ï¼šBB84åè®®ã€é‡å­ä¸­ç»§å™¨ã€é‡å­å«æ˜Ÿ
   - **åº”ç”¨å†…å®¹**ï¼šäº¬æ²ªå¹²çº¿ã€å¢¨å­å·å«æ˜Ÿã€é‡å­äº’è”ç½‘
   - **æˆæœ**ï¼šå®ç°äº†å…¨çƒé¦–ä¸ªé‡å­é€šä¿¡ç½‘ç»œï¼Œè¿æ¥äº†å¤šä¸ªåŸå¸‚

2. **æ¬§æ´²SECOQCç½‘ç»œ**
   - **å·¥å…·**ï¼šå¤šç§QKDåè®®ã€é‡å­è·¯ç”±å™¨
   - **åº”ç”¨å†…å®¹**ï¼šæ¬§æ´²é‡å­é€šä¿¡ç½‘ç»œã€å…³é”®åŸºç¡€è®¾æ–½ä¿æŠ¤
   - **æˆæœ**ï¼šè¿æ¥äº†å¤šä¸ªæ¬§æ´²åŸå¸‚ï¼Œä¿æŠ¤äº†å…³é”®åŸºç¡€è®¾æ–½é€šä¿¡

3. **é‡å­å®‰å…¨é“¶è¡Œç³»ç»Ÿ**
   - **å·¥å…·**ï¼šQKDåè®®ã€é‡å­éšæœºæ•°ç”Ÿæˆå™¨
   - **åº”ç”¨å†…å®¹**ï¼šé“¶è¡Œé—´å®‰å…¨é€šä¿¡ã€é‡‘èäº¤æ˜“ä¿æŠ¤
   - **æˆæœ**ï¼šå®ç°äº†é“¶è¡Œé—´å®‰å…¨é€šä¿¡ï¼Œä¿æŠ¤äº†é‡‘èäº¤æ˜“æ•°æ®

---

*æœ¬æ–‡æ¡£æä¾›äº†é‡å­å¯†é’¥åˆ†å‘çš„å®Œæ•´ç†è®ºæ¡†æ¶å’Œå®ç°æ–¹æ³•ï¼Œä¸ºé‡å­é€šä¿¡ç³»ç»Ÿçš„å®‰å…¨è®¾è®¡æä¾›äº†ç†è®ºåŸºç¡€ã€‚é€šè¿‡å®é™…å·¥ç¨‹åº”ç”¨æ¡ˆä¾‹ï¼Œå±•ç¤ºäº†é‡å­å¯†é’¥åˆ†å‘åœ¨ç°ä»£ä¿¡æ¯å®‰å…¨ä¸­çš„é‡è¦ä½œç”¨ã€‚*
