# é‡å­é€šä¿¡ - é‡å­å¯†é’¥åˆ†å‘ / Quantum Communication - Quantum Key Distribution

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä»‹ç»é‡å­å¯†é’¥åˆ†å‘çš„åŸºç¡€æ¦‚å¿µã€BB84åè®®ã€E91åè®®ã€BBM92åè®®ã€è¿ç»­å˜é‡QKDã€é‡å­å¯†é’¥åˆ†å‘ç½‘ç»œå’Œå®‰å…¨æ€§åˆ†æã€‚æœ¬æ–‡æ¡£å¯¹æ ‡å›½é™…é¡¶çº§æ ‡å‡†ï¼ˆMITã€Stanfordã€Caltechã€Oxfordï¼‰å’Œæœ€æ–°é‡å­é€šä¿¡ç ”ç©¶è¿›å±•ï¼ˆ2024-2025ï¼‰ï¼Œæä¾›ä¸¥æ ¼ã€å®Œæ•´ã€å›½é™…åŒ–çš„é‡å­å¯†é’¥åˆ†å‘ä½“ç³»ã€‚

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: æŒç»­æ›´æ–°ä¸­ âš™ï¸

**æ¦‚å¿µçŸ©é˜µä¸åè®®é€‰å‹å†³ç­–æ ‘**ï¼šè§ [05-é‡å­é€šä¿¡ README](../README.md) æ€ç»´è¡¨å¾å·¥å…·é›†åˆåŠ [View å¯¹æ¯”çŸ©é˜µé›†-2025](../../view/Viewæ–‡ä»¶å¤¹å¯¹æ¯”çŸ©é˜µé›†-2025.md)ã€‚

**å†å²èƒŒæ™¯ / Historical Background**:

- **1984å¹´**: Bennettå’ŒBrassardæå‡ºBB84åè®®ï¼Œå¼€åˆ›é‡å­å¯†é’¥åˆ†å‘
- **1991å¹´**: Ekertæå‡ºE91åè®®ï¼ŒåŸºäºé‡å­çº ç¼ çš„QKD
- **1992å¹´**: Bennettã€Brassardå’ŒMerminæå‡ºBBM92åè®®
- **2000å¹´ä»£**: è¿ç»­å˜é‡QKDåè®®æå‡ºï¼Œå®ç°å¤æ‚åº¦é™ä½
- **2010å¹´ä»£**: è®¾å¤‡æ— å…³QKDå’Œæµ‹é‡è®¾å¤‡æ— å…³QKDæå‡ºï¼Œå®‰å…¨æ€§æå‡
- **2016å¹´**: å¢¨å­å·é‡å­å«æ˜Ÿå‘å°„ï¼Œå®ç°æ˜Ÿåœ°é‡å­é€šä¿¡
- **2020å¹´ä»£**: é‡å­äº’è”ç½‘æ¶æ„è®¾è®¡ï¼Œå¤§è§„æ¨¡QKDç½‘ç»œéƒ¨ç½²

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [é‡å­é€šä¿¡ - é‡å­å¯†é’¥åˆ†å‘ / Quantum Communication - Quantum Key Distribution](#é‡å­é€šä¿¡---é‡å­å¯†é’¥åˆ†å‘--quantum-communication---quantum-key-distribution)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [1. é‡å­å¯†é’¥åˆ†å‘åŸºç¡€](#1-é‡å­å¯†é’¥åˆ†å‘åŸºç¡€)
    - [1.1 åŸºæœ¬å®šä¹‰](#11-åŸºæœ¬å®šä¹‰)
    - [1.2 å®‰å…¨æ¨¡å‹](#12-å®‰å…¨æ¨¡å‹)
  - [2. BB84åè®®](#2-bb84åè®®)
    - [2.0 é‡å­å¯†é’¥åˆ†å‘åè®®å¯¹æ¯”çŸ©é˜µ / Quantum Key Distribution Protocols Comparison Matrix](#20-é‡å­å¯†é’¥åˆ†å‘åè®®å¯¹æ¯”çŸ©é˜µ--quantum-key-distribution-protocols-comparison-matrix)
    - [2.1 åè®®å®šä¹‰](#21-åè®®å®šä¹‰)
    - [2.2 åè®®åˆ†æ](#22-åè®®åˆ†æ)
  - [3. E91åè®®](#3-e91åè®®)
    - [3.1 åè®®å®šä¹‰](#31-åè®®å®šä¹‰)
    - [3.2 è´å°”ä¸ç­‰å¼éªŒè¯](#32-è´å°”ä¸ç­‰å¼éªŒè¯)
  - [4. BBM92åè®®](#4-bbm92åè®®)
    - [4.1 åè®®å®šä¹‰](#41-åè®®å®šä¹‰)
  - [5. è¿ç»­å˜é‡QKD](#5-è¿ç»­å˜é‡qkd)
    - [5.1 è¿ç»­å˜é‡å®šä¹‰](#51-è¿ç»­å˜é‡å®šä¹‰)
    - [5.2 è¿ç»­å˜é‡QKDçš„å®‰å…¨æ€§](#52-è¿ç»­å˜é‡qkdçš„å®‰å…¨æ€§)
  - [ğŸš€ **5.3 æœ€æ–°QKDåè®®ï¼ˆ2024-2025ï¼‰/ Latest QKD Protocols (2024-2025)**](#-53-æœ€æ–°qkdåè®®2024-2025-latest-qkd-protocols-2024-2025)
    - [5.3.1 è®¾å¤‡æ— å…³QKD (DI-QKD)](#531-è®¾å¤‡æ— å…³qkd-di-qkd)
    - [5.3.2 æµ‹é‡è®¾å¤‡æ— å…³QKD (MDI-QKD)](#532-æµ‹é‡è®¾å¤‡æ— å…³qkd-mdi-qkd)
    - [5.3.3 å«æ˜ŸQKDç½‘ç»œ](#533-å«æ˜Ÿqkdç½‘ç»œ)
  - [6. é‡å­å¯†é’¥åˆ†å‘ç½‘ç»œ](#6-é‡å­å¯†é’¥åˆ†å‘ç½‘ç»œ)
    - [6.1 ç½‘ç»œæ‹“æ‰‘](#61-ç½‘ç»œæ‹“æ‰‘)
    - [6.2 é‡å­äº’è”ç½‘æ¶æ„ï¼ˆ2024-2025æœ€æ–°è¿›å±•ï¼‰](#62-é‡å­äº’è”ç½‘æ¶æ„2024-2025æœ€æ–°è¿›å±•)
      - [6.2.1 é‡å­äº’è”ç½‘å±‚æ¬¡ç»“æ„](#621-é‡å­äº’è”ç½‘å±‚æ¬¡ç»“æ„)
      - [6.2.2 é‡å­ä¸­ç»§å™¨æŠ€æœ¯](#622-é‡å­ä¸­ç»§å™¨æŠ€æœ¯)
      - [6.2.3 é‡å­-ç»å…¸æ··åˆç½‘ç»œ](#623-é‡å­-ç»å…¸æ··åˆç½‘ç»œ)
  - [7. å®‰å…¨æ€§åˆ†æ](#7-å®‰å…¨æ€§åˆ†æ)
    - [7.1 ä¿¡æ¯è®ºå®‰å…¨æ€§](#71-ä¿¡æ¯è®ºå®‰å…¨æ€§)
  - [8. å¤šæ¨¡æ€è¡¨è¾¾ä¸å¯è§†åŒ–](#8-å¤šæ¨¡æ€è¡¨è¾¾ä¸å¯è§†åŒ–)
    - [8.1 åè®®æµç¨‹å›¾](#81-åè®®æµç¨‹å›¾)
    - [8.2 é‡å­ç”µè·¯å›¾](#82-é‡å­ç”µè·¯å›¾)
    - [8.3 å®‰å…¨æ€§åˆ†æå›¾](#83-å®‰å…¨æ€§åˆ†æå›¾)
  - [9. è‡ªåŠ¨åŒ–è„šæœ¬å»ºè®®](#9-è‡ªåŠ¨åŒ–è„šæœ¬å»ºè®®)
    - [9.1 åè®®å®ç°è„šæœ¬](#91-åè®®å®ç°è„šæœ¬)
    - [9.2 å®‰å…¨æ€§åˆ†æè„šæœ¬](#92-å®‰å…¨æ€§åˆ†æè„šæœ¬)
    - [9.3 ç½‘ç»œä»¿çœŸè„šæœ¬](#93-ç½‘ç»œä»¿çœŸè„šæœ¬)
  - [10. å½¢å¼åŒ–è¯­ä¹‰ä¸æ¦‚å¿µè§£é‡Š](#10-å½¢å¼åŒ–è¯­ä¹‰ä¸æ¦‚å¿µè§£é‡Š)
    - [10.1 å½¢å¼åŒ–è¯­ä¹‰](#101-å½¢å¼åŒ–è¯­ä¹‰)
    - [10.2 å…¸å‹å®šç†ä¸è¯æ˜](#102-å…¸å‹å®šç†ä¸è¯æ˜)
    - [10.3 è‡ªåŠ¨åŒ–éªŒè¯å»ºè®®](#103-è‡ªåŠ¨åŒ–éªŒè¯å»ºè®®)
  - [ğŸ’¼ **11. å®é™…å·¥ç¨‹åº”ç”¨æ¡ˆä¾‹ / Real-World Engineering Application Cases**](#-11-å®é™…å·¥ç¨‹åº”ç”¨æ¡ˆä¾‹--real-world-engineering-application-cases)
    - [11.1 é‡å­å¯†é’¥åˆ†å‘ç½‘ç»œåº”ç”¨ / Quantum Key Distribution Network Applications](#111-é‡å­å¯†é’¥åˆ†å‘ç½‘ç»œåº”ç”¨--quantum-key-distribution-network-applications)
      - [11.1.1 ä¸­å›½é‡å­é€šä¿¡ç½‘ç»œ](#1111-ä¸­å›½é‡å­é€šä¿¡ç½‘ç»œ)
      - [11.1.2 æ¬§æ´²SECOQCç½‘ç»œ](#1112-æ¬§æ´²secoqcç½‘ç»œ)
    - [11.2 é‡å­å®‰å…¨åº”ç”¨ / Quantum Security Applications](#112-é‡å­å®‰å…¨åº”ç”¨--quantum-security-applications)
      - [11.2.1 é‡å­å®‰å…¨é“¶è¡Œç³»ç»Ÿ](#1121-é‡å­å®‰å…¨é“¶è¡Œç³»ç»Ÿ)
      - [11.2.2 é‡å­å®‰å…¨æ”¿åŠ¡ç³»ç»Ÿ](#1122-é‡å­å®‰å…¨æ”¿åŠ¡ç³»ç»Ÿ)
    - [11.3 é‡å­å¯†é’¥åˆ†å‘å·¥å…·ä¸åº”ç”¨ / Quantum Key Distribution Tools and Applications](#113-é‡å­å¯†é’¥åˆ†å‘å·¥å…·ä¸åº”ç”¨--quantum-key-distribution-tools-and-applications)
      - [11.3.1 ä¸»æµé‡å­å¯†é’¥åˆ†å‘å·¥å…·](#1131-ä¸»æµé‡å­å¯†é’¥åˆ†å‘å·¥å…·)
      - [11.3.2 å®é™…åº”ç”¨æ¡ˆä¾‹](#1132-å®é™…åº”ç”¨æ¡ˆä¾‹)

---

## 1. é‡å­å¯†é’¥åˆ†å‘åŸºç¡€

### 1.1 åŸºæœ¬å®šä¹‰

**å®šä¹‰ 1.1** (é‡å­å¯†é’¥åˆ†å‘ - Quantum Key Distribution)
**é‡å­å¯†é’¥åˆ†å‘**æ˜¯åˆ©ç”¨é‡å­åŠ›å­¦åŸç†åœ¨ä¸¤ä¸ªæˆ–å¤šä¸ªå‚ä¸æ–¹ä¹‹é—´å®‰å…¨åˆ†å‘å¯†é’¥çš„åè®®ï¼š
$$\mathcal{QKD} = \langle \mathcal{P}, \mathcal{Q}, \mathcal{M}, \mathcal{V}, \mathcal{K} \rangle$$

å…¶ä¸­ï¼š

- $\mathcal{P}$ æ˜¯åè®®å‚ä¸æ–¹é›†
- $\mathcal{Q}$ æ˜¯é‡å­ç³»ç»Ÿé›†
- $\mathcal{M}$ æ˜¯æµ‹é‡åŸºé›†
- $\mathcal{V}$ æ˜¯éªŒè¯æ–¹æ³•é›†
- $\mathcal{K}$ æ˜¯å¯†é’¥ç”Ÿæˆç®—æ³•é›†

**å®šä¹‰ 1.2** (é‡å­å¯†é’¥åˆ†å‘å®‰å…¨æ€§)
**é‡å­å¯†é’¥åˆ†å‘å®‰å…¨æ€§**æ˜¯æŒ‡åè®®åœ¨å­˜åœ¨çªƒå¬è€…çš„æƒ…å†µä¸‹ä»èƒ½ç”Ÿæˆå®‰å…¨å¯†é’¥ï¼š
$$\text{Security}(\mathcal{QKD}) = \text{Privacy} \land \text{Authenticity} \land \text{Completeness}$$

**å½¢å¼åŒ–è¯­ä¹‰**ï¼š

- é›†åˆè®ºè¯­ä¹‰ï¼š$\mathcal{P} \neq \emptyset, \mathcal{Q} \subseteq \mathcal{H}^{\otimes n}, \mathcal{M} \subseteq \mathcal{B}(\mathcal{H})$
- èŒƒç•´è®ºè¯­ä¹‰ï¼šQKDåè®®ä½œä¸ºé‡å­åè®®èŒƒç•´ä¸­çš„æ€å°„
- è‡ªåŠ¨æœºè¯­ä¹‰ï¼šQKDå¯å»ºæ¨¡ä¸ºé‡å­è‡ªåŠ¨æœº $A = (Q, \Sigma, \delta, q_0, F)$

### 1.2 å®‰å…¨æ¨¡å‹

**å®šä¹‰ 1.3** (çªƒå¬æ¨¡å‹)
**çªƒå¬æ¨¡å‹**æè¿°æ”»å‡»è€…çš„èƒ½åŠ›ï¼š
$$\mathcal{E} = \langle \mathcal{A}, \mathcal{C}, \mathcal{O}, \mathcal{Q} \rangle$$

å…¶ä¸­ï¼š

- $\mathcal{A}$ æ˜¯æ”»å‡»è€…ç±»å‹ï¼ˆå¦‚Eveï¼‰
- $\mathcal{C}$ æ˜¯è®¡ç®—èƒ½åŠ›
- $\mathcal{O}$ æ˜¯è§‚æµ‹èƒ½åŠ›
- $\mathcal{Q}$ æ˜¯é‡å­æ“ä½œèƒ½åŠ›

**å®šä¹‰ 1.4** (ä¸å¯å…‹éš†å®šç†)
**ä¸å¯å…‹éš†å®šç†**ï¼šæœªçŸ¥é‡å­æ€æ— æ³•è¢«å®Œç¾å¤åˆ¶ï¼š
$$\nexists U \text{ s.t. } U|\psi\rangle|0\rangle = |\psi\rangle|\psi\rangle \text{ for all } |\psi\rangle$$

**å®šç† 1.1** (ä¸å¯å…‹éš†å®šç†è¯æ˜)
**è¯æ˜**ï¼š

1. å‡è®¾å­˜åœ¨å¹ºæ­£ç®—ç¬¦ $U$ ä½¿å¾— $U|\psi\rangle|0\rangle = |\psi\rangle|\psi\rangle$
2. å¯¹ä»»æ„ $|\psi\rangle, |\phi\rangle$ï¼Œæœ‰ï¼š
   $$\langle\psi|\phi\rangle = \langle\psi|\phi\rangle^2$$
3. è¿™ä»…åœ¨ $|\psi\rangle = |\phi\rangle$ æˆ– $\langle\psi|\phi\rangle = 0$ æ—¶æˆç«‹
4. çŸ›ç›¾ï¼Œæ•…ä¸å­˜åœ¨è¿™æ ·çš„ $U$

$\boxed{\text{è¯æ¯•}}$

## 2. BB84åè®®

### 2.0 é‡å­å¯†é’¥åˆ†å‘åè®®å¯¹æ¯”çŸ©é˜µ / Quantum Key Distribution Protocols Comparison Matrix

| åè®® | é‡å­èµ„æº | å®‰å…¨æ€§åŸºç¡€ | å®ç°å¤æ‚åº¦ | ä¼ è¾“è·ç¦» | å¯†é’¥ç‡ | ä¼˜ç‚¹ | ç¼ºç‚¹ | å…¸å‹åº”ç”¨ |
|------|---------|-----------|-----------|---------|--------|------|------|---------|
| **BB84** | å•å…‰å­ | ä¸å¯å…‹éš†å®šç† | ä¸­ç­‰ | ä¸­ç­‰ | ä¸­ç­‰ | æˆç†Ÿã€ç¨³å®š | éœ€è¦å•å…‰å­æº | å…‰çº¤ç½‘ç»œ |
| **E91** | çº ç¼ å¯¹ | è´å°”ä¸ç­‰å¼ | é«˜ | é•¿ | é«˜ | å®‰å…¨æ€§å¼º | éœ€è¦çº ç¼ æº | é•¿è·ç¦»é€šä¿¡ |
| **BBM92** | çº ç¼ å¯¹ | è´å°”ä¸ç­‰å¼ | é«˜ | é•¿ | é«˜ | åŸºäºçº ç¼  | å®ç°å¤æ‚ | é‡å­ç½‘ç»œ |
| **è¿ç»­å˜é‡QKD** | è¿ç»­å˜é‡ | ä¸å¯å…‹éš†å®šç† | ä½ | çŸ­ | é«˜ | å®ç°ç®€å• | å®‰å…¨æ€§è¾ƒå¼± | çŸ­è·ç¦»é€šä¿¡ |
| **SARG04** | å•å…‰å­ | ä¸å¯å…‹éš†å®šç† | ä¸­ç­‰ | ä¸­ç­‰ | ä¸­ç­‰ | æŠ—PNSæ”»å‡» | æ•ˆç‡è¾ƒä½ | æ”¹è¿›BB84 |
| **DPS** | å•å…‰å­ | ä¸å¯å…‹éš†å®šç† | ä¸­ç­‰ | ä¸­ç­‰ | ä¸­ç­‰ | ç›¸ä½ç¼–ç  | éœ€è¦ç¨³å®šç›¸ä½ | ç›¸ä½ç¼–ç ç³»ç»Ÿ |

**ç¬¦å·è¯´æ˜**ï¼š

- PNSï¼šå…‰å­æ•°åˆ†ç¦»æ”»å‡»
- DPSï¼šå·®åˆ†ç›¸ä½åç§»

### 2.1 åè®®å®šä¹‰

**å®šä¹‰ 2.1** (BB84åè®®)
**BB84åè®®**æ˜¯ç¬¬ä¸€ä¸ªé‡å­å¯†é’¥åˆ†å‘åè®®ï¼Œç”±Bennettå’ŒBrassardäº1984å¹´æå‡ºï¼š
$$\text{BB84} = \langle \text{Preparation}, \text{Transmission}, \text{Measurement}, \text{Sifting}, \text{ErrorEstimation}, \text{PrivacyAmplification} \rangle$$

**ç®—æ³• 2.1** (BB84åè®®å®ç°)

```python
import numpy as np
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.quantum_info import Operator

class BB84Protocol:
    def __init__(self, key_length=1000):
        self.key_length = key_length
        self.alice_bits = []
        self.alice_bases = []
        self.bob_bits = []
        self.bob_bases = []
        self.shared_key = []

    def alice_prepare_qubits(self):
        """Aliceå‡†å¤‡é‡å­æ¯”ç‰¹"""
        for i in range(self.key_length):
            # éšæœºé€‰æ‹©æ¯”ç‰¹å’ŒåŸº
            bit = np.random.randint(0, 2)
            basis = np.random.randint(0, 2)  # 0: ZåŸº, 1: XåŸº

            self.alice_bits.append(bit)
            self.alice_bases.append(basis)

            # åˆ›å»ºé‡å­ç”µè·¯
            qc = QuantumCircuit(1, 1)

            if basis == 0:  # ZåŸº
                if bit == 1:
                    qc.x(0)
            else:  # XåŸº
                qc.h(0)
                if bit == 1:
                    qc.x(0)
                qc.h(0)

            yield qc

    def bob_measure_qubits(self, qubits):
        """Bobæµ‹é‡é‡å­æ¯”ç‰¹"""
        for i, qubit in enumerate(qubits):
            # éšæœºé€‰æ‹©æµ‹é‡åŸº
            basis = np.random.randint(0, 2)
            self.bob_bases.append(basis)

            # æµ‹é‡
            if basis == 0:  # ZåŸºæµ‹é‡
                result = qubit.measure_all(inplace=False)
            else:  # XåŸºæµ‹é‡
                qubit.h(0)
                result = qubit.measure_all(inplace=False)

            self.bob_bits.append(result.get_counts()['1'])

    def sifting(self):
        """ç­›é€‰ç›¸åŒåŸºçš„æµ‹é‡ç»“æœ"""
        for i in range(self.key_length):
            if self.alice_bases[i] == self.bob_bases[i]:
                self.shared_key.append(self.alice_bits[i])

        return len(self.shared_key)

    def estimate_error_rate(self, sample_size=100):
        """ä¼°è®¡é”™è¯¯ç‡"""
        if len(self.shared_key) < sample_size:
            return 1.0

        # éšæœºé€‰æ‹©æ ·æœ¬è¿›è¡Œé”™è¯¯ä¼°è®¡
        sample_indices = np.random.choice(
            len(self.shared_key),
            min(sample_size, len(self.shared_key)),
            replace=False
        )

        errors = 0
        for idx in sample_indices:
            if self.alice_bits[idx] != self.bob_bits[idx]:
                errors += 1

        return errors / len(sample_indices)

    def privacy_amplification(self, final_length=256):
        """éšç§æ”¾å¤§"""
        if len(self.shared_key) < final_length:
            return None

        # ä½¿ç”¨éšæœºçŸ©é˜µè¿›è¡Œéšç§æ”¾å¤§
        matrix = np.random.randint(0, 2, (final_length, len(self.shared_key)))
        final_key = np.dot(matrix, self.shared_key) % 2

        return final_key.tolist()
```

### 2.2 åè®®åˆ†æ

**å®šç† 2.1** (BB84å®‰å…¨æ€§)
BB84åè®®åœ¨å­˜åœ¨çªƒå¬è€…çš„æƒ…å†µä¸‹ï¼Œå¦‚æœé”™è¯¯ç‡ä½äº11%ï¼Œåˆ™èƒ½ç”Ÿæˆå®‰å…¨å¯†é’¥ã€‚

**è¯æ˜**ï¼š

1. çªƒå¬è€…Eveçš„å¹²æ‰°ä¼šå¼•å…¥é”™è¯¯
2. é”™è¯¯ç‡ $e$ ä¸çªƒå¬è€…è·å¾—çš„ä¿¡æ¯é‡ç›¸å…³
3. å½“ $e < 11\%$ æ—¶ï¼Œéšç§æ”¾å¤§èƒ½æ¶ˆé™¤Eveçš„ä¿¡æ¯
4. æœ€ç»ˆå¯†é’¥çš„å®‰å…¨æ€§ç”±ä¿¡æ¯è®ºä¿è¯

$\boxed{\text{è¯æ¯•}}$

**ç®—æ³• 2.2** (BB84å®‰å…¨æ€§åˆ†æ)

```python
def bb84_security_analysis(error_rate):
    """BB84å®‰å…¨æ€§åˆ†æ"""
    # è®¡ç®—çªƒå¬è€…è·å¾—çš„ä¿¡æ¯é‡
    if error_rate <= 0.11:
        # ä½¿ç”¨éšç§æ”¾å¤§æ¶ˆé™¤çªƒå¬è€…ä¿¡æ¯
        privacy_amplification_rate = 1 - 2 * error_rate
        return True, privacy_amplification_rate
    else:
        return False, 0.0

def calculate_secure_key_rate(error_rate, raw_key_rate):
    """è®¡ç®—å®‰å…¨å¯†é’¥ç‡"""
    if error_rate > 0.11:
        return 0.0

    # è€ƒè™‘é”™è¯¯çº æ­£å’Œéšç§æ”¾å¤§çš„å¼€é”€
    error_correction_rate = 1 - h(error_rate)  # h(x)æ˜¯äºŒè¿›åˆ¶ç†µå‡½æ•°
    privacy_amplification_rate = 1 - 2 * error_rate

    secure_rate = raw_key_rate * error_correction_rate * privacy_amplification_rate
    return secure_rate

def h(x):
    """äºŒè¿›åˆ¶ç†µå‡½æ•°"""
    if x == 0 or x == 1:
        return 0
    return -x * np.log2(x) - (1-x) * np.log2(1-x)
```

## 3. E91åè®®

### 3.1 åè®®å®šä¹‰

**å®šä¹‰ 3.1** (E91åè®®)
**E91åè®®**æ˜¯åŸºäºé‡å­çº ç¼ çš„å¯†é’¥åˆ†å‘åè®®ï¼š
$$\text{E91} = \langle \text{EntanglementDistribution}, \text{Measurement}, \text{CorrelationAnalysis}, \text{KeyGeneration} \rangle$$

**ç®—æ³• 3.1** (E91åè®®å®ç°)

```python
class E91Protocol:
    def __init__(self, key_length=1000):
        self.key_length = key_length
        self.alice_measurements = []
        self.bob_measurements = []
        self.alice_bases = []
        self.bob_bases = []
        self.shared_key = []

    def prepare_bell_pairs(self):
        """å‡†å¤‡Bellæ€å¯¹"""
        bell_pairs = []
        for i in range(self.key_length):
            # åˆ›å»ºBellæ€ |Î¦âºâŸ© = (|00âŸ© + |11âŸ©)/âˆš2
            qc = QuantumCircuit(2, 2)
            qc.h(0)
            qc.cx(0, 1)
            bell_pairs.append(qc)

        return bell_pairs

    def alice_measure(self, bell_pairs):
        """Aliceæµ‹é‡Bellæ€çš„ç¬¬ä¸€éƒ¨åˆ†"""
        for i, bell_pair in enumerate(bell_pairs):
            # éšæœºé€‰æ‹©æµ‹é‡åŸº
            basis = np.random.choice([0, 45, 90, 135])  # è§’åº¦
            self.alice_bases.append(basis)

            # åº”ç”¨æ—‹è½¬é—¨
            qc = bell_pair.copy()
            qc.rz(np.radians(basis), 0)
            qc.h(0)

            # æµ‹é‡
            result = qc.measure_all(inplace=False)
            self.alice_measurements.append(result.get_counts()['1'])

    def bob_measure(self, bell_pairs):
        """Bobæµ‹é‡Bellæ€çš„ç¬¬äºŒéƒ¨åˆ†"""
        for i, bell_pair in enumerate(bell_pairs):
            # éšæœºé€‰æ‹©æµ‹é‡åŸº
            basis = np.random.choice([0, 45, 90, 135])
            self.bob_bases.append(basis)

            # åº”ç”¨æ—‹è½¬é—¨
            qc = bell_pair.copy()
            qc.rz(np.radians(basis), 1)
            qc.h(1)

            # æµ‹é‡
            result = qc.measure_all(inplace=False)
            self.bob_measurements.append(result.get_counts()['1'])

    def analyze_correlations(self):
        """åˆ†ææµ‹é‡ç›¸å…³æ€§"""
        correlations = []
        for i in range(self.key_length):
            if self.alice_bases[i] == self.bob_bases[i]:
                # ç›¸åŒåŸºçš„æµ‹é‡ç»“æœåº”è¯¥ç›¸å…³
                correlation = self.alice_measurements[i] == self.bob_measurements[i]
                correlations.append(correlation)

        return correlations

    def generate_key(self, correlations):
        """åŸºäºç›¸å…³æ€§ç”Ÿæˆå¯†é’¥"""
        for i, correlation in enumerate(correlations):
            if correlation:
                # ç›¸å…³ç»“æœç”¨äºç”Ÿæˆå¯†é’¥
                self.shared_key.append(self.alice_measurements[i])

        return len(self.shared_key)
```

### 3.2 è´å°”ä¸ç­‰å¼éªŒè¯

**å®šä¹‰ 3.2** (è´å°”ä¸ç­‰å¼)
**è´å°”ä¸ç­‰å¼**æ˜¯åŒºåˆ†ç»å…¸ç›¸å…³æ€§å’Œé‡å­çº ç¼ çš„åˆ¤æ®ï¼š
$$|E(a,b) - E(a,b') + E(a',b) + E(a',b')| \leq 2$$

å…¶ä¸­ $E(a,b)$ æ˜¯æµ‹é‡åŸº $a$ å’Œ $b$ çš„ç›¸å…³æ€§ã€‚

**ç®—æ³• 3.2** (è´å°”ä¸ç­‰å¼éªŒè¯)

```python
def bell_inequality_test(measurements, bases):
    """è´å°”ä¸ç­‰å¼æµ‹è¯•"""
    # è®¡ç®—ä¸åŒåŸºç»„åˆçš„ç›¸å…³æ€§
    correlations = {}

    for a in [0, 45, 90, 135]:
        for b in [0, 45, 90, 135]:
            if a != b:
                # æ‰¾åˆ°ä½¿ç”¨åŸºaå’Œbçš„æµ‹é‡
                a_indices = [i for i, base in enumerate(bases) if base == a]
                b_indices = [i for i, base in enumerate(bases) if base == b]

                # è®¡ç®—ç›¸å…³æ€§
                if a_indices and b_indices:
                    common_indices = set(a_indices) & set(b_indices)
                    if common_indices:
                        correlation = sum(1 for i in common_indices
                                        if measurements[i] == measurements[i+1]) / len(common_indices)
                        correlations[(a, b)] = correlation

    # è®¡ç®—è´å°”ä¸ç­‰å¼
    bell_value = abs(correlations.get((0, 0), 0) - correlations.get((0, 45), 0) +
                    correlations.get((90, 0), 0) + correlations.get((90, 45), 0))

    return bell_value, bell_value > 2  # è¿åè´å°”ä¸ç­‰å¼è¡¨ç¤ºå­˜åœ¨é‡å­çº ç¼ 
```

## 4. BBM92åè®®

### 4.1 åè®®å®šä¹‰

**å®šä¹‰ 4.1** (BBM92åè®®)
**BBM92åè®®**æ˜¯BB84çš„æ”¹è¿›ç‰ˆæœ¬ï¼Œä½¿ç”¨çº ç¼ å…‰å­å¯¹ï¼š
$$\text{BBM92} = \langle \text{EntangledPairGeneration}, \text{Distribution}, \text{Measurement}, \text{KeyExtraction} \rangle$$

**ç®—æ³• 4.1** (BBM92åè®®å®ç°)

```python
class BBM92Protocol:
    def __init__(self, key_length=1000):
        self.key_length = key_length
        self.alice_results = []
        self.bob_results = []
        self.alice_bases = []
        self.bob_bases = []
        self.shared_key = []

    def generate_entangled_pairs(self):
        """ç”Ÿæˆçº ç¼ å…‰å­å¯¹"""
        entangled_pairs = []
        for i in range(self.key_length):
            # åˆ›å»ºçº ç¼ æ€ |Î¨â»âŸ© = (|01âŸ© - |10âŸ©)/âˆš2
            qc = QuantumCircuit(2, 2)
            qc.x(0)
            qc.h(0)
            qc.cx(0, 1)
            qc.z(1)
            entangled_pairs.append(qc)

        return entangled_pairs

    def alice_measure_entangled_qubit(self, entangled_pairs):
        """Aliceæµ‹é‡çº ç¼ å¯¹çš„ç¬¬ä¸€éƒ¨åˆ†"""
        for i, pair in enumerate(entangled_pairs):
            # éšæœºé€‰æ‹©æµ‹é‡åŸº
            basis = np.random.randint(0, 2)  # 0: ZåŸº, 1: XåŸº
            self.alice_bases.append(basis)

            # æµ‹é‡
            qc = pair.copy()
            if basis == 1:  # XåŸºæµ‹é‡
                qc.h(0)
            result = qc.measure_all(inplace=False)
            self.alice_results.append(result.get_counts()['1'])

    def bob_measure_entangled_qubit(self, entangled_pairs):
        """Bobæµ‹é‡çº ç¼ å¯¹çš„ç¬¬äºŒéƒ¨åˆ†"""
        for i, pair in enumerate(entangled_pairs):
            # éšæœºé€‰æ‹©æµ‹é‡åŸº
            basis = np.random.randint(0, 2)
            self.bob_bases.append(basis)

            # æµ‹é‡
            qc = pair.copy()
            if basis == 1:  # XåŸºæµ‹é‡
                qc.h(1)
            result = qc.measure_all(inplace=False)
            self.bob_results.append(result.get_counts()['1'])

    def extract_key(self):
        """æå–å¯†é’¥"""
        for i in range(self.key_length):
            if self.alice_bases[i] == self.bob_bases[i]:
                # ç›¸åŒåŸºçš„æµ‹é‡ç»“æœç”¨äºç”Ÿæˆå¯†é’¥
                self.shared_key.append(self.alice_results[i])

        return len(self.shared_key)
```

## 5. è¿ç»­å˜é‡QKD

### 5.1 è¿ç»­å˜é‡å®šä¹‰

**å®šä¹‰ 5.1** (è¿ç»­å˜é‡QKD / Continuous Variable QKD)

**è¿ç»­å˜é‡QKD**ä½¿ç”¨è¿ç»­å˜é‡ï¼ˆå¦‚ä½ç½®å’ŒåŠ¨é‡ï¼‰è¿›è¡Œå¯†é’¥åˆ†å‘ï¼š
$$\text{CV-QKD} = \langle \text{CoherentStatePreparation}, \text{Modulation}, \text{HeterodyneDetection}, \text{PostProcessing} \rangle$$

### 5.2 è¿ç»­å˜é‡QKDçš„å®‰å…¨æ€§

**å®šç† 5.1** (è¿ç»­å˜é‡QKDå®‰å…¨æ€§)

è¿ç»­å˜é‡QKDåœ¨å­˜åœ¨é«˜æ–¯å™ªå£°çš„æƒ…å†µä¸‹ï¼Œå¦‚æœä¿¡å™ªæ¯”ï¼ˆSNRï¼‰è¶³å¤Ÿé«˜ï¼Œåˆ™èƒ½ç”Ÿæˆå®‰å…¨å¯†é’¥ã€‚

**å®‰å…¨å¯†é’¥ç‡**ï¼š
$$R_{secure} = \beta I_{AB} - \chi_{BE}$$

å…¶ä¸­ï¼š

- $\beta$ æ˜¯åå¤„ç†æ•ˆç‡
- $I_{AB}$ æ˜¯Aliceå’ŒBobä¹‹é—´çš„äº’ä¿¡æ¯
- $\chi_{BE}$ æ˜¯Bobå’ŒEveä¹‹é—´çš„Holevoç•Œ

## ğŸš€ **5.3 æœ€æ–°QKDåè®®ï¼ˆ2024-2025ï¼‰/ Latest QKD Protocols (2024-2025)**

### 5.3.1 è®¾å¤‡æ— å…³QKD (DI-QKD)

**å®šä¹‰ 5.3.1** (è®¾å¤‡æ— å…³QKD / Device-Independent QKD)

**è®¾å¤‡æ— å…³QKD**ä¸ä¾èµ–äºè®¾å¤‡çš„å®‰å…¨æ€§å‡è®¾ï¼Œä»…åŸºäºé‡å­åŠ›å­¦çš„åŸºæœ¬åŸç†ï¼š

$$\text{DI-QKD} = \langle \text{BellTest}, \text{CHSHInequality}, \text{KeyExtraction} \rangle$$

**å®‰å…¨æ€§åŸºç¡€**ï¼š

1. **è´å°”ä¸ç­‰å¼è¿å**ï¼šè¯æ˜å­˜åœ¨é‡å­çº ç¼ 
2. **æ— æ¼æ´è´å°”æµ‹è¯•**ï¼šæ’é™¤æ‰€æœ‰å¯èƒ½çš„æ¼æ´
3. **è‡ªæµ‹è¯•**ï¼šä»æµ‹é‡ç»“æœæ¨æ–­è®¾å¤‡çŠ¶æ€

**å®šç† 5.3.1** (è®¾å¤‡æ— å…³QKDå®‰å…¨æ€§)

å¦‚æœCHSHå€¼ $S > 2$ï¼Œåˆ™è®¾å¤‡æ— å…³QKDèƒ½ç”Ÿæˆå®‰å…¨å¯†é’¥ï¼Œå®‰å…¨å¯†é’¥ç‡ä¸ºï¼š
$$R_{DI-QKD} \geq 1 - h\left(\frac{1 + \sqrt{(S/2)^2 - 1}}{2}\right) - h\left(\frac{1 + \sqrt{2 - (S/2)^2}}{2}\right)$$

å…¶ä¸­ $h(x) = -x\log_2 x - (1-x)\log_2(1-x)$ æ˜¯äºŒè¿›åˆ¶ç†µå‡½æ•°ã€‚

**è¯æ˜æ€è·¯**ï¼š

1. CHSHå€¼ $S > 2$ è¯æ˜å­˜åœ¨é‡å­çº ç¼ 
2. çº ç¼ çš„å­˜åœ¨ä¿è¯å¯†é’¥çš„å®‰å…¨æ€§
3. é€šè¿‡ä¿¡æ¯è®ºæ–¹æ³•è®¡ç®—å®‰å…¨å¯†é’¥ç‡

**ç®—æ³• 5.3.1** (è®¾å¤‡æ— å…³QKDå®ç° / Device-Independent QKD Implementation)

```python
class DeviceIndependentQKD:
    """è®¾å¤‡æ— å…³QKDå®ç°"""

    def __init__(self, num_rounds=10000):
        self.num_rounds = num_rounds
        self.alice_inputs = []
        self.bob_inputs = []
        self.alice_outputs = []
        self.bob_outputs = []
        self.shared_key = []

    def bell_test_round(self):
        """æ‰§è¡Œä¸€è½®è´å°”æµ‹è¯•"""
        # Aliceå’ŒBobéšæœºé€‰æ‹©æµ‹é‡è®¾ç½®
        alice_input = np.random.randint(0, 2)  # 0æˆ–1
        bob_input = np.random.randint(0, 2)    # 0æˆ–1

        self.alice_inputs.append(alice_input)
        self.bob_inputs.append(bob_input)

        # æ‰§è¡Œæµ‹é‡ï¼ˆä½¿ç”¨çº ç¼ æ€ï¼‰
        # è¿™é‡Œå‡è®¾æœ‰å…±äº«çš„Bellæ€
        alice_output, bob_output = self.perform_bell_measurement(
            alice_input, bob_input
        )

        self.alice_outputs.append(alice_output)
        self.bob_outputs.append(bob_output)

        return alice_output, bob_output

    def compute_chsh_value(self):
        """è®¡ç®—CHSHå€¼"""
        # CHSHå€¼: S = E(0,0) - E(0,1) + E(1,0) + E(1,1)
        # å…¶ä¸­ E(x,y) = P(a=b|x,y) - P(aâ‰ b|x,y)

        correlations = {}
        for x in [0, 1]:
            for y in [0, 1]:
                # è®¡ç®—ç›¸å…³æ€§
                matches = sum(
                    1 for i in range(self.num_rounds)
                    if self.alice_inputs[i] == x and
                    self.bob_inputs[i] == y and
                    self.alice_outputs[i] == self.bob_outputs[i]
                )
                total = sum(
                    1 for i in range(self.num_rounds)
                    if self.alice_inputs[i] == x and self.bob_inputs[i] == y
                )
                if total > 0:
                    prob_match = matches / total
                    correlations[(x, y)] = 2 * prob_match - 1  # E(x,y)

        chsh_value = (
            correlations.get((0, 0), 0) -
            correlations.get((0, 1), 0) +
            correlations.get((1, 0), 0) +
            correlations.get((1, 1), 0)
        )

        return chsh_value

    def extract_key(self, chsh_value, threshold=2.0):
        """æå–å¯†é’¥"""
        if chsh_value <= threshold:
            # CHSHå€¼ä¸å¤Ÿé«˜ï¼Œæ— æ³•ä¿è¯å®‰å…¨æ€§
            return None

        # ä½¿ç”¨æ»¡è¶³ç‰¹å®šæ¡ä»¶çš„è½®æ¬¡ç”Ÿæˆå¯†é’¥
        for i in range(self.num_rounds):
            # ä½¿ç”¨è¾“å…¥ä¸º(0,0)çš„è½®æ¬¡ç”Ÿæˆå¯†é’¥
            if self.alice_inputs[i] == 0 and self.bob_inputs[i] == 0:
                self.shared_key.append(self.alice_outputs[i])

        return self.shared_key

# å¤æ‚åº¦åˆ†æ
# æ—¶é—´å¤æ‚åº¦: O(n) å…¶ä¸­næ˜¯è½®æ¬¡æ•°
# ç©ºé—´å¤æ‚åº¦: O(n) å­˜å‚¨æ‰€æœ‰æµ‹é‡ç»“æœ
```

### 5.3.2 æµ‹é‡è®¾å¤‡æ— å…³QKD (MDI-QKD)

**å®šä¹‰ 5.3.2** (æµ‹é‡è®¾å¤‡æ— å…³QKD / Measurement-Device-Independent QKD)

**æµ‹é‡è®¾å¤‡æ— å…³QKD**ä¸ä¾èµ–äºæµ‹é‡è®¾å¤‡çš„å®‰å…¨æ€§ï¼Œä»…è¦æ±‚æºçš„å®‰å…¨æ€§ï¼š

$$\text{MDI-QKD} = \langle \text{SourcePreparation}, \text{UntrustedMeasurement}, \text{PostSelection}, \text{KeyExtraction} \rangle$$

**å®‰å…¨æ€§ä¼˜åŠ¿**ï¼š

1. **æŠµæŠ—æ‰€æœ‰æµ‹é‡ç«¯æ”»å‡»**ï¼šåŒ…æ‹¬å…‰å­æ•°åˆ†ç¦»æ”»å‡»ã€æ—¶é—´ä½ç§»æ”»å‡»ç­‰
2. **ä»…éœ€æºçš„å®‰å…¨æ€§**ï¼šç®€åŒ–äº†å®‰å…¨å‡è®¾
3. **é€‚åˆç½‘ç»œéƒ¨ç½²**ï¼šä¸­é—´èŠ‚ç‚¹å¯ä»¥æ˜¯ä¸å¯ä¿¡çš„

**ç®—æ³• 5.3.2** (æµ‹é‡è®¾å¤‡æ— å…³QKDå®ç° / MDI-QKD Implementation)

```python
class MeasurementDeviceIndependentQKD:
    """æµ‹é‡è®¾å¤‡æ— å…³QKDå®ç°"""

    def __init__(self, key_length=1000):
        self.key_length = key_length
        self.alice_states = []
        self.bob_states = []
        self.charlie_results = []  # ä¸å¯ä¿¡æµ‹é‡è€…Charlieçš„ç»“æœ
        self.shared_key = []

    def alice_prepare_state(self):
        """Aliceå‡†å¤‡é‡å­æ€"""
        for i in range(self.key_length):
            # éšæœºé€‰æ‹©æ¯”ç‰¹å’ŒåŸº
            bit = np.random.randint(0, 2)
            basis = np.random.randint(0, 2)

            # å‡†å¤‡ç›¸åº”çš„é‡å­æ€
            if basis == 0:  # ZåŸº
                state = self.prepare_z_basis_state(bit)
            else:  # XåŸº
                state = self.prepare_x_basis_state(bit)

            self.alice_states.append((state, bit, basis))

    def bob_prepare_state(self):
        """Bobå‡†å¤‡é‡å­æ€"""
        for i in range(self.key_length):
            # éšæœºé€‰æ‹©æ¯”ç‰¹å’ŒåŸº
            bit = np.random.randint(0, 2)
            basis = np.random.randint(0, 2)

            # å‡†å¤‡ç›¸åº”çš„é‡å­æ€
            if basis == 0:  # ZåŸº
                state = self.prepare_z_basis_state(bit)
            else:  # XåŸº
                state = self.prepare_x_basis_state(bit)

            self.bob_states.append((state, bit, basis))

    def charlie_bell_measurement(self, alice_state, bob_state):
        """Charlieæ‰§è¡Œè´å°”æ€æµ‹é‡ï¼ˆä¸å¯ä¿¡ï¼‰"""
        # Charlieå¯¹æ¥æ”¶åˆ°çš„ä¸¤ä¸ªé‡å­æ€è¿›è¡Œè´å°”æ€æµ‹é‡
        # æµ‹é‡ç»“æœï¼š|Î¦âºâŸ©, |Î¦â»âŸ©, |Î¨âºâŸ©, |Î¨â»âŸ©
        bell_result = self.perform_bell_measurement(alice_state, bob_state)
        return bell_result

    def post_selection(self):
        """åé€‰æ‹©ï¼šç­›é€‰å‡ºæˆåŠŸçš„äº‹ä»¶"""
        successful_rounds = []
        for i in range(self.key_length):
            alice_state, alice_bit, alice_basis = self.alice_states[i]
            bob_state, bob_bit, bob_basis = self.bob_states[i]
            charlie_result = self.charlie_results[i]

            # åªæœ‰å½“Aliceå’ŒBobä½¿ç”¨ç›¸åŒåŸºï¼Œä¸”Charlieçš„æµ‹é‡æˆåŠŸæ—¶ï¼Œæ‰ä¿ç•™
            if alice_basis == bob_basis and charlie_result is not None:
                successful_rounds.append((i, alice_bit, bob_bit, charlie_result))

        return successful_rounds

    def extract_key(self, successful_rounds):
        """æå–å¯†é’¥"""
        # æ ¹æ®Charlieçš„æµ‹é‡ç»“æœå’ŒAliceã€Bobçš„æ¯”ç‰¹æå–å¯†é’¥
        for i, alice_bit, bob_bit, charlie_result in successful_rounds:
            # æ ¹æ®Charlieçš„æµ‹é‡ç»“æœç¡®å®šå¯†é’¥æ¯”ç‰¹
            if charlie_result in [0, 1]:  # |Î¦âºâŸ© æˆ– |Î¦â»âŸ©
                key_bit = alice_bit
            else:  # |Î¨âºâŸ© æˆ– |Î¨â»âŸ©
                key_bit = 1 - alice_bit

            self.shared_key.append(key_bit)

        return self.shared_key

# å¤æ‚åº¦åˆ†æ
# æ—¶é—´å¤æ‚åº¦: O(n) å…¶ä¸­næ˜¯å¯†é’¥é•¿åº¦
# ç©ºé—´å¤æ‚åº¦: O(n) å­˜å‚¨æ‰€æœ‰çŠ¶æ€å’Œç»“æœ
```

### 5.3.3 å«æ˜ŸQKDç½‘ç»œ

**å®šä¹‰ 5.3.3** (å«æ˜ŸQKDç½‘ç»œ / Satellite QKD Network)

**å«æ˜ŸQKDç½‘ç»œ**ä½¿ç”¨å«æ˜Ÿä½œä¸ºä¸­ç»§èŠ‚ç‚¹ï¼Œå®ç°å…¨çƒèŒƒå›´çš„é‡å­å¯†é’¥åˆ†å‘ï¼š

$$\mathcal{SQKDN} = \langle \mathcal{S}, \mathcal{G}, \mathcal{L}, \mathcal{P} \rangle$$

å…¶ä¸­ï¼š

- $\mathcal{S}$ æ˜¯å«æ˜ŸèŠ‚ç‚¹é›†
- $\mathcal{G}$ æ˜¯åœ°é¢ç«™é›†
- $\mathcal{L}$ æ˜¯æ˜Ÿåœ°é‡å­é“¾è·¯é›†
- $\mathcal{P}$ æ˜¯QKDåè®®é›†

**å«æ˜ŸQKDä¼˜åŠ¿**ï¼š

1. **å…¨çƒè¦†ç›–**ï¼šä¸å—åœ°ç†é™åˆ¶
2. **é•¿è·ç¦»é€šä¿¡**ï¼šå«æ˜Ÿ-åœ°é¢è·ç¦»å¯è¾¾æ•°ç™¾å…¬é‡Œ
3. **ç§»åŠ¨æ€§**ï¼šæ”¯æŒç§»åŠ¨å¹³å°

**ä»£è¡¨æ€§é¡¹ç›®**ï¼š

- **å¢¨å­å·é‡å­å«æ˜Ÿ**ï¼ˆ2016ï¼‰ï¼šä¸­å›½å‘å°„çš„ä¸–ç•Œé¦–é¢—é‡å­ç§‘å­¦å®éªŒå«æ˜Ÿ
- **Micius**ï¼šå®ç°æ˜Ÿåœ°é‡å­å¯†é’¥åˆ†å‘ï¼Œè·ç¦»1200å…¬é‡Œ
- **QEYSSat**ï¼šåŠ æ‹¿å¤§é‡å­åŠ å¯†å’Œç§‘å­¦å«æ˜Ÿé¡¹ç›®

**ç®—æ³• 5.3.3** (å«æ˜ŸQKDåè®® / Satellite QKD Protocol)

```python
class SatelliteQKD:
    """å«æ˜ŸQKDå®ç°"""

    def __init__(self, satellite, ground_stations):
        self.satellite = satellite
        self.ground_stations = ground_stations
        self.quantum_channels = {}
        self.shared_keys = {}

    def establish_satellite_link(self, ground_station):
        """å»ºç«‹å«æ˜Ÿ-åœ°é¢ç«™é“¾è·¯"""
        # è®¡ç®—å«æ˜Ÿå’Œåœ°é¢ç«™çš„ç›¸å¯¹ä½ç½®
        distance = self.calculate_distance(
            self.satellite.position,
            ground_station.position
        )

        # è€ƒè™‘å¤§æ°”è¡°å‡
        atmospheric_loss = self.calculate_atmospheric_loss(distance)

        # å»ºç«‹é‡å­ä¿¡é“
        quantum_channel = QuantumChannel(
            source=self.satellite,
            destination=ground_station,
            distance=distance,
            loss=atmospheric_loss
        )

        self.quantum_channels[ground_station.id] = quantum_channel
        return quantum_channel

    def perform_satellite_qkd(self, ground_station1, ground_station2):
        """é€šè¿‡å«æ˜Ÿåœ¨ä¸¤ä¸ªåœ°é¢ç«™é—´æ‰§è¡ŒQKD"""
        # æ­¥éª¤1ï¼šå«æ˜Ÿä¸åœ°é¢ç«™1å»ºç«‹QKDé“¾è·¯
        key1 = self.establish_qkd_link(self.satellite, ground_station1)

        # æ­¥éª¤2ï¼šå«æ˜Ÿä¸åœ°é¢ç«™2å»ºç«‹QKDé“¾è·¯
        key2 = self.establish_qkd_link(self.satellite, ground_station2)

        # æ­¥éª¤3ï¼šå«æ˜Ÿä½¿ç”¨XORæ“ä½œç»„åˆä¸¤ä¸ªå¯†é’¥
        combined_key = [k1 ^ k2 for k1, k2 in zip(key1, key2)]

        # æ­¥éª¤4ï¼šå«æ˜Ÿé€šè¿‡ç»å…¸ä¿¡é“å‘é€combined_keyç»™åœ°é¢ç«™1
        # åœ°é¢ç«™1è®¡ç®—ï¼škey_final = combined_key XOR key1 = key2
        # è¿™æ ·åœ°é¢ç«™1å’Œåœ°é¢ç«™2å…±äº«å¯†é’¥key2ï¼Œè€Œå«æ˜Ÿä¸çŸ¥é“æœ€ç»ˆå¯†é’¥

        return combined_key

# å¤æ‚åº¦åˆ†æ
# æ—¶é—´å¤æ‚åº¦: O(n) å…¶ä¸­næ˜¯å¯†é’¥é•¿åº¦
# ç©ºé—´å¤æ‚åº¦: O(n) å­˜å‚¨å¯†é’¥
```

**ç®—æ³• 5.1** (è¿ç»­å˜é‡QKDå®ç°)

```python
class ContinuousVariableQKD:
    def __init__(self, key_length=1000):
        self.key_length = key_length
        self.alice_modulations = []
        self.bob_measurements = []
        self.shared_key = []

    def prepare_coherent_states(self):
        """å‡†å¤‡ç›¸å¹²æ€"""
        coherent_states = []
        for i in range(self.key_length):
            # ç”Ÿæˆéšæœºå¤æ•°æŒ¯å¹…
            alpha = np.random.normal(0, 1) + 1j * np.random.normal(0, 1)
            self.alice_modulations.append(alpha)

            # ç›¸å¹²æ€ |Î±âŸ© = exp(-|Î±|Â²/2) Î£ (Î±â¿/âˆšn!) |nâŸ©
            coherent_states.append(alpha)

        return coherent_states

    def heterodyne_detection(self, coherent_states):
        """å¤–å·®æ£€æµ‹"""
        for i, alpha in enumerate(coherent_states):
            # æ·»åŠ å™ªå£°
            noise = np.random.normal(0, 0.1) + 1j * np.random.normal(0, 0.1)
            measurement = alpha + noise
            self.bob_measurements.append(measurement)

    def post_processing(self):
        """åå¤„ç†"""
        # é‡åŒ–è¿ç»­æµ‹é‡ç»“æœ
        for i in range(self.key_length):
            # å°†å¤æ•°æµ‹é‡ç»“æœé‡åŒ–ä¸ºæ¯”ç‰¹
            real_part = self.bob_measurements[i].real
            if real_part > 0:
                self.shared_key.append(1)
            else:
                self.shared_key.append(0)

        return len(self.shared_key)
```

## 6. é‡å­å¯†é’¥åˆ†å‘ç½‘ç»œ

### 6.1 ç½‘ç»œæ‹“æ‰‘

**å®šä¹‰ 6.1** (QKDç½‘ç»œ / QKD Network)

**QKDç½‘ç»œ**æ˜¯å¤šä¸ªQKDèŠ‚ç‚¹çš„äº’è”ç½‘ç»œï¼š
$$\mathcal{QKDN} = \langle \mathcal{N}, \mathcal{L}, \mathcal{P}, \mathcal{R}, \mathcal{M} \rangle$$

å…¶ä¸­ï¼š

- $\mathcal{N}$ æ˜¯QKDèŠ‚ç‚¹é›†ï¼ˆQKD Node Setï¼‰
- $\mathcal{L}$ æ˜¯é‡å­é“¾è·¯é›†ï¼ˆQuantum Link Setï¼‰
- $\mathcal{P}$ æ˜¯QKDåè®®é›†ï¼ˆQKD Protocol Setï¼‰
- $\mathcal{R}$ æ˜¯è·¯ç”±ç®—æ³•é›†ï¼ˆRouting Algorithm Setï¼‰
- $\mathcal{M}$ æ˜¯ç½‘ç»œç®¡ç†åè®®é›†ï¼ˆNetwork Management Protocol Setï¼‰

### 6.2 é‡å­äº’è”ç½‘æ¶æ„ï¼ˆ2024-2025æœ€æ–°è¿›å±•ï¼‰

#### 6.2.1 é‡å­äº’è”ç½‘å±‚æ¬¡ç»“æ„

**å®šä¹‰ 6.2.1** (é‡å­äº’è”ç½‘ / Quantum Internet)

**é‡å­äº’è”ç½‘**æ˜¯ä¸€ä¸ªåˆ†å±‚çš„ç½‘ç»œæ¶æ„ï¼Œæ”¯æŒé‡å­é€šä¿¡å’Œé‡å­è®¡ç®—ï¼š

$$\mathcal{QI} = \langle \mathcal{L}_1, \mathcal{L}_2, \mathcal{L}_3, \mathcal{L}_4, \mathcal{L}_5, \mathcal{L}_6 \rangle$$

**å…­å±‚æ¶æ„**ï¼š

1. **L1 - ç»å…¸ç‰©ç†å±‚**ï¼šç»å…¸é€šä¿¡åŸºç¡€è®¾æ–½
2. **L2 - é‡å­ç‰©ç†å±‚**ï¼šé‡å­æ¯”ç‰¹ä¼ è¾“å’Œé‡å­ä¿¡é“
3. **L3 - é‡å­é“¾è·¯å±‚**ï¼šç«¯åˆ°ç«¯é‡å­çº ç¼ å»ºç«‹
4. **L4 - ç½‘ç»œå±‚**ï¼šé‡å­è·¯ç”±å’Œé‡å­ä¸­ç»§
5. **L5 - ä¼ è¾“å±‚**ï¼šé‡å­å¯†é’¥åˆ†å‘å’Œé‡å­å®‰å…¨é€šä¿¡
6. **L6 - åº”ç”¨å±‚**ï¼šé‡å­åº”ç”¨ï¼ˆåˆ†å¸ƒå¼é‡å­è®¡ç®—ã€é‡å­ä¼ æ„Ÿç­‰ï¼‰

#### 6.2.2 é‡å­ä¸­ç»§å™¨æŠ€æœ¯

**å®šä¹‰ 6.2.2** (é‡å­ä¸­ç»§å™¨ / Quantum Repeater)

**é‡å­ä¸­ç»§å™¨**ç”¨äºæ‰©å±•é‡å­é€šä¿¡è·ç¦»ï¼Œå…‹æœé‡å­ä¿¡é“çš„æŸè€—ï¼š

$$\mathcal{QR} = \langle \mathcal{E}, \mathcal{S}, \mathcal{B}, \mathcal{P} \rangle$$

å…¶ä¸­ï¼š

- $\mathcal{E}$ æ˜¯çº ç¼ äº§ç”Ÿæ¨¡å—ï¼ˆEntanglement Generationï¼‰
- $\mathcal{S}$ æ˜¯é‡å­å­˜å‚¨æ¨¡å—ï¼ˆQuantum Memoryï¼‰
- $\mathcal{B}$ æ˜¯è´å°”æ€æµ‹é‡æ¨¡å—ï¼ˆBell State Measurementï¼‰
- $\mathcal{P}$ æ˜¯çº¯åŒ–åè®®ï¼ˆPurification Protocolï¼‰

**é‡å­ä¸­ç»§å™¨å·¥ä½œåŸç†**ï¼š

1. **çº ç¼ äº§ç”Ÿ**ï¼šåœ¨ä¸¤ä¸ªç›¸é‚»èŠ‚ç‚¹é—´äº§ç”Ÿçº ç¼ å¯¹
2. **çº ç¼ äº¤æ¢**ï¼šé€šè¿‡è´å°”æ€æµ‹é‡è¿æ¥ä¸¤ä¸ªçº ç¼ å¯¹
3. **çº ç¼ çº¯åŒ–**ï¼šæé«˜çº ç¼ è´¨é‡
4. **çº ç¼ å­˜å‚¨**ï¼šåœ¨é‡å­å­˜å‚¨å™¨ä¸­ä¿å­˜çº ç¼ 

**ç®—æ³• 6.2.1** (é‡å­ä¸­ç»§å™¨ç®—æ³• / Quantum Repeater Algorithm)

```python
class QuantumRepeater:
    """é‡å­ä¸­ç»§å™¨å®ç°"""

    def __init__(self, node_id, neighbors):
        self.node_id = node_id
        self.neighbors = neighbors
        self.quantum_memory = {}  # é‡å­å­˜å‚¨å™¨
        self.entangled_pairs = {}  # å­˜å‚¨çš„çº ç¼ å¯¹

    def generate_entanglement(self, neighbor_id):
        """ä¸é‚»å±…èŠ‚ç‚¹äº§ç”Ÿçº ç¼ """
        # äº§ç”ŸBellæ€ |Î¦âºâŸ© = (|00âŸ© + |11âŸ©)/âˆš2
        entangled_pair = self.create_bell_state()

        # å­˜å‚¨çº ç¼ å¯¹
        pair_id = f"{self.node_id}-{neighbor_id}-{len(self.entangled_pairs)}"
        self.entangled_pairs[pair_id] = entangled_pair

        return pair_id

    def entanglement_swapping(self, pair1_id, pair2_id):
        """çº ç¼ äº¤æ¢"""
        pair1 = self.entangled_pairs[pair1_id]
        pair2 = self.entangled_pairs[pair2_id]

        # å¯¹ä¸­é—´ä¸¤ä¸ªé‡å­æ¯”ç‰¹è¿›è¡Œè´å°”æ€æµ‹é‡
        measurement_result = self.bell_state_measurement(
            pair1[1],  # pair1çš„ç¬¬äºŒä¸ªé‡å­æ¯”ç‰¹
            pair2[0]   # pair2çš„ç¬¬ä¸€ä¸ªé‡å­æ¯”ç‰¹
        )

        # æ ¹æ®æµ‹é‡ç»“æœï¼Œpair1çš„ç¬¬ä¸€ä¸ªé‡å­æ¯”ç‰¹å’Œpair2çš„ç¬¬äºŒä¸ªé‡å­æ¯”ç‰¹å½¢æˆæ–°çš„çº ç¼ 
        if measurement_result == 0:  # |Î¦âºâŸ©
            new_pair = (pair1[0], pair2[1])
        elif measurement_result == 1:  # |Î¦â»âŸ©
            new_pair = self.apply_pauli_z(pair1[0], pair2[1])
        elif measurement_result == 2:  # |Î¨âºâŸ©
            new_pair = self.apply_pauli_x(pair1[0], pair2[1])
        else:  # |Î¨â»âŸ©
            new_pair = self.apply_pauli_y(pair1[0], pair2[1])

        return new_pair

    def entanglement_purification(self, pair1, pair2):
        """çº ç¼ çº¯åŒ–"""
        # ä½¿ç”¨Bennett-Brassard-Popescu-Smolinåè®®
        # é€šè¿‡æµ‹é‡ä¸¤ä¸ªçº ç¼ å¯¹çš„å¥‡å¶æ€§æ¥æ£€æµ‹é”™è¯¯

        # æ‰§è¡ŒCNOTæ“ä½œ
        cnot_result = self.cnot_measurement(pair1, pair2)

        if cnot_result == 0:  # å¥‡å¶æ€§æ­£ç¡®
            # ä¿ç•™ç¬¬ä¸€ä¸ªçº ç¼ å¯¹
            return pair1
        else:  # æ£€æµ‹åˆ°é”™è¯¯
            # ä¸¢å¼ƒçº ç¼ å¯¹
            return None

# å¤æ‚åº¦åˆ†æ
# æ—¶é—´å¤æ‚åº¦: O(1) å•æ¬¡æ“ä½œ
# ç©ºé—´å¤æ‚åº¦: O(n) næ˜¯å­˜å‚¨çš„çº ç¼ å¯¹æ•°é‡
```

#### 6.2.3 é‡å­-ç»å…¸æ··åˆç½‘ç»œ

**å®šä¹‰ 6.2.3** (é‡å­-ç»å…¸æ··åˆç½‘ç»œ / Quantum-Classical Hybrid Network)

**é‡å­-ç»å…¸æ··åˆç½‘ç»œ**åŒæ—¶ä½¿ç”¨é‡å­ä¿¡é“å’Œç»å…¸ä¿¡é“ï¼š

$$\mathcal{QCHN} = \langle \mathcal{G}_Q, \mathcal{G}_C, \mathcal{I} \rangle$$

å…¶ä¸­ï¼š

- $\mathcal{G}_Q = (V, E_Q)$ æ˜¯é‡å­ç½‘ç»œå›¾
- $\mathcal{G}_C = (V, E_C)$ æ˜¯ç»å…¸ç½‘ç»œå›¾
- $\mathcal{I}: E_Q \times E_C \to \mathbb{R}$ æ˜¯é‡å­-ç»å…¸äº¤äº’å‡½æ•°

**æ··åˆç½‘ç»œä¼˜åŠ¿**ï¼š

1. **é‡å­ä¿¡é“**ï¼šç”¨äºå¯†é’¥åˆ†å‘å’Œé‡å­ä¿¡æ¯ä¼ è¾“
2. **ç»å…¸ä¿¡é“**ï¼šç”¨äºæ§åˆ¶ä¿¡æ¯å’Œåè°ƒ
3. **ååŒå·¥ä½œ**ï¼šé‡å­å’Œç»å…¸ç½‘ç»œç›¸äº’è¡¥å……

**ç®—æ³• 6.1** (QKDç½‘ç»œè·¯ç”±)

```python
class QKDNetwork:
    def __init__(self, nodes, links):
        self.nodes = nodes
        self.links = links
        self.routing_table = {}

    def find_qkd_path(self, source, destination):
        """å¯»æ‰¾QKDè·¯å¾„"""
        # ä½¿ç”¨Dijkstraç®—æ³•å¯»æ‰¾æœ€çŸ­è·¯å¾„
        distances = {node: float('inf') for node in self.nodes}
        distances[source] = 0
        previous = {}
        unvisited = set(self.nodes)

        while unvisited:
            # æ‰¾åˆ°è·ç¦»æœ€å°çš„æœªè®¿é—®èŠ‚ç‚¹
            current = min(unvisited, key=lambda x: distances[x])
            unvisited.remove(current)

            if current == destination:
                break

            # æ›´æ–°é‚»å±…è·ç¦»
            for neighbor in self.get_neighbors(current):
                if neighbor in unvisited:
                    distance = distances[current] + self.get_link_distance(current, neighbor)
                    if distance < distances[neighbor]:
                        distances[neighbor] = distance
                        previous[neighbor] = current

        # é‡å»ºè·¯å¾„
        path = []
        current = destination
        while current in previous:
            path.append(current)
            current = previous[current]
        path.append(source)
        path.reverse()

        return path

    def establish_qkd_link(self, path):
        """å»ºç«‹QKDé“¾è·¯"""
        # æ²¿è·¯å¾„å»ºç«‹QKDè¿æ¥
        for i in range(len(path) - 1):
            node1, node2 = path[i], path[i+1]
            # æ‰§è¡ŒQKDåè®®
            key = self.perform_qkd(node1, node2)
            # å­˜å‚¨å¯†é’¥
            self.store_key(node1, node2, key)

    def perform_qkd(self, node1, node2):
        """æ‰§è¡ŒQKDåè®®"""
        # è¿™é‡Œå¯ä»¥è°ƒç”¨å…·ä½“çš„QKDåè®®å®ç°
        bb84 = BB84Protocol(key_length=100)
        # æ‰§è¡Œåè®®å¹¶è¿”å›ç”Ÿæˆçš„å¯†é’¥
        return bb84.generate_key()
```

## 7. å®‰å…¨æ€§åˆ†æ

### 7.1 ä¿¡æ¯è®ºå®‰å…¨æ€§

**å®šç† 7.1** (QKDä¿¡æ¯è®ºå®‰å…¨æ€§)
QKDåè®®åœ¨ä¿¡æ¯è®ºæ„ä¹‰ä¸‹æ˜¯å®‰å…¨çš„ï¼Œå³çªƒå¬è€…æ— æ³•è·å¾—ä»»ä½•å…³äºæœ€ç»ˆå¯†é’¥çš„ä¿¡æ¯ã€‚

**è¯æ˜**ï¼š

1. é‡å­åŠ›å­¦çš„ä¸ç¡®å®šæ€§åŸç†ä¿è¯çªƒå¬æ£€æµ‹
2. éšç§æ”¾å¤§æ¶ˆé™¤çªƒå¬è€…çš„éƒ¨åˆ†ä¿¡æ¯
3. æœ€ç»ˆå¯†é’¥çš„ç†µå¤§äºçªƒå¬è€…çš„ä¿¡æ¯é‡
4. å› æ­¤çªƒå¬è€…æ— æ³•è·å¾—å¯†é’¥ä¿¡æ¯

$\boxed{\text{è¯æ¯•}}$

**ç®—æ³• 7.1** (å®‰å…¨æ€§åˆ†æ)

```python
def qkd_security_analysis(error_rate, raw_key_length, final_key_length):
    """QKDå®‰å…¨æ€§åˆ†æ"""
    # è®¡ç®—çªƒå¬è€…è·å¾—çš„ä¿¡æ¯é‡
    eve_information = calculate_eve_information(error_rate, raw_key_length)

    # è®¡ç®—æœ€ç»ˆå¯†é’¥çš„ç†µ
    final_key_entropy = final_key_length

    # æ£€æŸ¥å®‰å…¨æ€§æ¡ä»¶
    if final_key_entropy > eve_information:
        security_level = final_key_entropy - eve_information
        return True, security_level
    else:
        return False, 0

def calculate_eve_information(error_rate, key_length):
    """è®¡ç®—çªƒå¬è€…ä¿¡æ¯é‡"""
    # åŸºäºé”™è¯¯ç‡ä¼°è®¡çªƒå¬è€…ä¿¡æ¯
    if error_rate <= 0.11:
        return key_length * (1 - 2 * error_rate)
    else:
        return key_length  # é”™è¯¯ç‡è¿‡é«˜ï¼Œçªƒå¬è€…å¯èƒ½è·å¾—å…¨éƒ¨ä¿¡æ¯
```

## 8. å¤šæ¨¡æ€è¡¨è¾¾ä¸å¯è§†åŒ–

### 8.1 åè®®æµç¨‹å›¾

```mermaid
sequenceDiagram
    participant A as Alice
    participant C as Channel
    participant B as Bob
    participant E as Eve

    A->>C: å‘é€é‡å­æ¯”ç‰¹
    C->>E: çªƒå¬å°è¯•
    E->>C: å¹²æ‰°ä¿¡å·
    C->>B: æ¥æ”¶é‡å­æ¯”ç‰¹
    A->>B: å…¬å¼€åŸºé€‰æ‹©
    B->>A: å…¬å¼€åŸºé€‰æ‹©
    A->>B: ç­›é€‰ç›¸åŒåŸº
    B->>A: é”™è¯¯ä¼°è®¡
    A->>B: éšç§æ”¾å¤§
    Note over A,B: ç”Ÿæˆå®‰å…¨å¯†é’¥
```

### 8.2 é‡å­ç”µè·¯å›¾

```python
# Qiskité‡å­ç”µè·¯å¯è§†åŒ–
def create_bb84_circuit():
    qc = QuantumCircuit(2, 2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure_all()
    return qc

# ç»˜åˆ¶ç”µè·¯
circuit = create_bb84_circuit()
circuit.draw(output='mpl')
```

### 8.3 å®‰å…¨æ€§åˆ†æå›¾

```python
import matplotlib.pyplot as plt
import numpy as np

def plot_qkd_security():
    error_rates = np.linspace(0, 0.2, 100)
    secure_rates = []

    for e in error_rates:
        if e <= 0.11:
            rate = 1 - 2 * e
            secure_rates.append(rate)
        else:
            secure_rates.append(0)

    plt.figure(figsize=(10, 6))
    plt.plot(error_rates, secure_rates, 'b-', linewidth=2)
    plt.axvline(x=0.11, color='r', linestyle='--', label='å®‰å…¨é˜ˆå€¼')
    plt.xlabel('é”™è¯¯ç‡')
    plt.ylabel('å®‰å…¨å¯†é’¥ç‡')
    plt.title('QKDå®‰å…¨æ€§åˆ†æ')
    plt.legend()
    plt.grid(True)
    plt.show()
```

## 9. è‡ªåŠ¨åŒ–è„šæœ¬å»ºè®®

### 9.1 åè®®å®ç°è„šæœ¬

- **`scripts/bb84_protocol.py`**ï¼šBB84åè®®å®Œæ•´å®ç°
- **`scripts/e91_protocol.py`**ï¼šE91åè®®å®ç°
- **`scripts/bbm92_protocol.py`**ï¼šBBM92åè®®å®ç°
- **`scripts/cv_qkd_protocol.py`**ï¼šè¿ç»­å˜é‡QKDå®ç°

### 9.2 å®‰å…¨æ€§åˆ†æè„šæœ¬

- **`scripts/qkd_security_analyzer.py`**ï¼šQKDå®‰å…¨æ€§åˆ†æ
- **`scripts/bell_inequality_tester.py`**ï¼šè´å°”ä¸ç­‰å¼æµ‹è¯•
- **`scripts/error_rate_estimator.py`**ï¼šé”™è¯¯ç‡ä¼°è®¡

### 9.3 ç½‘ç»œä»¿çœŸè„šæœ¬

- **`scripts/qkd_network_simulator.py`**ï¼šQKDç½‘ç»œä»¿çœŸ
- **`scripts/qkd_routing.py`**ï¼šQKDè·¯ç”±ç®—æ³•
- **`scripts/network_security_analyzer.py`**ï¼šç½‘ç»œå®‰å…¨åˆ†æ

## 10. å½¢å¼åŒ–è¯­ä¹‰ä¸æ¦‚å¿µè§£é‡Š

### 10.1 å½¢å¼åŒ–è¯­ä¹‰

- **é‡å­è¯­ä¹‰**ï¼šQKDåè®®åœ¨å¸Œå°”ä¼¯ç‰¹ç©ºé—´ä¸­çš„æ¼”åŒ–
- **ä¿¡æ¯è®ºè¯­ä¹‰**ï¼šå¯†é’¥ç†µä¸çªƒå¬è€…ä¿¡æ¯é‡çš„å…³ç³»
- **å¯†ç å­¦è¯­ä¹‰**ï¼šQKDä½œä¸ºå¯†ç å­¦åŸè¯­çš„å®‰å…¨æ€§

### 10.2 å…¸å‹å®šç†ä¸è¯æ˜

- **ä¸å¯å…‹éš†å®šç†**ï¼šé‡å­æ€æ— æ³•å®Œç¾å¤åˆ¶
- **BB84å®‰å…¨æ€§å®šç†**ï¼šé”™è¯¯ç‡é˜ˆå€¼ä¸å®‰å…¨æ€§å…³ç³»
- **è´å°”ä¸ç­‰å¼**ï¼šé‡å­çº ç¼ çš„åˆ¤æ®

### 10.3 è‡ªåŠ¨åŒ–éªŒè¯å»ºè®®

- ä½¿ç”¨Qiskitè¿›è¡Œé‡å­åè®®ä»¿çœŸ
- ä½¿ç”¨Coq/Leanå½¢å¼åŒ–QKDå®‰å…¨æ€§è¯æ˜
- ä½¿ç”¨Pythonå®ç°åè®®æ€§èƒ½åˆ†æ

## ğŸ’¼ **11. å®é™…å·¥ç¨‹åº”ç”¨æ¡ˆä¾‹ / Real-World Engineering Application Cases**

### 11.1 é‡å­å¯†é’¥åˆ†å‘ç½‘ç»œåº”ç”¨ / Quantum Key Distribution Network Applications

#### 11.1.1 ä¸­å›½é‡å­é€šä¿¡ç½‘ç»œ

**é¡¹ç›®èƒŒæ™¯**ï¼š

- **é—®é¢˜**ï¼šéœ€è¦å»ºç«‹å®‰å…¨çš„é‡å­é€šä¿¡ç½‘ç»œï¼Œå®ç°é•¿è·ç¦»é‡å­å¯†é’¥åˆ†å‘
- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨BB84åè®®æ„å»ºé‡å­é€šä¿¡ç½‘ç»œ
- **æŠ€æœ¯è¦ç‚¹**ï¼š
  - ä½¿ç”¨BB84åè®®å®ç°é‡å­å¯†é’¥åˆ†å‘
  - ä½¿ç”¨é‡å­ä¸­ç»§å™¨æ‰©å±•é€šä¿¡è·ç¦»
  - ä½¿ç”¨é‡å­å«æ˜Ÿå®ç°å…¨çƒè¦†ç›–
- **å®é™…æ•ˆæœ**ï¼š
  - äº¬æ²ªå¹²çº¿è¿æ¥åŒ—äº¬å’Œä¸Šæµ·ï¼Œæ€»é•¿åº¦è¶…è¿‡2000å…¬é‡Œ
  - å¢¨å­å·å«æ˜Ÿå®ç°æ˜Ÿåœ°é‡å­é€šä¿¡
  - å®ç°äº†å…¨çƒé¦–ä¸ªé‡å­é€šä¿¡ç½‘ç»œ

#### 11.1.2 æ¬§æ´²SECOQCç½‘ç»œ

**é¡¹ç›®èƒŒæ™¯**ï¼š

- **é—®é¢˜**ï¼šéœ€è¦å»ºç«‹æ¬§æ´²èŒƒå›´çš„é‡å­é€šä¿¡ç½‘ç»œï¼Œä¿æŠ¤å…³é”®åŸºç¡€è®¾æ–½
- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨å¤šç§QKDåè®®æ„å»ºæ¬§æ´²é‡å­é€šä¿¡ç½‘ç»œ
- **æŠ€æœ¯è¦ç‚¹**ï¼š
  - ä½¿ç”¨BB84ã€E91ç­‰å¤šç§QKDåè®®
  - ä½¿ç”¨é‡å­ä¸­ç»§å™¨è¿æ¥å¤šä¸ªåŸå¸‚
  - ä½¿ç”¨é‡å­è·¯ç”±å™¨å®ç°ç½‘ç»œè·¯ç”±
- **å®é™…æ•ˆæœ**ï¼š
  - è¿æ¥äº†å¤šä¸ªæ¬§æ´²åŸå¸‚
  - å®ç°äº†å®‰å…¨çš„é‡å­å¯†é’¥åˆ†å‘
  - ä¿æŠ¤äº†å…³é”®åŸºç¡€è®¾æ–½é€šä¿¡

### 11.2 é‡å­å®‰å…¨åº”ç”¨ / Quantum Security Applications

#### 11.2.1 é‡å­å®‰å…¨é“¶è¡Œç³»ç»Ÿ

**é¡¹ç›®èƒŒæ™¯**ï¼š

- **é—®é¢˜**ï¼šé“¶è¡Œç³»ç»Ÿéœ€è¦æœ€é«˜çº§åˆ«çš„å®‰å…¨é€šä¿¡
- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨é‡å­å¯†é’¥åˆ†å‘ä¿æŠ¤é“¶è¡Œé€šä¿¡
- **æŠ€æœ¯è¦ç‚¹**ï¼š
  - ä½¿ç”¨QKDåè®®ç”Ÿæˆå®‰å…¨å¯†é’¥
  - ä½¿ç”¨é‡å­éšæœºæ•°ç”Ÿæˆå™¨ç”Ÿæˆéšæœºæ•°
  - ä½¿ç”¨é‡å­åŠ å¯†ä¿æŠ¤æ•æ„Ÿæ•°æ®
- **å®é™…æ•ˆæœ**ï¼š
  - å®ç°äº†é“¶è¡Œé—´å®‰å…¨é€šä¿¡
  - ä¿æŠ¤äº†é‡‘èäº¤æ˜“æ•°æ®
  - æé«˜äº†é“¶è¡Œç³»ç»Ÿçš„å®‰å…¨æ€§

#### 11.2.2 é‡å­å®‰å…¨æ”¿åŠ¡ç³»ç»Ÿ

**é¡¹ç›®èƒŒæ™¯**ï¼š

- **é—®é¢˜**ï¼šæ”¿åŠ¡ç³»ç»Ÿéœ€è¦ä¿æŠ¤æ•æ„Ÿä¿¡æ¯ï¼Œé˜²æ­¢çªƒå¬
- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨é‡å­å¯†é’¥åˆ†å‘ä¿æŠ¤æ”¿åŠ¡é€šä¿¡
- **æŠ€æœ¯è¦ç‚¹**ï¼š
  - ä½¿ç”¨QKDåè®®ä¿æŠ¤æ”¿åŠ¡é€šä¿¡
  - ä½¿ç”¨é‡å­åŠ å¯†ä¿æŠ¤æ•æ„Ÿä¿¡æ¯
  - ä½¿ç”¨é‡å­éšæœºæ•°ç”Ÿæˆå™¨ä¿è¯éšæœºæ€§
- **å®é™…æ•ˆæœ**ï¼š
  - ä¿æŠ¤äº†æ”¿åŠ¡æ•æ„Ÿä¿¡æ¯
  - é˜²æ­¢äº†ä¿¡æ¯æ³„éœ²
  - æé«˜äº†æ”¿åŠ¡ç³»ç»Ÿå®‰å…¨æ€§

### 11.3 é‡å­å¯†é’¥åˆ†å‘å·¥å…·ä¸åº”ç”¨ / Quantum Key Distribution Tools and Applications

#### 11.3.1 ä¸»æµé‡å­å¯†é’¥åˆ†å‘å·¥å…·

1. **Qiskit**
   - **ç”¨é€”**ï¼šé‡å­è®¡ç®—å’Œé‡å­é€šä¿¡å¼€å‘æ¡†æ¶
   - **ç‰¹ç‚¹**ï¼šæ”¯æŒé‡å­ç”µè·¯è®¾è®¡ã€QKDåè®®å®ç°ã€é‡å­ç½‘ç»œä»¿çœŸ
   - **åº”ç”¨**ï¼šQKDåè®®å¼€å‘ã€é‡å­ç½‘ç»œä»¿çœŸã€é‡å­ç®—æ³•ç ”ç©¶

2. **QuTiP**
   - **ç”¨é€”**ï¼šé‡å­å·¥å…·åŒ…
   - **ç‰¹ç‚¹**ï¼šæ”¯æŒé‡å­ç³»ç»Ÿä»¿çœŸã€QKDåè®®åˆ†æã€é‡å­ä¿¡æ¯å¤„ç†
   - **åº”ç”¨**ï¼šQKDåè®®å»ºæ¨¡ã€å®‰å…¨æ€§åˆ†æã€é‡å­ä¿¡æ¯ç†è®ºç ”ç©¶

3. **QKD Simulator**
   - **ç”¨é€”**ï¼šé‡å­å¯†é’¥åˆ†å‘åè®®ä»¿çœŸ
   - **ç‰¹ç‚¹**ï¼šæ”¯æŒå¤šç§QKDåè®®ã€å®‰å…¨æ€§åˆ†æã€æ€§èƒ½è¯„ä¼°
   - **åº”ç”¨**ï¼šQKDåè®®è®¾è®¡ã€å®‰å…¨æ€§éªŒè¯ã€æ€§èƒ½ä¼˜åŒ–

#### 11.3.2 å®é™…åº”ç”¨æ¡ˆä¾‹

1. **ä¸­å›½é‡å­é€šä¿¡ç½‘ç»œ**
   - **å·¥å…·**ï¼šBB84åè®®ã€é‡å­ä¸­ç»§å™¨ã€é‡å­å«æ˜Ÿ
   - **åº”ç”¨å†…å®¹**ï¼šäº¬æ²ªå¹²çº¿ã€å¢¨å­å·å«æ˜Ÿã€é‡å­äº’è”ç½‘
   - **æˆæœ**ï¼šå®ç°äº†å…¨çƒé¦–ä¸ªé‡å­é€šä¿¡ç½‘ç»œï¼Œè¿æ¥äº†å¤šä¸ªåŸå¸‚

2. **æ¬§æ´²SECOQCç½‘ç»œ**
   - **å·¥å…·**ï¼šå¤šç§QKDåè®®ã€é‡å­è·¯ç”±å™¨
   - **åº”ç”¨å†…å®¹**ï¼šæ¬§æ´²é‡å­é€šä¿¡ç½‘ç»œã€å…³é”®åŸºç¡€è®¾æ–½ä¿æŠ¤
   - **æˆæœ**ï¼šè¿æ¥äº†å¤šä¸ªæ¬§æ´²åŸå¸‚ï¼Œä¿æŠ¤äº†å…³é”®åŸºç¡€è®¾æ–½é€šä¿¡

3. **é‡å­å®‰å…¨é“¶è¡Œç³»ç»Ÿ**
   - **å·¥å…·**ï¼šQKDåè®®ã€é‡å­éšæœºæ•°ç”Ÿæˆå™¨
   - **åº”ç”¨å†…å®¹**ï¼šé“¶è¡Œé—´å®‰å…¨é€šä¿¡ã€é‡‘èäº¤æ˜“ä¿æŠ¤
   - **æˆæœ**ï¼šå®ç°äº†é“¶è¡Œé—´å®‰å…¨é€šä¿¡ï¼Œä¿æŠ¤äº†é‡‘èäº¤æ˜“æ•°æ®

---

*æœ¬æ–‡æ¡£æä¾›äº†é‡å­å¯†é’¥åˆ†å‘çš„å®Œæ•´ç†è®ºæ¡†æ¶å’Œå®ç°æ–¹æ³•ï¼Œä¸ºé‡å­é€šä¿¡ç³»ç»Ÿçš„å®‰å…¨è®¾è®¡æä¾›äº†ç†è®ºåŸºç¡€ã€‚é€šè¿‡å®é™…å·¥ç¨‹åº”ç”¨æ¡ˆä¾‹ï¼Œå±•ç¤ºäº†é‡å­å¯†é’¥åˆ†å‘åœ¨ç°ä»£ä¿¡æ¯å®‰å…¨ä¸­çš„é‡è¦ä½œç”¨ã€‚*
