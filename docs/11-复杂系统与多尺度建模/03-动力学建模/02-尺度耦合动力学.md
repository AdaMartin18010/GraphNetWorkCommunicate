# å°ºåº¦è€¦åˆåŠ¨åŠ›å­¦ / Scale Coupling Dynamics

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£æè¿°å°ºåº¦è€¦åˆåŠ¨åŠ›å­¦çš„å®šä¹‰å’Œç±»å‹ã€‚å°ºåº¦è€¦åˆæ˜¯ä¸åŒå°ºåº¦é—´çš„ç›¸äº’ä½œç”¨ï¼Œæ˜¯ç†è§£å¤šå°ºåº¦ç³»ç»Ÿè¡Œä¸ºçš„å…³é”®æœºåˆ¶ã€‚

---

## ğŸ“ **å½¢å¼åŒ–å®šä¹‰ / Formal Definition**

### å®šä¹‰ 3.2 (å°ºåº¦è€¦åˆ / Scale Coupling)

**å°ºåº¦è€¦åˆ**æ˜¯ä¸åŒå°ºåº¦é—´çš„ç›¸äº’ä½œç”¨ï¼š

$$C_{ij}: \mathcal{S}_i \times \mathcal{S}_j \to \mathcal{S}_i \times \mathcal{S}_j$$

---

## ğŸ”§ **è€¦åˆç±»å‹ / Coupling Types**

1. **å¼ºè€¦åˆ**: å°ºåº¦é—´ç›¸äº’ä½œç”¨å¼ºçƒˆ
2. **å¼±è€¦åˆ**: å°ºåº¦é—´ç›¸äº’ä½œç”¨å¾®å¼±
3. **å•å‘è€¦åˆ**: åªæœ‰å•å‘ç›¸äº’ä½œç”¨
4. **è‡ªé€‚åº”è€¦åˆ**: æ ¹æ®ç³»ç»ŸçŠ¶æ€åŠ¨æ€è°ƒæ•´è€¦åˆå¼ºåº¦

---

## ğŸ’» **ç®—æ³•å®ç° / Algorithm Implementation**

```python
import numpy as np
from typing import Tuple, List

class ScaleCoupling:
    """å°ºåº¦è€¦åˆåŠ¨åŠ›å­¦å®ç°"""

    def __init__(self, coupling_strength: float = 0.1):
        self.coupling_strength = coupling_strength

    def strong_coupling(self, scale1_state: np.ndarray,
                       scale2_state: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """å¼ºè€¦åˆåŠ¨åŠ›å­¦"""
        # åŒå‘å¼ºè€¦åˆ
        coupling_force1 = self.coupling_strength * (scale2_state - scale1_state)
        coupling_force2 = self.coupling_strength * (scale1_state - scale2_state)

        new_state1 = scale1_state + coupling_force1
        new_state2 = scale2_state + coupling_force2

        return new_state1, new_state2

    def weak_coupling(self, scale1_state: np.ndarray,
                     scale2_state: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """å¼±è€¦åˆåŠ¨åŠ›å­¦"""
        # å¼±è€¦åˆï¼Œåªåœ¨å°æ‰°åŠ¨ä¸‹ç›¸äº’ä½œç”¨
        small_coupling = self.coupling_strength * 0.1

        coupling_force1 = small_coupling * np.sin(scale2_state - scale1_state)
        coupling_force2 = small_coupling * np.sin(scale1_state - scale2_state)

        new_state1 = scale1_state + coupling_force1
        new_state2 = scale2_state + coupling_force2

        return new_state1, new_state2

    def unidirectional_coupling(self, master_state: np.ndarray,
                               slave_state: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """å•å‘è€¦åˆåŠ¨åŠ›å­¦"""
        # ä¸»ç³»ç»Ÿå½±å“ä»ç³»ç»Ÿï¼Œä½†ä»ç³»ç»Ÿä¸å½±å“ä¸»ç³»ç»Ÿ
        coupling_force = self.coupling_strength * (master_state - slave_state)

        new_master_state = master_state  # ä¸»ç³»ç»Ÿä¸å—å½±å“
        new_slave_state = slave_state + coupling_force

        return new_master_state, new_slave_state

    def adaptive_coupling(self, scale1_state: np.ndarray,
                         scale2_state: np.ndarray,
                         coupling_history: List[float]) -> Tuple[np.ndarray, np.ndarray, float]:
        """è‡ªé€‚åº”è€¦åˆåŠ¨åŠ›å­¦"""
        # æ ¹æ®å†å²è€¦åˆå¼ºåº¦è‡ªé€‚åº”è°ƒæ•´
        if len(coupling_history) > 0:
            avg_coupling = np.mean(coupling_history)
            adaptive_strength = self.coupling_strength * (1 + 0.1 * np.sin(avg_coupling))
        else:
            adaptive_strength = self.coupling_strength

        coupling_force1 = adaptive_strength * (scale2_state - scale1_state)
        coupling_force2 = adaptive_strength * (scale1_state - scale2_state)

        new_state1 = scale1_state + coupling_force1
        new_state2 = scale2_state + coupling_force2

        return new_state1, new_state2, adaptive_strength
```

---

## ğŸ“Š **å¤æ‚åº¦åˆ†æ / Complexity Analysis**

- **æ—¶é—´å¤æ‚åº¦**: $O(N)$ å…¶ä¸­ $N$ æ˜¯çŠ¶æ€ç»´åº¦
- **ç©ºé—´å¤æ‚åº¦**: $O(N)$

---

## ğŸ”— **ç›¸å…³é“¾æ¥ / Related Links**

- [å¤æ‚ç³»ç»Ÿä¸å¤šå°ºåº¦å»ºæ¨¡ä¸»ç›®å½•](../../README.md)
- [åŠ¨åŠ›å­¦å»ºæ¨¡ç›®å½•](../README.md)
- [å¤šå°ºåº¦åŠ¨åŠ›å­¦](01-å¤šå°ºåº¦åŠ¨åŠ›å­¦.md)
- [å¤æ‚ç³»ç»Ÿå…ƒæ¨¡å‹](../../00-å¤æ‚ç³»ç»Ÿå…ƒæ¨¡å‹.md)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**çŠ¶æ€**: âœ… **å·²å®Œæˆ**
