# å¤šå°ºåº¦ç½‘ç»œå®šä¹‰ / Multi-Scale Network Definition

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£æè¿°å¤šå°ºåº¦ç½‘ç»œçš„å½¢å¼åŒ–å®šä¹‰ã€‚å¤šå°ºåº¦ç½‘ç»œæ˜¯åœ¨å¤šä¸ªå°ºåº¦ä¸ŠåŒæ—¶å­˜åœ¨çš„ç½‘ç»œç»“æ„ï¼Œæ˜¯å¤æ‚ç³»ç»Ÿå»ºæ¨¡çš„é‡è¦å·¥å…·ã€‚

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [å¤šå°ºåº¦ç½‘ç»œå®šä¹‰ / Multi-Scale Network Definition](#å¤šå°ºåº¦ç½‘ç»œå®šä¹‰--multi-scale-network-definition)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [ğŸ“ **å½¢å¼åŒ–å®šä¹‰ / Formal Definition**](#-å½¢å¼åŒ–å®šä¹‰--formal-definition)
  - [ğŸ’» **ç®—æ³•å®ç° / Algorithm Implementation**](#-ç®—æ³•å®ç°--algorithm-implementation)

---

## ğŸ“ **å½¢å¼åŒ–å®šä¹‰ / Formal Definition**

### å®šä¹‰ 2.1 (å¤šå°ºåº¦ç½‘ç»œ / Multi-Scale Network)

**å¤šå°ºåº¦ç½‘ç»œ**æ˜¯åœ¨å¤šä¸ªå°ºåº¦ä¸ŠåŒæ—¶å­˜åœ¨çš„ç½‘ç»œç»“æ„ï¼š

$$MSN = \langle \{G_i\}_{i=1}^n, \{F_{ij}\}_{i,j=1}^n, \mathcal{W} \rangle$$

å…¶ä¸­ï¼š

- $G_i = (V_i, E_i)$ æ˜¯ç¬¬ $i$ ä¸ªå°ºåº¦çš„ç½‘ç»œ (Network at Scale i)
- $F_{ij}: G_i \to G_j$ æ˜¯å°ºåº¦é—´çš„æ˜ å°„å‡½æ•° (Scale Mapping Function)
- $\mathcal{W}$ æ˜¯æƒé‡åˆ†é…å‡½æ•° (Weight Assignment Function)

---

## ğŸ’» **ç®—æ³•å®ç° / Algorithm Implementation**

```python
import numpy as np
import networkx as nx
from typing import Dict, List, Tuple, Optional

class MultiScaleNetwork:
    """å¤šå°ºåº¦ç½‘ç»œå®ç°"""

    def __init__(self, base_network: nx.Graph, scales: List[float]):
        self.base_network = base_network
        self.scales = scales
        self.networks = {}
        self.mappings = {}
        self.weights = {}

    def construct_scale_networks(self) -> Dict[float, nx.Graph]:
        """æ„å»ºä¸åŒå°ºåº¦çš„ç½‘ç»œ"""
        for scale in self.scales:
            # ä½¿ç”¨ä¸åŒçš„é˜ˆå€¼æ„å»ºç½‘ç»œ
            if scale < 1.0:
                # ç¨€ç–åŒ–ç½‘ç»œ
                threshold = np.percentile([d['weight'] for _, _, d in self.base_network.edges(data=True)],
                                       (1 - scale) * 100)
                edges_to_remove = [(u, v) for u, v, d in self.base_network.edges(data=True)
                                 if d['weight'] < threshold]
                network = self.base_network.copy()
                network.remove_edges_from(edges_to_remove)
            else:
                # ç¨ å¯†åŒ–ç½‘ç»œ
                network = self.base_network.copy()
                # æ·»åŠ æ–°è¾¹
                nodes = list(network.nodes())
                for i, node1 in enumerate(nodes):
                    for node2 in nodes[i+1:]:
                        if not network.has_edge(node1, node2):
                            # åŸºäºèŠ‚ç‚¹ç›¸ä¼¼æ€§æ·»åŠ è¾¹
                            similarity = self.calculate_node_similarity(node1, node2)
                            if similarity > scale:
                                network.add_edge(node1, node2, weight=similarity)

            self.networks[scale] = network

        return self.networks

    def calculate_node_similarity(self, node1: int, node2: int) -> float:
        """è®¡ç®—èŠ‚ç‚¹ç›¸ä¼¼æ€§"""
        # åŸºäºå…±åŒé‚»å±…è®¡ç®—ç›¸ä¼¼æ€§
        neighbors1 = set(self.base_network.neighbors(node1))
        neighbors2 = set(self.base_network.neighbors(node2))

        if len(neighbors1) == 0 and len(neighbors2) == 0:
            return 0.0

        intersection = len(neighbors1 & neighbors2)
        union = len(neighbors1 | neighbors2)

        return intersection / union if union > 0 else 0.0

    def create_scale_mappings(self) -> Dict[Tuple[float, float], Dict]:
        """åˆ›å»ºå°ºåº¦é—´æ˜ å°„"""
        for i, scale1 in enumerate(self.scales):
            for scale2 in self.scales[i+1:]:
                mapping = self.map_between_scales(scale1, scale2)
                self.mappings[(scale1, scale2)] = mapping

        return self.mappings

    def map_between_scales(self, scale1: float, scale2: float) -> Dict:
        """åœ¨ä¸¤ä¸ªå°ºåº¦é—´åˆ›å»ºæ˜ å°„"""
        network1 = self.networks[scale1]
        network2 = self.networks[scale2]

        mapping = {
            'node_mapping': {},
            'edge_mapping': {},
            'weight_mapping': {}
        }

        # èŠ‚ç‚¹æ˜ å°„
        for node in network1.nodes():
            if node in network2.nodes():
                mapping['node_mapping'][node] = node

        # è¾¹æ˜ å°„
        for edge in network1.edges():
            if edge in network2.edges():
                mapping['edge_mapping'][edge] = edge

        return mapping
```

---

## ğŸ“Š **å¤æ‚åº¦åˆ†æ / Complexity Analysis**

- **æ—¶é—´å¤æ‚åº¦**: $O(n^2 \cdot s^2)$ å…¶ä¸­ $n$ æ˜¯èŠ‚ç‚¹æ•°ï¼Œ$s$ æ˜¯å°ºåº¦æ•°
- **ç©ºé—´å¤æ‚åº¦**: $O(n^2 \cdot s)$

---

## ğŸ”— **ç›¸å…³é“¾æ¥ / Related Links**

- [å¤æ‚ç³»ç»Ÿä¸å¤šå°ºåº¦å»ºæ¨¡ä¸»ç›®å½•](../../README.md)
- [å¤šå°ºåº¦ç½‘ç»œæ¨¡å‹ç›®å½•](../README.md)
- [å°ºåº¦æ˜ å°„å…³ç³»](02-å°ºåº¦æ˜ å°„å…³ç³».md)
- [å¤æ‚ç³»ç»Ÿå…ƒæ¨¡å‹](../../00-å¤æ‚ç³»ç»Ÿå…ƒæ¨¡å‹.md)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**çŠ¶æ€**: âœ… **å·²å®Œæˆ**
