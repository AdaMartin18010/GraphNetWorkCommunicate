# 树分解 / Tree Decomposition

## 📚 **概述 / Overview**

本文档介绍图论中的树分解（Tree Decomposition）理论，包括树分解的定义、树宽的概念、算法实现和应用场景。

---

## 📐 **形式化定义 / Formal Definition**

### 定义 5.1.1 (树分解 / Tree Decomposition)

图 $G = (V, E)$ 的**树分解**是一个有序对 $(T, \{X_t\}_{t \in V(T)})$，其中：

1. $T = (V(T), E(T))$ 是一棵树
2. 每个 $X_t \subseteq V(G)$ 是 $G$ 的顶点子集，称为**袋子**（bag）
3. $\bigcup_{t \in V(T)} X_t = V(G)$（覆盖所有顶点）
4. 对于每条边 $uv \in E(G)$，存在某个节点 $t \in V(T)$ 使得 $u, v \in X_t$（每条边都在某个袋子里）
5. 对于每个顶点 $v \in V(G)$，$T$ 中所有包含 $v$ 的节点形成 $T$ 的连通子树（连通性条件）

**形式化定义**：

设 $G = (V, E)$ 是一个图，$(T, \{X_t\}_{t \in V(T)})$ 是 $G$ 的树分解，当且仅当：

- $T = (V(T), E(T))$ 是一棵树
- $\forall t \in V(T): X_t \subseteq V$
- $\bigcup_{t \in V(T)} X_t = V$
- $\forall uv \in E: \exists t \in V(T): u, v \in X_t$
- $\forall v \in V: \{t \in V(T) \mid v \in X_t\}$ 在 $T$ 中连通

---

### 定义 5.1.2 (树宽 / Treewidth)

图 $G$ 的**树宽**定义为：

$$\text{tw}(G) = \min_{(T, \{X_t\})} \max_{t \in V(T)} |X_t| - 1$$

其中最小值取遍 $G$ 的所有树分解。

---

## 🔧 **性质 / Properties**

- 树的树宽为 1
- 完全图 $K_n$ 的树宽为 $n-1$
- 环的树宽为 2
- 网格图的树宽为 $O(\sqrt{n})$

---

## 💻 **算法实现 / Algorithm Implementation**

### 算法 5.1.1 (树分解构建 - 简化版)

```python
from collections import defaultdict, deque
from typing import Dict, List, Set, Tuple

class TreeDecomposition:
    """
    图的树分解实现。
    这是一个简化的实现，实际应用中需要使用更高效的算法。
    """

    def __init__(self, graph: Dict[int, List[int]]):
        """
        初始化树分解。

        Args:
            graph: 图的邻接表表示 {vertex: [neighbors]}
        """
        self.graph = graph
        self.vertices = set(graph.keys())
        self.tree = {}  # 树结构 {node: [children]}
        self.bags = {}  # 袋子 {node: set of vertices}
        self.node_counter = 0

    def build_tree_decomposition(self) -> Tuple[Dict, Dict]:
        """
        构建树分解（使用贪心方法，简化实现）。

        返回:
            (tree, bags) 树结构和袋子映射
        """
        if not self.vertices:
            return {}, {}

        # 简化实现：为每个最大团创建一个袋子
        # 实际应用中应使用更高效的方法（如基于消去顺序的方法）

        cliques = self._find_maximal_cliques()

        # 为每个最大团创建一个树节点
        for i, clique in enumerate(cliques):
            node_id = f"node_{i}"
            self.bags[node_id] = set(clique)

            if i > 0:
                # 连接到前一个节点（简化：线性连接）
                parent_node = f"node_{i-1}"
                if parent_node not in self.tree:
                    self.tree[parent_node] = []
                self.tree[parent_node].append(node_id)

        return self.tree, self.bags

    def _find_maximal_cliques(self) -> List[List[int]]:
        """
        查找所有最大团（使用Bron-Kerbosch算法的简化版本）。

        返回:
            最大团列表
        """
        cliques = []
        vertices_list = list(self.vertices)

        # 简化实现：对每个顶点，尝试构建包含它的最大团
        for v in vertices_list:
            clique = self._extend_clique([v], set(vertices_list) - {v})
            if clique:
                cliques.append(clique)

        # 去除重复和子团
        unique_cliques = []
        for clique in cliques:
            clique_set = set(clique)
            is_maximal = True
            for other in unique_cliques:
                other_set = set(other)
                if clique_set.issubset(other_set):
                    is_maximal = False
                    break
                if other_set.issubset(clique_set):
                    unique_cliques.remove(other)
            if is_maximal:
                unique_cliques.append(clique)

        return unique_cliques

    def _extend_clique(self, current_clique: List[int], candidates: Set[int]) -> List[int]:
        """
        扩展当前团。

        Args:
            current_clique: 当前团
            candidates: 候选顶点

        返回:
            扩展后的最大团
        """
        if not candidates:
            return current_clique

        # 找到与当前团所有顶点都相邻的候选顶点
        valid_candidates = []
        for candidate in candidates:
            if all(candidate in self.graph.get(v, []) for v in current_clique):
                valid_candidates.append(candidate)

        if not valid_candidates:
            return current_clique

        # 贪心地添加候选顶点
        best_candidate = max(valid_candidates,
                            key=lambda v: len(set(self.graph.get(v, [])) & candidates))

        new_clique = current_clique + [best_candidate]
        new_candidates = candidates - {best_candidate}

        return self._extend_clique(new_clique, new_candidates)

    def compute_treewidth(self) -> int:
        """
        计算树宽。

        返回:
            树宽值
        """
        _, bags = self.build_tree_decomposition()

        if not bags:
            return 0

        max_bag_size = max(len(bag) for bag in bags.values())
        return max_bag_size - 1

    def verify_decomposition(self) -> bool:
        """
        验证树分解是否满足所有条件。

        返回:
            如果树分解有效返回True，否则返回False
        """
        tree, bags = self.build_tree_decomposition()

        # 检查条件1: T是一棵树
        if not self._is_tree(tree):
            return False

        # 检查条件2-3: 覆盖所有顶点
        all_vertices_in_bags = set()
        for bag in bags.values():
            all_vertices_in_bags.update(bag)
        if all_vertices_in_bags != self.vertices:
            return False

        # 检查条件4: 每条边都在某个袋子里
        for u in self.graph:
            for v in self.graph[u]:
                edge_in_bag = False
                for bag in bags.values():
                    if u in bag and v in bag:
                        edge_in_bag = True
                        break
                if not edge_in_bag:
                    return False

        # 检查条件5: 连通性条件
        for v in self.vertices:
            nodes_containing_v = [node for node, bag in bags.items() if v in bag]
            if not self._is_connected_subtree(tree, nodes_containing_v):
                return False

        return True

    def _is_tree(self, tree: Dict) -> bool:
        """检查是否是树结构（简化：检查连通性）"""
        if not tree:
            return True

        # 简单检查：树应该是连通的且边数 = 节点数 - 1
        all_nodes = set()
        edge_count = 0
        for node, children in tree.items():
            all_nodes.add(node)
            edge_count += len(children)
            all_nodes.update(children)

        return edge_count == len(all_nodes) - 1

    def _is_connected_subtree(self, tree: Dict, nodes: List) -> bool:
        """检查节点集合是否形成连通子树（简化实现）"""
        if len(nodes) <= 1:
            return True

        # 使用DFS检查连通性
        visited = set()
        stack = [nodes[0]]

        while stack:
            node = stack.pop()
            if node in visited:
                continue
            visited.add(node)

            # 检查树中的邻居
            for parent, children in tree.items():
                if node == parent:
                    for child in children:
                        if child in nodes and child not in visited:
                            stack.append(child)
                if node in children and parent in nodes and parent not in visited:
                    stack.append(parent)

        return len(visited) == len(nodes)
```

---

## 📊 **复杂度分析 / Complexity Analysis**

- **时间复杂度**:
  - `build_tree_decomposition`: $O(2^n)$ 最坏情况（寻找最大团是NP-hard）
  - `compute_treewidth`: $O(2^n)$
  - `verify_decomposition`: $O(|V|^2 + |E|)$
- **空间复杂度**: $O(|V|^2 + |T|)$ 其中 $|T|$ 是树节点数

---

## 💼 **应用场景 / Application Scenarios**

- **动态规划优化**：对于有界树宽的图，许多NP-hard问题可以在多项式时间内解决
- **算法设计**：利用树分解设计高效的图算法
- **参数化复杂性**：树宽是参数化算法中的重要参数

---

## 🔗 **相关链接 / Related Links**

- [图的分解理论目录](../README.md)
- [路径分解](02-路径分解.md)
- [分支分解](03-分支分解.md)
- [图论高级理论主目录](../../README.md)

---

**文档版本**: v1.0
**创建时间**: 2025年1月
**状态**: ✅ **已完成**
