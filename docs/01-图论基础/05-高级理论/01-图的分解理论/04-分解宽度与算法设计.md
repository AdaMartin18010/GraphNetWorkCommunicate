# åˆ†è§£å®½åº¦ä¸ç®—æ³•è®¾è®¡ / Decomposition Width and Algorithm Design

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»åˆ†è§£å®½åº¦ï¼ˆæ ‘å®½ã€è·¯å¾„å®½ã€åˆ†æ”¯å®½ï¼‰ä¸ç®—æ³•è®¾è®¡çš„å…³ç³»ï¼ŒåŒ…æ‹¬åŠ¨æ€è§„åˆ’åœ¨åˆ†è§£å›¾ä¸Šçš„åº”ç”¨ã€å‚æ•°åŒ–ç®—æ³•è®¾è®¡åŸç†å’Œå®é™…åº”ç”¨æ¡ˆä¾‹ã€‚

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [åˆ†è§£å®½åº¦ä¸ç®—æ³•è®¾è®¡ / Decomposition Width and Algorithm Design](#åˆ†è§£å®½åº¦ä¸ç®—æ³•è®¾è®¡--decomposition-width-and-algorithm-design)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [1. åˆ†è§£å®½åº¦ä¸å‚æ•°åŒ–å¤æ‚æ€§ / Decomposition Width and Parameterized Complexity](#1-åˆ†è§£å®½åº¦ä¸å‚æ•°åŒ–å¤æ‚æ€§--decomposition-width-and-parameterized-complexity)
  - [2. åŠ¨æ€è§„åˆ’åœ¨æ ‘åˆ†è§£ä¸Šçš„åº”ç”¨ / Dynamic Programming on Tree Decomposition](#2-åŠ¨æ€è§„åˆ’åœ¨æ ‘åˆ†è§£ä¸Šçš„åº”ç”¨--dynamic-programming-on-tree-decomposition)
  - [3. å…¸å‹é—®é¢˜çš„å‚æ•°åŒ–ç®—æ³• / Parameterized Algorithms for Classic Problems](#3-å…¸å‹é—®é¢˜çš„å‚æ•°åŒ–ç®—æ³•--parameterized-algorithms-for-classic-problems)
  - [4. åº”ç”¨æ¡ˆä¾‹ / Application Cases](#4-åº”ç”¨æ¡ˆä¾‹--application-cases)
  - [ğŸ”— **ç›¸å…³é“¾æ¥ / Related Links**](#-ç›¸å…³é“¾æ¥--related-links)

---

## 1. åˆ†è§£å®½åº¦ä¸å‚æ•°åŒ–å¤æ‚æ€§ / Decomposition Width and Parameterized Complexity

### 1.1 å‚æ•°åŒ–å¤æ‚æ€§çš„åŸºæœ¬æ¦‚å¿µ

**å®šä¹‰ 1.1** (å‚æ•°åŒ–é—®é¢˜ / Parameterized Problem)

ä¸€ä¸ª**å‚æ•°åŒ–é—®é¢˜**æ˜¯ä¸€ä¸ªå¯¹ $(I, k)$ï¼Œå…¶ä¸­ $I$ æ˜¯è¾“å…¥å®ä¾‹ï¼Œ$k$ æ˜¯å‚æ•°ã€‚

**å®šä¹‰ 1.2** (å›ºå®šå‚æ•°å¯è§£ / Fixed-Parameter Tractable, FPT)

ä¸€ä¸ªå‚æ•°åŒ–é—®é¢˜ $(I, k)$ æ˜¯**å›ºå®šå‚æ•°å¯è§£çš„**ï¼Œå¦‚æœå­˜åœ¨ç®—æ³•åœ¨ $O(f(k) \cdot |I|^{O(1)})$ æ—¶é—´å†…è§£å†³ï¼Œå…¶ä¸­ $f$ æ˜¯åªä¾èµ–äº $k$ çš„å‡½æ•°ã€‚

### 1.2 åˆ†è§£å®½åº¦ä½œä¸ºå‚æ•°

**å®šç† 1.1** (æ ‘å®½ä¸FPTç®—æ³•)

å¯¹äºæ ‘å®½ä¸º $k$ çš„å›¾ï¼Œè®¸å¤šNPéš¾é—®é¢˜å¯ä»¥åœ¨ $O(f(k) \cdot n)$ æ—¶é—´å†…è§£å†³ï¼Œå…¶ä¸­ $f$ æ˜¯ $k$ çš„æŒ‡æ•°å‡½æ•°ã€‚

**å…³é”®æ€æƒ³**:
- æ ‘å®½å°çš„å›¾å…·æœ‰"æ ‘çŠ¶"ç»“æ„
- å¯ä»¥åˆ©ç”¨åŠ¨æ€è§„åˆ’åœ¨æ ‘åˆ†è§£ä¸Šé«˜æ•ˆæ±‚è§£
- å¯¹äºå›ºå®šçš„æ ‘å®½ï¼Œç®—æ³•æ˜¯çº¿æ€§çš„

---

## 2. åŠ¨æ€è§„åˆ’åœ¨æ ‘åˆ†è§£ä¸Šçš„åº”ç”¨ / Dynamic Programming on Tree Decomposition

### 2.1 åŠ¨æ€è§„åˆ’æ¡†æ¶

**ç®—æ³•æ¡†æ¶**:

1. **æ„å»ºæ ‘åˆ†è§£**: æ‰¾åˆ°æ ‘å®½ä¸º $k$ çš„æ ‘åˆ†è§£ $(T, \{X_t\})$
2. **è‡ªåº•å‘ä¸Šéå†**: å¯¹æ ‘ $T$ è¿›è¡Œååºéå†
3. **çŠ¶æ€å®šä¹‰**: å¯¹æ¯ä¸ªèŠ‚ç‚¹ $t$ï¼Œå®šä¹‰çŠ¶æ€ $dp[t][S]$ï¼Œå…¶ä¸­ $S \subseteq X_t$
4. **çŠ¶æ€è½¬ç§»**: æ ¹æ®å­èŠ‚ç‚¹çš„çŠ¶æ€è¿›è¡Œè½¬ç§»
5. **ç­”æ¡ˆæå–**: ä»æ ¹èŠ‚ç‚¹çš„çŠ¶æ€ä¸­æå–ç­”æ¡ˆ

### 2.2 çŠ¶æ€ç©ºé—´å¤§å°

**å¼•ç† 2.1** (çŠ¶æ€ç©ºé—´å¤§å°)

å¯¹äºæ ‘å®½ä¸º $k$ çš„å›¾ï¼Œæ¯ä¸ªè¢‹å­çš„çŠ¶æ€ç©ºé—´å¤§å°ä¸º $O(2^k)$ æˆ– $O(k^k)$ï¼Œå–å†³äºé—®é¢˜ç±»å‹ã€‚

**è¯æ˜**:
- æ¯ä¸ªè¢‹å­æœ€å¤šåŒ…å« $k+1$ ä¸ªé¡¶ç‚¹
- çŠ¶æ€é€šå¸¸æ˜¯å¯¹è¿™äº›é¡¶ç‚¹çš„æŸç§èµ‹å€¼
- å› æ­¤çŠ¶æ€ç©ºé—´æ˜¯æŒ‡æ•°çº§çš„ï¼Œä½†å¯¹äºå›ºå®šçš„ $k$ æ˜¯å¯ç®¡ç†çš„

---

## 3. å…¸å‹é—®é¢˜çš„å‚æ•°åŒ–ç®—æ³• / Parameterized Algorithms for Classic Problems

### 3.1 ç‹¬ç«‹é›†é—®é¢˜

**é—®é¢˜**: åœ¨æ ‘å®½ä¸º $k$ çš„å›¾ä¸­æ‰¾æœ€å¤§ç‹¬ç«‹é›†ã€‚

**ç®—æ³• 3.1** (åŸºäºæ ‘åˆ†è§£çš„ç‹¬ç«‹é›†ç®—æ³•)

```python
def max_independent_set_treewidth(graph, tree_decomposition):
    """
    åœ¨æ ‘å®½ä¸ºkçš„å›¾ä¸­æ‰¾æœ€å¤§ç‹¬ç«‹é›†ã€‚

    æ—¶é—´å¤æ‚åº¦: O(2^k * k * n)
    ç©ºé—´å¤æ‚åº¦: O(2^k * n)
    """
    T, bags = tree_decomposition
    dp = {}  # dp[t][S] = æœ€å¤§ç‹¬ç«‹é›†å¤§å°

    # è‡ªåº•å‘ä¸Šéå†æ ‘
    for t in postorder_traversal(T):
        dp[t] = {}

        # å¯¹è¢‹å­çš„æ¯ä¸ªå­é›†Sï¼ˆç‹¬ç«‹é›†ï¼‰
        for S in powerset(bags[t]):
            if not is_independent_set(S, graph):
                continue

            # åˆå§‹åŒ–ï¼šåªè€ƒè™‘è¢‹å­ä¸­çš„é¡¶ç‚¹
            max_size = len(S)

            # è€ƒè™‘å­èŠ‚ç‚¹çš„çŠ¶æ€
            for child in children(T, t):
                # æ‰¾åˆ°å­èŠ‚ç‚¹è¢‹å­ä¸å½“å‰è¢‹å­çš„äº¤é›†
                intersection = bags[child] & bags[t]

                # æ‰¾åˆ°å­èŠ‚ç‚¹çŠ¶æ€ä¸­ä¸Så…¼å®¹çš„çŠ¶æ€
                best_child = 0
                for child_S in dp[child]:
                    if (child_S & intersection) == (S & intersection):
                        best_child = max(best_child, dp[child][child_S])

                max_size = max(max_size, len(S) + best_child - len(S & intersection))

            dp[t][S] = max_size

    # ä»æ ¹èŠ‚ç‚¹æå–ç­”æ¡ˆ
    root = get_root(T)
    return max(dp[root].values())
```

**æ—¶é—´å¤æ‚åº¦**: $O(2^k \cdot k \cdot n)$
**ç©ºé—´å¤æ‚åº¦**: $O(2^k \cdot n)$

### 3.2 é¡¶ç‚¹è¦†ç›–é—®é¢˜

**é—®é¢˜**: åœ¨æ ‘å®½ä¸º $k$ çš„å›¾ä¸­æ‰¾æœ€å°é¡¶ç‚¹è¦†ç›–ã€‚

**ç®—æ³• 3.2** (åŸºäºæ ‘åˆ†è§£çš„é¡¶ç‚¹è¦†ç›–ç®—æ³•)

```python
def min_vertex_cover_treewidth(graph, tree_decomposition):
    """
    åœ¨æ ‘å®½ä¸ºkçš„å›¾ä¸­æ‰¾æœ€å°é¡¶ç‚¹è¦†ç›–ã€‚

    æ—¶é—´å¤æ‚åº¦: O(2^k * k * n)
    ç©ºé—´å¤æ‚åº¦: O(2^k * n)
    """
    T, bags = tree_decomposition
    dp = {}  # dp[t][S] = æœ€å°è¦†ç›–å¤§å°

    # è‡ªåº•å‘ä¸Šéå†æ ‘
    for t in postorder_traversal(T):
        dp[t] = {}

        # å¯¹è¢‹å­çš„æ¯ä¸ªå­é›†Sï¼ˆè¦†ç›–çš„ä¸€éƒ¨åˆ†ï¼‰
        for S in powerset(bags[t]):
            # æ£€æŸ¥Sæ˜¯å¦è¦†ç›–äº†è¢‹å­å†…çš„æ‰€æœ‰è¾¹
            if not covers_bag_edges(S, bags[t], graph):
                continue

            # åˆå§‹åŒ–
            min_size = len(S)

            # è€ƒè™‘å­èŠ‚ç‚¹çš„çŠ¶æ€
            for child in children(T, t):
                intersection = bags[child] & bags[t]

                best_child = float('inf')
                for child_S in dp[child]:
                    if (child_S & intersection) == (S & intersection):
                        best_child = min(best_child, dp[child][child_S])

                min_size = min(min_size, len(S) + best_child - len(S & intersection))

            dp[t][S] = min_size

    root = get_root(T)
    return min(dp[root].values())
```

**æ—¶é—´å¤æ‚åº¦**: $O(2^k \cdot k \cdot n)$
**ç©ºé—´å¤æ‚åº¦**: $O(2^k \cdot n)$

### 3.3 æ”¯é…é›†é—®é¢˜

**é—®é¢˜**: åœ¨æ ‘å®½ä¸º $k$ çš„å›¾ä¸­æ‰¾æœ€å°æ”¯é…é›†ã€‚

**ç®—æ³• 3.3** (åŸºäºæ ‘åˆ†è§£çš„æ”¯é…é›†ç®—æ³•)

```python
def min_dominating_set_treewidth(graph, tree_decomposition):
    """
    åœ¨æ ‘å®½ä¸ºkçš„å›¾ä¸­æ‰¾æœ€å°æ”¯é…é›†ã€‚

    æ—¶é—´å¤æ‚åº¦: O(3^k * k * n)
    ç©ºé—´å¤æ‚åº¦: O(3^k * n)
    """
    T, bags = tree_decomposition
    dp = {}  # dp[t][S] = æœ€å°æ”¯é…é›†å¤§å°

    # çŠ¶æ€ï¼šå¯¹æ¯ä¸ªé¡¶ç‚¹ï¼Œæ ‡è®°ä¸ºï¼š
    # 0: ä¸åœ¨æ”¯é…é›†ä¸­ï¼Œæœªè¢«æ”¯é…
    # 1: ä¸åœ¨æ”¯é…é›†ä¸­ï¼Œå·²è¢«æ”¯é…
    # 2: åœ¨æ”¯é…é›†ä¸­

    for t in postorder_traversal(T):
        dp[t] = {}

        # å¯¹è¢‹å­çš„æ¯ä¸ªçŠ¶æ€ï¼ˆ3^kç§å¯èƒ½ï¼‰
        for state in all_states(bags[t]):  # æ¯ä¸ªé¡¶ç‚¹3ç§çŠ¶æ€
            if not is_valid_state(state, bags[t], graph):
                continue

            min_size = count_dominating_vertices(state)

            for child in children(T, t):
                intersection = bags[child] & bags[t]

                best_child = float('inf')
                for child_state in dp[child]:
                    if compatible_states(state, child_state, intersection):
                        best_child = min(best_child, dp[child][child_state])

                min_size = min(min_size, min_size + best_child - count_intersection(state, child_state, intersection))

            dp[t][state] = min_size

    root = get_root(T)
    return min(dp[root].values())
```

**æ—¶é—´å¤æ‚åº¦**: $O(3^k \cdot k \cdot n)$
**ç©ºé—´å¤æ‚åº¦**: $O(3^k \cdot n)$

---

## 4. åº”ç”¨æ¡ˆä¾‹ / Application Cases

### 4.1 å®é™…åº”ç”¨åœºæ™¯

1. **VLSIè®¾è®¡**: ç”µè·¯å›¾çš„æ ‘å®½é€šå¸¸è¾ƒå°ï¼Œå¯ä»¥é«˜æ•ˆæ±‚è§£å¸ƒå±€é—®é¢˜
2. **ç”Ÿç‰©ä¿¡æ¯å­¦**: è›‹ç™½è´¨ç›¸äº’ä½œç”¨ç½‘ç»œçš„æ ‘å®½åˆ†æ
3. **ç¤¾äº¤ç½‘ç»œ**: å°ä¸–ç•Œç½‘ç»œçš„æ ‘å®½åˆ†æ
4. **ç¼–è¯‘å™¨ä¼˜åŒ–**: ç¨‹åºä¾èµ–å›¾çš„æ ‘å®½åˆ†æ

### 4.2 æ€§èƒ½åˆ†æ

| é—®é¢˜ | æ ‘å®½k | æ—¶é—´å¤æ‚åº¦ | å®é™…æ€§èƒ½ |
|------|-------|-----------|---------|
| **ç‹¬ç«‹é›†** | k=10 | $O(2^{10} \cdot 10 \cdot n)$ | å¯¹äºn=1000ï¼Œçº¦$10^7$æ¬¡æ“ä½œ |
| **é¡¶ç‚¹è¦†ç›–** | k=10 | $O(2^{10} \cdot 10 \cdot n)$ | å¯¹äºn=1000ï¼Œçº¦$10^7$æ¬¡æ“ä½œ |
| **æ”¯é…é›†** | k=10 | $O(3^{10} \cdot 10 \cdot n)$ | å¯¹äºn=1000ï¼Œçº¦$6 \times 10^8$æ¬¡æ“ä½œ |

---

## ğŸ”— **ç›¸å…³é“¾æ¥ / Related Links**

- [æ ‘åˆ†è§£](01-æ ‘åˆ†è§£.md)
- [è·¯å¾„åˆ†è§£](02-è·¯å¾„åˆ†è§£.md)
- [åˆ†æ”¯åˆ†è§£](03-åˆ†æ”¯åˆ†è§£.md)
- [å›¾è®ºé«˜çº§ç†è®ºä¸»ç›®å½•](../README.md)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
