# è·¯å¾„åˆ†è§£ / Path Decomposition

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä»‹ç»å›¾è®ºä¸­çš„è·¯å¾„åˆ†è§£ï¼ˆPath Decompositionï¼‰ç†è®ºï¼ŒåŒ…æ‹¬è·¯å¾„åˆ†è§£çš„å®šä¹‰ã€è·¯å¾„å®½çš„æ¦‚å¿µå’Œç®—æ³•å®ç°ã€‚

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [è·¯å¾„åˆ†è§£ / Path Decomposition](#è·¯å¾„åˆ†è§£--path-decomposition)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [ğŸ“ **å½¢å¼åŒ–å®šä¹‰ / Formal Definition**](#-å½¢å¼åŒ–å®šä¹‰--formal-definition)
    - [å®šä¹‰ 5.1.3 (è·¯å¾„åˆ†è§£ / Path Decomposition)](#å®šä¹‰-513-è·¯å¾„åˆ†è§£--path-decomposition)
    - [å®šä¹‰ 5.1.4 (è·¯å¾„å®½ / Pathwidth)](#å®šä¹‰-514-è·¯å¾„å®½--pathwidth)
  - [ğŸ”§ **æ€§è´¨ / Properties**](#-æ€§è´¨--properties)
  - [ğŸ’» **ç®—æ³•å®ç° / Algorithm Implementation**](#-ç®—æ³•å®ç°--algorithm-implementation)
    - [ç®—æ³• 5.1.2 (è·¯å¾„åˆ†è§£æ„å»º - ç®€åŒ–ç‰ˆ)](#ç®—æ³•-512-è·¯å¾„åˆ†è§£æ„å»º---ç®€åŒ–ç‰ˆ)
  - [ğŸ“Š **å¤æ‚åº¦åˆ†æ / Complexity Analysis**](#-å¤æ‚åº¦åˆ†æ--complexity-analysis)
  - [ğŸ’¼ **åº”ç”¨åœºæ™¯ / Application Scenarios**](#-åº”ç”¨åœºæ™¯--application-scenarios)
  - [ğŸ”— **ç›¸å…³é“¾æ¥ / Related Links**](#-ç›¸å…³é“¾æ¥--related-links)

---

## ğŸ“ **å½¢å¼åŒ–å®šä¹‰ / Formal Definition**

### å®šä¹‰ 5.1.3 (è·¯å¾„åˆ†è§£ / Path Decomposition)

å›¾ $G = (V, E)$ çš„**è·¯å¾„åˆ†è§£**æ˜¯ä¸€ä¸ªæœ‰åºå¯¹ $(P, \{X_t\}_{t \in V(P)})$ï¼Œå…¶ä¸­ï¼š

1. $P$ æ˜¯ä¸€æ¡è·¯å¾„ï¼ˆè€Œä¸æ˜¯ä¸€èˆ¬çš„æ ‘ï¼‰
2. æ¯ä¸ª $X_t \subseteq V(G)$ æ˜¯ $G$ çš„é¡¶ç‚¹å­é›†
3. $\bigcup_{t \in V(P)} X_t = V(G)$
4. å¯¹äºæ¯æ¡è¾¹ $uv \in E(G)$ï¼Œå­˜åœ¨æŸä¸ªèŠ‚ç‚¹ $t \in V(P)$ ä½¿å¾— $u, v \in X_t$
5. å¯¹äºæ¯ä¸ªé¡¶ç‚¹ $v \in V(G)$ï¼Œ$P$ ä¸­æ‰€æœ‰åŒ…å« $v$ çš„èŠ‚ç‚¹å½¢æˆ $P$ çš„è¿é€šå­è·¯å¾„

---

### å®šä¹‰ 5.1.4 (è·¯å¾„å®½ / Pathwidth)

å›¾ $G$ çš„**è·¯å¾„å®½**å®šä¹‰ä¸ºï¼š

$$\text{pw}(G) = \min_{(P, \{X_t\})} \max_{t \in V(P)} |X_t| - 1$$

å…¶ä¸­æœ€å°å€¼å–é $G$ çš„æ‰€æœ‰è·¯å¾„åˆ†è§£ã€‚

---

## ğŸ”§ **æ€§è´¨ / Properties**

- è·¯å¾„å®½æ€»æ˜¯å¤§äºç­‰äºæ ‘å®½ï¼š$\text{pw}(G) \geq \text{tw}(G)$
- å¯¹äºæ ‘ï¼Œè·¯å¾„å®½å¯ä»¥å¤§äºæ ‘å®½
- è·¯å¾„å›¾ï¼ˆpath graphï¼‰çš„è·¯å¾„å®½ä¸º 1

---

## ğŸ’» **ç®—æ³•å®ç° / Algorithm Implementation**

### ç®—æ³• 5.1.2 (è·¯å¾„åˆ†è§£æ„å»º - ç®€åŒ–ç‰ˆ)

```python
from typing import List, Set, Dict

class PathDecomposition:
    """
    å›¾çš„è·¯å¾„åˆ†è§£å®ç°ï¼ˆç®€åŒ–ç‰ˆï¼‰ã€‚
    å®é™…åº”ç”¨ä¸­å¯ä»¥ä½¿ç”¨æ›´é«˜æ•ˆçš„ç®—æ³•ã€‚
    """

    def __init__(self, graph: Dict[int, List[int]]):
        self.graph = graph
        self.vertices = set(graph.keys())
        self.path = []  # è·¯å¾„èŠ‚ç‚¹åºåˆ—
        self.bags = {}  # è¢‹å­æ˜ å°„

    def build_path_decomposition(self) -> tuple:
        """
        æ„å»ºè·¯å¾„åˆ†è§£ã€‚

        è¿”å›:
            (path, bags) è·¯å¾„å’Œè¢‹å­æ˜ å°„
        """
        if not self.vertices:
            return [], {}

        # ç®€åŒ–å®ç°ï¼šä½¿ç”¨é¡¶ç‚¹æ¶ˆå»é¡ºåº
        elimination_order = self._compute_elimination_order()

        # ä¸ºæ¯ä¸ªé¡¶ç‚¹åˆ›å»ºè·¯å¾„èŠ‚ç‚¹
        for i, vertex in enumerate(elimination_order):
            node_id = f"node_{i}"

            # è¢‹å­åŒ…å«å½“å‰é¡¶ç‚¹åŠå…¶åœ¨æœªå¤„ç†é¡¶ç‚¹ä¸­çš„é‚»å±…
            bag = {vertex}
            remaining_neighbors = [v for v in self.graph.get(vertex, [])
                                 if v in elimination_order[i+1:]]
            bag.update(remaining_neighbors)

            self.path.append(node_id)
            self.bags[node_id] = bag

        return self.path, self.bags

    def _compute_elimination_order(self) -> List[int]:
        """
        è®¡ç®—é¡¶ç‚¹æ¶ˆå»é¡ºåºï¼ˆä½¿ç”¨è´ªå¿ƒæ–¹æ³•ï¼Œæœ€å°åŒ–æœ€å¤§å›¢å¤§å°ï¼‰ã€‚

        è¿”å›:
            é¡¶ç‚¹æ¶ˆå»é¡ºåºåˆ—è¡¨
        """
        order = []
        remaining = set(self.vertices)
        graph_copy = {v: set(neighbors) for v, neighbors in self.graph.items()}

        while remaining:
            # é€‰æ‹©åº¦æœ€å°çš„é¡¶ç‚¹
            best_vertex = min(remaining,
                            key=lambda v: len(graph_copy.get(v, set()) & remaining))

            order.append(best_vertex)
            remaining.remove(best_vertex)

        return order

    def compute_pathwidth(self) -> int:
        """
        è®¡ç®—è·¯å¾„å®½ã€‚

        è¿”å›:
            è·¯å¾„å®½å€¼
        """
        _, bags = self.build_path_decomposition()

        if not bags:
            return 0

        max_bag_size = max(len(bag) for bag in bags.values())
        return max_bag_size - 1
```

---

## ğŸ“Š **å¤æ‚åº¦åˆ†æ / Complexity Analysis**

- **æ—¶é—´å¤æ‚åº¦**: $O(|V|^2)$ (ç®€åŒ–å®ç°)
- **ç©ºé—´å¤æ‚åº¦**: $O(|V|^2)$

---

## ğŸ”— **ç›¸å…³é“¾æ¥ / Related Links**

- [å›¾çš„åˆ†è§£ç†è®ºç›®å½•](../README.md)
- [æ ‘åˆ†è§£](01-æ ‘åˆ†è§£.md)
- [åˆ†æ”¯åˆ†è§£](03-åˆ†æ”¯åˆ†è§£.md)
- [å›¾è®ºé«˜çº§ç†è®ºä¸»ç›®å½•](../../README.md)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**çŠ¶æ€**: âœ… **å·²å®Œæˆ**
