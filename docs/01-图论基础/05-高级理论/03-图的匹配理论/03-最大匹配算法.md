# æœ€å¤§åŒ¹é…ç®—æ³• / Maximum Matching Algorithms

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä»‹ç»äºŒåˆ†å›¾ä¸­çš„æœ€å¤§åŒ¹é…ç®—æ³•ï¼ŒåŒ…æ‹¬åŒˆç‰™åˆ©ç®—æ³•å’ŒHopcroft-Karpç®—æ³•ã€‚

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [æœ€å¤§åŒ¹é…ç®—æ³• / Maximum Matching Algorithms](#æœ€å¤§åŒ¹é…ç®—æ³•--maximum-matching-algorithms)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [ğŸ’» **ç®—æ³•å®ç° / Algorithm Implementation**](#-ç®—æ³•å®ç°--algorithm-implementation)
    - [ç®—æ³• 5.3.1 (åŒˆç‰™åˆ©ç®—æ³• / Hungarian Algorithm)](#ç®—æ³•-531-åŒˆç‰™åˆ©ç®—æ³•--hungarian-algorithm)
    - [ç®—æ³• 5.3.2 (Hopcroft-Karpç®—æ³•)](#ç®—æ³•-532-hopcroft-karpç®—æ³•)
  - [ğŸ“Š **å¤æ‚åº¦åˆ†æ / Complexity Analysis**](#-å¤æ‚åº¦åˆ†æ--complexity-analysis)
    - [åŒˆç‰™åˆ©ç®—æ³•](#åŒˆç‰™åˆ©ç®—æ³•)
    - [Hopcroft-Karpç®—æ³•](#hopcroft-karpç®—æ³•)
  - [ğŸ”— **ç›¸å…³é“¾æ¥ / Related Links**](#-ç›¸å…³é“¾æ¥--related-links)

---

## ğŸ’» **ç®—æ³•å®ç° / Algorithm Implementation**

### ç®—æ³• 5.3.1 (åŒˆç‰™åˆ©ç®—æ³• / Hungarian Algorithm)

åŒˆç‰™åˆ©ç®—æ³•ç”¨äºåœ¨äºŒåˆ†å›¾ä¸­å¯»æ‰¾æœ€å¤§åŒ¹é…ã€‚

**æ—¶é—´å¤æ‚åº¦**ï¼š$O(V \cdot E)$

**ç®—æ³•æè¿°**ï¼š

1. ä»ç©ºçš„åŒ¹é…å¼€å§‹
2. å¯¹äº $U$ ä¸­çš„æ¯ä¸ªæœªåŒ¹é…é¡¶ç‚¹ï¼Œå°è¯•æ‰¾åˆ°å¢å¹¿è·¯å¾„
3. å¦‚æœæ‰¾åˆ°å¢å¹¿è·¯å¾„ï¼Œåˆ™æ²¿è·¯å¾„æ‰©å±•åŒ¹é…
4. é‡å¤ç›´åˆ°æ‰¾ä¸åˆ°å¢å¹¿è·¯å¾„

**ç®—æ³•å®ç°**ï¼š

```python
from typing import Dict, List, Set, Optional, Tuple

class BipartiteGraph:
    """
    äºŒåˆ†å›¾å®ç°ã€‚
    """

    def __init__(self, left_vertices: List[str], right_vertices: List[str],
                 edges: List[Tuple[str, str]]):
        """
        åˆå§‹åŒ–äºŒåˆ†å›¾ã€‚

        Args:
            left_vertices: å·¦éƒ¨é¡¶ç‚¹åˆ—è¡¨ï¼ˆUï¼‰
            right_vertices: å³éƒ¨é¡¶ç‚¹åˆ—è¡¨ï¼ˆVï¼‰
            edges: è¾¹åˆ—è¡¨ï¼Œæ¯ä¸ªå…ƒç´ ä¸º (u, v)
        """
        self.U = set(left_vertices)
        self.V = set(right_vertices)
        self.edges = set(edges)

        # æ„å»ºé‚»æ¥è¡¨
        self.adj_U: Dict[str, List[str]] = {u: [] for u in left_vertices}
        self.adj_V: Dict[str, List[str]] = {v: [] for v in right_vertices}

        for u, v in edges:
            if u in self.U and v in self.V:
                self.adj_U[u].append(v)
                self.adj_V[v].append(u)

    def hungarian(self) -> Dict[str, str]:
        """
        åŒˆç‰™åˆ©ç®—æ³•è®¡ç®—æœ€å¤§åŒ¹é…ã€‚

        Returns:
            åŒ¹é…å­—å…¸ {u: v}ï¼Œè¡¨ç¤º u åŒ¹é…åˆ° v
        """
        # åŒ¹é…ï¼šä»å³éƒ¨é¡¶ç‚¹åˆ°å·¦éƒ¨é¡¶ç‚¹çš„æ˜ å°„
        matching: Dict[str, Optional[str]] = {v: None for v in self.V}

        def dfs(u: str, visited: Set[str]) -> bool:
            """
            ä½¿ç”¨DFSå¯»æ‰¾å¢å¹¿è·¯å¾„ã€‚

            Args:
                u: å½“å‰å·¦éƒ¨é¡¶ç‚¹
                visited: å·²è®¿é—®çš„å³éƒ¨é¡¶ç‚¹é›†åˆ

            Returns:
                å¦‚æœæ‰¾åˆ°å¢å¹¿è·¯å¾„è¿”å›True
            """
            for v in self.adj_U[u]:
                if v in visited:
                    continue
                visited.add(v)

                # å¦‚æœvæœªåŒ¹é…ï¼Œæˆ–è€…å¯ä»¥ä¸ºvçš„å½“å‰åŒ¹é…æ‰¾åˆ°æ–°çš„åŒ¹é…
                if matching[v] is None or dfs(matching[v], visited):
                    matching[v] = u
                    return True

            return False

        # å¯¹æ¯ä¸ªæœªåŒ¹é…çš„å·¦éƒ¨é¡¶ç‚¹ï¼Œå°è¯•æ‰¾å¢å¹¿è·¯å¾„
        for u in self.U:
            dfs(u, set())

        # è½¬æ¢ä¸ºä»å·¦éƒ¨åˆ°å³éƒ¨çš„æ˜ å°„
        result = {}
        for v, u in matching.items():
            if u is not None:
                result[u] = v

        return result

    def get_max_matching_size(self) -> int:
        """è·å–æœ€å¤§åŒ¹é…çš„å¤§å°"""
        matching = self.hungarian()
        return len(matching)
```

---

### ç®—æ³• 5.3.2 (Hopcroft-Karpç®—æ³•)

Hopcroft-Karpç®—æ³•æ˜¯æ›´é«˜æ•ˆçš„æœ€å¤§åŒ¹é…ç®—æ³•ï¼Œä½¿ç”¨BFSåˆ†å±‚å¯»æ‰¾å¤šæ¡ä¸ç›¸äº¤çš„å¢å¹¿è·¯å¾„ã€‚

**æ—¶é—´å¤æ‚åº¦**ï¼š$O(\sqrt{V} \cdot E)$

**ç®—æ³•å®ç°**ï¼š

```python
from collections import deque
from typing import Dict, List, Set, Optional

class HopcroftKarp:
    """
    Hopcroft-Karpç®—æ³•å®ç°ã€‚
    """

    def __init__(self, bipartite_graph: BipartiteGraph):
        self.graph = bipartite_graph
        self.U = bipartite_graph.U
        self.V = bipartite_graph.V

    def hopcroft_karp(self) -> Dict[str, str]:
        """
        Hopcroft-Karpç®—æ³•è®¡ç®—æœ€å¤§åŒ¹é…ã€‚

        Returns:
            åŒ¹é…å­—å…¸ {u: v}
        """
        # åŒ¹é…ï¼šä»å³éƒ¨åˆ°å·¦éƒ¨çš„æ˜ å°„
        matching_V: Dict[str, Optional[str]] = {v: None for v in self.V}
        matching_U: Dict[str, Optional[str]] = {u: None for u in self.U}

        def bfs() -> bool:
            """
            ä½¿ç”¨BFSæ„å»ºåˆ†å±‚å›¾ï¼Œå¯»æ‰¾æœ€çŸ­å¢å¹¿è·¯å¾„ã€‚

            Returns:
                å¦‚æœæ‰¾åˆ°å¢å¹¿è·¯å¾„è¿”å›True
            """
            queue = deque()
            dist: Dict[str, int] = {}

            # ä»æ‰€æœ‰æœªåŒ¹é…çš„å·¦éƒ¨é¡¶ç‚¹å¼€å§‹
            for u in self.U:
                if matching_U[u] is None:
                    dist[u] = 0
                    queue.append(u)
                else:
                    dist[u] = float('inf')

            dist[None] = float('inf')

            while queue:
                u = queue.popleft()
                if dist[u] < dist[None]:
                    for v in self.graph.adj_U[u]:
                        u_next = matching_V[v]
                        if u_next is None:
                            u_next = None
                        if dist.get(u_next, float('inf')) == float('inf'):
                            dist[u_next] = dist[u] + 1 if u_next is not None else dist[u] + 1
                            queue.append(u_next)

            return dist[None] != float('inf')

        def dfs(u: str) -> bool:
            """
            ä½¿ç”¨DFSåœ¨åˆ†å±‚å›¾ä¸­å¯»æ‰¾å¢å¹¿è·¯å¾„ã€‚

            Args:
                u: å½“å‰å·¦éƒ¨é¡¶ç‚¹

            Returns:
                å¦‚æœæ‰¾åˆ°å¢å¹¿è·¯å¾„è¿”å›True
            """
            if u is None:
                return True

            for v in self.graph.adj_U[u]:
                u_next = matching_V[v]
                if u_next is None or (dist.get(u_next, float('inf')) == dist[u] + 1 and dfs(u_next)):
                    matching_V[v] = u
                    matching_U[u] = v
                    return True

            dist[u] = float('inf')
            return False

        matching_count = 0

        # åå¤å¯»æ‰¾å¢å¹¿è·¯å¾„
        while bfs():
            for u in self.U:
                if matching_U[u] is None:
                    if dfs(u):
                        matching_count += 1

        # è½¬æ¢ä¸ºä»å·¦éƒ¨åˆ°å³éƒ¨çš„æ˜ å°„
        result = {}
        for u, v in matching_U.items():
            if v is not None:
                result[u] = v

        return result
```

---

## ğŸ“Š **å¤æ‚åº¦åˆ†æ / Complexity Analysis**

### åŒˆç‰™åˆ©ç®—æ³•

- **æ—¶é—´å¤æ‚åº¦**: $O(V \cdot E)$
  - å¤–å±‚å¾ªç¯éå†æ‰€æœ‰å·¦éƒ¨é¡¶ç‚¹: $O(|U|)$
  - æ¯æ¬¡DFS: $O(E)$
- **ç©ºé—´å¤æ‚åº¦**: $O(V + E)$

### Hopcroft-Karpç®—æ³•

- **æ—¶é—´å¤æ‚åº¦**: $O(\sqrt{V} \cdot E)$
  - æœ€å¤šéœ€è¦ $O(\sqrt{V})$ æ¬¡è¿­ä»£ï¼ˆæ¯æ¬¡æ‰¾åˆ°å¤šæ¡ä¸ç›¸äº¤å¢å¹¿è·¯å¾„ï¼‰
  - æ¯æ¬¡BFS+DFS: $O(E)$
- **ç©ºé—´å¤æ‚åº¦**: $O(V + E)$

---

## ğŸ”— **ç›¸å…³é“¾æ¥ / Related Links**

- [å›¾çš„åŒ¹é…ç†è®ºç›®å½•](../README.md)
- [KÃ¶nigå®šç†çš„å®Œæ•´è¯æ˜](01-KÃ¶nigå®šç†çš„å®Œæ•´è¯æ˜.md)
- [éœå°”å©šå§»å®šç†çš„è¯¦ç»†è¯æ˜](02-éœå°”å©šå§»å®šç†çš„è¯¦ç»†è¯æ˜.md)
- [åŠ æƒåŒ¹é…ç®—æ³•](04-åŠ æƒåŒ¹é…ç®—æ³•.md)
- [å›¾è®ºé«˜çº§ç†è®ºä¸»ç›®å½•](../../README.md)

**æƒå¨å‡ºå¤„ä¸å¤æ‚åº¦æ ‡å‡†**ï¼šåŒˆç‰™åˆ©ç®—æ³• $O(VE)$ â€” Kuhn (1955), CLRS Ch.26, Diestel *Graph Theory*ï¼›Hopcroft-Karp $O(E\sqrt{V})$ â€” Hopcroft & Karp (1973)ï¼›MIT 18.217 å›¾è®ºè¯¾ç¨‹ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**çŠ¶æ€**: âœ… **å·²å®Œæˆ**
