# åŠ æƒåŒ¹é…ç®—æ³• / Weighted Matching Algorithms

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä»‹ç»å¸¦æƒäºŒåˆ†å›¾ä¸­çš„åŠ æƒåŒ¹é…ç®—æ³•ï¼Œä¸»è¦æ˜¯Kuhn-Munkresç®—æ³•ï¼ˆKMç®—æ³•ï¼‰ã€‚

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [åŠ æƒåŒ¹é…ç®—æ³• / Weighted Matching Algorithms](#åŠ æƒåŒ¹é…ç®—æ³•--weighted-matching-algorithms)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [ğŸ’» **ç®—æ³•å®ç° / Algorithm Implementation**](#-ç®—æ³•å®ç°--algorithm-implementation)

---

## ğŸ’» **ç®—æ³•å®ç° / Algorithm Implementation**

### ç®—æ³• 5.3.3 (Kuhn-Munkresç®—æ³• / KMç®—æ³•)

KMç®—æ³•ç”¨äºåœ¨å¸¦æƒäºŒåˆ†å›¾ä¸­å¯»æ‰¾æœ€å¤§æƒå®Œç¾åŒ¹é…ï¼ˆæˆ–æœ€å¤§æƒåŒ¹é…ï¼‰ã€‚

**æ—¶é—´å¤æ‚åº¦**ï¼š$O(V^3)$

**ç®—æ³•æè¿°**ï¼š

1. åˆå§‹åŒ–é¡¶æ ‡ï¼ˆvertex labelingï¼‰
2. æ„å»ºç›¸ç­‰å­å›¾
3. åœ¨ç›¸ç­‰å­å›¾ä¸­å¯»æ‰¾å®Œç¾åŒ¹é…
4. å¦‚æœæœªæ‰¾åˆ°ï¼Œè°ƒæ•´é¡¶æ ‡ï¼Œé‡å¤æ­¥éª¤2-3

**ç®—æ³•å®ç°**ï¼š

```python
from typing import Dict, List, Tuple, Optional, Set
import sys

class WeightedBipartiteGraph:
    """
    å¸¦æƒäºŒåˆ†å›¾å®ç°ã€‚
    """

    def __init__(self, left_vertices: List[str], right_vertices: List[str],
                 edges: List[Tuple[str, str, float]]):
        """
        åˆå§‹åŒ–å¸¦æƒäºŒåˆ†å›¾ã€‚

        Args:
            left_vertices: å·¦éƒ¨é¡¶ç‚¹åˆ—è¡¨
            right_vertices: å³éƒ¨é¡¶ç‚¹åˆ—è¡¨
            edges: è¾¹åˆ—è¡¨ï¼Œæ¯ä¸ªå…ƒç´ ä¸º (u, v, weight)
        """
        self.U = set(left_vertices)
        self.V = set(right_vertices)

        # æƒé‡çŸ©é˜µ
        self.weights: Dict[Tuple[str, str], float] = {}
        self.adj_U: Dict[str, List[str]] = {u: [] for u in left_vertices}

        for u, v, w in edges:
            if u in self.U and v in self.V:
                self.weights[(u, v)] = w
                self.adj_U[u].append(v)

    def kuhn_munkres(self) -> Tuple[Dict[str, str], float]:
        """
        Kuhn-Munkresç®—æ³•è®¡ç®—æœ€å¤§æƒå®Œç¾åŒ¹é…ã€‚

        Returns:
            (matching, total_weight) åŒ¹é…å­—å…¸å’Œæ€»æƒé‡
        """
        # åˆå§‹åŒ–é¡¶æ ‡
        label_U: Dict[str, float] = {u: max(self.weights.get((u, v), 0)
                                           for v in self.V) for u in self.U}
        label_V: Dict[str, float] = {v: 0.0 for v in self.V}

        # åŒ¹é…ï¼šä»å³éƒ¨åˆ°å·¦éƒ¨çš„æ˜ å°„
        matching_V: Dict[str, Optional[str]] = {v: None for v in self.V}
        matching_U: Dict[str, Optional[str]] = {u: None for u in self.U}

        def get_slack(u: str, v: str) -> float:
            """è®¡ç®—æ¾å¼›å€¼"""
            return label_U[u] + label_V[v] - self.weights.get((u, v), 0)

        def is_tight(u: str, v: str) -> bool:
            """æ£€æŸ¥è¾¹æ˜¯å¦æ˜¯ç´§è¾¹"""
            return abs(get_slack(u, v)) < 1e-9

        def find_augmenting_path(u: str, visited_U: Set[str], visited_V: Set[str],
                                slack: Dict[str, float], slack_v: Dict[str, str]) -> bool:
            """
            å¯»æ‰¾å¢å¹¿è·¯å¾„ã€‚
            """
            visited_U.add(u)

            for v in self.adj_U[u]:
                if v in visited_V:
                    continue

                slack_val = get_slack(u, v)
                if slack_val < slack[v]:
                    slack[v] = slack_val
                    slack_v[v] = u

                if is_tight(u, v):
                    visited_V.add(v)
                    u_next = matching_V[v]
                    if u_next is None or find_augmenting_path(u_next, visited_U, visited_V, slack, slack_v):
                        matching_V[v] = u
                        matching_U[u] = v
                        return True

            return False

        # å¯¹æ¯ä¸ªå·¦éƒ¨é¡¶ç‚¹ï¼Œå°è¯•æ‰¾å¢å¹¿è·¯å¾„
        for u in self.U:
            visited_U: Set[str] = set()
            visited_V: Set[str] = set()
            slack: Dict[str, float] = {v: float('inf') for v in self.V}
            slack_v: Dict[str, str] = {}

            # å¯»æ‰¾å¢å¹¿è·¯å¾„
            if not find_augmenting_path(u, visited_U, visited_V, slack, slack_v):
                # è°ƒæ•´é¡¶æ ‡
                delta = min(slack[v] for v in self.V if v not in visited_V)

                for u_visited in visited_U:
                    label_U[u_visited] -= delta

                for v_visited in visited_V:
                    label_V[v_visited] += delta

                for v in self.V:
                    if v not in visited_V:
                        slack[v] -= delta
                        if slack[v] < 1e-9:
                            visited_V.add(v)
                            u_next = matching_V[v]
                            if u_next is None:
                                matching_V[v] = slack_v[v]
                                matching_U[slack_v[v]] = v

        # è®¡ç®—æ€»æƒé‡
        total_weight = sum(self.weights.get((u, v), 0)
                          for u, v in matching_U.items() if v is not None)

        # è½¬æ¢ä¸ºä»å·¦éƒ¨åˆ°å³éƒ¨çš„æ˜ å°„
        result = {u: v for u, v in matching_U.items() if v is not None}

        return result, total_weight
```

---

## ğŸ“Š **å¤æ‚åº¦åˆ†æ / Complexity Analysis**

- **æ—¶é—´å¤æ‚åº¦**: $O(V^3)$
  - å¤–å±‚å¾ªç¯: $O(V)$
  - æ¯æ¬¡å¯»æ‰¾å¢å¹¿è·¯å¾„å’Œè°ƒæ•´é¡¶æ ‡: $O(V^2)$
- **ç©ºé—´å¤æ‚åº¦**: $O(V^2)$

---

## ğŸ”— **ç›¸å…³é“¾æ¥ / Related Links**

- [å›¾çš„åŒ¹é…ç†è®ºç›®å½•](../README.md)
- [KÃ¶nigå®šç†çš„å®Œæ•´è¯æ˜](01-KÃ¶nigå®šç†çš„å®Œæ•´è¯æ˜.md)
- [éœå°”å©šå§»å®šç†çš„è¯¦ç»†è¯æ˜](02-éœå°”å©šå§»å®šç†çš„è¯¦ç»†è¯æ˜.md)
- [æœ€å¤§åŒ¹é…ç®—æ³•](03-æœ€å¤§åŒ¹é…ç®—æ³•.md)
- [å›¾è®ºé«˜çº§ç†è®ºä¸»ç›®å½•](../../README.md)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**çŠ¶æ€**: âœ… **å·²å®Œæˆ**
