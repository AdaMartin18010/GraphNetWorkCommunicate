# æœ€å°è´¹ç”¨æµç†è®º / Minimum Cost Flow Theory

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä»‹ç»æœ€å°è´¹ç”¨æµç†è®ºï¼ŒåŒ…æ‹¬æœ€å°è´¹ç”¨æµé—®é¢˜çš„å®šä¹‰ã€ç®—æ³•å®ç°å’Œåº”ç”¨åœºæ™¯ã€‚

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [æœ€å°è´¹ç”¨æµç†è®º / Minimum Cost Flow Theory](#æœ€å°è´¹ç”¨æµç†è®º--minimum-cost-flow-theory)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [1. å½¢å¼åŒ–å®šä¹‰ / Formal Definition](#1-å½¢å¼åŒ–å®šä¹‰--formal-definition)
    - [å®šä¹‰ 1.1 (æœ€å°è´¹ç”¨æµç½‘ç»œ / Minimum Cost Flow Network)](#å®šä¹‰-11-æœ€å°è´¹ç”¨æµç½‘ç»œ--minimum-cost-flow-network)
    - [å®šä¹‰ 1.2 (æœ€å°è´¹ç”¨æµ / Minimum Cost Flow)](#å®šä¹‰-12-æœ€å°è´¹ç”¨æµ--minimum-cost-flow)
  - [2. ç®—æ³•å®ç° / Algorithm Implementation](#2-ç®—æ³•å®ç°--algorithm-implementation)
    - [ç®—æ³• 2.1 (æœ€å°è´¹ç”¨æœ€å¤§æµç®—æ³• - åŸºäºè´Ÿç¯æ¶ˆé™¤)](#ç®—æ³•-21-æœ€å°è´¹ç”¨æœ€å¤§æµç®—æ³•---åŸºäºè´Ÿç¯æ¶ˆé™¤)
  - [3. å¤æ‚åº¦åˆ†æ / Complexity Analysis](#3-å¤æ‚åº¦åˆ†æ--complexity-analysis)
    - [å®šç† 3.1 (æœ€å°è´¹ç”¨æµç®—æ³•å¤æ‚åº¦)](#å®šç†-31-æœ€å°è´¹ç”¨æµç®—æ³•å¤æ‚åº¦)
    - [ä¼˜åŒ–æ–¹æ³•](#ä¼˜åŒ–æ–¹æ³•)
  - [4. åº”ç”¨åœºæ™¯ / Application Scenarios](#4-åº”ç”¨åœºæ™¯--application-scenarios)
    - [4.1 è¿è¾“é—®é¢˜](#41-è¿è¾“é—®é¢˜)
    - [4.2 ä»»åŠ¡åˆ†é…é—®é¢˜](#42-ä»»åŠ¡åˆ†é…é—®é¢˜)
    - [4.3 ç½‘ç»œè®¾è®¡é—®é¢˜](#43-ç½‘ç»œè®¾è®¡é—®é¢˜)
  - [ğŸ”— **ç›¸å…³é“¾æ¥ / Related Links**](#-ç›¸å…³é“¾æ¥--related-links)

---

## 1. å½¢å¼åŒ–å®šä¹‰ / Formal Definition

### å®šä¹‰ 1.1 (æœ€å°è´¹ç”¨æµç½‘ç»œ / Minimum Cost Flow Network)

ä¸€ä¸ª**æœ€å°è´¹ç”¨æµç½‘ç»œ**æ˜¯ä¸€ä¸ªå…­å…ƒç»„ $N = (G, s, t, c, w, d)$ï¼Œå…¶ä¸­ï¼š

- $G = (V, E)$ æ˜¯æœ‰å‘å›¾
- $s \in V$ æ˜¯**æºç‚¹**ï¼ˆsourceï¼‰
- $t \in V$ æ˜¯**æ±‡ç‚¹**ï¼ˆsinkï¼‰
- $c: E \to \mathbb{R}^+$ æ˜¯**å®¹é‡å‡½æ•°**ï¼ˆcapacity functionï¼‰
- $w: E \to \mathbb{R}$ æ˜¯**è´¹ç”¨å‡½æ•°**ï¼ˆcost functionï¼‰
- $d \in \mathbb{R}^+$ æ˜¯**éœ€æ±‚æµå€¼**ï¼ˆdemand flow valueï¼‰

### å®šä¹‰ 1.2 (æœ€å°è´¹ç”¨æµ / Minimum Cost Flow)

ç»™å®šæœ€å°è´¹ç”¨æµç½‘ç»œ $N$ï¼Œ**æœ€å°è´¹ç”¨æµ**æ˜¯æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„æµ $f$ï¼š

1. **å®¹é‡çº¦æŸ**ï¼š$0 \leq f(e) \leq c(e)$ å¯¹äºæ‰€æœ‰ $e \in E$
2. **æµé‡å®ˆæ’**ï¼šå¯¹äºæ‰€æœ‰ $v \in V - \{s, t\}$ï¼š
   $$\sum_{e \in \delta^+(v)} f(e) = \sum_{e \in \delta^-(v)} f(e)$$
3. **éœ€æ±‚æ»¡è¶³**ï¼š$|f| = d$
4. **è´¹ç”¨æœ€å°**ï¼šåœ¨æ‰€æœ‰æ»¡è¶³ä¸Šè¿°æ¡ä»¶çš„æµä¸­ï¼Œ$f$ çš„è´¹ç”¨æœ€å°

**æµçš„è´¹ç”¨**å®šä¹‰ä¸ºï¼š
$$\text{cost}(f) = \sum_{e \in E} w(e) \cdot f(e)$$

---

## 2. ç®—æ³•å®ç° / Algorithm Implementation

### ç®—æ³• 2.1 (æœ€å°è´¹ç”¨æœ€å¤§æµç®—æ³• - åŸºäºè´Ÿç¯æ¶ˆé™¤)

**ç®—æ³•æè¿°**ï¼š

1. åˆå§‹åŒ–æµ $f$ ä¸ºå…¨é›¶æµ
2. åœ¨æ®‹å·®ç½‘ç»œä¸­å¯»æ‰¾è´Ÿè´¹ç”¨å¢å¹¿è·¯å¾„
3. å¦‚æœæ‰¾åˆ°ï¼Œæ²¿è·¯å¾„å¢åŠ æµ
4. é‡å¤æ­¥éª¤2-3ï¼Œç›´åˆ°æ‰¾ä¸åˆ°å¢å¹¿è·¯å¾„æˆ–è¾¾åˆ°éœ€æ±‚æµå€¼

**ç®—æ³•å®ç°**ï¼š

```python
from typing import Dict, List, Tuple, Optional
from collections import deque
import math

class MinCostFlowNetwork:
    """
    æœ€å°è´¹ç”¨æµç½‘ç»œå®ç°ã€‚
    """

    def __init__(self, vertices: List[str], edges: List[Tuple[str, str, int, int]],
                 source: str, sink: str, demand: int):
        """
        åˆå§‹åŒ–æœ€å°è´¹ç”¨æµç½‘ç»œã€‚

        Args:
            vertices: é¡¶ç‚¹åˆ—è¡¨
            edges: è¾¹åˆ—è¡¨ï¼Œæ¯ä¸ªå…ƒç´ ä¸º (u, v, capacity, cost)
            source: æºç‚¹
            sink: æ±‡ç‚¹
            demand: éœ€æ±‚æµå€¼
        """
        self.vertices = set(vertices)
        self.source = source
        self.sink = sink
        self.demand = demand

        # æ„å»ºé‚»æ¥è¡¨å’Œå®¹é‡/è´¹ç”¨çŸ©é˜µ
        self.graph: Dict[str, List[str]] = {v: [] for v in vertices}
        self.capacity: Dict[Tuple[str, str], int] = {}
        self.cost: Dict[Tuple[str, str], int] = {}
        self.flow: Dict[Tuple[str, str], int] = {}

        for u, v, cap, cost_val in edges:
            self.graph[u].append(v)
            self.capacity[(u, v)] = cap
            self.cost[(u, v)] = cost_val
            self.flow[(u, v)] = 0

    def residual_capacity(self, u: str, v: str) -> int:
        """
        è®¡ç®—æ®‹å·®å®¹é‡ã€‚

        Args:
            u: èµ·ç‚¹
            v: ç»ˆç‚¹

        Returns:
            æ®‹å·®å®¹é‡
        """
        # æ­£å‘è¾¹çš„æ®‹å·®å®¹é‡
        if (u, v) in self.capacity:
            return self.capacity[(u, v)] - self.flow.get((u, v), 0)
        # åå‘è¾¹çš„æ®‹å·®å®¹é‡
        elif (v, u) in self.flow:
            return self.flow.get((v, u), 0)
        return 0

    def residual_cost(self, u: str, v: str) -> int:
        """
        è®¡ç®—æ®‹å·®è´¹ç”¨ã€‚

        Args:
            u: èµ·ç‚¹
            v: ç»ˆç‚¹

        Returns:
            æ®‹å·®è´¹ç”¨
        """
        # æ­£å‘è¾¹
        if (u, v) in self.cost:
            return self.cost[(u, v)]
        # åå‘è¾¹ï¼ˆè´¹ç”¨å–è´Ÿï¼‰
        elif (v, u) in self.cost:
            return -self.cost[(v, u)]
        return 0

    def find_negative_cycle(self) -> Optional[List[str]]:
        """
        ä½¿ç”¨Bellman-Fordç®—æ³•å¯»æ‰¾è´Ÿè´¹ç”¨åœˆã€‚

        Returns:
            è´Ÿè´¹ç”¨åœˆï¼ˆå¦‚æœå­˜åœ¨ï¼‰ï¼Œå¦åˆ™è¿”å›None
        """
        # ä½¿ç”¨Bellman-Fordç®—æ³•æ£€æµ‹è´Ÿç¯
        dist: Dict[str, float] = {v: 0 for v in self.vertices}
        parent: Dict[str, Optional[str]] = {v: None for v in self.vertices}

        # æ¾å¼›æ‰€æœ‰è¾¹ |V| æ¬¡
        for _ in range(len(self.vertices)):
            for u in self.vertices:
                for v in self.graph[u]:
                    if self.residual_capacity(u, v) > 0:
                        new_dist = dist[u] + self.residual_cost(u, v)
                        if new_dist < dist[v]:
                            dist[v] = new_dist
                            parent[v] = u

        # æ£€æµ‹è´Ÿç¯
        for u in self.vertices:
            for v in self.graph[u]:
                if self.residual_capacity(u, v) > 0:
                    if dist[u] + self.residual_cost(u, v) < dist[v]:
                        # æ‰¾åˆ°è´Ÿç¯ï¼Œå›æº¯è·¯å¾„
                        cycle = []
                        visited = set()
                        current = v
                        while current not in visited:
                            visited.add(current)
                            cycle.append(current)
                            current = parent[current]
                        cycle.append(current)
                        return cycle[::-1]

        return None

    def min_cost_flow(self) -> Tuple[int, int]:
        """
        è®¡ç®—æœ€å°è´¹ç”¨æµã€‚

        Returns:
            (æµå€¼, æ€»è´¹ç”¨)
        """
        total_flow = 0
        total_cost = 0

        # ä½¿ç”¨å¢å¹¿è·¯å¾„æ–¹æ³•
        while total_flow < self.demand:
            # å¯»æ‰¾æœ€å°è´¹ç”¨å¢å¹¿è·¯å¾„ï¼ˆä½¿ç”¨Bellman-Fordï¼‰
            path, path_flow = self.find_min_cost_path()

            if path is None:
                break

            # æ²¿è·¯å¾„å¢åŠ æµ
            for i in range(len(path) - 1):
                u, v = path[i], path[i + 1]
                flow_increase = min(path_flow, self.residual_capacity(u, v))

                if (u, v) in self.flow:
                    self.flow[(u, v)] += flow_increase
                else:
                    self.flow[(v, u)] -= flow_increase

                total_cost += flow_increase * self.residual_cost(u, v)

            total_flow += path_flow

        return total_flow, total_cost

    def find_min_cost_path(self) -> Tuple[Optional[List[str]], int]:
        """
        ä½¿ç”¨Bellman-Fordç®—æ³•å¯»æ‰¾æœ€å°è´¹ç”¨è·¯å¾„ã€‚

        Returns:
            (è·¯å¾„, è·¯å¾„ä¸Šçš„æœ€å°å®¹é‡)
        """
        dist: Dict[str, float] = {v: math.inf for v in self.vertices}
        dist[self.source] = 0
        parent: Dict[str, Optional[str]] = {v: None for v in self.vertices}

        # æ¾å¼› |V| - 1 æ¬¡
        for _ in range(len(self.vertices) - 1):
            for u in self.vertices:
                for v in self.graph[u]:
                    if self.residual_capacity(u, v) > 0:
                        new_dist = dist[u] + self.residual_cost(u, v)
                        if new_dist < dist[v]:
                            dist[v] = new_dist
                            parent[v] = u

        # å¦‚æœæ— æ³•åˆ°è¾¾æ±‡ç‚¹ï¼Œè¿”å›None
        if dist[self.sink] == math.inf:
            return None, 0

        # å›æº¯è·¯å¾„
        path = []
        current = self.sink
        while current is not None:
            path.append(current)
            current = parent[current]
        path.reverse()

        # è®¡ç®—è·¯å¾„ä¸Šçš„æœ€å°å®¹é‡
        min_capacity = math.inf
        for i in range(len(path) - 1):
            u, v = path[i], path[i + 1]
            min_capacity = min(min_capacity, self.residual_capacity(u, v))

        return path, min_capacity

# å¤æ‚åº¦åˆ†æ
# æ—¶é—´å¤æ‚åº¦: O(V * E * F)ï¼Œå…¶ä¸­Fæ˜¯æœ€å¤§æµå€¼
# ç©ºé—´å¤æ‚åº¦: O(V + E)
```

---

## 3. å¤æ‚åº¦åˆ†æ / Complexity Analysis

### å®šç† 3.1 (æœ€å°è´¹ç”¨æµç®—æ³•å¤æ‚åº¦)

**ç®—æ³• 2.1** çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(V \cdot E \cdot F)$ï¼Œå…¶ä¸­ $F$ æ˜¯æœ€å¤§æµå€¼ã€‚

**è¯æ˜**ï¼š

1. **è·¯å¾„æŸ¥æ‰¾**: æ¯æ¬¡ä½¿ç”¨Bellman-Fordç®—æ³•æŸ¥æ‰¾æœ€å°è´¹ç”¨è·¯å¾„ï¼Œæ—¶é—´å¤æ‚åº¦ $O(V \cdot E)$
2. **å¢å¹¿æ¬¡æ•°**: æœ€å¤šéœ€è¦ $F$ æ¬¡å¢å¹¿ï¼ˆæ¯æ¬¡è‡³å°‘å¢åŠ 1å•ä½æµï¼‰
3. **æ€»å¤æ‚åº¦**: $O(V \cdot E \cdot F)$

### ä¼˜åŒ–æ–¹æ³•

1. **ä½¿ç”¨Dijkstraç®—æ³•**: å¦‚æœè´¹ç”¨éè´Ÿï¼Œå¯ä»¥ä½¿ç”¨Dijkstraç®—æ³•ï¼Œå¤æ‚åº¦ $O((V + E) \log V \cdot F)$
2. **å®¹é‡ç¼©æ”¾**: ä½¿ç”¨å®¹é‡ç¼©æ”¾æŠ€æœ¯ï¼Œå¤æ‚åº¦ $O(E^2 \log(V \cdot C) \cdot \log F)$ï¼Œå…¶ä¸­ $C$ æ˜¯æœ€å¤§å®¹é‡
3. **æˆæœ¬ç¼©æ”¾**: ä½¿ç”¨æˆæœ¬ç¼©æ”¾æŠ€æœ¯ï¼Œè¿›ä¸€æ­¥ä¼˜åŒ–

---

## 4. åº”ç”¨åœºæ™¯ / Application Scenarios

### 4.1 è¿è¾“é—®é¢˜

**é—®é¢˜æè¿°**: ä»å¤šä¸ªå·¥å‚è¿è¾“è´§ç‰©åˆ°å¤šä¸ªä»“åº“ï¼Œæœ€å°åŒ–è¿è¾“æˆæœ¬ã€‚

**å»ºæ¨¡**:

- æºç‚¹ï¼šå·¥å‚
- æ±‡ç‚¹ï¼šä»“åº“
- è¾¹å®¹é‡ï¼šè¿è¾“èƒ½åŠ›
- è¾¹è´¹ç”¨ï¼šå•ä½è¿è¾“æˆæœ¬

### 4.2 ä»»åŠ¡åˆ†é…é—®é¢˜

**é—®é¢˜æè¿°**: å°†ä»»åŠ¡åˆ†é…ç»™å·¥äººï¼Œæœ€å°åŒ–æ€»æˆæœ¬ã€‚

**å»ºæ¨¡**:

- æºç‚¹ï¼šä»»åŠ¡
- æ±‡ç‚¹ï¼šå·¥äºº
- è¾¹å®¹é‡ï¼š1ï¼ˆæ¯ä¸ªä»»åŠ¡åˆ†é…ç»™ä¸€ä¸ªå·¥äººï¼‰
- è¾¹è´¹ç”¨ï¼šä»»åŠ¡-å·¥äººåŒ¹é…æˆæœ¬

### 4.3 ç½‘ç»œè®¾è®¡é—®é¢˜

**é—®é¢˜æè¿°**: è®¾è®¡ç½‘ç»œè¿æ¥ï¼Œæ»¡è¶³æµé‡éœ€æ±‚ï¼Œæœ€å°åŒ–å»ºè®¾æˆæœ¬ã€‚

**å»ºæ¨¡**:

- è¾¹å®¹é‡ï¼šç½‘ç»œå®¹é‡
- è¾¹è´¹ç”¨ï¼šå»ºè®¾æˆæœ¬
- éœ€æ±‚ï¼šæµé‡éœ€æ±‚

---

## ğŸ”— **ç›¸å…³é“¾æ¥ / Related Links**

- [ç½‘ç»œæµçš„åŸºæœ¬æ¦‚å¿µ](01-ç½‘ç»œæµçš„åŸºæœ¬æ¦‚å¿µ.md)
- [æœ€å¤§æµç®—æ³•è¯¦ç»†åˆ†æ](03-æœ€å¤§æµç®—æ³•è¯¦ç»†åˆ†æ.md)
- [å¤šæºå¤šæ±‡æµé—®é¢˜](04-å¤šæºå¤šæ±‡æµé—®é¢˜.md)
- [å›¾è®ºé«˜çº§ç†è®ºä¸»ç›®å½•](../README.md)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: GraphNetWorkCommunicateé¡¹ç›®ç»„
