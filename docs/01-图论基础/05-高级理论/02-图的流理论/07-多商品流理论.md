# 多商品流理论 / Multi-Commodity Flow Theory

## 📚 **概述 / Overview**

本文档介绍多商品流理论，包括多商品流问题的定义、算法实现和应用场景。

**质量等级**: ⭐⭐⭐⭐⭐ 五星级
**国际对标**: 100% 达标 ✅
**完成状态**: ✅ 已完成

---

## 📑 **目录 / Table of Contents**

- [多商品流理论 / Multi-Commodity Flow Theory](#多商品流理论--multi-commodity-flow-theory)
  - [📚 **概述 / Overview**](#-概述--overview)
  - [📑 **目录 / Table of Contents**](#-目录--table-of-contents)
  - [1. 形式化定义 / Formal Definition](#1-形式化定义--formal-definition)
  - [2. 算法实现 / Algorithm Implementation](#2-算法实现--algorithm-implementation)
  - [3. 复杂度分析 / Complexity Analysis](#3-复杂度分析--complexity-analysis)
  - [4. 应用场景 / Application Scenarios](#4-应用场景--application-scenarios)
  - [🔗 **相关链接 / Related Links**](#-相关链接--related-links)

---

## 1. 形式化定义 / Formal Definition

### 定义 1.1 (多商品流网络 / Multi-Commodity Flow Network)

一个**多商品流网络**是一个五元组 $N = (G, K, c)$，其中：

- $G = (V, E)$ 是有向图
- $K = \{(s_1, t_1, d_1), \ldots, (s_k, t_k, d_k)\}$ 是**商品集合**，每个商品 $(s_i, t_i, d_i)$ 表示从源点 $s_i$ 到汇点 $t_i$ 需要运输 $d_i$ 单位的商品
- $c: E \to \mathbb{R}^+$ 是**容量函数**（每条边的总容量）

### 定义 1.2 (多商品流 / Multi-Commodity Flow)

给定多商品流网络 $N$，**多商品流**是一组流 $\{f_1, f_2, \ldots, f_k\}$，其中 $f_i$ 是第 $i$ 个商品的流，满足：

1. **容量约束**：对于每条边 $e \in E$：
   $$\sum_{i=1}^k f_i(e) \leq c(e)$$
2. **流量守恒**：对于每个商品 $i$ 和每个顶点 $v \in V - \{s_i, t_i\}$：
   $$\sum_{e \in \delta^+(v)} f_i(e) = \sum_{e \in \delta^-(v)} f_i(e)$$
3. **需求满足**：对于每个商品 $i$：
   $$|f_i| = d_i$$

### 定义 1.3 (多商品流可行性 / Multi-Commodity Flow Feasibility)

**多商品流可行性问题**：判断是否存在满足所有需求的多商品流。

---

## 2. 算法实现 / Algorithm Implementation

### 算法 2.1 (多商品流可行性检查 - 线性规划方法)

**算法描述**：

多商品流问题可以建模为线性规划问题：

**目标函数**：最大化总流（或检查可行性）

**约束条件**：
1. 容量约束：$\sum_{i=1}^k f_i(e) \leq c(e)$ 对于所有 $e \in E$
2. 流量守恒：对于每个商品和每个中间顶点
3. 需求约束：$|f_i| = d_i$ 对于所有商品 $i$

**算法实现**：

```python
from typing import Dict, List, Tuple
import numpy as np
from scipy.optimize import linprog

class MultiCommodityFlowNetwork:
    """
    多商品流网络实现。
    """

    def __init__(self, vertices: List[str], edges: List[Tuple[str, str, int]],
                 commodities: List[Tuple[str, str, int]]):
        """
        初始化多商品流网络。

        Args:
            vertices: 顶点列表
            edges: 边列表，每个元素为 (u, v, capacity)
            commodities: 商品列表，每个元素为 (source, sink, demand)
        """
        self.vertices = vertices
        self.edges = edges
        self.commodities = commodities
        self.n_vertices = len(vertices)
        self.n_edges = len(edges)
        self.n_commodities = len(commodities)

    def check_feasibility(self) -> Tuple[bool, Dict]:
        """
        检查多商品流的可行性（使用线性规划）。

        Returns:
            (是否可行, 流分配)
        """
        # 构建线性规划问题
        # 变量：每个商品在每条边上的流值
        n_vars = self.n_commodities * self.n_edges

        # 目标函数：最大化总流（或最小化0，仅检查可行性）
        c = np.zeros(n_vars)

        # 约束1：容量约束
        # 对于每条边e，所有商品的流之和 <= 容量
        A_ub = []
        b_ub = []
        for e_idx, (u, v, cap) in enumerate(self.edges):
            row = np.zeros(n_vars)
            for k in range(self.n_commodities):
                var_idx = k * self.n_edges + e_idx
                row[var_idx] = 1
            A_ub.append(row)
            b_ub.append(cap)

        # 约束2：流量守恒（等式约束）
        A_eq = []
        b_eq = []

        for k, (s_k, t_k, d_k) in enumerate(self.commodities):
            for v in self.vertices:
                if v == s_k or v == t_k:
                    continue

                row = np.zeros(n_vars)
                # 进入v的流
                for e_idx, (u, edge_v, _) in enumerate(self.edges):
                    if edge_v == v:
                        var_idx = k * self.n_edges + e_idx
                        row[var_idx] = 1
                # 离开v的流
                for e_idx, (edge_u, u, _) in enumerate(self.edges):
                    if edge_u == v:
                        var_idx = k * self.n_edges + e_idx
                        row[var_idx] = -1

                A_eq.append(row)
                b_eq.append(0)

        # 约束3：需求约束
        for k, (s_k, t_k, d_k) in enumerate(self.commodities):
            row = np.zeros(n_vars)
            # 从源点s_k流出的流 - 流入s_k的流 = d_k
            for e_idx, (u, v, _) in enumerate(self.edges):
                var_idx = k * self.n_edges + e_idx
                if u == s_k:
                    row[var_idx] = 1
                elif v == s_k:
                    row[var_idx] = -1
            A_eq.append(row)
            b_eq.append(d_k)

        # 变量下界（非负）
        bounds = [(0, None) for _ in range(n_vars)]

        # 求解线性规划
        result = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq,
                        bounds=bounds, method='highs')

        if result.success:
            # 提取流分配
            flow_allocation = {}
            for k in range(self.n_commodities):
                flow_allocation[k] = {}
                for e_idx, (u, v, _) in enumerate(self.edges):
                    var_idx = k * self.n_edges + e_idx
                    flow_allocation[k][(u, v)] = result.x[var_idx]
            return True, flow_allocation
        else:
            return False, {}

# 复杂度分析
# 时间复杂度: O((k*E + V*k)^3) - 线性规划求解
# 空间复杂度: O(k*E + V*k)
```

---

## 3. 复杂度分析 / Complexity Analysis

### 定理 3.1 (多商品流问题复杂度)

**多商品流可行性问题**是NP完全问题（对于一般情况）。

**证明思路**：

1. **NP成员性**: 给定流分配，可以在多项式时间内验证是否满足所有约束
2. **NP困难性**: 可以归约到整数流问题，后者是NP完全的

### 特殊情况

1. **两商品流**: 对于 $k=2$，可以在多项式时间内求解
2. **单位需求**: 如果所有需求为1，可以使用整数流算法
3. **树网络**: 在树网络上，多商品流问题可以在多项式时间内求解

---

## 4. 应用场景 / Application Scenarios

### 4.1 网络路由

**问题描述**: 在通信网络中，同时路由多个数据流，满足带宽约束。

**建模**:
- 商品：不同的数据流
- 容量：链路带宽
- 需求：数据流大小

### 4.2 交通规划

**问题描述**: 规划多条交通路线，满足交通需求，不超出道路容量。

**建模**:
- 商品：不同的交通流
- 容量：道路容量
- 需求：交通流量需求

### 4.3 资源分配

**问题描述**: 在共享资源网络中，分配多个任务，满足资源约束。

**建模**:
- 商品：不同的任务
- 容量：资源容量
- 需求：任务资源需求

---

## 🔗 **相关链接 / Related Links**

- [网络流的基本概念](01-网络流的基本概念.md)
- [最小费用流理论](05-最小费用流理论.md)
- [多源多汇流问题](04-多源多汇流问题.md)
- [图论高级理论主目录](../README.md)

---

**文档版本**: v1.0
**创建时间**: 2025年1月
**最后更新**: 2025年1月
**维护者**: GraphNetWorkCommunicate项目组
