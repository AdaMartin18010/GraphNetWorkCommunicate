# 最大流算法详细分析 / Detailed Analysis of Maximum Flow Algorithms

## 📚 **概述 / Overview**

本文档详细介绍最大流算法，包括Edmonds-Karp算法和Dinic算法的实现和复杂度分析。

---

## 📑 **目录 / Table of Contents**

- [最大流算法详细分析 / Detailed Analysis of Maximum Flow Algorithms](#最大流算法详细分析--detailed-analysis-of-maximum-flow-algorithms)
  - [📚 **概述 / Overview**](#-概述--overview)
  - [📑 **目录 / Table of Contents**](#-目录--table-of-contents)
  - [💻 **算法实现 / Algorithm Implementation**](#-算法实现--algorithm-implementation)

---

## 💻 **算法实现 / Algorithm Implementation**

### 算法 5.2.1 (Edmonds-Karp算法)

Edmonds-Karp算法是Ford-Fulkerson算法的改进，使用BFS寻找增广路径。

**时间复杂度**：$O(V \cdot E^2)$

**算法描述**：

1. 初始化流 $f$ 为全零流
2. 在残差网络中使用BFS寻找从 $s$ 到 $t$ 的最短增广路径
3. 如果找到增广路径，沿路径增加流
4. 重复步骤2-3，直到找不到增广路径

**算法实现**：

```python
from typing import Dict, List, Tuple, Optional
from collections import deque

class FlowNetwork:
    """
    流网络实现。
    """

    def __init__(self, vertices: List[str], edges: List[Tuple[str, str, int]],
                 source: str, sink: str):
        """
        初始化流网络。

        Args:
            vertices: 顶点列表
            edges: 边列表，每个元素为 (u, v, capacity)
            source: 源点
            sink: 汇点
        """
        self.vertices = set(vertices)
        self.source = source
        self.sink = sink

        # 构建邻接表和容量矩阵
        self.graph: Dict[str, List[str]] = {v: [] for v in vertices}
        self.capacity: Dict[Tuple[str, str], int] = {}
        self.flow: Dict[Tuple[str, str], int] = {}

        for u, v, cap in edges:
            self.graph[u].append(v)
            self.capacity[(u, v)] = cap
            self.flow[(u, v)] = 0

            # 确保反向边也存在（初始容量为0）
            if v not in self.graph:
                self.graph[v] = []
            if (v, u) not in self.capacity:
                self.capacity[(v, u)] = 0
            if (v, u) not in self.flow:
                self.flow[(v, u)] = 0

    def get_residual_capacity(self, u: str, v: str) -> int:
        """获取残差容量"""
        return self.capacity.get((u, v), 0) - self.flow.get((u, v), 0)

    def edmonds_karp(self) -> int:
        """
        Edmonds-Karp算法计算最大流。

        Returns:
            最大流值
        """
        max_flow = 0

        while True:
            # 使用BFS寻找最短增广路径
            path = self._bfs_augmenting_path()
            if path is None:
                break

            # 计算瓶颈容量
            bottleneck = float('inf')
            for i in range(len(path) - 1):
                u, v = path[i], path[i + 1]
                bottleneck = min(bottleneck, self.get_residual_capacity(u, v))

            # 沿路径增加流
            for i in range(len(path) - 1):
                u, v = path[i], path[i + 1]
                self.flow[(u, v)] += bottleneck
                self.flow[(v, u)] -= bottleneck  # 反向边

            max_flow += bottleneck

        return max_flow

    def _bfs_augmenting_path(self) -> Optional[List[str]]:
        """
        使用BFS寻找最短增广路径。

        Returns:
            增广路径，如果不存在返回None
        """
        parent: Dict[str, Optional[str]] = {self.source: None}
        queue = deque([self.source])

        while queue:
            u = queue.popleft()

            if u == self.sink:
                # 重建路径
                path = []
                v = u
                while v is not None:
                    path.append(v)
                    v = parent[v]
                return path[::-1]

            # 检查所有邻居（包括反向边）
            neighbors = set(self.graph.get(u, []))
            # 添加可能的反向边
            for v in self.vertices:
                if self.get_residual_capacity(v, u) > 0:
                    neighbors.add(v)

            for v in neighbors:
                if v not in parent and self.get_residual_capacity(u, v) > 0:
                    parent[v] = u
                    queue.append(v)

        return None

    def get_min_cut(self) -> Tuple[set, set]:
        """
        计算最小割。

        Returns:
            (S, T) 最小割的两个集合
        """
        # 从源点进行BFS，找到可达的顶点
        reachable = {self.source}
        queue = deque([self.source])

        while queue:
            u = queue.popleft()
            for v in self.graph.get(u, []):
                if v not in reachable and self.get_residual_capacity(u, v) > 0:
                    reachable.add(v)
                    queue.append(v)

        S = reachable
        T = self.vertices - reachable
        return S, T
```

---

### 算法 5.2.2 (Dinic算法)

Dinic算法使用分层图和阻塞流来加速最大流计算。

**时间复杂度**：$O(V^2 \cdot E)$

**算法描述**：

1. 构建分层图（level graph）
2. 在分层图中寻找阻塞流（blocking flow）
3. 沿阻塞流增加流
4. 重复步骤1-3，直到分层图中没有从 $s$ 到 $t$ 的路径

**算法实现**：

```python
from typing import Dict, List, Tuple, Set, Optional
from collections import deque

class DinicFlowNetwork(FlowNetwork):
    """
    使用Dinic算法计算最大流的流网络。
    """

    def __init__(self, vertices: List[str], edges: List[Tuple[str, str, int]],
                 source: str, sink: str):
        super().__init__(vertices, edges, source, sink)
        self.level: Dict[str, int] = {}

    def dinic(self) -> int:
        """
        Dinic算法计算最大流。

        Returns:
            最大流值
        """
        max_flow = 0

        while self._build_level_graph():
            # 在分层图中寻找阻塞流
            while True:
                blocking_flow = self._find_blocking_flow(self.source, float('inf'))
                if blocking_flow == 0:
                    break
                max_flow += blocking_flow

        return max_flow

    def _build_level_graph(self) -> bool:
        """
        构建分层图（level graph）。

        Returns:
            如果从源点到汇点存在路径返回True，否则返回False
        """
        self.level = {}
        queue = deque([self.source])
        self.level[self.source] = 0

        while queue:
            u = queue.popleft()

            # 检查所有可能的边（包括反向边）
            for v in self.vertices:
                if v not in self.level:
                    residual_cap = self.get_residual_capacity(u, v)
                    if residual_cap > 0:
                        self.level[v] = self.level[u] + 1
                        queue.append(v)

                        if v == self.sink:
                            return True

        return self.sink in self.level

    def _find_blocking_flow(self, u: str, flow_limit: int) -> int:
        """
        使用DFS在分层图中寻找阻塞流。

        Args:
            u: 当前顶点
            flow_limit: 流的上限

        Returns:
            实际增加的流值
        """
        if u == self.sink:
            return flow_limit

        total_flow = 0

        for v in self.vertices:
            # 检查是否在下一层
            if v in self.level and self.level[v] == self.level[u] + 1:
                residual_cap = self.get_residual_capacity(u, v)
                if residual_cap > 0:
                    # 递归寻找从v到汇点的流
                    pushed = self._find_blocking_flow(v, min(flow_limit - total_flow, residual_cap))

                    if pushed > 0:
                        self.flow[(u, v)] += pushed
                        self.flow[(v, u)] -= pushed
                        total_flow += pushed

                        if total_flow >= flow_limit:
                            break

        return total_flow

    def dinic_optimized(self) -> int:
        """
        Dinic算法的优化版本，使用当前弧优化。

        Returns:
            最大流值
        """
        max_flow = 0
        # 当前弧数组，用于优化
        current_edge: Dict[str, int] = {}

        while self._build_level_graph():
            # 重置当前弧
            current_edge = {v: 0 for v in self.vertices}

            while True:
                blocking_flow = self._find_blocking_flow_optimized(
                    self.source, float('inf'), current_edge)
                if blocking_flow == 0:
                    break
                max_flow += blocking_flow

        return max_flow

    def _find_blocking_flow_optimized(self, u: str, flow_limit: int,
                                     current_edge: Dict[str, int]) -> int:
        """
        优化的阻塞流寻找，使用当前弧优化。
        """
        if u == self.sink:
            return flow_limit

        total_flow = 0
        neighbors = sorted([v for v in self.vertices
                           if v in self.level and self.level[v] == self.level[u] + 1])

        # 从上次停止的位置继续
        start_idx = current_edge.get(u, 0)
        for i in range(start_idx, len(neighbors)):
            v = neighbors[i]
            current_edge[u] = i + 1

            residual_cap = self.get_residual_capacity(u, v)
            if residual_cap > 0:
                pushed = self._find_blocking_flow_optimized(
                    v, min(flow_limit - total_flow, residual_cap), current_edge)

                if pushed > 0:
                    self.flow[(u, v)] += pushed
                    self.flow[(v, u)] -= pushed
                    total_flow += pushed

                    if total_flow >= flow_limit:
                        break

        return total_flow
```

---

## 🔬 **算法正确性证明 / Algorithm Correctness Proof**

### 定理 5.2.1 (Edmonds-Karp算法正确性 / Correctness of Edmonds-Karp Algorithm)

**陈述 / Statement**:
Edmonds-Karp算法在流网络$N = (G, s, t, c)$上终止，并返回最大流$f^*$。

**形式化表述 / Formal Statement**:
$$\text{EdmondsKarp}(N) = f^* \text{ 且 } |f^*| = \max_{f \text{ is a flow}} |f|$$

### 证明 / Proof

#### 步骤1: 算法保持流的有效性 / Step 1: Algorithm Maintains Flow Validity

**引理 5.2.1.1**: 算法执行过程中，流$f$始终保持为有效流。

**证明**:
- **初始条件**: 算法开始时，$f = 0$（全零流），满足容量约束和流量守恒。
- **保持条件**: 每次沿增广路径$P$增加流$\delta$时：
  - **容量约束**: 对于每条边$(u, v) \in P$，有$f(u, v) \leftarrow f(u, v) + \delta$，其中$\delta = \min_{(u,v) \in P} c_f(u, v)$。由于$\delta \leq c_f(u, v) = c(u, v) - f(u, v)$，因此$f(u, v) + \delta \leq c(u, v)$。
  - **流量守恒**: 对于路径上的中间顶点$v$（$v \neq s, t$），增加$\delta$的入流和出流，守恒性保持。
- **结论**: 由归纳法，算法执行过程中流始终保持有效。$\square$

#### 步骤2: 算法终止性 / Step 2: Algorithm Termination

**引理 5.2.1.2**: Edmonds-Karp算法在有限步内终止。

**证明**:
- 每次增广至少增加流值$\delta > 0$（因为BFS找到的路径上所有边残差容量$> 0$）。
- 流值上界为$\sum_{e \in \delta^+(s)} c(e) < \infty$。
- 因此，增广次数有上界，算法必然终止。$\square$

#### 步骤3: 终止时达到最大流 / Step 3: Maximum Flow at Termination

**引理 5.2.1.3**: 算法终止时，当前流$f$是最大流。

**证明**:
- 算法终止时，在残差网络$G_f$中不存在从$s$到$t$的路径。
- 定义$S = \{v \in V : \text{在 } G_f \text{ 中从 } s \text{ 可达 } v\}$。
- 对于任意边$(u, v)$，其中$u \in S$且$v \notin S$：
  - 如果$(u, v) \in E$，则$f(u, v) = c(u, v)$（否则$G_f$中有边$(u, v)$，$v$可达）。
  - 如果$(v, u) \in E$，则$f(v, u) = 0$（否则$G_f$中有边$(u, v)$，$v$可达）。
- 因此，$|f| = \sum_{e \in \delta^+(S)} f(e) - \sum_{e \in \delta^-(S)} f(e) = \sum_{e \in \delta^+(S)} c(e) = c(S)$。
- 由最大流最小割定理，$f$是最大流。$\square$

#### 步骤4: 结论 / Step 4: Conclusion

由引理5.2.1.1、5.2.1.2和5.2.1.3，Edmonds-Karp算法正确。$\boxed{\text{证毕}}$

---

## 📊 **复杂度分析 / Complexity Analysis**

### 定理 5.2.2 (Edmonds-Karp算法时间复杂度 / Time Complexity of Edmonds-Karp Algorithm)

**陈述 / Statement**:
Edmonds-Karp算法的时间复杂度为$O(V \cdot E^2)$。

### 证明 / Proof

#### 步骤1: 增广路径长度分析 / Step 1: Augmenting Path Length Analysis

**引理 5.2.2.1**: 在算法执行过程中，从$s$到$t$的最短路径长度（按边数）单调递增。

**证明**:
- 设$d_k(v)$为第$k$次增广后，从$s$到$v$在残差网络中的最短距离。
- 假设第$k+1$次增广沿路径$P$进行，且$d_{k+1}(t) < d_k(t)$。
- 设$(u, v)$是$P$上第一条满足$d_{k+1}(u) = d_k(u)$但$d_{k+1}(v) < d_k(v)$的边。
- 由于$d_{k+1}(v) = d_{k+1}(u) + 1 = d_k(u) + 1$，且$d_k(v) \leq d_k(u) + 1$（因为$d_k$是最短距离），因此$d_k(v) \leq d_k(u) + 1 = d_{k+1}(v)$，矛盾。
- 因此，$d_{k+1}(t) \geq d_k(t)$，最短路径长度单调递增。$\square$

#### 步骤2: 增广次数上界 / Step 2: Upper Bound on Augmentations

**引理 5.2.2.2**: 算法最多执行$O(V \cdot E)$次增广。

**证明**:
- 由引理5.2.2.1，最短路径长度从1开始，最多增加到$V-1$（最长路径）。
- 当最短路径长度为$d$时，最多有$O(E)$条边可以作为瓶颈边（每条边最多被使用一次作为瓶颈）。
- 因此，对于每个距离值$d \in [1, V-1]$，最多$O(E)$次增广。
- 总增广次数为$O(V \cdot E)$。$\square$

#### 步骤3: 单次增广复杂度 / Step 3: Complexity of Single Augmentation

**引理 5.2.2.3**: 每次增广（BFS + 更新流）的时间复杂度为$O(E)$。

**证明**:
- BFS遍历：访问每个顶点和每条边最多一次，$O(V + E) = O(E)$（假设图连通）。
- 路径重建和流更新：路径长度最多$V-1$，每条边更新$O(1)$，总计$O(V) = O(E)$。
- 因此，单次增广复杂度为$O(E)$。$\square$

#### 步骤4: 总复杂度 / Step 4: Total Complexity

由引理5.2.2.2和5.2.2.3：
- 增广次数：$O(V \cdot E)$
- 单次增广：$O(E)$
- 总时间复杂度：$O(V \cdot E^2)$ $\square$

### Edmonds-Karp算法复杂度总结

- **时间复杂度**: $O(V \cdot E^2)$
  - 每次BFS找增广路径: $O(E)$
  - 最多需要 $O(V \cdot E)$ 次增广（每条边最多被使用V次作为瓶颈边）
- **空间复杂度**: $O(V + E)$ 用于存储图和流信息

## 🔬 **Dinic算法正确性证明 / Dinic Algorithm Correctness Proof**

### 定理 5.2.3 (Dinic算法正确性 / Correctness of Dinic Algorithm)

**陈述 / Statement**:
Dinic算法在流网络$N = (G, s, t, c)$上终止，并返回最大流$f^*$。

**形式化表述 / Formal Statement**:
$$\text{Dinic}(N) = f^* \text{ 且 } |f^*| = \max_{f \text{ is a flow}} |f|$$

### 证明 / Proof

#### 步骤1: 阻塞流的有效性 / Step 1: Blocking Flow Validity

**引理 5.2.3.1**: 算法执行过程中，阻塞流$f_b$是有效流。

**证明**:
- **阻塞流定义**: 阻塞流是在分层图中，从$s$到$t$的每条路径都至少有一条边饱和的流。
- **容量约束**: 阻塞流中的每条边$(u, v)$满足$0 \leq f_b(u, v) \leq c(u, v)$（因为只在残差容量$> 0$的边上推送流）。
- **流量守恒**: 阻塞流在分层图中通过DFS递归推送，每个中间顶点的入流等于出流。
- **结论**: 阻塞流是有效流。$\square$

#### 步骤2: 算法终止性 / Step 2: Algorithm Termination

**引理 5.2.3.2**: Dinic算法在有限步内终止。

**证明**:
- 每次迭代构建新的分层图，从$s$到$t$的最短距离（按边数）至少增加1。
- 最短距离从1开始，最多为$V-1$（最长路径）。
- 因此，最多需要$V-1$次迭代。
- 每次迭代中，阻塞流的寻找在有限步内完成（DFS在有限图中终止）。
- **结论**: 算法在有限步内终止。$\square$

#### 步骤3: 终止时达到最大流 / Step 3: Maximum Flow at Termination

**引理 5.2.3.3**: 算法终止时，当前流$f$是最大流。

**证明**:
- 算法终止时，无法构建新的分层图，即在残差网络$G_f$中不存在从$s$到$t$的路径。
- 定义$S = \{v \in V : \text{在 } G_f \text{ 中从 } s \text{ 可达 } v\}$。
- 对于任意边$(u, v)$，其中$u \in S$且$v \notin S$：
  - 如果$(u, v) \in E$，则$f(u, v) = c(u, v)$（否则$G_f$中有边$(u, v)$，$v$可达）。
  - 如果$(v, u) \in E$，则$f(v, u) = 0$（否则$G_f$中有边$(u, v)$，$v$可达）。
- 因此，$|f| = \sum_{e \in \delta^+(S)} f(e) - \sum_{e \in \delta^-(S)} f(e) = \sum_{e \in \delta^+(S)} c(e) = c(S)$。
- 由最大流最小割定理，$f$是最大流。$\square$

#### 步骤4: 结论 / Step 4: Conclusion

由引理5.2.3.1、5.2.3.2和5.2.3.3，Dinic算法正确。$\boxed{\text{证毕}}$

---

## 📊 **Dinic算法复杂度分析 / Dinic Algorithm Complexity Analysis**

### 定理 5.2.4 (Dinic算法时间复杂度 / Time Complexity of Dinic Algorithm)

**陈述 / Statement**:
Dinic算法的时间复杂度为$O(V^2 \cdot E)$。

### 证明 / Proof

#### 步骤1: 迭代次数上界 / Step 1: Upper Bound on Iterations

**引理 5.2.4.1**: 算法最多执行$O(V)$次迭代。

**证明**:
- 每次迭代后，从$s$到$t$的最短距离至少增加1。
- 最短距离从1开始，最多为$V-1$。
- 因此，最多需要$V-1 = O(V)$次迭代。$\square$

#### 步骤2: 单次迭代复杂度 / Step 2: Complexity of Single Iteration

**引理 5.2.4.2**: 每次迭代（构建分层图 + 寻找阻塞流）的时间复杂度为$O(V \cdot E)$。

**证明**:
- **构建分层图**: 使用BFS，时间复杂度$O(V + E) = O(E)$（假设图连通）。
- **寻找阻塞流**: 使用DFS在分层图中寻找，每条边最多被访问一次，时间复杂度$O(V \cdot E)$（因为分层图最多有$V$层，每层最多$E$条边）。
- **总复杂度**: $O(E) + O(V \cdot E) = O(V \cdot E)$。$\square$

#### 步骤3: 总复杂度 / Step 3: Total Complexity

由引理5.2.4.1和5.2.4.2：
- 迭代次数：$O(V)$
- 单次迭代：$O(V \cdot E)$
- 总时间复杂度：$O(V^2 \cdot E)$ $\square$

### Dinic算法复杂度总结

- **时间复杂度**: $O(V^2 \cdot E)$
  - 构建分层图: $O(E)$
  - 每次阻塞流: $O(V \cdot E)$
  - 最多需要 $O(V)$ 次迭代
- **空间复杂度**: $O(V + E)$

### 优化版本（当前弧优化）

- **时间复杂度**: $O(V^2 \cdot E)$ (理论上界不变，但实际更快)
- **空间复杂度**: $O(V + E)$

---

## 🔗 **相关链接 / Related Links**

- [图的流理论目录](../README.md)
- [网络流的基本概念](01-网络流的基本概念.md)
- [最大流最小割定理的严格证明](02-最大流最小割定理的严格证明.md)
- [多源多汇流问题](04-多源多汇流问题.md)
- [图论高级理论主目录](../../README.md)

---

**文档版本**: v1.0
**创建时间**: 2025年1月
**状态**: ✅ **已完成**
