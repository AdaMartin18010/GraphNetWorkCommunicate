# 最大流算法详细分析 / Detailed Analysis of Maximum Flow Algorithms

## 📚 **概述 / Overview**

本文档详细介绍最大流算法，包括Edmonds-Karp算法和Dinic算法的实现和复杂度分析。

---

## 💻 **算法实现 / Algorithm Implementation**

### 算法 5.2.1 (Edmonds-Karp算法)

Edmonds-Karp算法是Ford-Fulkerson算法的改进，使用BFS寻找增广路径。

**时间复杂度**：$O(V \cdot E^2)$

**算法描述**：

1. 初始化流 $f$ 为全零流
2. 在残差网络中使用BFS寻找从 $s$ 到 $t$ 的最短增广路径
3. 如果找到增广路径，沿路径增加流
4. 重复步骤2-3，直到找不到增广路径

**算法实现**：

```python
from typing import Dict, List, Tuple, Optional
from collections import deque

class FlowNetwork:
    """
    流网络实现。
    """

    def __init__(self, vertices: List[str], edges: List[Tuple[str, str, int]],
                 source: str, sink: str):
        """
        初始化流网络。

        Args:
            vertices: 顶点列表
            edges: 边列表，每个元素为 (u, v, capacity)
            source: 源点
            sink: 汇点
        """
        self.vertices = set(vertices)
        self.source = source
        self.sink = sink

        # 构建邻接表和容量矩阵
        self.graph: Dict[str, List[str]] = {v: [] for v in vertices}
        self.capacity: Dict[Tuple[str, str], int] = {}
        self.flow: Dict[Tuple[str, str], int] = {}

        for u, v, cap in edges:
            self.graph[u].append(v)
            self.capacity[(u, v)] = cap
            self.flow[(u, v)] = 0

            # 确保反向边也存在（初始容量为0）
            if v not in self.graph:
                self.graph[v] = []
            if (v, u) not in self.capacity:
                self.capacity[(v, u)] = 0
            if (v, u) not in self.flow:
                self.flow[(v, u)] = 0

    def get_residual_capacity(self, u: str, v: str) -> int:
        """获取残差容量"""
        return self.capacity.get((u, v), 0) - self.flow.get((u, v), 0)

    def edmonds_karp(self) -> int:
        """
        Edmonds-Karp算法计算最大流。

        Returns:
            最大流值
        """
        max_flow = 0

        while True:
            # 使用BFS寻找最短增广路径
            path = self._bfs_augmenting_path()
            if path is None:
                break

            # 计算瓶颈容量
            bottleneck = float('inf')
            for i in range(len(path) - 1):
                u, v = path[i], path[i + 1]
                bottleneck = min(bottleneck, self.get_residual_capacity(u, v))

            # 沿路径增加流
            for i in range(len(path) - 1):
                u, v = path[i], path[i + 1]
                self.flow[(u, v)] += bottleneck
                self.flow[(v, u)] -= bottleneck  # 反向边

            max_flow += bottleneck

        return max_flow

    def _bfs_augmenting_path(self) -> Optional[List[str]]:
        """
        使用BFS寻找最短增广路径。

        Returns:
            增广路径，如果不存在返回None
        """
        parent: Dict[str, Optional[str]] = {self.source: None}
        queue = deque([self.source])

        while queue:
            u = queue.popleft()

            if u == self.sink:
                # 重建路径
                path = []
                v = u
                while v is not None:
                    path.append(v)
                    v = parent[v]
                return path[::-1]

            # 检查所有邻居（包括反向边）
            neighbors = set(self.graph.get(u, []))
            # 添加可能的反向边
            for v in self.vertices:
                if self.get_residual_capacity(v, u) > 0:
                    neighbors.add(v)

            for v in neighbors:
                if v not in parent and self.get_residual_capacity(u, v) > 0:
                    parent[v] = u
                    queue.append(v)

        return None

    def get_min_cut(self) -> Tuple[set, set]:
        """
        计算最小割。

        Returns:
            (S, T) 最小割的两个集合
        """
        # 从源点进行BFS，找到可达的顶点
        reachable = {self.source}
        queue = deque([self.source])

        while queue:
            u = queue.popleft()
            for v in self.graph.get(u, []):
                if v not in reachable and self.get_residual_capacity(u, v) > 0:
                    reachable.add(v)
                    queue.append(v)

        S = reachable
        T = self.vertices - reachable
        return S, T
```

---

### 算法 5.2.2 (Dinic算法)

Dinic算法使用分层图和阻塞流来加速最大流计算。

**时间复杂度**：$O(V^2 \cdot E)$

**算法描述**：

1. 构建分层图（level graph）
2. 在分层图中寻找阻塞流（blocking flow）
3. 沿阻塞流增加流
4. 重复步骤1-3，直到分层图中没有从 $s$ 到 $t$ 的路径

**算法实现**：

```python
from typing import Dict, List, Tuple, Set, Optional
from collections import deque

class DinicFlowNetwork(FlowNetwork):
    """
    使用Dinic算法计算最大流的流网络。
    """

    def __init__(self, vertices: List[str], edges: List[Tuple[str, str, int]],
                 source: str, sink: str):
        super().__init__(vertices, edges, source, sink)
        self.level: Dict[str, int] = {}

    def dinic(self) -> int:
        """
        Dinic算法计算最大流。

        Returns:
            最大流值
        """
        max_flow = 0

        while self._build_level_graph():
            # 在分层图中寻找阻塞流
            while True:
                blocking_flow = self._find_blocking_flow(self.source, float('inf'))
                if blocking_flow == 0:
                    break
                max_flow += blocking_flow

        return max_flow

    def _build_level_graph(self) -> bool:
        """
        构建分层图（level graph）。

        Returns:
            如果从源点到汇点存在路径返回True，否则返回False
        """
        self.level = {}
        queue = deque([self.source])
        self.level[self.source] = 0

        while queue:
            u = queue.popleft()

            # 检查所有可能的边（包括反向边）
            for v in self.vertices:
                if v not in self.level:
                    residual_cap = self.get_residual_capacity(u, v)
                    if residual_cap > 0:
                        self.level[v] = self.level[u] + 1
                        queue.append(v)

                        if v == self.sink:
                            return True

        return self.sink in self.level

    def _find_blocking_flow(self, u: str, flow_limit: int) -> int:
        """
        使用DFS在分层图中寻找阻塞流。

        Args:
            u: 当前顶点
            flow_limit: 流的上限

        Returns:
            实际增加的流值
        """
        if u == self.sink:
            return flow_limit

        total_flow = 0

        for v in self.vertices:
            # 检查是否在下一层
            if v in self.level and self.level[v] == self.level[u] + 1:
                residual_cap = self.get_residual_capacity(u, v)
                if residual_cap > 0:
                    # 递归寻找从v到汇点的流
                    pushed = self._find_blocking_flow(v, min(flow_limit - total_flow, residual_cap))

                    if pushed > 0:
                        self.flow[(u, v)] += pushed
                        self.flow[(v, u)] -= pushed
                        total_flow += pushed

                        if total_flow >= flow_limit:
                            break

        return total_flow

    def dinic_optimized(self) -> int:
        """
        Dinic算法的优化版本，使用当前弧优化。

        Returns:
            最大流值
        """
        max_flow = 0
        # 当前弧数组，用于优化
        current_edge: Dict[str, int] = {}

        while self._build_level_graph():
            # 重置当前弧
            current_edge = {v: 0 for v in self.vertices}

            while True:
                blocking_flow = self._find_blocking_flow_optimized(
                    self.source, float('inf'), current_edge)
                if blocking_flow == 0:
                    break
                max_flow += blocking_flow

        return max_flow

    def _find_blocking_flow_optimized(self, u: str, flow_limit: int,
                                     current_edge: Dict[str, int]) -> int:
        """
        优化的阻塞流寻找，使用当前弧优化。
        """
        if u == self.sink:
            return flow_limit

        total_flow = 0
        neighbors = sorted([v for v in self.vertices
                           if v in self.level and self.level[v] == self.level[u] + 1])

        # 从上次停止的位置继续
        start_idx = current_edge.get(u, 0)
        for i in range(start_idx, len(neighbors)):
            v = neighbors[i]
            current_edge[u] = i + 1

            residual_cap = self.get_residual_capacity(u, v)
            if residual_cap > 0:
                pushed = self._find_blocking_flow_optimized(
                    v, min(flow_limit - total_flow, residual_cap), current_edge)

                if pushed > 0:
                    self.flow[(u, v)] += pushed
                    self.flow[(v, u)] -= pushed
                    total_flow += pushed

                    if total_flow >= flow_limit:
                        break

        return total_flow
```

---

## 📊 **复杂度分析 / Complexity Analysis**

### Edmonds-Karp算法

- **时间复杂度**: $O(V \cdot E^2)$
  - 每次BFS找增广路径: $O(E)$
  - 最多需要 $O(V \cdot E)$ 次增广（每条边最多被使用V次作为瓶颈边）
- **空间复杂度**: $O(V + E)$ 用于存储图和流信息

### Dinic算法

- **时间复杂度**: $O(V^2 \cdot E)$
  - 构建分层图: $O(E)$
  - 每次阻塞流: $O(V \cdot E)$
  - 最多需要 $O(V)$ 次迭代
- **空间复杂度**: $O(V + E)$

### 优化版本（当前弧优化）

- **时间复杂度**: $O(V^2 \cdot E)$ (理论上界不变，但实际更快)
- **空间复杂度**: $O(V + E)$

---

## 🔗 **相关链接 / Related Links**

- [图的流理论目录](../README.md)
- [网络流的基本概念](01-网络流的基本概念.md)
- [最大流最小割定理的严格证明](02-最大流最小割定理的严格证明.md)
- [多源多汇流问题](04-多源多汇流问题.md)
- [图论高级理论主目录](../../README.md)

---

**文档版本**: v1.0
**创建时间**: 2025年1月
**状态**: ✅ **已完成**
