# 多源多汇流问题 / Multi-Source Multi-Sink Flow Problem

## 📚 **概述 / Overview**

本文档介绍多源多汇流问题，包括定义、转换方法和算法实现。

---

## 📑 **目录 / Table of Contents**

- [多源多汇流问题 / Multi-Source Multi-Sink Flow Problem](#多源多汇流问题--multi-source-multi-sink-flow-problem)
  - [📚 **概述 / Overview**](#-概述--overview)
  - [📑 **目录 / Table of Contents**](#-目录--table-of-contents)
  - [📐 **形式化定义 / Formal Definition**](#-形式化定义--formal-definition)
    - [定义 5.2.5 (多源多汇流网络 / Multi-Source Multi-Sink Flow Network)](#定义-525-多源多汇流网络--multi-source-multi-sink-flow-network)
  - [🔧 **转换方法 / Conversion Method**](#-转换方法--conversion-method)
  - [💻 **算法实现 / Algorithm Implementation**](#-算法实现--algorithm-implementation)
  - [📊 **复杂度分析 / Complexity Analysis**](#-复杂度分析--complexity-analysis)
  - [🔗 **相关链接 / Related Links**](#-相关链接--related-links)

---

## 📐 **形式化定义 / Formal Definition**

### 定义 5.2.5 (多源多汇流网络 / Multi-Source Multi-Sink Flow Network)

**多源多汇流网络**是一个五元组 $N = (G, S, T, c)$，其中：

- $G = (V, E)$ 是有向图
- $S \subseteq V$ 是**源点集**
- $T \subseteq V$ 是**汇点集**
- $c: E \to \mathbb{R}^+$ 是容量函数

---

## 🔧 **转换方法 / Conversion Method**

多源多汇流问题可以转换为单源单汇流问题：

1. 添加超级源点 $s^*$ 和超级汇点 $t^*$
2. 从 $s^*$ 到每个源点 $s_i \in S$ 添加容量为 $\infty$ 的边
3. 从每个汇点 $t_i \in T$ 到 $t^*$ 添加容量为 $\infty$ 的边
4. 在转换后的网络上使用标准最大流算法

---

## 💻 **算法实现 / Algorithm Implementation**

```python
class MultiSourceMultiSinkFlowNetwork:
    """
    多源多汇流网络实现。
    """

    def __init__(self, vertices: List[str], edges: List[Tuple[str, str, int]],
                 sources: List[str], sinks: List[str]):
        """
        初始化多源多汇流网络。

        Args:
            vertices: 顶点列表
            edges: 边列表
            sources: 源点列表
            sinks: 汇点列表
        """
        self.vertices = vertices
        self.edges = edges
        self.sources = sources
        self.sinks = sinks

    def convert_to_single_source_sink(self) -> Tuple[FlowNetwork, str, str]:
        """
        转换为单源单汇流网络。

        Returns:
            (flow_network, super_source, super_sink)
        """
        super_source = "SUPER_SOURCE"
        super_sink = "SUPER_SINK"

        # 添加超级源点和汇点
        new_vertices = self.vertices + [super_source, super_sink]
        new_edges = list(self.edges)

        # 从超级源点到所有源点
        for source in self.sources:
            new_edges.append((super_source, source, float('inf')))

        # 从所有汇点到超级汇点
        for sink in self.sinks:
            new_edges.append((sink, super_sink, float('inf')))

        # 创建单源单汇流网络
        flow_network = FlowNetwork(new_vertices, new_edges, super_source, super_sink)

        return flow_network, super_source, super_sink

    def max_flow(self) -> int:
        """
        计算最大流。

        Returns:
            最大流值
        """
        flow_network, _, _ = self.convert_to_single_source_sink()
        return flow_network.edmonds_karp()
```

---

## 📊 **复杂度分析 / Complexity Analysis**

- **时间复杂度**: 与单源单汇流相同，$O(V \cdot E^2)$ (Edmonds-Karp) 或 $O(V^2 \cdot E)$ (Dinic)
- **空间复杂度**: $O(V + E)$

---

## 🔗 **相关链接 / Related Links**

- [图的流理论目录](../README.md)
- [网络流的基本概念](01-网络流的基本概念.md)
- [最大流最小割定理的严格证明](02-最大流最小割定理的严格证明.md)
- [最大流算法详细分析](03-最大流算法详细分析.md)
- [图论高级理论主目录](../../README.md)

---

**文档版本**: v1.0
**创建时间**: 2025年1月
**状态**: ✅ **已完成**
