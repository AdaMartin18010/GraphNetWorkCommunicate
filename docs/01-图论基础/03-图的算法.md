# å›¾çš„ç®—æ³• / Graph Algorithms

## ðŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä»‹ç»å›¾è®ºä¸­çš„æ ¸å¿ƒç®—æ³•ï¼ŒåŒ…æ‹¬å›¾éåŽ†ã€æœ€çŸ­è·¯å¾„ã€æœ€å°ç”Ÿæˆæ ‘ã€ç½‘ç»œæµã€å›¾ç€è‰²ã€å¼ºè¿žé€šåˆ†é‡ç­‰ç®—æ³•åŠå…¶å¤æ‚åº¦åˆ†æžã€‚

## ðŸ“‘ **ç›®å½• / Table of Contents**

- [å›¾çš„ç®—æ³• / Graph Algorithms](#å›¾çš„ç®—æ³•--graph-algorithms)
  - [ðŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ðŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [3.1 å›¾éåŽ†ç®—æ³•](#31-å›¾éåŽ†ç®—æ³•)
    - [3.1.1 æ·±åº¦ä¼˜å…ˆæœç´¢ (DFS)](#311-æ·±åº¦ä¼˜å…ˆæœç´¢-dfs)
    - [3.1.2 å¹¿åº¦ä¼˜å…ˆæœç´¢ (BFS)](#312-å¹¿åº¦ä¼˜å…ˆæœç´¢-bfs)
  - [3.2 æœ€çŸ­è·¯å¾„ç®—æ³•](#32-æœ€çŸ­è·¯å¾„ç®—æ³•)
    - [3.2.1 Dijkstraç®—æ³•](#321-dijkstraç®—æ³•)
    - [3.2.2 Floyd-Warshallç®—æ³•](#322-floyd-warshallç®—æ³•)
  - [3.3 æœ€å°ç”Ÿæˆæ ‘ç®—æ³•](#33-æœ€å°ç”Ÿæˆæ ‘ç®—æ³•)
    - [3.3.1 Kruskalç®—æ³•](#331-kruskalç®—æ³•)
    - [3.3.2 Primç®—æ³•](#332-primç®—æ³•)
  - [3.4 ç½‘ç»œæµç®—æ³•](#34-ç½‘ç»œæµç®—æ³•)
    - [3.4.1 Ford-Fulkersonç®—æ³•](#341-ford-fulkersonç®—æ³•)
  - [3.5 å›¾ç€è‰²ç®—æ³•](#35-å›¾ç€è‰²ç®—æ³•)
    - [3.5.1 è´ªå¿ƒç€è‰²ç®—æ³•](#351-è´ªå¿ƒç€è‰²ç®—æ³•)
  - [3.6 å¼ºè¿žé€šåˆ†é‡ç®—æ³•](#36-å¼ºè¿žé€šåˆ†é‡ç®—æ³•)
    - [3.6.1 Tarjanç®—æ³•](#361-tarjanç®—æ³•)
  - [3.7 ç®—æ³•å¤æ‚åº¦åˆ†æž](#37-ç®—æ³•å¤æ‚åº¦åˆ†æž)
    - [3.7.1 æ—¶é—´å¤æ‚åº¦æ€»ç»“](#371-æ—¶é—´å¤æ‚åº¦æ€»ç»“)
    - [3.7.2 ç®—æ³•é€‰æ‹©æŒ‡å—](#372-ç®—æ³•é€‰æ‹©æŒ‡å—)
  - [3.8 å®žé™…åº”ç”¨](#38-å®žé™…åº”ç”¨)
    - [3.8.1 ç½‘ç»œè·¯ç”±](#381-ç½‘ç»œè·¯ç”±)
    - [3.8.2 ç¤¾äº¤ç½‘ç»œåˆ†æž](#382-ç¤¾äº¤ç½‘ç»œåˆ†æž)
    - [3.8.3 ç”Ÿç‰©ä¿¡æ¯å­¦](#383-ç”Ÿç‰©ä¿¡æ¯å­¦)
  - [3.9 æ€»ç»“](#39-æ€»ç»“)
  - [å¤šæ¨¡æ€è¡¨è¾¾ä¸Žå¯è§†åŒ–](#å¤šæ¨¡æ€è¡¨è¾¾ä¸Žå¯è§†åŒ–)

---

## 3.1 å›¾éåŽ†ç®—æ³•

### 3.1.1 æ·±åº¦ä¼˜å…ˆæœç´¢ (DFS)

**å®šä¹‰ 3.1.1** æ·±åº¦ä¼˜å…ˆæœç´¢æ˜¯ä¸€ç§å›¾éåŽ†ç®—æ³•ï¼Œå®ƒæ²¿ç€å›¾çš„è¾¹å°½å¯èƒ½æ·±åœ°æŽ¢ç´¢ï¼Œç›´åˆ°æ— æ³•ç»§ç»­å‰è¿›ï¼Œç„¶åŽå›žæº¯ã€‚

**ç®—æ³• 3.1.1** æ·±åº¦ä¼˜å…ˆæœç´¢ç®—æ³•

```python
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()

    visited.add(start)
    print(start, end=' ')

    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
```

**å®šç† 3.1.1** DFSçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(|V| + |E|)$ï¼Œå…¶ä¸­ $|V|$ æ˜¯é¡¶ç‚¹æ•°ï¼Œ$|E|$ æ˜¯è¾¹æ•°ã€‚

**è¯æ˜Ž** æ¯ä¸ªé¡¶ç‚¹æœ€å¤šè¢«è®¿é—®ä¸€æ¬¡ï¼Œæ¯æ¡è¾¹æœ€å¤šè¢«æ£€æŸ¥ä¸¤æ¬¡ï¼ˆæ— å‘å›¾ï¼‰ï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(|V| + |E|)$ã€‚

### 3.1.2 å¹¿åº¦ä¼˜å…ˆæœç´¢ (BFS)

**å®šä¹‰ 3.1.2** å¹¿åº¦ä¼˜å…ˆæœç´¢æ˜¯ä¸€ç§å›¾éåŽ†ç®—æ³•ï¼Œå®ƒå…ˆè®¿é—®æ‰€æœ‰ç›¸é‚»é¡¶ç‚¹ï¼Œç„¶åŽå†è®¿é—®ä¸‹ä¸€å±‚é¡¶ç‚¹ã€‚

**ç®—æ³• 3.1.2** å¹¿åº¦ä¼˜å…ˆæœç´¢ç®—æ³•

```python
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)

    while queue:
        vertex = queue.popleft()
        print(vertex, end=' ')

        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
```

**å®šç† 3.1.2** BFSçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(|V| + |E|)$ã€‚

## 3.2 æœ€çŸ­è·¯å¾„ç®—æ³•

### 3.2.1 Dijkstraç®—æ³•

**å®šä¹‰ 3.2.1** Dijkstraç®—æ³•ç”¨äºŽåœ¨å¸¦æƒå›¾ä¸­æ‰¾åˆ°ä»Žæºç‚¹åˆ°æ‰€æœ‰å…¶ä»–é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ã€‚

**ç®—æ³• 3.2.1** Dijkstraç®—æ³•

```python
import heapq

def dijkstra(graph, start):
    distances = {vertex: float('infinity') for vertex in graph}
    distances[start] = 0
    pq = [(0, start)]

    while pq:
        current_distance, current_vertex = heapq.heappop(pq)

        if current_distance > distances[current_vertex]:
            continue

        for neighbor, weight in graph[current_vertex].items():
            distance = current_distance + weight

            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(pq, (distance, neighbor))

    return distances
```

**å®šç† 3.2.1** Dijkstraç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º $O((|V| + |E|) \log |V|)$ã€‚

**è¯æ˜Ž** ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå †ï¼‰å®žçŽ°ï¼Œæ¯ä¸ªé¡¶ç‚¹æœ€å¤šè¢«è®¿é—®ä¸€æ¬¡ï¼Œæ¯æ¬¡æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(\log |V|)$ã€‚

### 3.2.2 Floyd-Warshallç®—æ³•

**å®šä¹‰ 3.2.2** Floyd-Warshallç®—æ³•ç”¨äºŽæ‰¾åˆ°å›¾ä¸­æ‰€æœ‰é¡¶ç‚¹å¯¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ã€‚

**ç®—æ³• 3.2.2** Floyd-Warshallç®—æ³•

```python
def floyd_warshall(graph):
    n = len(graph)
    dist = [[float('inf')] * n for _ in range(n)]

    # åˆå§‹åŒ–è·ç¦»çŸ©é˜µ
    for i in range(n):
        dist[i][i] = 0
        for j, weight in graph[i].items():
            dist[i][j] = weight

    # Floyd-Warshallæ ¸å¿ƒç®—æ³•
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]

    return dist
```

**å®šç† 3.2.2** Floyd-Warshallç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(|V|^3)$ã€‚

## 3.3 æœ€å°ç”Ÿæˆæ ‘ç®—æ³•

### 3.3.1 Kruskalç®—æ³•

**å®šä¹‰ 3.3.1** Kruskalç®—æ³•ç”¨äºŽåœ¨å¸¦æƒæ— å‘å›¾ä¸­æ‰¾åˆ°æœ€å°ç”Ÿæˆæ ‘ã€‚

**ç®—æ³• 3.3.1** Kruskalç®—æ³•

```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py:
            return False
        if self.rank[px] < self.rank[py]:
            px, py = py, px
        self.parent[py] = px
        if self.rank[px] == self.rank[py]:
            self.rank[px] += 1
        return True

def kruskal(graph):
    edges = []
    for u in graph:
        for v, weight in graph[u].items():
            edges.append((weight, u, v))
    edges.sort()

    uf = UnionFind(len(graph))
    mst = []

    for weight, u, v in edges:
        if uf.union(u, v):
            mst.append((u, v, weight))

    return mst
```

**å®šç† 3.3.1** Kruskalç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(|E| \log |E|)$ã€‚

### 3.3.2 Primç®—æ³•

**å®šä¹‰ 3.3.2** Primç®—æ³•æ˜¯å¦ä¸€ç§å¯»æ‰¾æœ€å°ç”Ÿæˆæ ‘çš„ç®—æ³•ï¼Œå®ƒä»Žå•ä¸ªé¡¶ç‚¹å¼€å§‹ï¼Œé€æ­¥æ‰©å±•æ ‘ã€‚

**ç®—æ³• 3.3.2** Primç®—æ³•

```python
import heapq

def prim(graph, start):
    mst = []
    visited = set()
    edges = [(0, start, start)]  # (weight, from, to)

    while edges and len(visited) < len(graph):
        weight, u, v = heapq.heappop(edges)

        if v in visited:
            continue

        visited.add(v)
        if u != v:
            mst.append((u, v, weight))

        for neighbor, w in graph[v].items():
            if neighbor not in visited:
                heapq.heappush(edges, (w, v, neighbor))

    return mst
```

**å®šç† 3.3.2** Primç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(|E| \log |V|)$ã€‚

## 3.4 ç½‘ç»œæµç®—æ³•

### 3.4.1 Ford-Fulkersonç®—æ³•

**å®šä¹‰ 3.4.1** Ford-Fulkersonç®—æ³•ç”¨äºŽåœ¨æµç½‘ç»œä¸­æ‰¾åˆ°æœ€å¤§æµã€‚

**ç®—æ³• 3.4.1** Ford-Fulkersonç®—æ³•

```python
def ford_fulkerson(graph, source, sink):
    def bfs(graph, source, sink, parent):
        visited = [False] * len(graph)
        queue = [source]
        visited[source] = True

        while queue:
            u = queue.pop(0)
            for v, capacity in enumerate(graph[u]):
                if not visited[v] and capacity > 0:
                    queue.append(v)
                    visited[v] = True
                    parent[v] = u
                    if v == sink:
                        return True
        return False

    max_flow = 0
    parent = [-1] * len(graph)

    while bfs(graph, source, sink, parent):
        path_flow = float('inf')
        v = sink
        while v != source:
            u = parent[v]
            path_flow = min(path_flow, graph[u][v])
            v = parent[v]

        v = sink
        while v != source:
            u = parent[v]
            graph[u][v] -= path_flow
            graph[v][u] += path_flow
            v = parent[v]

        max_flow += path_flow

    return max_flow
```

**å®šç† 3.4.1** Ford-Fulkersonç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(|E| \cdot |f^*|)$ï¼Œå…¶ä¸­ $|f^*|$ æ˜¯æœ€å¤§æµçš„å€¼ã€‚

## 3.5 å›¾ç€è‰²ç®—æ³•

### 3.5.1 è´ªå¿ƒç€è‰²ç®—æ³•

**å®šä¹‰ 3.5.1** å›¾ç€è‰²é—®é¢˜æ˜¯ç»™å›¾çš„é¡¶ç‚¹åˆ†é…é¢œè‰²ï¼Œä½¿å¾—ç›¸é‚»é¡¶ç‚¹å…·æœ‰ä¸åŒé¢œè‰²ã€‚

**ç®—æ³• 3.5.1** è´ªå¿ƒç€è‰²ç®—æ³•

```python
def greedy_coloring(graph):
    colors = {}
    available = set()

    for vertex in graph:
        # æ£€æŸ¥ç›¸é‚»é¡¶ç‚¹çš„é¢œè‰²
        for neighbor in graph[vertex]:
            if neighbor in colors:
                available.add(colors[neighbor])

        # æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¯ç”¨é¢œè‰²
        color = 0
        while color in available:
            color += 1

        colors[vertex] = color
        available.clear()

    return colors
```

**å®šç† 3.5.1** è´ªå¿ƒç€è‰²ç®—æ³•æœ€å¤šä½¿ç”¨ $\Delta(G) + 1$ ç§é¢œè‰²ï¼Œå…¶ä¸­ $\Delta(G)$ æ˜¯å›¾çš„æœ€å¤§åº¦æ•°ã€‚

**è¯æ˜Ž** å¯¹äºŽæ¯ä¸ªé¡¶ç‚¹ï¼Œæœ€å¤šæœ‰ $\Delta(G)$ ä¸ªç›¸é‚»é¡¶ç‚¹ï¼Œå› æ­¤æœ€å¤šéœ€è¦ $\Delta(G) + 1$ ç§é¢œè‰²ã€‚

## 3.6 å¼ºè¿žé€šåˆ†é‡ç®—æ³•

### 3.6.1 Tarjanç®—æ³•

**å®šä¹‰ 3.6.1** å¼ºè¿žé€šåˆ†é‡æ˜¯æœ‰å‘å›¾ä¸­çš„ä¸€ä¸ªå­å›¾ï¼Œå…¶ä¸­ä»»æ„ä¸¤ä¸ªé¡¶ç‚¹éƒ½ç›¸äº’å¯è¾¾ã€‚

**ç®—æ³• 3.6.1** Tarjanç®—æ³•

```python
def tarjan(graph):
    def dfs(v):
        nonlocal index
        indices[v] = index
        low_links[v] = index
        index += 1
        stack.append(v)
        on_stack[v] = True

        for neighbor in graph[v]:
            if indices[neighbor] == -1:
                dfs(neighbor)
                low_links[v] = min(low_links[v], low_links[neighbor])
            elif on_stack[neighbor]:
                low_links[v] = min(low_links[v], indices[neighbor])

        if low_links[v] == indices[v]:
            scc = []
            while True:
                w = stack.pop()
                on_stack[w] = False
                scc.append(w)
                if w == v:
                    break
            sccs.append(scc)

    n = len(graph)
    indices = [-1] * n
    low_links = [-1] * n
    on_stack = [False] * n
    stack = []
    sccs = []
    index = 0

    for v in range(n):
        if indices[v] == -1:
            dfs(v)

    return sccs
```

**å®šç† 3.6.1** Tarjanç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(|V| + |E|)$ã€‚

## 3.7 ç®—æ³•å¤æ‚åº¦åˆ†æž

### 3.7.1 æ—¶é—´å¤æ‚åº¦æ€»ç»“

| ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ |
|------|------------|------------|
| DFS | $O(\|V\| + \|E\|)$ | $O(\|V\|)$ |
| BFS | $O(\|V\| + \|E\|)$ | $O(\|V\|)$ |
| Dijkstra | $O((\|V\| + \|E\|) \log \|V\|)$ | $O(\|V\|)$ |
| Floyd-Warshall | $O(\|V\|^3)$ | $O(\|V\|^2)$ |
| Kruskal | $O(\|E\| \log \|E\|)$ | $O(\|V\|)$ |
| Prim | $O(\|E\| \log \|V\|)$ | $O(\|V\|)$ |
| Ford-Fulkerson | $O(\|E\| \cdot \|f^*\|)$ | $O(\|V\|^2)$ |
| Tarjan | $O(\|V\| + \|E\|)$ | $O(\|V\|)$ |

### 3.7.2 ç®—æ³•é€‰æ‹©æŒ‡å—

**å®šç† 3.7.1** å¯¹äºŽç¨€ç–å›¾ï¼ˆ$|E| = O(|V|)$ï¼‰ï¼Œé‚»æŽ¥è¡¨è¡¨ç¤ºæ›´ä¼˜ï¼›å¯¹äºŽç¨ å¯†å›¾ï¼ˆ$|E| = O(|V|^2)$ï¼‰ï¼Œé‚»æŽ¥çŸ©é˜µè¡¨ç¤ºæ›´ä¼˜ã€‚

**å®šç† 3.7.2** å¯¹äºŽå•æºæœ€çŸ­è·¯å¾„é—®é¢˜ï¼š

- æ— è´Ÿæƒè¾¹ï¼šä½¿ç”¨Dijkstraç®—æ³•
- æœ‰è´Ÿæƒè¾¹ï¼šä½¿ç”¨Bellman-Fordç®—æ³•
- æ‰€æœ‰é¡¶ç‚¹å¯¹ï¼šä½¿ç”¨Floyd-Warshallç®—æ³•

## 3.8 å®žé™…åº”ç”¨

### 3.8.1 ç½‘ç»œè·¯ç”±

å›¾ç®—æ³•åœ¨ç½‘ç»œè·¯ç”±ä¸­å¹¿æ³›åº”ç”¨ï¼š

- æœ€çŸ­è·¯å¾„ç®—æ³•ç”¨äºŽè·¯ç”±è¡¨è®¡ç®—
- æœ€å°ç”Ÿæˆæ ‘ç”¨äºŽç½‘ç»œæ‹“æ‰‘è®¾è®¡
- æœ€å¤§æµç®—æ³•ç”¨äºŽç½‘ç»œå®¹é‡è§„åˆ’

### 3.8.2 ç¤¾äº¤ç½‘ç»œåˆ†æž

- è¿žé€šåˆ†é‡ç®—æ³•ç”¨äºŽç¤¾åŒºå‘çŽ°
- æœ€çŸ­è·¯å¾„ç®—æ³•ç”¨äºŽå½±å“åŠ›ä¼ æ’­åˆ†æž
- å›¾ç€è‰²ç®—æ³•ç”¨äºŽèµ„æºåˆ†é…

### 3.8.3 ç”Ÿç‰©ä¿¡æ¯å­¦

- å›¾ç®—æ³•ç”¨äºŽè›‹ç™½è´¨ç›¸äº’ä½œç”¨ç½‘ç»œåˆ†æž
- åŸºå› è°ƒæŽ§ç½‘ç»œå»ºæ¨¡
- ä»£è°¢é€šè·¯åˆ†æž

## 3.9 æ€»ç»“

æœ¬ç« ä»‹ç»äº†å›¾è®ºä¸­çš„ç»å…¸ç®—æ³•ï¼ŒåŒ…æ‹¬ï¼š

1. **éåŽ†ç®—æ³•**ï¼šDFSå’ŒBFSï¼Œç”¨äºŽå›¾çš„æŽ¢ç´¢å’Œæœç´¢
2. **æœ€çŸ­è·¯å¾„ç®—æ³•**ï¼šDijkstraå’ŒFloyd-Warshallï¼Œç”¨äºŽè·ç¦»è®¡ç®—
3. **æœ€å°ç”Ÿæˆæ ‘ç®—æ³•**ï¼šKruskalå’ŒPrimï¼Œç”¨äºŽç½‘ç»œè®¾è®¡
4. **ç½‘ç»œæµç®—æ³•**ï¼šFord-Fulkersonï¼Œç”¨äºŽæµé‡ä¼˜åŒ–
5. **å›¾ç€è‰²ç®—æ³•**ï¼šè´ªå¿ƒç®—æ³•ï¼Œç”¨äºŽèµ„æºåˆ†é…
6. **å¼ºè¿žé€šåˆ†é‡ç®—æ³•**ï¼šTarjanç®—æ³•ï¼Œç”¨äºŽå›¾åˆ†è§£

è¿™äº›ç®—æ³•ä¸ºå›¾ç½‘ç»œé€šä¿¡æä¾›äº†é‡è¦çš„ç†è®ºåŸºç¡€å’Œå®žç”¨å·¥å…·ï¼Œä¸ºåŽç»­çš„ç½‘ç»œæ‹“æ‰‘è®¾è®¡å’Œé€šä¿¡åè®®åˆ†æžå¥ å®šäº†ç®—æ³•åŸºç¡€ã€‚

## å¤šæ¨¡æ€è¡¨è¾¾ä¸Žå¯è§†åŒ–

- **ç®—æ³•æµç¨‹å›¾**ï¼šç”¨Mermaid/PlantUMLæè¿°Dijkstraã€Ford-Fulkersonç­‰ç®—æ³•æµç¨‹ã€‚
- **ç»“æž„å›¾**ï¼šç”¨Graphviz/NetworkXå±•ç¤ºç®—æ³•æ‰§è¡Œå‰åŽå›¾ç»“æž„å˜åŒ–ã€‚
- **è‡ªåŠ¨åŒ–è„šæœ¬å»ºè®®**ï¼š
  - `scripts/graph_visualization.py`ï¼šè¾“å…¥ç®—æ³•æ­¥éª¤ï¼Œè¾“å‡ºæµç¨‹å›¾ã€ç»“æž„å›¾ã€‚
- **ç¤ºä¾‹**ï¼š
  - Mermaidæœ€çŸ­è·¯æµç¨‹ï¼š

    ```mermaid
    graph TD;
      Start-->Dijkstra;
      Dijkstra-->End;
    ```
