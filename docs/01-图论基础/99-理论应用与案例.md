# å›¾è®ºåŸºç¡€ï¼šç†è®º-åº”ç”¨å…¨é“¾è·¯ä¸å·¥ç¨‹æ¡ˆä¾‹ / Graph Theory Fundamentals: Theory-Application Pipeline and Engineering Cases

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä»‹ç»å›¾è®ºåŸºç¡€çš„ç†è®ºåº”ç”¨å…¨é“¾è·¯ä¸å·¥ç¨‹æ¡ˆä¾‹ï¼ŒåŒ…æ‹¬ç†è®ºåŸºç¡€ä¸å½¢å¼åŒ–è¯æ˜ã€ç®—æ³•å®ç°ä¸å·¥ç¨‹æ¡ˆä¾‹ã€è·¨é¢†åŸŸåº”ç”¨ä¸åˆ›æ–°ã€æ‰¹åˆ¤æ€§åˆ†æä¸æ”¹è¿›å»ºè®®ã€å½¢å¼åŒ–éªŒè¯ä¸æµ‹è¯•ã€‚

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [å›¾è®ºåŸºç¡€ï¼šç†è®º-åº”ç”¨å…¨é“¾è·¯ä¸å·¥ç¨‹æ¡ˆä¾‹ / Graph Theory Fundamentals: Theory-Application Pipeline and Engineering Cases](#å›¾è®ºåŸºç¡€ç†è®º-åº”ç”¨å…¨é“¾è·¯ä¸å·¥ç¨‹æ¡ˆä¾‹--graph-theory-fundamentals-theory-application-pipeline-and-engineering-cases)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [1. ç†è®ºåŸºç¡€ä¸å½¢å¼åŒ–è¯æ˜](#1-ç†è®ºåŸºç¡€ä¸å½¢å¼åŒ–è¯æ˜)
    - [1.1 å›¾è®ºåŸºæœ¬å®šç†](#11-å›¾è®ºåŸºæœ¬å®šç†)
      - [æ¬§æ‹‰å®šç†](#æ¬§æ‹‰å®šç†)
      - [å“ˆå¯†é¡¿å®šç†](#å“ˆå¯†é¡¿å®šç†)
    - [1.2 å›¾è®ºç®—æ³•æ­£ç¡®æ€§](#12-å›¾è®ºç®—æ³•æ­£ç¡®æ€§)
      - [Dijkstraç®—æ³•æ­£ç¡®æ€§](#dijkstraç®—æ³•æ­£ç¡®æ€§)
  - [2. ç®—æ³•å®ç°ä¸å·¥ç¨‹æ¡ˆä¾‹](#2-ç®—æ³•å®ç°ä¸å·¥ç¨‹æ¡ˆä¾‹)
    - [2.1 å›¾è®ºç®—æ³•å®ç°](#21-å›¾è®ºç®—æ³•å®ç°)
      - [æœ€çŸ­è·¯å¾„ç®—æ³•](#æœ€çŸ­è·¯å¾„ç®—æ³•)
    - [2.2 å·¥ç¨‹æ¡ˆä¾‹ï¼šç½‘ç»œè·¯ç”±ç³»ç»Ÿ](#22-å·¥ç¨‹æ¡ˆä¾‹ç½‘ç»œè·¯ç”±ç³»ç»Ÿ)
      - [æ¡ˆä¾‹1ï¼šäº’è”ç½‘è·¯ç”±ç®—æ³•](#æ¡ˆä¾‹1äº’è”ç½‘è·¯ç”±ç®—æ³•)
      - [æ¡ˆä¾‹2ï¼šç¤¾äº¤ç½‘ç»œåˆ†æ](#æ¡ˆä¾‹2ç¤¾äº¤ç½‘ç»œåˆ†æ)
  - [3. è·¨é¢†åŸŸåº”ç”¨ä¸åˆ›æ–°](#3-è·¨é¢†åŸŸåº”ç”¨ä¸åˆ›æ–°)
    - [3.1 å›¾è®ºä¸æœºå™¨å­¦ä¹ ](#31-å›¾è®ºä¸æœºå™¨å­¦ä¹ )
      - [å›¾ç¥ç»ç½‘ç»œåº”ç”¨](#å›¾ç¥ç»ç½‘ç»œåº”ç”¨)
    - [3.2 å›¾è®ºä¸ç”Ÿç‰©ä¿¡æ¯å­¦](#32-å›¾è®ºä¸ç”Ÿç‰©ä¿¡æ¯å­¦)
      - [è›‹ç™½è´¨ç›¸äº’ä½œç”¨ç½‘ç»œåˆ†æ](#è›‹ç™½è´¨ç›¸äº’ä½œç”¨ç½‘ç»œåˆ†æ)
  - [4. æ‰¹åˆ¤æ€§åˆ†æä¸æ”¹è¿›å»ºè®®](#4-æ‰¹åˆ¤æ€§åˆ†æä¸æ”¹è¿›å»ºè®®)
    - [4.1 ç°æœ‰ç®—æ³•çš„å±€é™æ€§](#41-ç°æœ‰ç®—æ³•çš„å±€é™æ€§)
      - [è®¡ç®—å¤æ‚æ€§](#è®¡ç®—å¤æ‚æ€§)
      - [ç®—æ³•ç²¾åº¦](#ç®—æ³•ç²¾åº¦)
    - [4.2 æ”¹è¿›æ–¹å‘](#42-æ”¹è¿›æ–¹å‘)
      - [æŠ€æœ¯åˆ›æ–°](#æŠ€æœ¯åˆ›æ–°)
      - [å·¥ç¨‹ä¼˜åŒ–](#å·¥ç¨‹ä¼˜åŒ–)
  - [5. å½¢å¼åŒ–éªŒè¯ä¸æµ‹è¯•](#5-å½¢å¼åŒ–éªŒè¯ä¸æµ‹è¯•)
    - [5.1 ç®—æ³•æ­£ç¡®æ€§éªŒè¯](#51-ç®—æ³•æ­£ç¡®æ€§éªŒè¯)
    - [5.2 æ€§èƒ½æµ‹è¯•](#52-æ€§èƒ½æµ‹è¯•)
  - [6. æ€»ç»“ä¸å±•æœ›](#6-æ€»ç»“ä¸å±•æœ›)
    - [æœªæ¥å‘å±•æ–¹å‘](#æœªæ¥å‘å±•æ–¹å‘)
  - [å¤šæ¨¡æ€è¡¨è¾¾ä¸å¯è§†åŒ–](#å¤šæ¨¡æ€è¡¨è¾¾ä¸å¯è§†åŒ–)
    - [å›¾ç»“æ„å¯è§†åŒ–](#å›¾ç»“æ„å¯è§†åŒ–)
    - [ç®—æ³•æ‰§è¡Œæµç¨‹å›¾](#ç®—æ³•æ‰§è¡Œæµç¨‹å›¾)
    - [è‡ªåŠ¨åŒ–è„šæœ¬å»ºè®®](#è‡ªåŠ¨åŒ–è„šæœ¬å»ºè®®)

---

## 1. ç†è®ºåŸºç¡€ä¸å½¢å¼åŒ–è¯æ˜

### 1.1 å›¾è®ºåŸºæœ¬å®šç†

#### æ¬§æ‹‰å®šç†

**å®šç†**ï¼šè¿é€šå›¾Gå­˜åœ¨æ¬§æ‹‰å›è·¯çš„å……è¦æ¡ä»¶æ˜¯Gä¸­æ‰€æœ‰é¡¶ç‚¹çš„åº¦æ•°éƒ½æ˜¯å¶æ•°ã€‚

**å½¢å¼åŒ–è¯æ˜**ï¼š

```math
\text{å¿…è¦æ€§ï¼š} \\
\text{å¦‚æœGå­˜åœ¨æ¬§æ‹‰å›è·¯ï¼Œåˆ™æ¯ä¸ªé¡¶ç‚¹åœ¨å›è·¯ä¸­å‡ºç°å¶æ•°æ¬¡ï¼Œå› æ­¤åº¦æ•°ä¸ºå¶æ•°ã€‚} \\
\text{å……åˆ†æ€§ï¼š} \\
\text{å¯¹é¡¶ç‚¹æ•°nè¿›è¡Œå½’çº³ã€‚} \\
\text{åŸºä¾‹ï¼šn=1æ—¶æ˜¾ç„¶æˆç«‹ã€‚} \\
\text{å½’çº³å‡è®¾ï¼šå¯¹n-1ä¸ªé¡¶ç‚¹çš„å›¾æˆç«‹ã€‚} \\
\text{å½’çº³æ­¥éª¤ï¼šä»ä»»æ„é¡¶ç‚¹å¼€å§‹ï¼Œæ²¿è¾¹è¡Œèµ°ç›´åˆ°æ— æ³•ç»§ç»­ã€‚} \\
\text{ç”±äºæ‰€æœ‰åº¦æ•°ä¸ºå¶æ•°ï¼Œæœ€ç»ˆä¼šå›åˆ°èµ·ç‚¹ï¼Œå½¢æˆå›è·¯ã€‚}
```

#### å“ˆå¯†é¡¿å®šç†

**å®šç†**ï¼šå¯¹äºnâ‰¥3çš„å®Œå…¨å›¾Knï¼Œå­˜åœ¨å“ˆå¯†é¡¿å›è·¯ã€‚

**å½¢å¼åŒ–è¯æ˜**ï¼š

```math
\text{æ„é€ æ€§è¯æ˜ï¼š} \\
\text{è®¾é¡¶ç‚¹ä¸º } v_1, v_2, \ldots, v_n \\
\text{å“ˆå¯†é¡¿å›è·¯ä¸ºï¼š} v_1 \rightarrow v_2 \rightarrow \cdots \rightarrow v_n \rightarrow v_1 \\
\text{å¯¹äºä»»æ„ä¸¤ä¸ªç›¸é‚»é¡¶ç‚¹ } v_i, v_{i+1} \text{ï¼Œè¾¹ } (v_i, v_{i+1}) \text{ å­˜åœ¨ã€‚}
```

### 1.2 å›¾è®ºç®—æ³•æ­£ç¡®æ€§

#### Dijkstraç®—æ³•æ­£ç¡®æ€§

**å®šç†**ï¼šDijkstraç®—æ³•èƒ½å¤Ÿæ­£ç¡®è®¡ç®—å•æºæœ€çŸ­è·¯å¾„ã€‚

**å½¢å¼åŒ–è¯æ˜**ï¼š

```math
\text{å½’çº³è¯æ˜ï¼š} \\
\text{åŸºä¾‹ï¼šåˆå§‹æ—¶åªæœ‰æºç‚¹sï¼Œè·ç¦»ä¸º0ï¼Œæ­£ç¡®ã€‚} \\
\text{å½’çº³å‡è®¾ï¼šå‰kæ¬¡è¿­ä»£åï¼Œå·²ç¡®å®škä¸ªé¡¶ç‚¹çš„æœ€çŸ­è·ç¦»ã€‚} \\
\text{å½’çº³æ­¥éª¤ï¼šç¬¬k+1æ¬¡é€‰æ‹©è·ç¦»æœ€å°çš„æœªè®¿é—®é¡¶ç‚¹uã€‚} \\
\text{å‡è®¾å­˜åœ¨æ›´çŸ­è·¯å¾„åˆ°uï¼Œåˆ™å¿…ç»è¿‡æŸä¸ªæœªè®¿é—®é¡¶ç‚¹vï¼Œ} \\
\text{ä½†d[v] â‰¥ d[u]ï¼ŒçŸ›ç›¾ã€‚å› æ­¤d[u]æ˜¯æœ€çŸ­è·ç¦»ã€‚}
```

## 2. ç®—æ³•å®ç°ä¸å·¥ç¨‹æ¡ˆä¾‹

### 2.1 å›¾è®ºç®—æ³•å®ç°

#### æœ€çŸ­è·¯å¾„ç®—æ³•

```python
import heapq
from typing import Dict, List, Tuple, Optional
import networkx as nx

class GraphAlgorithms:
    """å›¾è®ºç®—æ³•å®ç°"""

    def __init__(self, graph: nx.Graph):
        self.graph = graph
        self.n = len(graph.nodes())

    def dijkstra_shortest_path(self, source: str) -> Dict[str, float]:
        """Dijkstraæœ€çŸ­è·¯å¾„ç®—æ³•"""
        # åˆå§‹åŒ–è·ç¦»å’Œçˆ¶èŠ‚ç‚¹
        distances = {node: float('inf') for node in self.graph.nodes()}
        distances[source] = 0
        parent = {node: None for node in self.graph.nodes()}

        # ä¼˜å…ˆé˜Ÿåˆ—
        pq = [(0, source)]
        visited = set()

        while pq:
            current_dist, current_node = heapq.heappop(pq)

            if current_node in visited:
                continue

            visited.add(current_node)

            # æ›´æ–°é‚»å±…è·ç¦»
            for neighbor, weight in self.graph[current_node].items():
                if neighbor not in visited:
                    new_dist = current_dist + weight.get('weight', 1)
                    if new_dist < distances[neighbor]:
                        distances[neighbor] = new_dist
                        parent[neighbor] = current_node
                        heapq.heappush(pq, (new_dist, neighbor))

        return distances, parent

    def bellman_ford_shortest_path(self, source: str) -> Tuple[Dict[str, float], bool]:
        """Bellman-Fordç®—æ³•ï¼ˆæ”¯æŒè´Ÿæƒè¾¹ï¼‰"""
        distances = {node: float('inf') for node in self.graph.nodes()}
        distances[source] = 0

        # æ¾å¼›æ“ä½œ
        for _ in range(self.n - 1):
            for u, v, weight in self.graph.edges(data='weight', default=1):
                if distances[u] + weight < distances[v]:
                    distances[v] = distances[u] + weight

        # æ£€æµ‹è´Ÿç¯
        for u, v, weight in self.graph.edges(data='weight', default=1):
            if distances[u] + weight < distances[v]:
                return distances, True  # å­˜åœ¨è´Ÿç¯

        return distances, False

    def floyd_warshall_all_pairs(self) -> Dict[Tuple[str, str], float]:
        """Floyd-Warshallå…¨å¯¹æœ€çŸ­è·¯å¾„"""
        # åˆå§‹åŒ–è·ç¦»çŸ©é˜µ
        distances = {}
        for u in self.graph.nodes():
            for v in self.graph.nodes():
                if u == v:
                    distances[(u, v)] = 0
                elif self.graph.has_edge(u, v):
                    distances[(u, v)] = self.graph[u][v].get('weight', 1)
                else:
                    distances[(u, v)] = float('inf')

        # Floyd-Warshallç®—æ³•
        for k in self.graph.nodes():
            for i in self.graph.nodes():
                for j in self.graph.nodes():
                    if distances[(i, k)] + distances[(k, j)] < distances[(i, j)]:
                        distances[(i, j)] = distances[(i, k)] + distances[(k, j)]

        return distances

    def minimum_spanning_tree(self) -> nx.Graph:
        """Kruskalæœ€å°ç”Ÿæˆæ ‘ç®—æ³•"""
        # æŒ‰æƒé‡æ’åºè¾¹
        edges = sorted(self.graph.edges(data='weight', default=1),
                      key=lambda x: x[2])

        mst = nx.Graph()
        union_find = UnionFind(self.graph.nodes())

        for u, v, weight in edges:
            if union_find.find(u) != union_find.find(v):
                mst.add_edge(u, v, weight=weight)
                union_find.union(u, v)

        return mst

    def strongly_connected_components(self) -> List[List[str]]:
        """Tarjanå¼ºè¿é€šåˆ†é‡ç®—æ³•"""
        # åˆå§‹åŒ–
        index = 0
        indices = {}
        low_link = {}
        on_stack = set()
        stack = []
        components = []

        def tarjan_dfs(node):
            nonlocal index
            indices[node] = index
            low_link[node] = index
            index += 1
            stack.append(node)
            on_stack.add(node)

            for neighbor in self.graph.neighbors(node):
                if neighbor not in indices:
                    tarjan_dfs(neighbor)
                    low_link[node] = min(low_link[node], low_link[neighbor])
                elif neighbor in on_stack:
                    low_link[node] = min(low_link[node], indices[neighbor])

            if low_link[node] == indices[node]:
                component = []
                while True:
                    w = stack.pop()
                    on_stack.remove(w)
                    component.append(w)
                    if w == node:
                        break
                components.append(component)

        # å¯¹æ¯ä¸ªæœªè®¿é—®çš„èŠ‚ç‚¹æ‰§è¡ŒDFS
        for node in self.graph.nodes():
            if node not in indices:
                tarjan_dfs(node)

        return components

class UnionFind:
    """å¹¶æŸ¥é›†æ•°æ®ç»“æ„"""

    def __init__(self, elements):
        self.parent = {element: element for element in elements}
        self.rank = {element: 0 for element in elements}

    def find(self, element):
        """æŸ¥æ‰¾å…ƒç´ æ‰€åœ¨é›†åˆçš„ä»£è¡¨"""
        if self.parent[element] != element:
            self.parent[element] = self.find(self.parent[element])
        return self.parent[element]

    def union(self, element1, element2):
        """åˆå¹¶ä¸¤ä¸ªé›†åˆ"""
        root1 = self.find(element1)
        root2 = self.find(element2)

        if root1 == root2:
            return

        if self.rank[root1] < self.rank[root2]:
            self.parent[root1] = root2
        elif self.rank[root1] > self.rank[root2]:
            self.parent[root2] = root1
        else:
            self.parent[root2] = root1
            self.rank[root1] += 1
```

### 2.2 å·¥ç¨‹æ¡ˆä¾‹ï¼šç½‘ç»œè·¯ç”±ç³»ç»Ÿ

#### æ¡ˆä¾‹1ï¼šäº’è”ç½‘è·¯ç”±ç®—æ³•

```python
class InternetRouter:
    """äº’è”ç½‘è·¯ç”±å™¨å®ç°"""

    def __init__(self, router_id: str):
        self.router_id = router_id
        self.routing_table = {}
        self.neighbors = {}
        self.topology = nx.Graph()

    def build_topology(self, links: List[Tuple[str, str, float]]):
        """æ„å»ºç½‘ç»œæ‹“æ‰‘"""
        for source, target, cost in links:
            self.topology.add_edge(source, target, weight=cost)

    def compute_routing_table(self):
        """è®¡ç®—è·¯ç”±è¡¨"""
        # ä½¿ç”¨Dijkstraç®—æ³•è®¡ç®—æœ€çŸ­è·¯å¾„
        algorithms = GraphAlgorithms(self.topology)
        distances, parent = algorithms.dijkstra_shortest_path(self.router_id)

        # æ„å»ºè·¯ç”±è¡¨
        for destination, distance in distances.items():
            if destination != self.router_id:
                next_hop = self.find_next_hop(destination, parent)
                self.routing_table[destination] = {
                    'next_hop': next_hop,
                    'cost': distance,
                    'path': self.get_path(destination, parent)
                }

    def find_next_hop(self, destination: str, parent: Dict[str, str]) -> str:
        """æ‰¾åˆ°åˆ°ç›®çš„åœ°çš„ä¸‹ä¸€è·³"""
        current = destination
        while parent[current] != self.router_id:
            current = parent[current]
        return current

    def get_path(self, destination: str, parent: Dict[str, str]) -> List[str]:
        """è·å–åˆ°ç›®çš„åœ°çš„å®Œæ•´è·¯å¾„"""
        path = [destination]
        current = destination
        while parent[current] is not None:
            current = parent[current]
            path.append(current)
        return path[::-1]

    def route_packet(self, destination: str, packet_data: dict) -> str:
        """è·¯ç”±æ•°æ®åŒ…"""
        if destination in self.routing_table:
            next_hop = self.routing_table[destination]['next_hop']
            print(f"è·¯ç”±æ•°æ®åŒ…åˆ° {destination}ï¼Œä¸‹ä¸€è·³: {next_hop}")
            return next_hop
        else:
            print(f"æ— æ³•è·¯ç”±åˆ° {destination}")
            return None
```

#### æ¡ˆä¾‹2ï¼šç¤¾äº¤ç½‘ç»œåˆ†æ

```python
class SocialNetworkAnalyzer:
    """ç¤¾äº¤ç½‘ç»œåˆ†æç³»ç»Ÿ"""

    def __init__(self, network: nx.Graph):
        self.network = network
        self.analyzer = GraphAlgorithms(network)

    def find_influential_users(self, top_k: int = 10) -> List[Tuple[str, float]]:
        """æ‰¾åˆ°æœ‰å½±å“åŠ›çš„ç”¨æˆ·"""
        # è®¡ç®—å„ç§ä¸­å¿ƒæ€§æŒ‡æ ‡
        degree_centrality = nx.degree_centrality(self.network)
        betweenness_centrality = nx.betweenness_centrality(self.network)
        closeness_centrality = nx.closeness_centrality(self.network)
        pagerank = nx.pagerank(self.network)

        # ç»¼åˆå½±å“åŠ›å¾—åˆ†
        influence_scores = {}
        for node in self.network.nodes():
            score = (degree_centrality[node] * 0.3 +
                    betweenness_centrality[node] * 0.3 +
                    closeness_centrality[node] * 0.2 +
                    pagerank[node] * 0.2)
            influence_scores[node] = score

        # è¿”å›top_kä¸ªæœ€æœ‰å½±å“åŠ›çš„ç”¨æˆ·
        return sorted(influence_scores.items(), key=lambda x: x[1], reverse=True)[:top_k]

    def detect_communities(self) -> List[List[str]]:
        """æ£€æµ‹ç¤¾åŒº"""
        # ä½¿ç”¨Louvainç®—æ³•
        communities = nx.community.louvain_communities(self.network)
        return [list(community) for community in communities]

    def find_shortest_paths_between_users(self, user1: str, user2: str) -> List[List[str]]:
        """æ‰¾åˆ°ä¸¤ä¸ªç”¨æˆ·ä¹‹é—´çš„æ‰€æœ‰æœ€çŸ­è·¯å¾„"""
        try:
            paths = list(nx.all_shortest_paths(self.network, user1, user2))
            return paths
        except nx.NetworkXNoPath:
            return []

    def analyze_information_spread(self, seed_users: List[str],
                                 spread_probability: float = 0.1) -> Dict:
        """åˆ†æä¿¡æ¯ä¼ æ’­"""
        # ä½¿ç”¨ç‹¬ç«‹çº§è”æ¨¡å‹
        infected = set(seed_users)
        newly_infected = set(seed_users)
        spread_history = [list(infected)]

        while newly_infected:
            current_newly_infected = set()

            for infected_user in newly_infected:
                for neighbor in self.network.neighbors(infected_user):
                    if neighbor not in infected:
                        if random.random() < spread_probability:
                            current_newly_infected.add(neighbor)

            newly_infected = current_newly_infected
            infected.update(newly_infected)
            spread_history.append(list(infected))

        return {
            'total_infected': len(infected),
            'spread_history': spread_history,
            'final_reach': len(infected) / len(self.network.nodes())
        }
```

## 3. è·¨é¢†åŸŸåº”ç”¨ä¸åˆ›æ–°

### 3.1 å›¾è®ºä¸æœºå™¨å­¦ä¹ 

#### å›¾ç¥ç»ç½‘ç»œåº”ç”¨

```python
import torch
import torch.nn as nn
import torch_geometric.nn as gnn

class GraphNeuralNetwork(nn.Module):
    """å›¾ç¥ç»ç½‘ç»œ"""

    def __init__(self, input_dim: int, hidden_dim: int, output_dim: int):
        super(GraphNeuralNetwork, self).__init__()

        self.conv1 = gnn.GCNConv(input_dim, hidden_dim)
        self.conv2 = gnn.GCNConv(hidden_dim, hidden_dim)
        self.conv3 = gnn.GCNConv(hidden_dim, hidden_dim)

        self.classifier = nn.Sequential(
            nn.Linear(hidden_dim, hidden_dim // 2),
            nn.ReLU(),
            nn.Dropout(0.5),
            nn.Linear(hidden_dim // 2, output_dim)
        )

    def forward(self, x, edge_index):
        # å›¾å·ç§¯å±‚
        x = self.conv1(x, edge_index)
        x = torch.relu(x)
        x = self.conv2(x, edge_index)
        x = torch.relu(x)
        x = self.conv3(x, edge_index)

        # åˆ†ç±»
        x = self.classifier(x)
        return x

    def train_on_graph_data(self, data_loader, epochs=100):
        """åœ¨å›¾æ•°æ®ä¸Šè®­ç»ƒ"""
        optimizer = torch.optim.Adam(self.parameters(), lr=0.01)
        criterion = nn.CrossEntropyLoss()

        for epoch in range(epochs):
            total_loss = 0

            for batch in data_loader:
                optimizer.zero_grad()

                # å‰å‘ä¼ æ’­
                outputs = self(batch.x, batch.edge_index)
                loss = criterion(outputs, batch.y)

                # åå‘ä¼ æ’­
                loss.backward()
                optimizer.step()

                total_loss += loss.item()

            if epoch % 10 == 0:
                print(f'Epoch {epoch}, Loss: {total_loss/len(data_loader):.4f}')
```

### 3.2 å›¾è®ºä¸ç”Ÿç‰©ä¿¡æ¯å­¦

#### è›‹ç™½è´¨ç›¸äº’ä½œç”¨ç½‘ç»œåˆ†æ

```python
class ProteinInteractionAnalyzer:
    """è›‹ç™½è´¨ç›¸äº’ä½œç”¨ç½‘ç»œåˆ†æ"""

    def __init__(self, interaction_network: nx.Graph):
        self.network = interaction_network
        self.analyzer = GraphAlgorithms(interaction_network)

    def identify_protein_clusters(self) -> List[List[str]]:
        """è¯†åˆ«è›‹ç™½è´¨èšç±»"""
        # ä½¿ç”¨ç¤¾åŒºæ£€æµ‹ç®—æ³•
        communities = self.analyzer.strongly_connected_components()
        return communities

    def find_essential_proteins(self, top_k: int = 20) -> List[str]:
        """æ‰¾åˆ°å¿…éœ€è›‹ç™½è´¨"""
        # åŸºäºç½‘ç»œæ‹“æ‰‘ç‰¹å¾è¯†åˆ«å¿…éœ€è›‹ç™½è´¨
        degree_centrality = nx.degree_centrality(self.network)
        betweenness_centrality = nx.betweenness_centrality(self.network)

        essential_scores = {}
        for protein in self.network.nodes():
            score = (degree_centrality[protein] * 0.6 +
                    betweenness_centrality[protein] * 0.4)
            essential_scores[protein] = score

        return sorted(essential_scores.items(), key=lambda x: x[1], reverse=True)[:top_k]

    def analyze_pathway_enrichment(self, protein_list: List[str]) -> Dict:
        """åˆ†æé€šè·¯å¯Œé›†"""
        # è®¡ç®—è›‹ç™½è´¨åˆ—è¡¨çš„ç½‘ç»œç‰¹å¾
        subnetwork = self.network.subgraph(protein_list)

        # è®¡ç®—å„ç§ç½‘ç»œæŒ‡æ ‡
        density = nx.density(subnetwork)
        clustering_coefficient = nx.average_clustering(subnetwork)
        average_shortest_path = nx.average_shortest_path_length(subnetwork)

        return {
            'network_density': density,
            'clustering_coefficient': clustering_coefficient,
            'average_shortest_path': average_shortest_path,
            'protein_count': len(protein_list)
        }
```

## 4. æ‰¹åˆ¤æ€§åˆ†æä¸æ”¹è¿›å»ºè®®

### 4.1 ç°æœ‰ç®—æ³•çš„å±€é™æ€§

#### è®¡ç®—å¤æ‚æ€§

1. **å¤§è§„æ¨¡å›¾å¤„ç†**ï¼šä¼ ç»Ÿç®—æ³•éš¾ä»¥å¤„ç†å¤§è§„æ¨¡å›¾
2. **åŠ¨æ€å›¾æ›´æ–°**ï¼šå›¾ç»“æ„å˜åŒ–æ—¶çš„é‡æ–°è®¡ç®—å¼€é”€
3. **å†…å­˜æ¶ˆè€—**ï¼šå¤§è§„æ¨¡å›¾çš„å­˜å‚¨å’Œè®¿é—®é—®é¢˜

#### ç®—æ³•ç²¾åº¦

1. **è¿‘ä¼¼ç®—æ³•**ï¼šæŸäº›é—®é¢˜åªèƒ½ä½¿ç”¨è¿‘ä¼¼ç®—æ³•
2. **å¯å‘å¼æ–¹æ³•**ï¼šNPéš¾é—®é¢˜çš„å¯å‘å¼è§£å†³æ–¹æ¡ˆ
3. **å‚æ•°æ•æ„Ÿæ€§**ï¼šç®—æ³•å¯¹å‚æ•°è®¾ç½®çš„æ•æ„Ÿæ€§

### 4.2 æ”¹è¿›æ–¹å‘

#### æŠ€æœ¯åˆ›æ–°

1. **å¹¶è¡Œç®—æ³•**ï¼šåˆ©ç”¨å¹¶è¡Œè®¡ç®—åŠ é€Ÿå›¾ç®—æ³•
2. **æµå¼å¤„ç†**ï¼šå¤„ç†åŠ¨æ€å˜åŒ–çš„å›¾æ•°æ®
3. **è¿‘ä¼¼ç®—æ³•**ï¼šå¼€å‘æ›´ç²¾ç¡®çš„è¿‘ä¼¼ç®—æ³•

#### å·¥ç¨‹ä¼˜åŒ–

1. **å†…å­˜ä¼˜åŒ–**ï¼šå‹ç¼©å›¾è¡¨ç¤ºå’Œé«˜æ•ˆå­˜å‚¨
2. **ç¼“å­˜ç­–ç•¥**ï¼šæ™ºèƒ½ç¼“å­˜å¸¸ç”¨è®¡ç®—ç»“æœ
3. **åˆ†å¸ƒå¼å¤„ç†**ï¼šå¤§è§„æ¨¡å›¾çš„åˆ†å¸ƒå¼å¤„ç†

## 5. å½¢å¼åŒ–éªŒè¯ä¸æµ‹è¯•

### 5.1 ç®—æ³•æ­£ç¡®æ€§éªŒè¯

```python
class GraphAlgorithmVerifier:
    """å›¾ç®—æ³•éªŒè¯å™¨"""

    def __init__(self):
        self.verification_results = {}

    def verify_shortest_path_algorithm(self, algorithm, test_graph):
        """éªŒè¯æœ€çŸ­è·¯å¾„ç®—æ³•"""
        # ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹
        test_cases = self.generate_shortest_path_test_cases(test_graph)

        results = {}
        for source, target, expected_distance in test_cases:
            # è¿è¡Œç®—æ³•
            actual_distance = algorithm.compute_shortest_path(source, target)

            # éªŒè¯ç»“æœ
            is_correct = abs(actual_distance - expected_distance) < 1e-6
            results[f"{source}->{target}"] = {
                'expected': expected_distance,
                'actual': actual_distance,
                'correct': is_correct
            }

        return results

    def verify_minimum_spanning_tree(self, algorithm, test_graph):
        """éªŒè¯æœ€å°ç”Ÿæˆæ ‘ç®—æ³•"""
        # è®¡ç®—MST
        mst = algorithm.compute_mst(test_graph)

        # éªŒè¯MSTæ€§è´¨
        is_connected = nx.is_connected(mst)
        is_tree = nx.is_tree(mst)
        is_minimal = self.verify_mst_minimality(test_graph, mst)

        return {
            'is_connected': is_connected,
            'is_tree': is_tree,
            'is_minimal': is_minimal,
            'total_weight': sum(mst[u][v]['weight'] for u, v in mst.edges())
        }
```

### 5.2 æ€§èƒ½æµ‹è¯•

```python
class GraphAlgorithmBenchmark:
    """å›¾ç®—æ³•æ€§èƒ½æµ‹è¯•"""

    def __init__(self):
        self.benchmark_results = {}

    def benchmark_shortest_path_algorithms(self, test_graphs):
        """æµ‹è¯•æœ€çŸ­è·¯å¾„ç®—æ³•æ€§èƒ½"""
        algorithms = {
            'Dijkstra': self.dijkstra_algorithm,
            'Bellman-Ford': self.bellman_ford_algorithm,
            'Floyd-Warshall': self.floyd_warshall_algorithm
        }

        results = {}
        for graph_name, graph in test_graphs.items():
            results[graph_name] = {}
            for alg_name, algorithm in algorithms.items():
                # æµ‹é‡æ‰§è¡Œæ—¶é—´
                start_time = time.time()
                algorithm(graph)
                end_time = time.time()

                results[graph_name][alg_name] = {
                    'execution_time': end_time - start_time,
                    'memory_usage': self.measure_memory_usage(algorithm, graph)
                }

        return results

    def benchmark_community_detection(self, test_graphs):
        """æµ‹è¯•ç¤¾åŒºæ£€æµ‹ç®—æ³•æ€§èƒ½"""
        algorithms = {
            'Louvain': nx.community.louvain_communities,
            'Girvan-Newman': nx.community.girvan_newman,
            'Label Propagation': nx.community.label_propagation_communities
        }

        results = {}
        for graph_name, graph in test_graphs.items():
            results[graph_name] = {}
            for alg_name, algorithm in algorithms.items():
                start_time = time.time()
                communities = algorithm(graph)
                end_time = time.time()

                results[graph_name][alg_name] = {
                    'execution_time': end_time - start_time,
                    'community_count': len(communities),
                    'modularity': nx.community.modularity(graph, communities)
                }

        return results
```

## 6. æ€»ç»“ä¸å±•æœ›

æœ¬ç« ç³»ç»Ÿæ¢³ç†äº†å›¾è®ºåŸºç¡€ä»ç†è®ºåˆ°åº”ç”¨çš„å…¨é“¾è·¯ï¼Œæ¶µç›–ï¼š

1. **ç†è®ºåŸºç¡€**ï¼šæ¬§æ‹‰å®šç†ã€å“ˆå¯†é¡¿å®šç†ã€ç®—æ³•æ­£ç¡®æ€§çš„å½¢å¼åŒ–è¯æ˜
2. **ç®—æ³•å®ç°**ï¼šæœ€çŸ­è·¯å¾„ã€æœ€å°ç”Ÿæˆæ ‘ã€å¼ºè¿é€šåˆ†é‡ç­‰æ ¸å¿ƒç®—æ³•
3. **å·¥ç¨‹æ¡ˆä¾‹**ï¼šç½‘ç»œè·¯ç”±ã€ç¤¾äº¤ç½‘ç»œåˆ†æç­‰å®é™…åº”ç”¨
4. **è·¨é¢†åŸŸåº”ç”¨**ï¼šå›¾ç¥ç»ç½‘ç»œã€ç”Ÿç‰©ä¿¡æ¯å­¦ç­‰åˆ›æ–°åº”ç”¨
5. **æ‰¹åˆ¤æ€§åˆ†æ**ï¼šç°æœ‰ç®—æ³•çš„å±€é™æ€§åˆ†æä¸æ”¹è¿›å»ºè®®
6. **å½¢å¼åŒ–éªŒè¯**ï¼šç®—æ³•æ­£ç¡®æ€§éªŒè¯ã€æ€§èƒ½æµ‹è¯•ç­‰éªŒè¯æ–¹æ³•

### æœªæ¥å‘å±•æ–¹å‘

1. **å¤§è§„æ¨¡å›¾å¤„ç†**ï¼šå¼€å‘å¤„ç†TBçº§å›¾æ•°æ®çš„é«˜æ•ˆç®—æ³•
2. **åŠ¨æ€å›¾åˆ†æ**ï¼šå®æ—¶å¤„ç†åŠ¨æ€å˜åŒ–çš„å›¾ç»“æ„
3. **å›¾ç¥ç»ç½‘ç»œ**ï¼šç»“åˆæ·±åº¦å­¦ä¹ çš„å›¾åˆ†ææŠ€æœ¯
4. **é‡å­å›¾ç®—æ³•**ï¼šé‡å­è®¡ç®—åœ¨å›¾è®ºä¸­çš„åº”ç”¨

## å¤šæ¨¡æ€è¡¨è¾¾ä¸å¯è§†åŒ–

### å›¾ç»“æ„å¯è§†åŒ–

```mermaid
graph TB
    A[èŠ‚ç‚¹A] --> B[èŠ‚ç‚¹B]
    A --> C[èŠ‚ç‚¹C]
    B --> D[èŠ‚ç‚¹D]
    C --> D
    D --> E[èŠ‚ç‚¹E]
    B --> E
```

### ç®—æ³•æ‰§è¡Œæµç¨‹å›¾

```mermaid
flowchart TD
    Start[å¼€å§‹] --> Input[è¾“å…¥å›¾G]
    Input --> Algorithm[é€‰æ‹©ç®—æ³•]
    Algorithm --> Dijkstra[Dijkstraç®—æ³•]
    Algorithm --> BellmanFord[Bellman-Fordç®—æ³•]
    Algorithm --> FloydWarshall[Floyd-Warshallç®—æ³•]
    Dijkstra --> Output[è¾“å‡ºç»“æœ]
    BellmanFord --> Output
    FloydWarshall --> Output
    Output --> End[ç»“æŸ]
```

### è‡ªåŠ¨åŒ–è„šæœ¬å»ºè®®

- `scripts/graph_visualization.py`ï¼šå›¾ç»“æ„å¯è§†åŒ–
- `scripts/algorithm_benchmark.py`ï¼šç®—æ³•æ€§èƒ½æµ‹è¯•
- `scripts/network_analysis.py`ï¼šç½‘ç»œåˆ†æå·¥å…·
