# 图论基础 - 基本概念

## 1. 图的基本定义

### 1.1 图的数学定义

**定义 1.1** (图 - Graph)
图 $G$ 是一个有序对 $(V, E)$，其中：

- $V$ 是非空有限集，称为**顶点集**或**节点集** (vertex set)
- $E$ 是 $V$ 中元素的无序对集合，称为**边集** (edge set)

记作：$G = (V, E)$

**形式化语义**：

- 集合论语义：$V \neq \emptyset, E \subseteq \binom{V}{2}$
- 范畴论语义：图作为范畴中的对象，图同态作为态射

**定义 1.2** (有向图 - Directed Graph)
有向图 $D$ 是一个有序对 $(V, A)$，其中：

- $V$ 是非空有限集，称为**顶点集**
- $A$ 是 $V \times V$ 的子集，称为**弧集** (arc set)

记作：$D = (V, A)$

**定义 1.3** (多重图 - Multigraph)
多重图 $G$ 是一个三元组 $(V, E, \mu)$，其中：

- $V$ 是顶点集
- $E$ 是边集
- $\mu: E \to \binom{V}{2}$ 是边到顶点对的映射函数

**定义 1.4** (加权图 - Weighted Graph)
加权图 $G$ 是一个三元组 $(V, E, w)$，其中：

- $V$ 是顶点集
- $E$ 是边集
- $w: E \to \mathbb{R}$ 是权重函数

### 1.2 图的基本性质

**定义 1.5** (图的阶和规模)

- 图的**阶** (order)：$|V|$，即顶点数
- 图的**规模** (size)：$|E|$，即边数

**定义 1.6** (邻接关系 - Adjacency)
对于图 $G = (V, E)$：

- 顶点 $u, v \in V$ 是**邻接的** (adjacent)，当且仅当 $(u, v) \in E$
- 边 $e_1, e_2 \in E$ 是**邻接的**，当且仅当它们共享一个顶点

**定义 1.7** (关联关系 - Incidence)
顶点 $v$ 与边 $e$ 是**关联的**，当且仅当 $v \in e$

### 1.3 度的概念

**定义 1.8** (顶点的度 - Degree)
顶点 $v$ 的**度** $d(v)$ 是与 $v$ 关联的边数：
$$d(v) = |\{e \in E : v \in e\}|$$

**定义 1.9** (最小度和最大度)

- **最小度**：$\delta(G) = \min_{v \in V} d(v)$
- **最大度**：$\Delta(G) = \max_{v \in V} d(v)$

**定理 1.1** (握手定理 - Handshaking Lemma)
对于任意图 $G = (V, E)$：
$$\sum_{v \in V} d(v) = 2|E|$$

**证明**：
每条边贡献给两个顶点的度，因此所有顶点的度之和等于边数的两倍。

**推论 1.1** (奇度顶点数)
任意图中奇度顶点的个数是偶数。

**证明**：
设奇度顶点集为 $O$，偶度顶点集为 $E$，则：
$$\sum_{v \in O} d(v) + \sum_{v \in E} d(v) = 2|E|$$
由于 $\sum_{v \in E} d(v)$ 是偶数，$\sum_{v \in O} d(v)$ 也必须是偶数，因此 $|O|$ 是偶数。

## 2. 图的类型

### 2.1 特殊图类

**定义 2.1** (完全图 - Complete Graph)
$n$ 阶完全图 $K_n$ 是包含所有可能边的图：
$$K_n = (V, E) \text{ 其中 } |V| = n, E = \{(u, v) : u, v \in V, u \neq v\}$$

**性质 2.1**：

- $|E| = \binom{n}{2} = \frac{n(n-1)}{2}$
- 每个顶点的度都是 $n-1$

**定义 2.2** (空图 - Empty Graph)
$n$ 阶空图 $N_n$ 是不包含任何边的图：
$$N_n = (V, \emptyset) \text{ 其中 } |V| = n$$

**定义 2.3** (路径图 - Path Graph)
$n$ 阶路径图 $P_n$ 是顶点序列 $v_1, v_2, \ldots, v_n$ 的图，其中边集为：
$$E = \{(v_i, v_{i+1}) : 1 \leq i < n\}$$

**性质 2.2**：

- $|E| = n-1$
- 度为1的顶点有2个（端点），度为2的顶点有 $n-2$ 个

**定义 2.4** (圈图 - Cycle Graph)
$n$ 阶圈图 $C_n$ 是路径图加上边 $(v_n, v_1)$：
$$C_n = P_n \cup \{(v_n, v_1)\}$$

**性质 2.3**：

- $|E| = n$
- 每个顶点的度都是2

**定义 2.5** (星图 - Star Graph)
$n$ 阶星图 $S_n$ 是一个中心顶点与 $n-1$ 个叶子顶点相连的图：
$$S_n = (V, E) \text{ 其中 } V = \{v_0, v_1, \ldots, v_{n-1}\}, E = \{(v_0, v_i) : 1 \leq i < n\}$$

### 2.2 二分图

**定义 2.6** (二分图 - Bipartite Graph)
图 $G = (V, E)$ 是**二分图**，如果存在 $V$ 的划分 $V = V_1 \cup V_2$，使得：

- $V_1 \cap V_2 = \emptyset$
- 每条边连接 $V_1$ 中的一个顶点和 $V_2$ 中的一个顶点

记作：$G = (V_1, V_2, E)$

**定理 2.1** (二分图判定定理)
图 $G$ 是二分图当且仅当 $G$ 不包含奇数长度的圈。

**证明**：
必要性：如果 $G$ 包含奇数长度的圈，则无法进行二分划分。
充分性：用BFS算法进行2-着色，如果成功则 $G$ 是二分图。

**定义 2.7** (完全二分图 - Complete Bipartite Graph)
完全二分图 $K_{m,n}$ 是二分图 $(V_1, V_2, E)$，其中：

- $|V_1| = m, |V_2| = n$
- $E = \{(u, v) : u \in V_1, v \in V_2\}$

### 2.3 正则图

**定义 2.8** (正则图 - Regular Graph)
$k$-正则图是每个顶点的度都是 $k$ 的图。

**性质 2.4**：

- $k$-正则图的边数：$|E| = \frac{k|V|}{2}$
- 完全图 $K_n$ 是 $(n-1)$-正则图
- 圈图 $C_n$ 是2-正则图

## 3. 图的表示

### 3.1 邻接矩阵

**定义 3.1** (邻接矩阵 - Adjacency Matrix)
图 $G = (V, E)$ 的邻接矩阵 $A = [a_{ij}]$ 是 $n \times n$ 矩阵，其中：
$$a_{ij} = \begin{cases}
1 & \text{如果 } (v_i, v_j) \in E \\
0 & \text{否则}
\end{cases}$$

**性质 3.1**：
- $A$ 是对称矩阵（对于无向图）
- $A^2$ 的 $(i,j)$ 元素表示从 $v_i$ 到 $v_j$ 的长度为2的路径数
- $A^k$ 的 $(i,j)$ 元素表示从 $v_i$ 到 $v_j$ 的长度为 $k$ 的路径数

**定理 3.1** (邻接矩阵特征值)
邻接矩阵 $A$ 的特征值 $\lambda$ 满足：
$$|\lambda| \leq \Delta(G)$$

**证明**：
设 $x$ 是特征值 $\lambda$ 对应的特征向量，$x_i$ 是最大分量，则：
$$|\lambda x_i| = |\sum_{j=1}^n a_{ij} x_j| \leq \sum_{j=1}^n a_{ij} |x_j| \leq d(v_i) |x_i| \leq \Delta(G) |x_i|$$

### 3.2 邻接表

**定义 3.2** (邻接表 - Adjacency List)
图 $G = (V, E)$ 的邻接表是函数 $adj: V \to 2^V$，其中：
$$adj(v) = \{u \in V : (v, u) \in E\}$$

**算法 3.1** (邻接表构建)
```python
def build_adjacency_list(V, E):
    adj = {v: [] for v in V}
    for (u, v) in E:
        adj[u].append(v)
        adj[v].append(u)  # 无向图
    return adj
```

### 3.3 关联矩阵

**定义 3.3** (关联矩阵 - Incidence Matrix)
图 $G = (V, E)$ 的关联矩阵 $B = [b_{ij}]$ 是 $n \times m$ 矩阵，其中：
$$b_{ij} = \begin{cases}
1 & \text{如果顶点 } v_i \text{ 与边 } e_j \text{ 关联} \\
0 & \text{否则}
\end{cases}$$

**性质 3.2**：
- 每列恰好有两个1（无向图）
- 每行的1的个数等于对应顶点的度

## 4. 图的同构

### 4.1 同构定义

**定义 4.1** (图同构 - Graph Isomorphism)
图 $G_1 = (V_1, E_1)$ 和 $G_2 = (V_2, E_2)$ 是**同构的**，如果存在双射 $f: V_1 \to V_2$，使得：
$$(u, v) \in E_1 \iff (f(u), f(v)) \in E_2$$

记作：$G_1 \cong G_2$

**形式化语义**：
- 范畴论语义：同构是范畴中的可逆态射
- 代数语义：同构保持图的所有代数性质

### 4.2 同构不变量

**定义 4.2** (同构不变量 - Isomorphism Invariant)
图的**同构不变量**是在图同构下保持不变的图的性质。

**定理 4.1** (基本同构不变量)
以下性质是图同构的不变量：
1. 顶点数 $|V|$
2. 边数 $|E|$
3. 度序列 $(d_1, d_2, \ldots, d_n)$
4. 连通分支数
5. 圈的长度
6. 特征多项式
7. 谱（邻接矩阵特征值）

**证明**：
这些性质在顶点重标号下保持不变，因此是同构不变量。

**算法 4.1** (同构检测 - 简化版)
```python
def are_isomorphic(G1, G2):
    if len(G1.V) != len(G2.V) or len(G1.E) != len(G2.E):
        return False

    # 检查度序列
    deg_seq1 = sorted([d(v) for v in G1.V])
    deg_seq2 = sorted([d(v) for v in G2.V])
    if deg_seq1 != deg_seq2:
        return False

    # 尝试所有可能的顶点映射
    return try_all_mappings(G1, G2)
```

## 5. 子图

### 5.1 子图定义

**定义 5.1** (子图 - Subgraph)
图 $H = (V_H, E_H)$ 是图 $G = (V, E)$ 的**子图**，如果：
- $V_H \subseteq V$
- $E_H \subseteq E \cap (V_H \times V_H)$

记作：$H \subseteq G$

**定义 5.2** (生成子图 - Spanning Subgraph)
图 $H$ 是图 $G$ 的**生成子图**，如果 $H$ 是 $G$ 的子图且 $V_H = V$

**定义 5.3** (导出子图 - Induced Subgraph)
图 $G$ 由顶点集 $S \subseteq V$ **导出的子图**是：
$$G[S] = (S, E \cap (S \times S))$$

**定义 5.4** (边导出子图 - Edge-Induced Subgraph)
图 $G$ 由边集 $F \subseteq E$ **导出的子图**是：
$$G[F] = (V_F, F)$$
其中 $V_F$ 是 $F$ 中边关联的所有顶点

### 5.2 特殊子图

**定义 5.5** (团 - Clique)
图 $G$ 的**团**是 $G$ 的完全子图。

**定义 5.6** (独立集 - Independent Set)
图 $G$ 的**独立集**是 $V$ 的子集 $S$，使得 $G[S]$ 是空图。

**定义 5.7** (匹配 - Matching)
图 $G$ 的**匹配**是边集 $M \subseteq E$，使得 $M$ 中的边两两不相邻。

## 6. 图的运算

### 6.1 基本运算

**定义 6.1** (图的并 - Union)
图 $G_1 = (V_1, E_1)$ 和 $G_2 = (V_2, E_2)$ 的**并**是：
$$G_1 \cup G_2 = (V_1 \cup V_2, E_1 \cup E_2)$$

**定义 6.2** (图的交 - Intersection)
图 $G_1 = (V_1, E_1)$ 和 $G_2 = (V_2, E_2)$ 的**交**是：
$$G_1 \cap G_2 = (V_1 \cap V_2, E_1 \cap E_2)$$

**定义 6.3** (图的差 - Difference)
图 $G_1 = (V_1, E_1)$ 和 $G_2 = (V_2, E_2)$ 的**差**是：
$$G_1 - G_2 = (V_1, E_1 - E_2)$$

### 6.2 图的补

**定义 6.4** (图的补 - Complement)
图 $G = (V, E)$ 的**补图** $\overline{G}$ 是：
$$\overline{G} = (V, \overline{E})$$
其中 $\overline{E} = \{(u, v) : u, v \in V, u \neq v, (u, v) \notin E\}$

**性质 6.1**：
- $G \cup \overline{G} = K_n$（完全图）
- $G \cap \overline{G} = N_n$（空图）

### 6.3 图的积

**定义 6.5** (笛卡尔积 - Cartesian Product)
图 $G_1 = (V_1, E_1)$ 和 $G_2 = (V_2, E_2)$ 的**笛卡尔积**是：
$$G_1 \square G_2 = (V_1 \times V_2, E)$$
其中 $E = \{((u_1, v_1), (u_2, v_2)) : (u_1 = u_2 \land (v_1, v_2) \in E_2) \lor (v_1 = v_2 \land (u_1, u_2) \in E_1)\}$

## 7. 图的不变量

### 7.1 基本不变量

**定义 7.1** (图的阶)
图的**阶**是顶点数：$n(G) = |V|$

**定义 7.2** (图的规模)
图的**规模**是边数：$m(G) = |E|$

**定义 7.3** (图的密度)
图的**密度**是：
$$\rho(G) = \frac{2|E|}{|V|(|V|-1)}$$

**性质 7.1**：
- $0 \leq \rho(G) \leq 1$
- $\rho(G) = 1$ 当且仅当 $G$ 是完全图
- $\rho(G) = 0$ 当且仅当 $G$ 是空图

### 7.2 度序列

**定义 7.4** (度序列 - Degree Sequence)
图的**度序列**是顶点度的非增序列：
$$d_1 \geq d_2 \geq \cdots \geq d_n$$

**定理 7.1** (Havel-Hakimi定理 - 度序列可图性)
非增序列 $d_1 \geq d_2 \geq \cdots \geq d_n$ 是某个图的度序列，当且仅当：
1. $\sum_{i=1}^n d_i$ 是偶数
2. 对于所有 $k \in \{1, 2, \ldots, n\}$：
   $$\sum_{i=1}^k d_i \leq k(k-1) + \sum_{i=k+1}^n \min(d_i, k)$$

**算法 7.1** (Havel-Hakimi算法)
```python
def is_graphical(degrees):
    degrees = sorted(degrees, reverse=True)
    while degrees:
        d = degrees.pop(0)
        if d > len(degrees):
            return False
        for i in range(d):
            degrees[i] -= 1
            if degrees[i] < 0:
                return False
        degrees = sorted(degrees, reverse=True)
        degrees = [d for d in degrees if d > 0]
    return True
```

### 7.3 图的谱

**定义 7.5** (图的谱 - Graph Spectrum)
图的**谱**是其邻接矩阵的特征值集合。

**定理 7.2** (谱的基本性质)
设图 $G$ 的谱为 $\lambda_1 \geq \lambda_2 \geq \cdots \geq \lambda_n$，则：
1. $\sum_{i=1}^n \lambda_i = 0$
2. $\sum_{i=1}^n \lambda_i^2 = 2|E|$
3. $\lambda_1 \leq \Delta(G)$

## 8. 图的算法

### 8.1 基本遍历算法

**算法 8.1** (深度优先搜索 - DFS)
```python
def dfs(G, start):
    visited = set()
    stack = [start]
    while stack:
        vertex = stack.pop()
        if vertex not in visited:
            visited.add(vertex)
            for neighbor in G.adj[vertex]:
                if neighbor not in visited:
                    stack.append(neighbor)
    return visited
```

**算法 8.2** (广度优先搜索 - BFS)
```python
def bfs(G, start):
    visited = set()
    queue = [start]
    visited.add(start)
    while queue:
        vertex = queue.pop(0)
        for neighbor in G.adj[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    return visited
```

### 8.2 图的性质检测

**算法 8.3** (二分图检测)
```python
def is_bipartite(G):
    color = {}
    for vertex in G.V:
        if vertex not in color:
            if not dfs_color(G, vertex, color, 1):
                return False
    return True

def dfs_color(G, vertex, color, c):
    color[vertex] = c
    for neighbor in G.adj[vertex]:
        if neighbor in color:
            if color[neighbor] == c:
                return False
        else:
            if not dfs_color(G, neighbor, color, 3-c):
                return False
    return True
```

## 多模态表达与可视化

### 8.3 结构图可视化

**Graphviz示例**：
```dot
graph G {
    A -- B;
    B -- C;
    C -- A;
    A -- D;
}
```

**NetworkX示例**：
```python
import networkx as nx
import matplotlib.pyplot as plt

G = nx.Graph([(0,1), (1,2), (2,0), (0,3)])
nx.draw(G, with_labels=True)
plt.show()
```

### 8.4 算法流程图

**Mermaid示例**：
```mermaid
graph TD;
    Start([开始]) --> Input[输入图G]
    Input --> Check{检查基本条件}
    Check -->|不满足| False[返回False]
    Check -->|满足| DFS[DFS遍历]
    DFS --> Color[2-着色]
    Color --> Success{成功?}
    Success -->|是| True[返回True]
    Success -->|否| False
```

### 8.5 自动化脚本建议

**脚本功能**：
- `scripts/graph_visualization.py`：输入邻接表/矩阵，输出结构图、热力图
- `scripts/graph_properties.py`：计算图的基本性质（度、密度、谱等）
- `scripts/isomorphism_check.py`：检测图同构
- `scripts/bipartite_test.py`：检测二分图性质

---

*本文档提供了图论的基本概念和形式化定义，对标国际标准，为后续的网络通信理论奠定坚实基础。*
