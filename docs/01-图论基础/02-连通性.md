# å›¾è®ºåŸºç¡€ - è¿é€šæ€§ / Graph Theory Fundamentals - Connectivity

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä»‹ç»å›¾è®ºä¸­çš„è¿é€šæ€§ç†è®ºï¼ŒåŒ…æ‹¬è·¯å¾„ã€è¿é€šæ€§ã€å‰²é›†ã€Mengerå®šç†ã€å¼ºè¿é€šæ€§ã€æ ‘ä¸ç”Ÿæˆæ ‘ã€ç½‘ç»œæµç­‰æ ¸å¿ƒæ¦‚å¿µã€‚

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [å›¾è®ºåŸºç¡€ - è¿é€šæ€§ / Graph Theory Fundamentals - Connectivity](#å›¾è®ºåŸºç¡€---è¿é€šæ€§--graph-theory-fundamentals---connectivity)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [1. è·¯å¾„ä¸è¿é€šæ€§](#1-è·¯å¾„ä¸è¿é€šæ€§)
    - [1.1 è·¯å¾„å®šä¹‰](#11-è·¯å¾„å®šä¹‰)
    - [1.2 è¿é€šæ€§å®šä¹‰](#12-è¿é€šæ€§å®šä¹‰)
  - [2. è·ç¦»ä¸ç›´å¾„](#2-è·ç¦»ä¸ç›´å¾„)
    - [2.1 è·ç¦»å®šä¹‰](#21-è·ç¦»å®šä¹‰)
    - [2.2 ä¸­å¿ƒä¸ç¦»å¿ƒç‡](#22-ä¸­å¿ƒä¸ç¦»å¿ƒç‡)
  - [3. å‰²é›†ä¸è¿é€šåº¦](#3-å‰²é›†ä¸è¿é€šåº¦)
    - [3.1 å‰²é›†å®šä¹‰](#31-å‰²é›†å®šä¹‰)
    - [3.2 è¿é€šåº¦](#32-è¿é€šåº¦)
  - [4. Mengerå®šç†](#4-mengerå®šç†)
    - [4.1 é¡¶ç‚¹ç‰ˆæœ¬](#41-é¡¶ç‚¹ç‰ˆæœ¬)
    - [4.2 è¾¹ç‰ˆæœ¬](#42-è¾¹ç‰ˆæœ¬)
  - [5. å¼ºè¿é€šæ€§](#5-å¼ºè¿é€šæ€§)
    - [5.1 æœ‰å‘å›¾çš„è¿é€šæ€§](#51-æœ‰å‘å›¾çš„è¿é€šæ€§)
    - [5.2 å¯è¾¾æ€§](#52-å¯è¾¾æ€§)
  - [6. æ ‘ä¸ç”Ÿæˆæ ‘](#6-æ ‘ä¸ç”Ÿæˆæ ‘)
    - [6.1 æ ‘çš„æ€§è´¨](#61-æ ‘çš„æ€§è´¨)
    - [6.2 ç”Ÿæˆæ ‘](#62-ç”Ÿæˆæ ‘)
    - [6.3 æœ€å°ç”Ÿæˆæ ‘](#63-æœ€å°ç”Ÿæˆæ ‘)
  - [7. ç½‘ç»œæµ](#7-ç½‘ç»œæµ)
    - [7.1 æµç½‘ç»œ](#71-æµç½‘ç»œ)
    - [7.2 æœ€å¤§æµæœ€å°å‰²å®šç†](#72-æœ€å¤§æµæœ€å°å‰²å®šç†)
  - [8. è¿é€šæ€§ç®—æ³•](#8-è¿é€šæ€§ç®—æ³•)
    - [8.1 è¿é€šæ€§æ£€æµ‹](#81-è¿é€šæ€§æ£€æµ‹)
    - [8.2 å‰²ç‚¹æ£€æµ‹](#82-å‰²ç‚¹æ£€æµ‹)
  - [å¤šæ¨¡æ€è¡¨è¾¾ä¸å¯è§†åŒ–](#å¤šæ¨¡æ€è¡¨è¾¾ä¸å¯è§†åŒ–)
    - [8.3 è¿é€šæ€§å¯è§†åŒ–](#83-è¿é€šæ€§å¯è§†åŒ–)
    - [8.4 ç®—æ³•æµç¨‹å›¾](#84-ç®—æ³•æµç¨‹å›¾)
    - [8.5 è‡ªåŠ¨åŒ–è„šæœ¬å»ºè®®](#85-è‡ªåŠ¨åŒ–è„šæœ¬å»ºè®®)

---

## 1. è·¯å¾„ä¸è¿é€šæ€§

### 1.1 è·¯å¾„å®šä¹‰

**å®šä¹‰ 1.1** (è·¯å¾„ - Path)
å›¾ $G = (V, E)$ ä¸­çš„**è·¯å¾„**æ˜¯é¡¶ç‚¹åºåˆ— $P = (v_0, v_1, \ldots, v_k)$ï¼Œå…¶ä¸­ï¼š

- $v_i \in V$ å¯¹äºæ‰€æœ‰ $i = 0, 1, \ldots, k$
- $(v_{i-1}, v_i) \in E$ å¯¹äºæ‰€æœ‰ $i = 1, 2, \ldots, k$

**å½¢å¼åŒ–è¯­ä¹‰**ï¼š

- é›†åˆè®ºè¯­ä¹‰ï¼šè·¯å¾„æ˜¯é¡¶ç‚¹åºåˆ—çš„æœ‰é™åºåˆ—
- èŒƒç•´è®ºè¯­ä¹‰ï¼šè·¯å¾„æ˜¯å›¾èŒƒç•´ä¸­çš„æ€å°„

**å®šä¹‰ 1.2** (è·¯å¾„é•¿åº¦ - Path Length)
è·¯å¾„ $P = (v_0, v_1, \ldots, v_k)$ çš„**é•¿åº¦**æ˜¯ $k$ï¼Œå³è·¯å¾„ä¸­çš„è¾¹æ•°ã€‚

**å®šä¹‰ 1.3** (ç®€å•è·¯å¾„ - Simple Path)
**ç®€å•è·¯å¾„**æ˜¯ä¸åŒ…å«é‡å¤é¡¶ç‚¹çš„è·¯å¾„ã€‚

**å®šä¹‰ 1.4** (é—­è·¯å¾„ - Closed Path)
**é—­è·¯å¾„**æ˜¯æ»¡è¶³ $v_0 = v_k$ çš„è·¯å¾„ã€‚

**å®šä¹‰ 1.5** (åœˆ - Cycle)
**åœˆ**æ˜¯é•¿åº¦è‡³å°‘ä¸º3çš„ç®€å•é—­è·¯å¾„ã€‚

### 1.2 è¿é€šæ€§å®šä¹‰

**å®šä¹‰ 1.6** (è¿é€šé¡¶ç‚¹ - Connected Vertices)
å›¾ $G = (V, E)$ ä¸­ï¼Œé¡¶ç‚¹ $u$ å’Œ $v$ æ˜¯**è¿é€šçš„**ï¼Œå¦‚æœå­˜åœ¨ä» $u$ åˆ° $v$ çš„è·¯å¾„ã€‚

**å®šä¹‰ 1.7** (è¿é€šå›¾ - Connected Graph)
å›¾ $G$ æ˜¯**è¿é€šå›¾**ï¼Œå¦‚æœå¯¹äºä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ $u, v \in V$ï¼Œéƒ½å­˜åœ¨ä» $u$ åˆ° $v$ çš„è·¯å¾„ã€‚

**å®šä¹‰ 1.8** (è¿é€šåˆ†æ”¯ - Connected Component)
å›¾ $G$ çš„**è¿é€šåˆ†æ”¯**æ˜¯ $G$ çš„æå¤§è¿é€šå­å›¾ã€‚

**å®šç† 1.1** (è¿é€šåˆ†æ”¯æ€§è´¨)
å›¾ $G$ çš„è¿é€šåˆ†æ”¯æ„æˆ $V$ çš„ä¸€ä¸ªåˆ’åˆ†ã€‚

**è¯æ˜**ï¼š
è¿é€šæ€§æ˜¯ä¸€ä¸ªç­‰ä»·å…³ç³»ï¼Œå› æ­¤è¿é€šåˆ†æ”¯æ˜¯ç­‰ä»·ç±»ï¼Œæ„æˆ $V$ çš„åˆ’åˆ†ã€‚

**ç®—æ³• 1.1** (è¿é€šåˆ†æ”¯ç®—æ³•)

```python
def find_connected_components(G):
    components = []
    visited = set()

    for vertex in G.V:
        if vertex not in visited:
            component = dfs_component(G, vertex, visited)
            components.append(component)

    return components

def dfs_component(G, start, visited):
    component = set()
    stack = [start]

    while stack:
        vertex = stack.pop()
        if vertex not in visited:
            visited.add(vertex)
            component.add(vertex)
            for neighbor in G.adj[vertex]:
                if neighbor not in visited:
                    stack.append(neighbor)

    return component
```

## 2. è·ç¦»ä¸ç›´å¾„

### 2.1 è·ç¦»å®šä¹‰

**å®šä¹‰ 2.1** (è·ç¦» - Distance)
å›¾ $G = (V, E)$ ä¸­ï¼Œé¡¶ç‚¹ $u$ å’Œ $v$ ä¹‹é—´çš„**è·ç¦»** $d(u, v)$ æ˜¯ï¼š
$$d(u, v) = \min\{k : \text{å­˜åœ¨é•¿åº¦ä¸º } k \text{ çš„è·¯å¾„ä» } u \text{ åˆ° } v\}$$

å¦‚æœ $u$ å’Œ $v$ ä¸è¿é€šï¼Œåˆ™ $d(u, v) = \infty$ã€‚

**æ€§è´¨ 2.1** (è·ç¦»çš„åº¦é‡æ€§è´¨)ï¼š

1. $d(u, v) \geq 0$ ä¸” $d(u, v) = 0$ å½“ä¸”ä»…å½“ $u = v$
2. $d(u, v) = d(v, u)$ï¼ˆæ— å‘å›¾ï¼‰
3. $d(u, v) + d(v, w) \geq d(u, w)$ï¼ˆä¸‰è§’ä¸ç­‰å¼ï¼‰

**å®šä¹‰ 2.2** (å›¾çš„ç›´å¾„ - Diameter)
å›¾ $G$ çš„**ç›´å¾„**æ˜¯ï¼š
$$\text{diam}(G) = \max_{u, v \in V} d(u, v)$$

**å®šä¹‰ 2.3** (å›¾çš„åŠå¾„ - Radius)
å›¾ $G$ çš„**åŠå¾„**æ˜¯ï¼š
$$\text{rad}(G) = \min_{v \in V} \max_{u \in V} d(u, v)$$

### 2.2 ä¸­å¿ƒä¸ç¦»å¿ƒç‡

**å®šä¹‰ 2.4** (ç¦»å¿ƒç‡ - Eccentricity)
é¡¶ç‚¹ $v$ çš„**ç¦»å¿ƒç‡**æ˜¯ï¼š
$$e(v) = \max_{u \in V} d(u, v)$$

**å®šä¹‰ 2.5** (ä¸­å¿ƒ - Center)
å›¾ $G$ çš„**ä¸­å¿ƒ**æ˜¯ç¦»å¿ƒç‡æœ€å°çš„é¡¶ç‚¹é›†ï¼š
$$C(G) = \{v \in V : e(v) = \text{rad}(G)\}$$

**å®šç† 2.1** (ç›´å¾„ä¸åŠå¾„å…³ç³»)
å¯¹äºä»»æ„è¿é€šå›¾ $G$ï¼š
$$\text{rad}(G) \leq \text{diam}(G) \leq 2 \cdot \text{rad}(G)$$

**è¯æ˜**ï¼š
è®¾ $u, v$ æ˜¯ç›´å¾„ç«¯ç‚¹ï¼Œ$w$ æ˜¯ä¸­å¿ƒç‚¹ï¼Œåˆ™ï¼š
$$d(u, v) \leq d(u, w) + d(w, v) \leq 2 \cdot \text{rad}(G)$$

**ç®—æ³• 2.1** (Floyd-Warshallç®—æ³• - å…¨æºæœ€çŸ­è·¯)

```python
def floyd_warshall(G):
    n = len(G.V)
    dist = [[float('inf')] * n for _ in range(n)]

    # åˆå§‹åŒ–
    for i in range(n):
        dist[i][i] = 0
    for (u, v) in G.E:
        dist[u][v] = 1
        dist[v][u] = 1  # æ— å‘å›¾

    # Floyd-Warshall
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]

    return dist
```

## 3. å‰²é›†ä¸è¿é€šåº¦

### 3.1 å‰²é›†å®šä¹‰

**å®šä¹‰ 3.1** (é¡¶ç‚¹å‰² - Vertex Cut)
å›¾ $G = (V, E)$ çš„**é¡¶ç‚¹å‰²**æ˜¯é¡¶ç‚¹é›† $S \subseteq V$ï¼Œä½¿å¾— $G - S$ çš„è¿é€šåˆ†æ”¯æ•°å¤§äº $G$ çš„è¿é€šåˆ†æ”¯æ•°ã€‚

**å®šä¹‰ 3.2** (è¾¹å‰² - Edge Cut)
å›¾ $G = (V, E)$ çš„**è¾¹å‰²**æ˜¯è¾¹é›† $F \subseteq E$ï¼Œä½¿å¾— $G - F$ çš„è¿é€šåˆ†æ”¯æ•°å¤§äº $G$ çš„è¿é€šåˆ†æ”¯æ•°ã€‚

**å®šä¹‰ 3.3** (æœ€å°å‰² - Minimum Cut)
**æœ€å°é¡¶ç‚¹å‰²**ï¼ˆæˆ–**æœ€å°è¾¹å‰²**ï¼‰æ˜¯å¤§å°æœ€å°çš„é¡¶ç‚¹å‰²ï¼ˆæˆ–è¾¹å‰²ï¼‰ã€‚

### 3.2 è¿é€šåº¦

**å®šä¹‰ 3.4** (é¡¶ç‚¹è¿é€šåº¦ - Vertex Connectivity)
å›¾ $G$ çš„**é¡¶ç‚¹è¿é€šåº¦** $\kappa(G)$ æ˜¯ï¼š
$$\kappa(G) = \min\{|S| : S \text{ æ˜¯ } G \text{ çš„é¡¶ç‚¹å‰²}\}$$

å¦‚æœ $G$ æ˜¯å®Œå…¨å›¾ï¼Œåˆ™ $\kappa(G) = |V| - 1$ã€‚

**å®šä¹‰ 3.5** (è¾¹è¿é€šåº¦ - Edge Connectivity)
å›¾ $G$ çš„**è¾¹è¿é€šåº¦** $\lambda(G)$ æ˜¯ï¼š
$$\lambda(G) = \min\{|F| : F \text{ æ˜¯ } G \text{ çš„è¾¹å‰²}\}$$

**å®šç† 3.1** (è¿é€šåº¦ä¸ç­‰å¼ - Connectivity Inequality)
å¯¹äºä»»æ„å›¾ $G$ï¼š
$$\kappa(G) \leq \lambda(G) \leq \delta(G)$$

å…¶ä¸­ $\delta(G) = \min_{v \in V} d(v)$ æ˜¯å›¾çš„æœ€å°åº¦ã€‚

**è¯æ˜**ï¼š

1. $\lambda(G) \leq \delta(G)$ï¼šåˆ é™¤æŸä¸ªæœ€å°åº¦é¡¶ç‚¹çš„æ‰€æœ‰å…³è”è¾¹æ„æˆè¾¹å‰²
2. $\kappa(G) \leq \lambda(G)$ï¼šMengerå®šç†çš„ç›´æ¥æ¨è®º

**å®šç† 3.2** (Whitneyå®šç†)
å¯¹äºä»»æ„éå®Œå…¨å›¾ $G$ï¼š
$$\kappa(G) \leq \lambda(G) \leq \delta(G)$$

**è¯æ˜**ï¼š
é€šè¿‡æ„é€ æ€§è¯æ˜ï¼Œåˆ é™¤æœ€å°åº¦é¡¶ç‚¹çš„æ‰€æœ‰å…³è”è¾¹å¾—åˆ°è¾¹å‰²ã€‚

## 4. Mengerå®šç†

### 4.1 é¡¶ç‚¹ç‰ˆæœ¬

**å®šç† 4.1** (Mengerå®šç† - é¡¶ç‚¹ç‰ˆæœ¬)
å›¾ $G$ ä¸­ï¼Œé¡¶ç‚¹ $u$ å’Œ $v$ ä¹‹é—´çš„é¡¶ç‚¹è¿é€šåº¦ç­‰äº $u$ åˆ° $v$ çš„ä¸ç›¸äº¤è·¯å¾„çš„æœ€å¤§æ•°é‡ã€‚

**å½¢å¼åŒ–è¡¨è¿°**ï¼š
è®¾ $u, v$ æ˜¯å›¾ $G$ ä¸­ä¸ç›¸é‚»çš„é¡¶ç‚¹ï¼Œåˆ™ï¼š
$$\kappa_G(u, v) = \max\{k : \text{å­˜åœ¨ } k \text{ æ¡ä» } u \text{ åˆ° } v \text{ çš„é¡¶ç‚¹ä¸ç›¸äº¤è·¯å¾„}\}$$

**è¯æ˜**ï¼š
é€šè¿‡æœ€å¤§æµæœ€å°å‰²å®šç†è¯æ˜ã€‚æ„é€ è¾…åŠ©å›¾ï¼Œå°†é¡¶ç‚¹è¿é€šåº¦é—®é¢˜è½¬åŒ–ä¸ºè¾¹è¿é€šåº¦é—®é¢˜ã€‚

### 4.2 è¾¹ç‰ˆæœ¬

**å®šç† 4.2** (Mengerå®šç† - è¾¹ç‰ˆæœ¬)
å›¾ $G$ ä¸­ï¼Œé¡¶ç‚¹ $u$ å’Œ $v$ ä¹‹é—´çš„è¾¹è¿é€šåº¦ç­‰äº $u$ åˆ° $v$ çš„è¾¹ä¸ç›¸äº¤è·¯å¾„çš„æœ€å¤§æ•°é‡ã€‚

**å½¢å¼åŒ–è¡¨è¿°**ï¼š
$$\lambda_G(u, v) = \max\{k : \text{å­˜åœ¨ } k \text{ æ¡ä» } u \text{ åˆ° } v \text{ çš„è¾¹ä¸ç›¸äº¤è·¯å¾„}\}$$

**ç®—æ³• 4.1** (Mengerå®šç†åº”ç”¨ - æœ€å¤§æµç®—æ³•)

```python
def max_vertex_disjoint_paths(G, s, t):
    # æ„é€ è¾…åŠ©å›¾
    G_aux = construct_auxiliary_graph(G)

    # ä½¿ç”¨æœ€å¤§æµç®—æ³•
    max_flow = ford_fulkerson(G_aux, s, t)

    return max_flow

def construct_auxiliary_graph(G):
    # å°†æ¯ä¸ªé¡¶ç‚¹væ‹†åˆ†ä¸ºv_inå’Œv_out
    # æ·»åŠ å®¹é‡ä¸º1çš„è¾¹(v_in, v_out)
    # å°†åŸå›¾çš„è¾¹(u,v)æ›¿æ¢ä¸º(u_out, v_in)
    pass
```

## 5. å¼ºè¿é€šæ€§

### 5.1 æœ‰å‘å›¾çš„è¿é€šæ€§

**å®šä¹‰ 5.1** (å¼ºè¿é€š - Strongly Connected)
æœ‰å‘å›¾ $D = (V, A)$ æ˜¯**å¼ºè¿é€šçš„**ï¼Œå¦‚æœå¯¹äºä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ $u, v \in V$ï¼Œéƒ½å­˜åœ¨ä» $u$ åˆ° $v$ çš„æœ‰å‘è·¯å¾„ã€‚

**å®šä¹‰ 5.2** (å¼ºè¿é€šåˆ†æ”¯ - Strongly Connected Component)
æœ‰å‘å›¾ $D$ çš„**å¼ºè¿é€šåˆ†æ”¯**æ˜¯ $D$ çš„æå¤§å¼ºè¿é€šå­å›¾ã€‚

**å®šç† 5.1** (å¼ºè¿é€šåˆ†æ”¯æ€§è´¨)
æœ‰å‘å›¾çš„å¼ºè¿é€šåˆ†æ”¯æ„æˆé¡¶ç‚¹é›†çš„ä¸€ä¸ªåˆ’åˆ†ã€‚

### 5.2 å¯è¾¾æ€§

**å®šä¹‰ 5.3** (å¯è¾¾æ€§ - Reachability)
åœ¨æœ‰å‘å›¾ $D$ ä¸­ï¼Œé¡¶ç‚¹ $v$ ä»é¡¶ç‚¹ $u$ **å¯è¾¾**ï¼Œå¦‚æœå­˜åœ¨ä» $u$ åˆ° $v$ çš„æœ‰å‘è·¯å¾„ã€‚

**å®šä¹‰ 5.4** (å¯è¾¾æ€§çŸ©é˜µ - Reachability Matrix)
æœ‰å‘å›¾ $D = (V, A)$ çš„**å¯è¾¾æ€§çŸ©é˜µ** $R = [r_{ij}]$ æ˜¯ï¼š
$$
r_{ij} = \begin{cases}
1 & \text{å¦‚æœ } v_j \text{ ä» } v_i \text{ å¯è¾¾} \\
0 & \text{å¦åˆ™}
\end{cases}
$$

**ç®—æ³• 5.1** (Kosarajuç®—æ³• - å¼ºè¿é€šåˆ†æ”¯)

```python
def kosaraju_scc(G):
    # ç¬¬ä¸€éDFSï¼šè®¡ç®—å®Œæˆæ—¶é—´
    visited = set()
    finish_order = []

    def dfs1(v):
        visited.add(v)
        for u in G.adj[v]:
            if u not in visited:
                dfs1(u)
        finish_order.append(v)

    for v in G.V:
        if v not in visited:
            dfs1(v)

    # ç¬¬äºŒéDFSï¼šåœ¨è½¬ç½®å›¾ä¸Šæ‰¾å¼ºè¿é€šåˆ†æ”¯
    G_T = transpose(G)
    visited = set()
    sccs = []

    def dfs2(v, component):
        visited.add(v)
        component.append(v)
        for u in G_T.adj[v]:
            if u not in visited:
                dfs2(u, component)

    for v in reversed(finish_order):
        if v not in visited:
            component = []
            dfs2(v, component)
            sccs.append(component)

    return sccs
```

**ç®—æ³• 5.2** (Tarjanç®—æ³• - å¼ºè¿é€šåˆ†æ”¯)

```python
def tarjan_scc(G):
    index = 0
    indices = {}
    lowlinks = {}
    on_stack = set()
    stack = []
    sccs = []

    def strongconnect(v):
        nonlocal index
        indices[v] = index
        lowlinks[v] = index
        index += 1
        stack.append(v)
        on_stack.add(v)

        for w in G.adj[v]:
            if w not in indices:
                strongconnect(w)
                lowlinks[v] = min(lowlinks[v], lowlinks[w])
            elif w in on_stack:
                lowlinks[v] = min(lowlinks[v], indices[w])

        if lowlinks[v] == indices[v]:
            scc = []
            while True:
                w = stack.pop()
                on_stack.remove(w)
                scc.append(w)
                if w == v:
                    break
            sccs.append(scc)

    for v in G.V:
        if v not in indices:
            strongconnect(v)

    return sccs
```

## 6. æ ‘ä¸ç”Ÿæˆæ ‘

### 6.1 æ ‘çš„æ€§è´¨

**å®šä¹‰ 6.1** (æ ‘ - Tree)
**æ ‘**æ˜¯è¿é€šæ— åœˆå›¾ã€‚

**å®šç† 6.1** (æ ‘çš„åŸºæœ¬æ€§è´¨)
å›¾ $T$ æ˜¯æ ‘ï¼Œå½“ä¸”ä»…å½“ä»¥ä¸‹æ¡ä»¶ä¹‹ä¸€æˆç«‹ï¼š

1. $T$ æ˜¯è¿é€šæ— åœˆå›¾
2. $T$ æ˜¯è¿é€šå›¾ä¸” $|E| = |V| - 1$
3. $T$ æ˜¯æ— åœˆå›¾ä¸” $|E| = |V| - 1$
4. $T$ ä¸­ä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´æœ‰å”¯ä¸€è·¯å¾„

**è¯æ˜**ï¼š
é€šè¿‡å½’çº³æ³•å¯ä»¥è¯æ˜è¿™äº›æ¡ä»¶çš„ç­‰ä»·æ€§ã€‚

**æ¨è®º 6.1** (æ ‘çš„è¾¹æ•°)
$n$ é˜¶æ ‘æœ‰ $n-1$ æ¡è¾¹ã€‚

**æ¨è®º 6.2** (æ ‘çš„å¶å­)
ä»»ä½•éå¹³å‡¡æ ‘è‡³å°‘æœ‰ä¸¤ä¸ªå¶å­é¡¶ç‚¹ã€‚

### 6.2 ç”Ÿæˆæ ‘

**å®šä¹‰ 6.2** (ç”Ÿæˆæ ‘ - Spanning Tree)
å›¾ $G$ çš„**ç”Ÿæˆæ ‘**æ˜¯ $G$ çš„ç”Ÿæˆå­å›¾ä¸”æ˜¯æ ‘ã€‚

**å®šç† 6.2** (ç”Ÿæˆæ ‘å­˜åœ¨æ€§)
å›¾ $G$ æœ‰ç”Ÿæˆæ ‘ï¼Œå½“ä¸”ä»…å½“ $G$ æ˜¯è¿é€šå›¾ã€‚

**è¯æ˜**ï¼š
å¦‚æœ $G$ è¿é€šï¼Œå¯ä»¥é€šè¿‡åˆ é™¤åœˆä¸­çš„è¾¹å¾—åˆ°ç”Ÿæˆæ ‘ã€‚å¦‚æœ $G$ ä¸è¿é€šï¼Œåˆ™æ²¡æœ‰ç”Ÿæˆæ ‘ã€‚

**ç®—æ³• 6.1** (DFSç”Ÿæˆæ ‘)

```python
def dfs_spanning_tree(G, start):
    tree_edges = []
    visited = set()

    def dfs(v):
        visited.add(v)
        for u in G.adj[v]:
            if u not in visited:
                tree_edges.append((v, u))
                dfs(u)

    dfs(start)
    return tree_edges
```

### 6.3 æœ€å°ç”Ÿæˆæ ‘

**å®šä¹‰ 6.3** (æœ€å°ç”Ÿæˆæ ‘ - Minimum Spanning Tree)
å¸¦æƒå›¾ $G$ çš„**æœ€å°ç”Ÿæˆæ ‘**æ˜¯æƒé‡æœ€å°çš„ç”Ÿæˆæ ‘ã€‚

**å®šç† 6.3** (æœ€å°ç”Ÿæˆæ ‘å”¯ä¸€æ€§)
å¦‚æœå›¾ $G$ çš„æ‰€æœ‰è¾¹æƒé‡éƒ½ä¸ç›¸åŒï¼Œåˆ™æœ€å°ç”Ÿæˆæ ‘å”¯ä¸€ã€‚

**ç®—æ³• 6.2** (Kruskalç®—æ³•)

```python
def kruskal_mst(G):
    # æŒ‰æƒé‡æ’åºè¾¹
    edges = sorted(G.E, key=lambda e: G.weight[e])

    # å¹¶æŸ¥é›†
    parent = {v: v for v in G.V}

    def find(v):
        if parent[v] != v:
            parent[v] = find(parent[v])
        return parent[v]

    def union(u, v):
        parent[find(u)] = find(v)

    mst_edges = []
    for (u, v) in edges:
        if find(u) != find(v):
            mst_edges.append((u, v))
            union(u, v)

    return mst_edges
```

**ç®—æ³• 6.3** (Primç®—æ³•)

```python
def prim_mst(G, start):
    import heapq

    mst_edges = []
    visited = {start}
    edges = [(G.weight[(start, v)], start, v) for v in G.adj[start]]
    heapq.heapify(edges)

    while edges and len(visited) < len(G.V):
        weight, u, v = heapq.heappop(edges)
        if v not in visited:
            visited.add(v)
            mst_edges.append((u, v))

            for w in G.adj[v]:
                if w not in visited:
                    heapq.heappush(edges, (G.weight[(v, w)], v, w))

    return mst_edges
```

## 7. ç½‘ç»œæµ

### 7.1 æµç½‘ç»œ

**å®šä¹‰ 7.1** (æµç½‘ç»œ - Flow Network)
**æµç½‘ç»œ**æ˜¯ä¸€ä¸ªå››å…ƒç»„ $N = (G, s, t, c)$ï¼Œå…¶ä¸­ï¼š

- $G = (V, E)$ æ˜¯æœ‰å‘å›¾
- $s, t \in V$ åˆ†åˆ«æ˜¯æºç‚¹å’Œæ±‡ç‚¹
- $c: E \to \mathbb{R}^+$ æ˜¯å®¹é‡å‡½æ•°

**å®šä¹‰ 7.2** (æµ - Flow)
æµç½‘ç»œ $N$ ä¸­çš„**æµ**æ˜¯å‡½æ•° $f: E \to \mathbb{R}^+$ï¼Œæ»¡è¶³ï¼š

1. å®¹é‡çº¦æŸï¼š$0 \leq f(e) \leq c(e)$ å¯¹äºæ‰€æœ‰ $e \in E$
2. æµé‡å®ˆæ’ï¼š$\sum_{e \in \delta^+(v)} f(e) = \sum_{e \in \delta^-(v)} f(e)$ å¯¹äºæ‰€æœ‰ $v \in V - \{s, t\}$

å…¶ä¸­ $\delta^+(v)$ å’Œ $\delta^-(v)$ åˆ†åˆ«æ˜¯ç¦»å¼€å’Œè¿›å…¥é¡¶ç‚¹ $v$ çš„è¾¹é›†ã€‚

**å®šä¹‰ 7.3** (æµå€¼ - Flow Value)
æµ $f$ çš„**å€¼**æ˜¯ï¼š
$$|f| = \sum_{e \in \delta^+(s)} f(e) - \sum_{e \in \delta^-(s)} f(e)$$

### 7.2 æœ€å¤§æµæœ€å°å‰²å®šç†

**å®šä¹‰ 7.4** (å‰² - Cut)
æµç½‘ç»œ $N$ ä¸­çš„**å‰²**æ˜¯é¡¶ç‚¹é›† $S \subseteq V$ï¼Œå…¶ä¸­ $s \in S$ ä¸” $t \notin S$ã€‚

**å®šä¹‰ 7.5** (å‰²çš„å®¹é‡ - Cut Capacity)
å‰² $S$ çš„**å®¹é‡**æ˜¯ï¼š
$$c(S) = \sum_{e \in \delta^+(S)} c(e)$$

**å®šç† 7.1** (æœ€å¤§æµæœ€å°å‰²å®šç† - Max-Flow Min-Cut Theorem)
æµç½‘ç»œä¸­çš„æœ€å¤§æµå€¼ç­‰äºæœ€å°å‰²å®¹é‡ã€‚

**è¯æ˜**ï¼š
é€šè¿‡Ford-Fulkersonç®—æ³•å’Œå¢å¹¿è·¯å¾„ç†è®ºè¯æ˜ã€‚

**ç®—æ³• 7.1** (Ford-Fulkersonç®—æ³•)

```python
def ford_fulkerson(G, s, t):
    # åˆå§‹åŒ–æµ
    flow = {e: 0 for e in G.E}
    residual = {e: G.capacity[e] for e in G.E}

    def find_augmenting_path():
        # BFSæ‰¾å¢å¹¿è·¯å¾„
        parent = {s: None}
        queue = [s]

        while queue:
            u = queue.pop(0)
            for v in G.adj[u]:
                if v not in parent and residual[(u, v)] > 0:
                    parent[v] = u
                    queue.append(v)
                    if v == t:
                        break

        if t not in parent:
            return None

        # é‡å»ºè·¯å¾„
        path = []
        v = t
        while v is not None:
            path.append(v)
            v = parent[v]
        return path[::-1]

    # ä¸»å¾ªç¯
    while True:
        path = find_augmenting_path()
        if path is None:
            break

        # è®¡ç®—ç“¶é¢ˆå®¹é‡
        bottleneck = float('inf')
        for i in range(len(path) - 1):
            u, v = path[i], path[i + 1]
            bottleneck = min(bottleneck, residual[(u, v)])

        # æ›´æ–°æµå’Œæ®‹é‡ç½‘ç»œ
        for i in range(len(path) - 1):
            u, v = path[i], path[i + 1]
            flow[(u, v)] += bottleneck
            residual[(u, v)] -= bottleneck
            residual[(v, u)] += bottleneck

    return flow
```

## 8. è¿é€šæ€§ç®—æ³•

### 8.1 è¿é€šæ€§æ£€æµ‹

**ç®—æ³• 8.1** (è¿é€šæ€§æ£€æµ‹)

```python
def is_connected(G):
    if not G.V:
        return True

    start = next(iter(G.V))
    visited = dfs_visit(G, start)
    return len(visited) == len(G.V)

def dfs_visit(G, start):
    visited = set()
    stack = [start]

    while stack:
        v = stack.pop()
        if v not in visited:
            visited.add(v)
            for u in G.adj[v]:
                if u not in visited:
                    stack.append(u)

    return visited
```

### 8.2 å‰²ç‚¹æ£€æµ‹

**ç®—æ³• 8.2** (Tarjanå‰²ç‚¹ç®—æ³•)

```python
def find_articulation_points(G):
    index = 0
    indices = {}
    lowlinks = {}
    articulation_points = set()

    def dfs(v, parent):
        nonlocal index
        indices[v] = index
        lowlinks[v] = index
        index += 1

        children = 0
        for u in G.adj[v]:
            if u not in indices:
                children += 1
                dfs(u, v)
                lowlinks[v] = min(lowlinks[v], lowlinks[u])

                # æ ¹èŠ‚ç‚¹æ¡ä»¶
                if parent is None and children > 1:
                    articulation_points.add(v)
                # éæ ¹èŠ‚ç‚¹æ¡ä»¶
                elif parent is not None and lowlinks[u] >= indices[v]:
                    articulation_points.add(v)
            elif u != parent:
                lowlinks[v] = min(lowlinks[v], indices[u])

    for v in G.V:
        if v not in indices:
            dfs(v, None)

    return articulation_points
```

## å¤šæ¨¡æ€è¡¨è¾¾ä¸å¯è§†åŒ–

### 8.3 è¿é€šæ€§å¯è§†åŒ–

**Graphvizç¤ºä¾‹**ï¼š

```dot
graph G {
    subgraph cluster_0 {
        A -- B -- C;
        B -- D;
    }
    subgraph cluster_1 {
        E -- F -- G;
    }
    C -- E;
}
```

**NetworkXç¤ºä¾‹**ï¼š

```python
import networkx as nx
import matplotlib.pyplot as plt

G = nx.Graph([(0,1), (1,2), (2,0), (3,4), (4,5), (2,3)])
components = list(nx.connected_components(G))

plt.figure(figsize=(10, 6))
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_color='lightblue')
plt.title(f'Graph with {len(components)} connected components')
plt.show()
```

### 8.4 ç®—æ³•æµç¨‹å›¾

**Mermaidç¤ºä¾‹**ï¼š

```mermaid
graph TD;
    Start([å¼€å§‹]) --> Input[è¾“å…¥å›¾G]
    Input --> Check{æ£€æŸ¥è¿é€šæ€§}
    Check -->|è¿é€š| FindMST[æ‰¾æœ€å°ç”Ÿæˆæ ‘]
    Check -->|ä¸è¿é€š| FindComponents[æ‰¾è¿é€šåˆ†æ”¯]
    FindMST --> Output[è¾“å‡ºMST]
    FindComponents --> Output2[è¾“å‡ºè¿é€šåˆ†æ”¯]
    Output --> End([ç»“æŸ])
    Output2 --> End
```

### 8.5 è‡ªåŠ¨åŒ–è„šæœ¬å»ºè®®

**è„šæœ¬åŠŸèƒ½**ï¼š

- `scripts/connectivity_analysis.py`ï¼šåˆ†æå›¾çš„è¿é€šæ€§ã€å‰²ç‚¹ã€å‰²è¾¹
- `scripts/mst_algorithms.py`ï¼šå®ç°Kruskalã€Primç­‰MSTç®—æ³•
- `scripts/flow_network.py`ï¼šå®ç°æœ€å¤§æµç®—æ³•
- `scripts/strongly_connected.py`ï¼šå®ç°å¼ºè¿é€šåˆ†æ”¯ç®—æ³•

---

*æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº†å›¾è®ºä¸­çš„è¿é€šæ€§æ¦‚å¿µï¼Œå¯¹æ ‡å›½é™…æ ‡å‡†ï¼Œä¸ºç½‘ç»œé€šä¿¡ç†è®ºæä¾›äº†é‡è¦çš„æ•°å­¦åŸºç¡€ã€‚*
