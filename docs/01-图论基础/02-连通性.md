# å›¾è®ºåŸºç¡€ - è¿é€šæ€§ / Graph Theory Fundamentals - Connectivity

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä»‹ç»å›¾è®ºä¸­çš„è¿é€šæ€§ç†è®ºï¼ŒåŒ…æ‹¬è·¯å¾„ã€è¿é€šæ€§ã€å‰²é›†ã€Mengerå®šç†ã€å¼ºè¿é€šæ€§ã€æ ‘ä¸ç”Ÿæˆæ ‘ã€ç½‘ç»œæµç­‰æ ¸å¿ƒæ¦‚å¿µã€‚æœ¬æ–‡æ¡£å¯¹æ ‡å›½é™…é¡¶çº§æ ‡å‡†ï¼ˆMITã€Stanfordã€CMUã€Berkeleyï¼‰å’Œæœ€æ–°å›¾è®ºç ”ç©¶è¿›å±•ï¼ˆ2024-2025ï¼‰ï¼Œæä¾›ä¸¥æ ¼ã€å®Œæ•´ã€å›½é™…åŒ–çš„è¿é€šæ€§ç†è®ºä½“ç³»ã€‚

**ç›¸å…³æ–‡æ¡£**ï¼š

- ğŸ“– [01-åŸºæœ¬æ¦‚å¿µ.md](01-åŸºæœ¬æ¦‚å¿µ.md) - å›¾çš„åŸºæœ¬å®šä¹‰å’ŒåŸºæœ¬å…³ç³»ï¼ˆé‚»æ¥ã€è·¯å¾„ã€è¿é€šæ€§ï¼‰
- ğŸ“– [03-å›¾çš„ç®—æ³•.md](03-å›¾çš„ç®—æ³•.md) - å›¾éå†ç®—æ³•å’Œæœ€çŸ­è·¯å¾„ç®—æ³•
  - **å…³ç³»**: æœ¬æ–‡æ¡£çš„è¿é€šæ€§ç†è®ºç”±ç®—æ³•æ–‡æ¡£ä¸­çš„ç®—æ³•å®ç°ï¼Œç‰¹åˆ«æ˜¯DFS/BFSç”¨äºè¿é€šæ€§æ£€æµ‹ï¼ŒTarjanç®—æ³•ç”¨äºå¼ºè¿é€šåˆ†é‡
  - **å‚è§**: [è¿é€šæ€§æ£€æµ‹](#81-è¿é€šæ€§æ£€æµ‹)ã€[Tarjanç®—æ³•å®ç°](../03-å›¾çš„ç®—æ³•.md#361-tarjanç®—æ³•)
- ğŸ“– [04-è°±å›¾ç†è®º.md](04-è°±å›¾ç†è®º.md) - è°±å›¾ç†è®ºå’Œè¿é€šæ€§åˆ†æ
- ğŸ“– [05-é«˜çº§ç†è®º/02-å›¾çš„æµç†è®º/](05-é«˜çº§ç†è®º/02-å›¾çš„æµç†è®º/) - å›¾çš„æµç†è®º
  - **å…³ç³»**: è¿é€šæ€§æ˜¯æµç†è®ºçš„åŸºç¡€ï¼Œæµç½‘ç»œéœ€è¦æºç‚¹å’Œæ±‡ç‚¹ä¹‹é—´çš„è¿é€šæ€§
  - **å‚è§**: [ç½‘ç»œæµ](#7-ç½‘ç»œæµ)ã€[æœ€å¤§æµæœ€å°å‰²å®šç†](#72-æœ€å¤§æµæœ€å°å‰²å®šç†)
- ğŸ§  [æ€ç»´è¡¨å¾å·¥å…·-å›¾è®ºåŸºç¡€.md](æ€ç»´è¡¨å¾å·¥å…·-å›¾è®ºåŸºç¡€.md) - å›¾è®ºåŸºç¡€æ€ç»´è¡¨å¾å·¥å…·ï¼ˆåŒ…å«è¿é€šæ€§ç›¸å…³æ¦‚å¿µï¼‰
- ğŸ“š [99-ç†è®ºåº”ç”¨ä¸æ¡ˆä¾‹.md](99-ç†è®ºåº”ç”¨ä¸æ¡ˆä¾‹.md) - è¿é€šæ€§ç†è®ºåº”ç”¨å’Œå·¥ç¨‹æ¡ˆä¾‹

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆï¼ˆåŒ…å«å®Œæ•´ç®—æ³•å®ç°å’Œåº”ç”¨æ¡ˆä¾‹ï¼‰
**æ–‡æ¡£ç‰ˆæœ¬**: v2.0ï¼ˆæ·±åº¦æ”¹è¿›ç‰ˆï¼‰
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ

**å†å²èƒŒæ™¯ / Historical Background**:

- **1736å¹´**: æ¬§æ‹‰è§£å†³æŸ¯å°¼æ–¯å ¡ä¸ƒæ¡¥é—®é¢˜ï¼Œå¼€åˆ›è¿é€šæ€§ç ”ç©¶
- **1927å¹´**: Mengeræå‡ºMengerå®šç†
- **1950å¹´ä»£**: ç½‘ç»œæµç†è®ºå‘å±•
- **1970å¹´ä»£**: å¼ºè¿é€šæ€§ç®—æ³•ç ”ç©¶
- **1990å¹´ä»£**: åŠ¨æ€è¿é€šæ€§ç®—æ³•
- **2000å¹´ä»£**: å¤§è§„æ¨¡ç½‘ç»œè¿é€šæ€§åˆ†æ
- **2010å¹´ä»£**: åˆ†å¸ƒå¼è¿é€šæ€§ç®—æ³•
- **2024-2025å¹´**: é‡å­è¿é€šæ€§ç®—æ³•ã€AIé©±åŠ¨çš„è¿é€šæ€§åˆ†æã€å®æ—¶è¿é€šæ€§ç›‘æµ‹

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [å›¾è®ºåŸºç¡€ - è¿é€šæ€§ / Graph Theory Fundamentals - Connectivity](#å›¾è®ºåŸºç¡€---è¿é€šæ€§--graph-theory-fundamentals---connectivity)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [1. è·¯å¾„ä¸è¿é€šæ€§](#1-è·¯å¾„ä¸è¿é€šæ€§)
    - [1.1 è·¯å¾„å®šä¹‰](#11-è·¯å¾„å®šä¹‰)
    - [1.2 è¿é€šæ€§å®šä¹‰](#12-è¿é€šæ€§å®šä¹‰)
  - [2. è·ç¦»ä¸ç›´å¾„](#2-è·ç¦»ä¸ç›´å¾„)
    - [2.1 è·ç¦»å®šä¹‰](#21-è·ç¦»å®šä¹‰)
    - [2.2 ä¸­å¿ƒä¸ç¦»å¿ƒç‡](#22-ä¸­å¿ƒä¸ç¦»å¿ƒç‡)
  - [3. å‰²é›†ä¸è¿é€šåº¦](#3-å‰²é›†ä¸è¿é€šåº¦)
    - [3.1 å‰²é›†å®šä¹‰](#31-å‰²é›†å®šä¹‰)
    - [3.2 è¿é€šåº¦](#32-è¿é€šåº¦)
  - [4. Mengerå®šç†](#4-mengerå®šç†)
    - [4.1 é¡¶ç‚¹ç‰ˆæœ¬](#41-é¡¶ç‚¹ç‰ˆæœ¬)
    - [4.2 è¾¹ç‰ˆæœ¬](#42-è¾¹ç‰ˆæœ¬)
  - [5. å¼ºè¿é€šæ€§](#5-å¼ºè¿é€šæ€§)
    - [5.1 æœ‰å‘å›¾çš„è¿é€šæ€§](#51-æœ‰å‘å›¾çš„è¿é€šæ€§)
    - [5.2 å¯è¾¾æ€§](#52-å¯è¾¾æ€§)
    - [6.3 æœ€å°ç”Ÿæˆæ ‘](#63-æœ€å°ç”Ÿæˆæ ‘)
  - [7. ç½‘ç»œæµ](#7-ç½‘ç»œæµ)
    - [7.1 æµç½‘ç»œ](#71-æµç½‘ç»œ)
    - [7.2 æœ€å¤§æµæœ€å°å‰²å®šç†](#72-æœ€å¤§æµæœ€å°å‰²å®šç†)
  - [8. è¿é€šæ€§ç®—æ³•](#8-è¿é€šæ€§ç®—æ³•)
    - [8.0 è¿é€šæ€§ç®—æ³•å¯¹æ¯”çŸ©é˜µ / Connectivity Algorithms Comparison Matrix](#80-è¿é€šæ€§ç®—æ³•å¯¹æ¯”çŸ©é˜µ--connectivity-algorithms-comparison-matrix)
    - [8.1 è¿é€šæ€§æ£€æµ‹](#81-è¿é€šæ€§æ£€æµ‹)
    - [8.2 å‰²ç‚¹æ£€æµ‹](#82-å‰²ç‚¹æ£€æµ‹)
  - [å¤šæ¨¡æ€è¡¨è¾¾ä¸å¯è§†åŒ–](#å¤šæ¨¡æ€è¡¨è¾¾ä¸å¯è§†åŒ–)
    - [8.3 è¿é€šæ€§å¯è§†åŒ–](#83-è¿é€šæ€§å¯è§†åŒ–)
    - [8.4 ç®—æ³•æµç¨‹å›¾](#84-ç®—æ³•æµç¨‹å›¾)
    - [8.5 è‡ªåŠ¨åŒ–è„šæœ¬å»ºè®®](#85-è‡ªåŠ¨åŒ–è„šæœ¬å»ºè®®)
  - [ğŸ’¼ **9. å®é™…å·¥ç¨‹åº”ç”¨æ¡ˆä¾‹ / Real-World Engineering Application Cases**](#-9-å®é™…å·¥ç¨‹åº”ç”¨æ¡ˆä¾‹--real-world-engineering-application-cases)
    - [9.1 ç½‘ç»œè¿é€šæ€§åˆ†æåº”ç”¨ / Network Connectivity Analysis Applications](#91-ç½‘ç»œè¿é€šæ€§åˆ†æåº”ç”¨--network-connectivity-analysis-applications)
      - [9.1.1 äº’è”ç½‘è·¯ç”±ç³»ç»Ÿè¿é€šæ€§åˆ†æ](#911-äº’è”ç½‘è·¯ç”±ç³»ç»Ÿè¿é€šæ€§åˆ†æ)
      - [9.1.2 ç¤¾äº¤ç½‘ç»œè¿é€šæ€§åˆ†æ](#912-ç¤¾äº¤ç½‘ç»œè¿é€šæ€§åˆ†æ)
    - [9.2 æœ€å°ç”Ÿæˆæ ‘åº”ç”¨ / Minimum Spanning Tree Applications](#92-æœ€å°ç”Ÿæˆæ ‘åº”ç”¨--minimum-spanning-tree-applications)
      - [9.2.1 é€šä¿¡ç½‘ç»œè®¾è®¡](#921-é€šä¿¡ç½‘ç»œè®¾è®¡)
      - [9.2.2 ç”µåŠ›ç½‘ç»œè§„åˆ’](#922-ç”µåŠ›ç½‘ç»œè§„åˆ’)
    - [9.3 ç½‘ç»œæµåº”ç”¨ / Network Flow Applications](#93-ç½‘ç»œæµåº”ç”¨--network-flow-applications)
      - [9.3.1 äº¤é€šç½‘ç»œæµé‡ä¼˜åŒ–](#931-äº¤é€šç½‘ç»œæµé‡ä¼˜åŒ–)
      - [9.3.2 æ•°æ®ç½‘ç»œå¸¦å®½åˆ†é…](#932-æ•°æ®ç½‘ç»œå¸¦å®½åˆ†é…)
    - [9.4 è¿é€šæ€§å·¥å…·ä¸åº”ç”¨ / Connectivity Tools and Applications](#94-è¿é€šæ€§å·¥å…·ä¸åº”ç”¨--connectivity-tools-and-applications)
      - [9.4.1 ä¸»æµè¿é€šæ€§åˆ†æå·¥å…·](#941-ä¸»æµè¿é€šæ€§åˆ†æå·¥å…·)
      - [9.4.2 å®é™…åº”ç”¨æ¡ˆä¾‹](#942-å®é™…åº”ç”¨æ¡ˆä¾‹)
  - [ğŸš€ **10. æœ€æ–°ç ”ç©¶è¿›å±•ï¼ˆ2024-2025ï¼‰/ Latest Research Progress (2024-2025)**](#-10-æœ€æ–°ç ”ç©¶è¿›å±•2024-2025-latest-research-progress-2024-2025)
    - [10.1 é‡å­è¿é€šæ€§ç®—æ³•](#101-é‡å­è¿é€šæ€§ç®—æ³•)
      - [é‡å­è®¡ç®—åœ¨è¿é€šæ€§åˆ†æä¸­çš„åº”ç”¨](#é‡å­è®¡ç®—åœ¨è¿é€šæ€§åˆ†æä¸­çš„åº”ç”¨)
    - [10.2 AIé©±åŠ¨çš„è¿é€šæ€§åˆ†æ](#102-aié©±åŠ¨çš„è¿é€šæ€§åˆ†æ)
      - [æœºå™¨å­¦ä¹ åœ¨è¿é€šæ€§é¢„æµ‹ä¸­çš„åº”ç”¨](#æœºå™¨å­¦ä¹ åœ¨è¿é€šæ€§é¢„æµ‹ä¸­çš„åº”ç”¨)
    - [10.3 å®æ—¶è¿é€šæ€§ç›‘æµ‹](#103-å®æ—¶è¿é€šæ€§ç›‘æµ‹)
      - [åŠ¨æ€ç½‘ç»œçš„å®æ—¶è¿é€šæ€§åˆ†æ](#åŠ¨æ€ç½‘ç»œçš„å®æ—¶è¿é€šæ€§åˆ†æ)
  - [ğŸ“ **11. æ€»ç»“ / Summary**](#-11-æ€»ç»“--summary)
  - [ğŸ“š **12. å‚è€ƒæ–‡çŒ® / References**](#-12-å‚è€ƒæ–‡çŒ®--references)
    - [12.1 ç»å…¸æ–‡çŒ® / Classic Literature](#121-ç»å…¸æ–‡çŒ®--classic-literature)
    - [12.2 æœ€æ–°ç ”ç©¶è®ºæ–‡ / Latest Research Papers (2024-2025)](#122-æœ€æ–°ç ”ç©¶è®ºæ–‡--latest-research-papers-2024-2025)
    - [12.3 åœ¨çº¿èµ„æº / Online Resources](#123-åœ¨çº¿èµ„æº--online-resources)

---

## 1. è·¯å¾„ä¸è¿é€šæ€§

### 1.1 è·¯å¾„å®šä¹‰

**å®šä¹‰ 1.1** (è·¯å¾„ - Path)
å›¾ $G = (V, E)$ ä¸­çš„**è·¯å¾„**æ˜¯é¡¶ç‚¹åºåˆ— $P = (v_0, v_1, \ldots, v_k)$ï¼Œå…¶ä¸­ï¼š

- $v_i \in V$ å¯¹äºæ‰€æœ‰ $i = 0, 1, \ldots, k$
- $(v_{i-1}, v_i) \in E$ å¯¹äºæ‰€æœ‰ $i = 1, 2, \ldots, k$

**å½¢å¼åŒ–è¯­ä¹‰**ï¼š

- é›†åˆè®ºè¯­ä¹‰ï¼šè·¯å¾„æ˜¯é¡¶ç‚¹åºåˆ—çš„æœ‰é™åºåˆ—
- èŒƒç•´è®ºè¯­ä¹‰ï¼šè·¯å¾„æ˜¯å›¾èŒƒç•´ä¸­çš„æ€å°„

**å®šä¹‰ 1.2** (è·¯å¾„é•¿åº¦ - Path Length)
è·¯å¾„ $P = (v_0, v_1, \ldots, v_k)$ çš„**é•¿åº¦**æ˜¯ $k$ï¼Œå³è·¯å¾„ä¸­çš„è¾¹æ•°ã€‚

**å®šä¹‰ 1.3** (ç®€å•è·¯å¾„ - Simple Path)
**ç®€å•è·¯å¾„**æ˜¯ä¸åŒ…å«é‡å¤é¡¶ç‚¹çš„è·¯å¾„ã€‚

**å®šä¹‰ 1.4** (é—­è·¯å¾„ - Closed Path)
**é—­è·¯å¾„**æ˜¯æ»¡è¶³ $v_0 = v_k$ çš„è·¯å¾„ã€‚

**å®šä¹‰ 1.5** (åœˆ - Cycle)
**åœˆ**æ˜¯é•¿åº¦è‡³å°‘ä¸º3çš„ç®€å•é—­è·¯å¾„ã€‚

### 1.2 è¿é€šæ€§å®šä¹‰

**å®šä¹‰ 1.6** (è¿é€šé¡¶ç‚¹ - Connected Vertices)
å›¾ $G = (V, E)$ ä¸­ï¼Œé¡¶ç‚¹ $u$ å’Œ $v$ æ˜¯**è¿é€šçš„**ï¼Œå¦‚æœå­˜åœ¨ä» $u$ åˆ° $v$ çš„è·¯å¾„ã€‚

**å®šä¹‰ 1.7** (è¿é€šå›¾ - Connected Graph)
å›¾ $G$ æ˜¯**è¿é€šå›¾**ï¼Œå¦‚æœå¯¹äºä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ $u, v \in V$ï¼Œéƒ½å­˜åœ¨ä» $u$ åˆ° $v$ çš„è·¯å¾„ã€‚

**å®šä¹‰ 1.8** (è¿é€šåˆ†æ”¯ - Connected Component)
å›¾ $G$ çš„**è¿é€šåˆ†æ”¯**æ˜¯ $G$ çš„æå¤§è¿é€šå­å›¾ã€‚

**å®šç† 1.1** (è¿é€šåˆ†æ”¯æ€§è´¨)
å›¾ $G$ çš„è¿é€šåˆ†æ”¯æ„æˆ $V$ çš„ä¸€ä¸ªåˆ’åˆ†ã€‚

**è¯æ˜**ï¼š
è¿é€šæ€§æ˜¯ä¸€ä¸ªç­‰ä»·å…³ç³»ï¼Œå› æ­¤è¿é€šåˆ†æ”¯æ˜¯ç­‰ä»·ç±»ï¼Œæ„æˆ $V$ çš„åˆ’åˆ†ã€‚

**ç®—æ³• 1.1** (è¿é€šåˆ†æ”¯ç®—æ³•)

```python
def find_connected_components(G):
    components = []
    visited = set()

    for vertex in G.V:
        if vertex not in visited:
            component = dfs_component(G, vertex, visited)
            components.append(component)

    return components

def dfs_component(G, start, visited):
    component = set()
    stack = [start]

    while stack:
        vertex = stack.pop()
        if vertex not in visited:
            visited.add(vertex)
            component.add(vertex)
            for neighbor in G.adj[vertex]:
                if neighbor not in visited:
                    stack.append(neighbor)

    return component
```

## 2. è·ç¦»ä¸ç›´å¾„

### 2.1 è·ç¦»å®šä¹‰

**å®šä¹‰ 2.1** (è·ç¦» - Distance)
å›¾ $G = (V, E)$ ä¸­ï¼Œé¡¶ç‚¹ $u$ å’Œ $v$ ä¹‹é—´çš„**è·ç¦»** $d(u, v)$ æ˜¯ï¼š
$$d(u, v) = \min\{k : \text{å­˜åœ¨é•¿åº¦ä¸º } k \text{ çš„è·¯å¾„ä» } u \text{ åˆ° } v\}$$

å¦‚æœ $u$ å’Œ $v$ ä¸è¿é€šï¼Œåˆ™ $d(u, v) = \infty$ã€‚

**æ€§è´¨ 2.1** (è·ç¦»çš„åº¦é‡æ€§è´¨)ï¼š

1. $d(u, v) \geq 0$ ä¸” $d(u, v) = 0$ å½“ä¸”ä»…å½“ $u = v$
2. $d(u, v) = d(v, u)$ï¼ˆæ— å‘å›¾ï¼‰
3. $d(u, v) + d(v, w) \geq d(u, w)$ï¼ˆä¸‰è§’ä¸ç­‰å¼ï¼‰

**å®šä¹‰ 2.2** (å›¾çš„ç›´å¾„ - Diameter)
å›¾ $G$ çš„**ç›´å¾„**æ˜¯ï¼š
$$\text{diam}(G) = \max_{u, v \in V} d(u, v)$$

**å®šä¹‰ 2.3** (å›¾çš„åŠå¾„ - Radius)
å›¾ $G$ çš„**åŠå¾„**æ˜¯ï¼š
$$\text{rad}(G) = \min_{v \in V} \max_{u \in V} d(u, v)$$

### 2.2 ä¸­å¿ƒä¸ç¦»å¿ƒç‡

**å®šä¹‰ 2.4** (ç¦»å¿ƒç‡ - Eccentricity)
é¡¶ç‚¹ $v$ çš„**ç¦»å¿ƒç‡**æ˜¯ï¼š
$$e(v) = \max_{u \in V} d(u, v)$$

**å®šä¹‰ 2.5** (ä¸­å¿ƒ - Center)
å›¾ $G$ çš„**ä¸­å¿ƒ**æ˜¯ç¦»å¿ƒç‡æœ€å°çš„é¡¶ç‚¹é›†ï¼š
$$C(G) = \{v \in V : e(v) = \text{rad}(G)\}$$

**å®šç† 2.1** (ç›´å¾„ä¸åŠå¾„å…³ç³»)
å¯¹äºä»»æ„è¿é€šå›¾ $G$ï¼š
$$\text{rad}(G) \leq \text{diam}(G) \leq 2 \cdot \text{rad}(G)$$

**è¯æ˜**ï¼š
è®¾ $u, v$ æ˜¯ç›´å¾„ç«¯ç‚¹ï¼Œ$w$ æ˜¯ä¸­å¿ƒç‚¹ï¼Œåˆ™ï¼š
$$d(u, v) \leq d(u, w) + d(w, v) \leq 2 \cdot \text{rad}(G)$$

**ç®—æ³• 2.1** (Floyd-Warshallç®—æ³• - å…¨æºæœ€çŸ­è·¯)

```python
def floyd_warshall(G):
    n = len(G.V)
    dist = [[float('inf')] * n for _ in range(n)]

    # åˆå§‹åŒ–
    for i in range(n):
        dist[i][i] = 0
    for (u, v) in G.E:
        dist[u][v] = 1
        dist[v][u] = 1  # æ— å‘å›¾

    # Floyd-Warshall
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]

    return dist
```

## 3. å‰²é›†ä¸è¿é€šåº¦

### 3.1 å‰²é›†å®šä¹‰

**å®šä¹‰ 3.1** (é¡¶ç‚¹å‰² - Vertex Cut)
å›¾ $G = (V, E)$ çš„**é¡¶ç‚¹å‰²**æ˜¯é¡¶ç‚¹é›† $S \subseteq V$ï¼Œä½¿å¾— $G - S$ çš„è¿é€šåˆ†æ”¯æ•°å¤§äº $G$ çš„è¿é€šåˆ†æ”¯æ•°ã€‚

**å®šä¹‰ 3.2** (è¾¹å‰² - Edge Cut)
å›¾ $G = (V, E)$ çš„**è¾¹å‰²**æ˜¯è¾¹é›† $F \subseteq E$ï¼Œä½¿å¾— $G - F$ çš„è¿é€šåˆ†æ”¯æ•°å¤§äº $G$ çš„è¿é€šåˆ†æ”¯æ•°ã€‚

**å®šä¹‰ 3.3** (æœ€å°å‰² - Minimum Cut)
**æœ€å°é¡¶ç‚¹å‰²**ï¼ˆæˆ–**æœ€å°è¾¹å‰²**ï¼‰æ˜¯å¤§å°æœ€å°çš„é¡¶ç‚¹å‰²ï¼ˆæˆ–è¾¹å‰²ï¼‰ã€‚

### 3.2 è¿é€šåº¦

**å®šä¹‰ 3.4** (é¡¶ç‚¹è¿é€šåº¦ - Vertex Connectivity)
å›¾ $G$ çš„**é¡¶ç‚¹è¿é€šåº¦** $\kappa(G)$ æ˜¯ï¼š
$$\kappa(G) = \min\{|S| : S \text{ æ˜¯ } G \text{ çš„é¡¶ç‚¹å‰²}\}$$

å¦‚æœ $G$ æ˜¯å®Œå…¨å›¾ï¼Œåˆ™ $\kappa(G) = |V| - 1$ã€‚

**å®šä¹‰ 3.5** (è¾¹è¿é€šåº¦ - Edge Connectivity)
å›¾ $G$ çš„**è¾¹è¿é€šåº¦** $\lambda(G)$ æ˜¯ï¼š
$$\lambda(G) = \min\{|F| : F \text{ æ˜¯ } G \text{ çš„è¾¹å‰²}\}$$

**å®šç† 3.1** (è¿é€šåº¦ä¸ç­‰å¼ - Connectivity Inequality)
å¯¹äºä»»æ„å›¾ $G$ï¼š
$$\kappa(G) \leq \lambda(G) \leq \delta(G)$$

å…¶ä¸­ $\delta(G) = \min_{v \in V} d(v)$ æ˜¯å›¾çš„æœ€å°åº¦ã€‚

**è¯æ˜**ï¼š

1. $\lambda(G) \leq \delta(G)$ï¼šåˆ é™¤æŸä¸ªæœ€å°åº¦é¡¶ç‚¹çš„æ‰€æœ‰å…³è”è¾¹æ„æˆè¾¹å‰²
2. $\kappa(G) \leq \lambda(G)$ï¼šMengerå®šç†çš„ç›´æ¥æ¨è®º

**å®šç† 3.2** (Whitneyå®šç†)
å¯¹äºä»»æ„éå®Œå…¨å›¾ $G$ï¼š
$$\kappa(G) \leq \lambda(G) \leq \delta(G)$$

**è¯æ˜**ï¼š
é€šè¿‡æ„é€ æ€§è¯æ˜ï¼Œåˆ é™¤æœ€å°åº¦é¡¶ç‚¹çš„æ‰€æœ‰å…³è”è¾¹å¾—åˆ°è¾¹å‰²ã€‚

## 4. Mengerå®šç†

### 4.1 é¡¶ç‚¹ç‰ˆæœ¬

**å®šç† 4.1** (Mengerå®šç† - é¡¶ç‚¹ç‰ˆæœ¬ / Menger's Theorem - Vertex Version)
å›¾ $G$ ä¸­ï¼Œé¡¶ç‚¹ $u$ å’Œ $v$ ä¹‹é—´çš„é¡¶ç‚¹è¿é€šåº¦ç­‰äº $u$ åˆ° $v$ çš„ä¸ç›¸äº¤è·¯å¾„çš„æœ€å¤§æ•°é‡ã€‚

**å½¢å¼åŒ–è¡¨è¿°**ï¼š
è®¾ $u, v$ æ˜¯å›¾ $G$ ä¸­ä¸ç›¸é‚»çš„é¡¶ç‚¹ï¼Œåˆ™ï¼š
$$\kappa_G(u, v) = \max\{k : \text{å­˜åœ¨ } k \text{ æ¡ä» } u \text{ åˆ° } v \text{ çš„é¡¶ç‚¹ä¸ç›¸äº¤è·¯å¾„}\}$$

**å½¢å¼åŒ–è¯æ˜ / Formal Proof**ï¼š

**æ­¥éª¤ 1**ï¼šæ„é€ è¾…åŠ©å›¾
å°†å›¾ $G = (V, E)$ è½¬æ¢ä¸ºæœ‰å‘æµç½‘ç»œ $G' = (V', E')$ï¼š

- å¯¹äºæ¯ä¸ªé¡¶ç‚¹ $w \in V - \{u, v\}$ï¼Œåœ¨ $V'$ ä¸­æ·»åŠ ä¸¤ä¸ªé¡¶ç‚¹ $w_{in}$ å’Œ $w_{out}$
- æ·»åŠ è¾¹ $(w_{in}, w_{out})$ï¼Œå®¹é‡ä¸º 1
- å¯¹äºåŸå›¾ä¸­çš„æ¯æ¡è¾¹ $(x, y) \in E$ï¼š
  - å¦‚æœ $x, y \notin \{u, v\}$ï¼Œæ·»åŠ è¾¹ $(x_{out}, y_{in})$ï¼Œå®¹é‡ä¸º $\infty$
  - å¦‚æœ $x = u$ï¼Œæ·»åŠ è¾¹ $(u, y_{in})$ï¼Œå®¹é‡ä¸º $\infty$
  - å¦‚æœ $y = v$ï¼Œæ·»åŠ è¾¹ $(x_{out}, v)$ï¼Œå®¹é‡ä¸º $\infty$

**æ­¥éª¤ 2**ï¼šå»ºç«‹ç­‰ä»·å…³ç³»
åœ¨ $G'$ ä¸­ï¼Œä» $u$ åˆ° $v$ çš„æ•´æ•°æµå¯¹åº” $G$ ä¸­ä» $u$ åˆ° $v$ çš„é¡¶ç‚¹ä¸ç›¸äº¤è·¯å¾„ï¼š

- æ¯æ¡è·¯å¾„å¯¹åº”æµå€¼ä¸º 1 çš„æµ
- é¡¶ç‚¹ä¸ç›¸äº¤æ€§ç”±å®¹é‡ä¸º 1 çš„è¾¹ $(w_{in}, w_{out})$ ä¿è¯

**æ­¥éª¤ 3**ï¼šåº”ç”¨æœ€å¤§æµæœ€å°å‰²å®šç†
åœ¨ $G'$ ä¸­ï¼Œæœ€å¤§æµå€¼ç­‰äºæœ€å°å‰²å®¹é‡ã€‚

**æ­¥éª¤ 4**ï¼šè¯æ˜æœ€å°å‰²å¯¹åº”é¡¶ç‚¹å‰²
$G'$ ä¸­çš„æœ€å°å‰²å¯¹åº” $G$ ä¸­çš„æœ€å°é¡¶ç‚¹å‰²ï¼š

- å‰²ä¸­çš„è¾¹ $(w_{in}, w_{out})$ å¯¹åº”é¡¶ç‚¹ $w$ åœ¨é¡¶ç‚¹å‰²ä¸­
- å‰²çš„å®¹é‡ç­‰äºé¡¶ç‚¹å‰²çš„å¤§å°

**æ­¥éª¤ 5**ï¼šç»“è®º
ç”±æœ€å¤§æµæœ€å°å‰²å®šç†ï¼Œæœ€å¤§æµå€¼ï¼ˆå³æœ€å¤§é¡¶ç‚¹ä¸ç›¸äº¤è·¯å¾„æ•°ï¼‰ç­‰äºæœ€å°å‰²å®¹é‡ï¼ˆå³æœ€å°é¡¶ç‚¹å‰²å¤§å°ï¼‰ï¼Œå› æ­¤ï¼š
$$\kappa_G(u, v) = \max\{k : \text{å­˜åœ¨ } k \text{ æ¡ä» } u \text{ åˆ° } v \text{ çš„é¡¶ç‚¹ä¸ç›¸äº¤è·¯å¾„}\} \quad \square$$

**å†å²èƒŒæ™¯**ï¼š

- **1927å¹´**ï¼šKarl Menger é¦–æ¬¡æå‡ºå¹¶è¯æ˜
- **1956å¹´**ï¼šFord-Fulkerson é€šè¿‡æœ€å¤§æµæœ€å°å‰²å®šç†ç»™å‡ºæ–°è¯æ˜
- **ç°ä»£**ï¼šå¹¿æ³›åº”ç”¨äºç½‘ç»œå¯é æ€§åˆ†æå’Œå›¾è®ºç ”ç©¶

### 4.2 è¾¹ç‰ˆæœ¬

**å®šç† 4.2** (Mengerå®šç† - è¾¹ç‰ˆæœ¬ / Menger's Theorem - Edge Version)
å›¾ $G$ ä¸­ï¼Œé¡¶ç‚¹ $u$ å’Œ $v$ ä¹‹é—´çš„è¾¹è¿é€šåº¦ç­‰äº $u$ åˆ° $v$ çš„è¾¹ä¸ç›¸äº¤è·¯å¾„çš„æœ€å¤§æ•°é‡ã€‚

**å½¢å¼åŒ–è¡¨è¿°**ï¼š
$$\lambda_G(u, v) = \max\{k : \text{å­˜åœ¨ } k \text{ æ¡ä» } u \text{ åˆ° } v \text{ çš„è¾¹ä¸ç›¸äº¤è·¯å¾„}\}$$

**å½¢å¼åŒ–è¯æ˜ / Formal Proof**ï¼š

**æ­¥éª¤ 1**ï¼šæ„é€ æµç½‘ç»œ
å°†æ— å‘å›¾ $G = (V, E)$ è½¬æ¢ä¸ºæœ‰å‘æµç½‘ç»œ $G' = (V, E')$ï¼š

- å¯¹äºæ¯æ¡æ— å‘è¾¹ $\{u, v\} \in E$ï¼Œæ·»åŠ ä¸¤æ¡æœ‰å‘è¾¹ $(u, v)$ å’Œ $(v, u)$ï¼Œå®¹é‡å‡ä¸º 1

**æ­¥éª¤ 2**ï¼šå»ºç«‹ç­‰ä»·å…³ç³»
åœ¨ $G'$ ä¸­ï¼Œä» $s$ åˆ° $t$ çš„æ•´æ•°æµå¯¹åº” $G$ ä¸­ä» $s$ åˆ° $t$ çš„è¾¹ä¸ç›¸äº¤è·¯å¾„ï¼š

- æ¯æ¡è·¯å¾„å¯¹åº”æµå€¼ä¸º 1 çš„æµ
- è¾¹ä¸ç›¸äº¤æ€§ç”±æ¯æ¡è¾¹çš„å®¹é‡ä¸º 1 ä¿è¯

**æ­¥éª¤ 3**ï¼šåº”ç”¨æœ€å¤§æµæœ€å°å‰²å®šç†
åœ¨ $G'$ ä¸­ï¼Œæœ€å¤§æµå€¼ç­‰äºæœ€å°å‰²å®¹é‡ã€‚

**æ­¥éª¤ 4**ï¼šè¯æ˜æœ€å°å‰²å¯¹åº”è¾¹å‰²
$G'$ ä¸­çš„æœ€å°å‰²å¯¹åº” $G$ ä¸­çš„æœ€å°è¾¹å‰²ï¼š

- å‰²ä¸­çš„è¾¹å¯¹åº”è¾¹å‰²ä¸­çš„è¾¹
- å‰²çš„å®¹é‡ç­‰äºè¾¹å‰²çš„å¤§å°

**æ­¥éª¤ 5**ï¼šç»“è®º
ç”±æœ€å¤§æµæœ€å°å‰²å®šç†ï¼Œæœ€å¤§æµå€¼ï¼ˆå³æœ€å¤§è¾¹ä¸ç›¸äº¤è·¯å¾„æ•°ï¼‰ç­‰äºæœ€å°å‰²å®¹é‡ï¼ˆå³æœ€å°è¾¹å‰²å¤§å°ï¼‰ï¼Œå› æ­¤ï¼š
$$\lambda_G(u, v) = \max\{k : \text{å­˜åœ¨ } k \text{ æ¡ä» } u \text{ åˆ° } v \text{ çš„è¾¹ä¸ç›¸äº¤è·¯å¾„}\} \quad \square$$

**ç®—æ³• 4.1** (Mengerå®šç†åº”ç”¨ - æœ€å¤§æµç®—æ³•)

```python
def max_vertex_disjoint_paths(G, s, t):
    # æ„é€ è¾…åŠ©å›¾
    G_aux = construct_auxiliary_graph(G)

    # ä½¿ç”¨æœ€å¤§æµç®—æ³•
    max_flow = ford_fulkerson(G_aux, s, t)

    return max_flow

def construct_auxiliary_graph(G):
    # å°†æ¯ä¸ªé¡¶ç‚¹væ‹†åˆ†ä¸ºv_inå’Œv_out
    # æ·»åŠ å®¹é‡ä¸º1çš„è¾¹(v_in, v_out)
    # å°†åŸå›¾çš„è¾¹(u,v)æ›¿æ¢ä¸º(u_out, v_in)
    pass
```

## 5. å¼ºè¿é€šæ€§

### 5.1 æœ‰å‘å›¾çš„è¿é€šæ€§

**å®šä¹‰ 5.1** (å¼ºè¿é€š - Strongly Connected)
æœ‰å‘å›¾ $D = (V, A)$ æ˜¯**å¼ºè¿é€šçš„**ï¼Œå¦‚æœå¯¹äºä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ $u, v \in V$ï¼Œéƒ½å­˜åœ¨ä» $u$ åˆ° $v$ çš„æœ‰å‘è·¯å¾„ã€‚

**å®šä¹‰ 5.2** (å¼ºè¿é€šåˆ†æ”¯ - Strongly Connected Component)
æœ‰å‘å›¾ $D$ çš„**å¼ºè¿é€šåˆ†æ”¯**æ˜¯ $D$ çš„æå¤§å¼ºè¿é€šå­å›¾ã€‚

**å®šç† 5.1** (å¼ºè¿é€šåˆ†æ”¯æ€§è´¨)
æœ‰å‘å›¾çš„å¼ºè¿é€šåˆ†æ”¯æ„æˆé¡¶ç‚¹é›†çš„ä¸€ä¸ªåˆ’åˆ†ã€‚

### 5.2 å¯è¾¾æ€§

**å®šä¹‰ 5.3** (å¯è¾¾æ€§ - Reachability)
åœ¨æœ‰å‘å›¾ $D$ ä¸­ï¼Œé¡¶ç‚¹ $v$ ä»é¡¶ç‚¹ $u$ **å¯è¾¾**ï¼Œå¦‚æœå­˜åœ¨ä» $u$ åˆ° $v$ çš„æœ‰å‘è·¯å¾„ã€‚

**å®šä¹‰ 5.4** (å¯è¾¾æ€§çŸ©é˜µ - Reachability Matrix)
æœ‰å‘å›¾ $D = (V, A)$ çš„**å¯è¾¾æ€§çŸ©é˜µ** $R = [r_{ij}]$ æ˜¯ï¼š
$$
r_{ij} = \begin{cases}
1 & \text{å¦‚æœ } v_j \text{ ä» } v_i \text{ å¯è¾¾} \\
0 & \text{å¦åˆ™}
\end{cases}
$$

**ç®—æ³• 5.1** (Kosarajuç®—æ³• - å¼ºè¿é€šåˆ†æ”¯)

```python
def kosaraju_scc(G):
    # ç¬¬ä¸€éDFSï¼šè®¡ç®—å®Œæˆæ—¶é—´
    visited = set()
    finish_order = []

    def dfs1(v):
        visited.add(v)
        for u in G.adj[v]:
            if u not in visited:
                dfs1(u)
        finish_order.append(v)

    for v in G.V:
        if v not in visited:
            dfs1(v)

    # ç¬¬äºŒéDFSï¼šåœ¨è½¬ç½®å›¾ä¸Šæ‰¾å¼ºè¿é€šåˆ†æ”¯
    G_T = transpose(G)
    visited = set()
    sccs = []

    def dfs2(v, component):
        visited.add(v)
        component.append(v)
        for u in G_T.adj[v]:
            if u not in visited:
                dfs2(u, component)

    for v in reversed(finish_order):
        if v not in visited:
            component = []
            dfs2(v, component)
            sccs.append(component)

    return sccs
```

**ç®—æ³• 5.2** (Tarjanç®—æ³• - å¼ºè¿é€šåˆ†æ”¯)

Tarjanç®—æ³•ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œåœ¨ä¸€æ¬¡éå†ä¸­æ‰¾å‡ºæ‰€æœ‰å¼ºè¿é€šåˆ†æ”¯ã€‚ç®—æ³•åŸºäºå‘ç°æ—¶é—´å’Œæœ€å°å¯è¾¾æ—¶é—´ï¼ˆlowlinkï¼‰çš„æ¦‚å¿µã€‚

**ç®—æ³•æ€æƒ³**ï¼š

1. ä½¿ç”¨DFSéå†å›¾ï¼Œä¸ºæ¯ä¸ªé¡¶ç‚¹åˆ†é…å‘ç°æ—¶é—´ï¼ˆindexï¼‰
2. ç»´æŠ¤æ¯ä¸ªé¡¶ç‚¹çš„lowlinkï¼ˆæœ€å°å¯è¾¾æ—¶é—´ï¼‰
3. å½“å‘ç°é¡¶ç‚¹çš„lowlinkç­‰äºå…¶indexæ—¶ï¼Œå®ƒå°±æ˜¯ä¸€ä¸ªå¼ºè¿é€šåˆ†æ”¯çš„æ ¹
4. æ”¶é›†è¯¥åˆ†æ”¯çš„æ‰€æœ‰é¡¶ç‚¹

```python
def tarjan_scc(graph):
    """
    Tarjanç®—æ³•ï¼šæ‰¾å‡ºæœ‰å‘å›¾çš„æ‰€æœ‰å¼ºè¿é€šåˆ†æ”¯

    å‚æ•°:
        graph: æœ‰å‘å›¾çš„é‚»æ¥è¡¨è¡¨ç¤º {v: [neighbors]}

    è¿”å›:
        sccs: å¼ºè¿é€šåˆ†æ”¯åˆ—è¡¨ï¼Œæ¯ä¸ªåˆ†æ”¯æ˜¯ä¸€ä¸ªé¡¶ç‚¹é›†åˆçš„åˆ—è¡¨
    """
    index = 0
    indices = {}  # é¡¶ç‚¹çš„å‘ç°æ—¶é—´
    lowlinks = {}  # é¡¶ç‚¹çš„æœ€å°å¯è¾¾æ—¶é—´
    on_stack = set()  # åœ¨æ ˆä¸­çš„é¡¶ç‚¹
    stack = []  # DFSæ ˆ
    sccs = []  # å¼ºè¿é€šåˆ†æ”¯åˆ—è¡¨

    def strong_connect(v):
        nonlocal index
        # è®¾ç½®å‘ç°æ—¶é—´å’Œlowlink
        indices[v] = index
        lowlinks[v] = index
        index += 1
        stack.append(v)
        on_stack.add(v)

        # éå†æ‰€æœ‰é‚»å±…
        for w in graph.get(v, []):
            if w not in indices:
                # wæœªè¢«è®¿é—®ï¼Œé€’å½’
                strong_connect(w)
                lowlinks[v] = min(lowlinks[v], lowlinks[w])
            elif w in on_stack:
                # wåœ¨æ ˆä¸­ï¼Œè¯´æ˜åœ¨åŒä¸€ä¸ªå¼ºè¿é€šåˆ†æ”¯ä¸­
                lowlinks[v] = min(lowlinks[v], indices[w])

        # å¦‚æœvæ˜¯å¼ºè¿é€šåˆ†æ”¯çš„æ ¹
        if lowlinks[v] == indices[v]:
            # æ”¶é›†è¯¥å¼ºè¿é€šåˆ†æ”¯çš„æ‰€æœ‰é¡¶ç‚¹
            scc = []
            while True:
                w = stack.pop()
                on_stack.remove(w)
                scc.append(w)
                if w == v:
                    break
            sccs.append(scc)

    # å¯¹æ¯ä¸ªæœªè®¿é—®çš„é¡¶ç‚¹è°ƒç”¨strong_connect
    for v in graph:
        if v not in indices:
            strong_connect(v)

    return sccs

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    # ç¤ºä¾‹æœ‰å‘å›¾
    graph = {
        0: [1],
        1: [2],
        2: [0, 3],
        3: [4],
        4: [3]
    }

    sccs = tarjan_scc(graph)
    print("å¼ºè¿é€šåˆ†æ”¯:", sccs)
    # è¾“å‡º: [[0, 2, 1], [3, 4]]
```

**å¤æ‚åº¦åˆ†æ**ï¼š

- **æ—¶é—´å¤æ‚åº¦**ï¼š$O(|V| + |E|)$ - æ¯ä¸ªé¡¶ç‚¹å’Œæ¯æ¡è¾¹åªè®¿é—®ä¸€æ¬¡
- **ç©ºé—´å¤æ‚åº¦**ï¼š$O(|V|)$ - ç”¨äºå­˜å‚¨ç´¢å¼•ã€lowlinkå’Œæ ˆ

**å®é™…åº”ç”¨æ¡ˆä¾‹**ï¼š

1. **ç¼–è¯‘å™¨ä¸­çš„ä¾èµ–åˆ†æ**ï¼š
   - åˆ†ææ¨¡å—ä¹‹é—´çš„ä¾èµ–å…³ç³»
   - æ£€æµ‹å¾ªç¯ä¾èµ–
   - ç¡®å®šç¼–è¯‘é¡ºåº

2. **ç¤¾äº¤ç½‘ç»œåˆ†æ**ï¼š
   - è¯†åˆ«å¼ºè¿æ¥çš„ç¤¾åŒº
   - åˆ†æå½±å“åŠ›ä¼ æ’­è·¯å¾„

3. **ç½‘ç»œè·¯ç”±ç³»ç»Ÿ**ï¼š
   - åˆ†æè·¯ç”±å™¨çš„å¯è¾¾æ€§
   - æ£€æµ‹è·¯ç”±å¾ªç¯

**æƒå¨æ¥æºå¼•ç”¨**ï¼š

- **Wikipedia**: [Tarjan's strongly connected components algorithm](https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm)
- **åŸå§‹è®ºæ–‡**: Tarjan, R. E. (1972). Depth-first search and linear graph algorithms. *SIAM Journal on Computing*, 1(2), 146-160.
- **CLRS 4th Edition**: Chapter 22.5 - Strongly connected components
    sccs = []

    def strongconnect(v):
        nonlocal index
        indices[v] = index
        lowlinks[v] = index
        index += 1
        stack.append(v)
        on_stack.add(v)

        for w in G.adj[v]:
            if w not in indices:
                strongconnect(w)
                lowlinks[v] = min(lowlinks[v], lowlinks[w])
            elif w in on_stack:
                lowlinks[v] = min(lowlinks[v], indices[w])

        if lowlinks[v] == indices[v]:
            scc = []
            while True:
                w = stack.pop()
                on_stack.remove(w)
                scc.append(w)
                if w == v:
                    break
            sccs.append(scc)

    for v in G.V:
        if v not in indices:
            strongconnect(v)

    return sccs

```

## 6. æ ‘ä¸ç”Ÿæˆæ ‘

### 6.1 æ ‘çš„æ€§è´¨

**å®šä¹‰ 6.1** (æ ‘ - Tree)
**æ ‘**æ˜¯è¿é€šæ— åœˆå›¾ã€‚

**å®šç† 6.1** (æ ‘çš„åŸºæœ¬æ€§è´¨)
å›¾ $T$ æ˜¯æ ‘ï¼Œå½“ä¸”ä»…å½“ä»¥ä¸‹æ¡ä»¶ä¹‹ä¸€æˆç«‹ï¼š

1. $T$ æ˜¯è¿é€šæ— åœˆå›¾
2. $T$ æ˜¯è¿é€šå›¾ä¸” $|E| = |V| - 1$
3. $T$ æ˜¯æ— åœˆå›¾ä¸” $|E| = |V| - 1$
4. $T$ ä¸­ä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´æœ‰å”¯ä¸€è·¯å¾„

**è¯æ˜**ï¼š
é€šè¿‡å½’çº³æ³•å¯ä»¥è¯æ˜è¿™äº›æ¡ä»¶çš„ç­‰ä»·æ€§ã€‚

**æ¨è®º 6.1** (æ ‘çš„è¾¹æ•°)
$n$ é˜¶æ ‘æœ‰ $n-1$ æ¡è¾¹ã€‚

**æ¨è®º 6.2** (æ ‘çš„å¶å­)
ä»»ä½•éå¹³å‡¡æ ‘è‡³å°‘æœ‰ä¸¤ä¸ªå¶å­é¡¶ç‚¹ã€‚

### 6.2 ç”Ÿæˆæ ‘

**å®šä¹‰ 6.2** (ç”Ÿæˆæ ‘ - Spanning Tree)
å›¾ $G$ çš„**ç”Ÿæˆæ ‘**æ˜¯ $G$ çš„ç”Ÿæˆå­å›¾ä¸”æ˜¯æ ‘ã€‚

**å®šç† 6.2** (ç”Ÿæˆæ ‘å­˜åœ¨æ€§)
å›¾ $G$ æœ‰ç”Ÿæˆæ ‘ï¼Œå½“ä¸”ä»…å½“ $G$ æ˜¯è¿é€šå›¾ã€‚

**è¯æ˜**ï¼š
å¦‚æœ $G$ è¿é€šï¼Œå¯ä»¥é€šè¿‡åˆ é™¤åœˆä¸­çš„è¾¹å¾—åˆ°ç”Ÿæˆæ ‘ã€‚å¦‚æœ $G$ ä¸è¿é€šï¼Œåˆ™æ²¡æœ‰ç”Ÿæˆæ ‘ã€‚

**ç®—æ³• 6.1** (DFSç”Ÿæˆæ ‘)

```python
def dfs_spanning_tree(G, start):
    tree_edges = []
    visited = set()

    def dfs(v):
        visited.add(v)
        for u in G.adj[v]:
            if u not in visited:
                tree_edges.append((v, u))
                dfs(u)

    dfs(start)
    return tree_edges
```

### 6.3 æœ€å°ç”Ÿæˆæ ‘

**å®šä¹‰ 6.3** (æœ€å°ç”Ÿæˆæ ‘ - Minimum Spanning Tree)
å¸¦æƒå›¾ $G$ çš„**æœ€å°ç”Ÿæˆæ ‘**æ˜¯æƒé‡æœ€å°çš„ç”Ÿæˆæ ‘ã€‚

**å®šç† 6.3** (æœ€å°ç”Ÿæˆæ ‘å”¯ä¸€æ€§)
å¦‚æœå›¾ $G$ çš„æ‰€æœ‰è¾¹æƒé‡éƒ½ä¸ç›¸åŒï¼Œåˆ™æœ€å°ç”Ÿæˆæ ‘å”¯ä¸€ã€‚

**ç®—æ³• 6.2** (Kruskalç®—æ³•)

```python
def kruskal_mst(G):
    # æŒ‰æƒé‡æ’åºè¾¹
    edges = sorted(G.E, key=lambda e: G.weight[e])

    # å¹¶æŸ¥é›†
    parent = {v: v for v in G.V}

    def find(v):
        if parent[v] != v:
            parent[v] = find(parent[v])
        return parent[v]

    def union(u, v):
        parent[find(u)] = find(v)

    mst_edges = []
    for (u, v) in edges:
        if find(u) != find(v):
            mst_edges.append((u, v))
            union(u, v)

    return mst_edges
```

**ç®—æ³• 6.3** (Primç®—æ³•)

```python
def prim_mst(G, start):
    import heapq

    mst_edges = []
    visited = {start}
    edges = [(G.weight[(start, v)], start, v) for v in G.adj[start]]
    heapq.heapify(edges)

    while edges and len(visited) < len(G.V):
        weight, u, v = heapq.heappop(edges)
        if v not in visited:
            visited.add(v)
            mst_edges.append((u, v))

            for w in G.adj[v]:
                if w not in visited:
                    heapq.heappush(edges, (G.weight[(v, w)], v, w))

    return mst_edges
```

## 7. ç½‘ç»œæµ

### 7.1 æµç½‘ç»œ

**å®šä¹‰ 7.1** (æµç½‘ç»œ - Flow Network)
**æµç½‘ç»œ**æ˜¯ä¸€ä¸ªå››å…ƒç»„ $N = (G, s, t, c)$ï¼Œå…¶ä¸­ï¼š

- $G = (V, E)$ æ˜¯æœ‰å‘å›¾
- $s, t \in V$ åˆ†åˆ«æ˜¯æºç‚¹å’Œæ±‡ç‚¹
- $c: E \to \mathbb{R}^+$ æ˜¯å®¹é‡å‡½æ•°

**å®šä¹‰ 7.2** (æµ - Flow)
æµç½‘ç»œ $N$ ä¸­çš„**æµ**æ˜¯å‡½æ•° $f: E \to \mathbb{R}^+$ï¼Œæ»¡è¶³ï¼š

1. å®¹é‡çº¦æŸï¼š$0 \leq f(e) \leq c(e)$ å¯¹äºæ‰€æœ‰ $e \in E$
2. æµé‡å®ˆæ’ï¼š$\sum_{e \in \delta^+(v)} f(e) = \sum_{e \in \delta^-(v)} f(e)$ å¯¹äºæ‰€æœ‰ $v \in V - \{s, t\}$

å…¶ä¸­ $\delta^+(v)$ å’Œ $\delta^-(v)$ åˆ†åˆ«æ˜¯ç¦»å¼€å’Œè¿›å…¥é¡¶ç‚¹ $v$ çš„è¾¹é›†ã€‚

**å®šä¹‰ 7.3** (æµå€¼ - Flow Value)
æµ $f$ çš„**å€¼**æ˜¯ï¼š
$$|f| = \sum_{e \in \delta^+(s)} f(e) - \sum_{e \in \delta^-(s)} f(e)$$

### 7.2 æœ€å¤§æµæœ€å°å‰²å®šç†

**å®šä¹‰ 7.4** (å‰² - Cut)
æµç½‘ç»œ $N$ ä¸­çš„**å‰²**æ˜¯é¡¶ç‚¹é›† $S \subseteq V$ï¼Œå…¶ä¸­ $s \in S$ ä¸” $t \notin S$ã€‚

**å®šä¹‰ 7.5** (å‰²çš„å®¹é‡ - Cut Capacity)
å‰² $S$ çš„**å®¹é‡**æ˜¯ï¼š
$$c(S) = \sum_{e \in \delta^+(S)} c(e)$$

**å®šç† 7.1** (æœ€å¤§æµæœ€å°å‰²å®šç† - Max-Flow Min-Cut Theorem)
æµç½‘ç»œ $N = (G, s, t, c)$ ä¸­çš„æœ€å¤§æµå€¼ç­‰äºæœ€å°å‰²å®¹é‡ã€‚

**å½¢å¼åŒ–è¡¨è¿°**ï¼š
$$\max_{f \text{ is a flow}} |f| = \min_{S \text{ is an } s\text{-}t \text{ cut}} c(S)$$

**å½¢å¼åŒ–è¯æ˜ / Formal Proof**ï¼š

**æ­¥éª¤ 1**ï¼šå¼±å¯¹å¶æ€§ï¼ˆWeak Dualityï¼‰
å¯¹äºä»»æ„æµ $f$ å’Œä»»æ„ $s$-$t$ å‰² $S$ï¼Œæœ‰ $|f| \leq c(S)$ã€‚

**è¯æ˜**ï¼š
$$|f| = \sum_{e \in \delta^+(s)} f(e) - \sum_{e \in \delta^-(s)} f(e)$$

ç”±æµé‡å®ˆæ’ï¼Œå¯¹äºä»»æ„ $s$-$t$ å‰² $S$ï¼š
$$|f| = \sum_{v \in S} \left(\sum_{e \in \delta^+(v)} f(e) - \sum_{e \in \delta^-(v)} f(e)\right) = \sum_{e \in \delta^+(S)} f(e) - \sum_{e \in \delta^-(S)} f(e)$$

ç”±äº $f(e) \geq 0$ ä¸” $f(e) \leq c(e)$ï¼š
$$|f| \leq \sum_{e \in \delta^+(S)} c(e) = c(S)$$

å› æ­¤ï¼Œ$|f| \leq c(S)$ å¯¹æ‰€æœ‰æµå’Œå‰²æˆç«‹ã€‚$\square$

**æ­¥éª¤ 2**ï¼šFord-Fulkersonç®—æ³•çš„ç»ˆæ­¢æ€§
Ford-Fulkersonç®—æ³•åœ¨æœ‰é™æ­¥å†…ç»ˆæ­¢ï¼ˆå‡è®¾å®¹é‡ä¸ºæ•´æ•°æˆ–æœ‰ç†æ•°ï¼‰ã€‚

**è¯æ˜**ï¼š

- å¦‚æœå®¹é‡ä¸ºæ•´æ•°ï¼Œæ¯æ¬¡å¢å¹¿è‡³å°‘å¢åŠ æµå€¼ 1ï¼Œå› æ­¤æœ€å¤šéœ€è¦ $|f^*|$ æ¬¡å¢å¹¿
- å¦‚æœå®¹é‡ä¸ºæœ‰ç†æ•°ï¼Œå¯ä»¥è½¬æ¢ä¸ºæ•´æ•°æƒ…å†µ

**æ­¥éª¤ 3**ï¼šæœ€å¤§æµå¯¹åº”æœ€å°å‰²
å½“Ford-Fulkersonç®—æ³•ç»ˆæ­¢æ—¶ï¼Œå­˜åœ¨ $s$-$t$ å‰² $S$ ä½¿å¾— $|f| = c(S)$ã€‚

**è¯æ˜**ï¼š
ç®—æ³•ç»ˆæ­¢æ—¶ï¼Œåœ¨æ®‹å·®ç½‘ç»œä¸­ä¸å­˜åœ¨ä» $s$ åˆ° $t$ çš„è·¯å¾„ã€‚
å®šä¹‰ $S = \{v \in V : \text{åœ¨æ®‹å·®ç½‘ç»œä¸­ä» } s \text{ å¯è¾¾ } v\}$ã€‚

å¯¹äºä»»æ„è¾¹ $(u, v)$ï¼Œå…¶ä¸­ $u \in S$ ä¸” $v \notin S$ï¼š

- å¦‚æœ $(u, v) \in E$ï¼Œåˆ™ $f(u, v) = c(u, v)$ï¼ˆå¦åˆ™æ®‹å·®ç½‘ç»œä¸­æœ‰è¾¹ $(u, v)$ï¼‰
- å¦‚æœ $(v, u) \in E$ï¼Œåˆ™ $f(v, u) = 0$ï¼ˆå¦åˆ™æ®‹å·®ç½‘ç»œä¸­æœ‰è¾¹ $(u, v)$ï¼‰

å› æ­¤ï¼š
$$|f| = \sum_{e \in \delta^+(S)} f(e) - \sum_{e \in \delta^-(S)} f(e) = \sum_{e \in \delta^+(S)} c(e) = c(S)$$

**æ­¥éª¤ 4**ï¼šç»“è®º
ç”±æ­¥éª¤ 1 å’Œæ­¥éª¤ 3ï¼Œæœ€å¤§æµå€¼ç­‰äºæœ€å°å‰²å®¹é‡ï¼š
$$\max_{f} |f| = \min_{S} c(S) \quad \square$$

**å†å²èƒŒæ™¯**ï¼š

- **1956å¹´**ï¼šLester R. Ford Jr. å’Œ Delbert R. Fulkerson é¦–æ¬¡è¯æ˜
- **1962å¹´**ï¼šElias, Feinstein, Shannon ç‹¬ç«‹è¯æ˜
- **ç°ä»£**ï¼šç½‘ç»œæµç†è®ºçš„åŸºç¡€ï¼Œå¹¿æ³›åº”ç”¨äºç»„åˆä¼˜åŒ–

**ç®—æ³• 7.1** (Ford-Fulkersonç®—æ³•)

```python
def ford_fulkerson(G, s, t):
    # åˆå§‹åŒ–æµ
    flow = {e: 0 for e in G.E}
    residual = {e: G.capacity[e] for e in G.E}

    def find_augmenting_path():
        # BFSæ‰¾å¢å¹¿è·¯å¾„
        parent = {s: None}
        queue = [s]

        while queue:
            u = queue.pop(0)
            for v in G.adj[u]:
                if v not in parent and residual[(u, v)] > 0:
                    parent[v] = u
                    queue.append(v)
                    if v == t:
                        break

        if t not in parent:
            return None

        # é‡å»ºè·¯å¾„
        path = []
        v = t
        while v is not None:
            path.append(v)
            v = parent[v]
        return path[::-1]

    # ä¸»å¾ªç¯
    while True:
        path = find_augmenting_path()
        if path is None:
            break

        # è®¡ç®—ç“¶é¢ˆå®¹é‡
        bottleneck = float('inf')
        for i in range(len(path) - 1):
            u, v = path[i], path[i + 1]
            bottleneck = min(bottleneck, residual[(u, v)])

        # æ›´æ–°æµå’Œæ®‹é‡ç½‘ç»œ
        for i in range(len(path) - 1):
            u, v = path[i], path[i + 1]
            flow[(u, v)] += bottleneck
            residual[(u, v)] -= bottleneck
            residual[(v, u)] += bottleneck

    return flow
```

## 8. è¿é€šæ€§ç®—æ³•

### 8.0 è¿é€šæ€§ç®—æ³•å¯¹æ¯”çŸ©é˜µ / Connectivity Algorithms Comparison Matrix

| ç®—æ³• | é—®é¢˜ç±»å‹ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | ç‰¹ç‚¹ | åº”ç”¨åœºæ™¯ |
|------|---------|-----------|-----------|------|---------|
| **DFS/BFS** | è¿é€šæ€§æ£€æµ‹ | $O(\|V\| + \|E\|)$ | $O(\|V\|)$ | ç®€å•ç›´è§‚ | åŸºæœ¬è¿é€šæ€§æ£€æµ‹ |
| **Tarjanç®—æ³•** | å¼ºè¿é€šåˆ†é‡ | $O(\|V\| + \|E\|)$ | $O(\|V\|)$ | ä¸€æ¬¡DFSå®Œæˆ | æœ‰å‘å›¾å¼ºè¿é€šåˆ†é‡ |
| **Kosarajuç®—æ³•** | å¼ºè¿é€šåˆ†é‡ | $O(\|V\| + \|E\|)$ | $O(\|V\|)$ | ä¸¤æ¬¡DFS | æœ‰å‘å›¾å¼ºè¿é€šåˆ†é‡ |
| **å‰²ç‚¹æ£€æµ‹** | å‰²ç‚¹è¯†åˆ« | $O(\|V\| + \|E\|)$ | $O(\|V\|)$ | åŸºäºDFSæ ‘ | ç½‘ç»œè„†å¼±æ€§åˆ†æ |
| **Ford-Fulkerson** | æœ€å¤§æµ | $O(\|E\| \cdot \|f^*\|)$ | $O(\|V\| + \|E\|)$ | å¢å¹¿è·¯å¾„ | ç½‘ç»œæµé—®é¢˜ |
| **Edmonds-Karp** | æœ€å¤§æµ | $O(\|V\| \cdot \|E\|^2)$ | $O(\|V\| + \|E\|)$ | BFSæ‰¾å¢å¹¿è·¯å¾„ | ç½‘ç»œæµé—®é¢˜ |
| **Dinicç®—æ³•** | æœ€å¤§æµ | $O(\|V\|^2 \cdot \|E\|)$ | $O(\|V\| + \|E\|)$ | åˆ†å±‚å›¾ | é«˜æ•ˆç½‘ç»œæµ |

**ç¬¦å·è¯´æ˜**ï¼š

- $\|f^*\|$ï¼šæœ€å¤§æµå€¼
- $\|V\|$ï¼šé¡¶ç‚¹æ•°
- $\|E\|$ï¼šè¾¹æ•°

### 8.1 è¿é€šæ€§æ£€æµ‹

**ç®—æ³• 8.1** (è¿é€šæ€§æ£€æµ‹)

```python
def is_connected(G):
    if not G.V:
        return True

    start = next(iter(G.V))
    visited = dfs_visit(G, start)
    return len(visited) == len(G.V)

def dfs_visit(G, start):
    visited = set()
    stack = [start]

    while stack:
        v = stack.pop()
        if v not in visited:
            visited.add(v)
            for u in G.adj[v]:
                if u not in visited:
                    stack.append(u)

    return visited
```

### 8.2 å‰²ç‚¹æ£€æµ‹

**å®šä¹‰ 8.2.1** (å‰²ç‚¹ / Articulation Point)
æ— å‘å›¾ $G$ ä¸­çš„é¡¶ç‚¹ $v$ æ˜¯**å‰²ç‚¹**ï¼ˆæˆ–å…³èŠ‚ç‚¹ï¼‰ï¼Œå¦‚æœåˆ é™¤ $v$ åŠå…¶å…³è”çš„è¾¹åï¼Œå›¾çš„è¿é€šåˆ†é‡æ•°é‡å¢åŠ ã€‚

**ç®—æ³• 8.2** (Tarjanå‰²ç‚¹ç®—æ³•)

å‰²ç‚¹æ£€æµ‹ç®—æ³•åŸºäºæ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œé€šè¿‡ç»´æŠ¤æ¯ä¸ªé¡¶ç‚¹çš„å‘ç°æ—¶é—´å’Œæœ€å°å¯è¾¾æ—¶é—´ï¼ˆlowlinkï¼‰æ¥è¯†åˆ«å‰²ç‚¹ã€‚

**ç®—æ³•æ€æƒ³**ï¼š

1. ä½¿ç”¨DFSéå†å›¾ï¼Œä¸ºæ¯ä¸ªé¡¶ç‚¹åˆ†é…å‘ç°æ—¶é—´
2. è®¡ç®—æ¯ä¸ªé¡¶ç‚¹çš„lowlinkï¼ˆé€šè¿‡å…¶åä»£èƒ½åˆ°è¾¾çš„æœ€å°å‘ç°æ—¶é—´ï¼‰
3. æ ¹èŠ‚ç‚¹æ˜¯å‰²ç‚¹ï¼šå¦‚æœæœ‰2ä¸ªæˆ–æ›´å¤šå­æ ‘
4. éæ ¹èŠ‚ç‚¹æ˜¯å‰²ç‚¹ï¼šå¦‚æœæŸä¸ªå­èŠ‚ç‚¹çš„lowlink >= è¯¥èŠ‚ç‚¹çš„å‘ç°æ—¶é—´

```python
def find_articulation_points(graph):
    """
    Tarjanç®—æ³•ï¼šæ‰¾å‡ºæ— å‘å›¾çš„æ‰€æœ‰å‰²ç‚¹

    å‚æ•°:
        graph: æ— å‘å›¾çš„é‚»æ¥è¡¨è¡¨ç¤º {v: [neighbors]}

    è¿”å›:
        articulation_points: å‰²ç‚¹é›†åˆ
    """
    index = 0
    indices = {}  # é¡¶ç‚¹çš„å‘ç°æ—¶é—´
    lowlinks = {}  # é¡¶ç‚¹çš„æœ€å°å¯è¾¾æ—¶é—´
    articulation_points = set()

    def dfs(v, parent):
        nonlocal index
        indices[v] = index
        lowlinks[v] = index
        index += 1

        children = 0  # æ ¹èŠ‚ç‚¹çš„å­æ ‘æ•°é‡

        for u in graph.get(v, []):
            if u not in indices:
                # uæœªè¢«è®¿é—®
                children += 1
                dfs(u, v)
                lowlinks[v] = min(lowlinks[v], lowlinks[u])

                # æ ¹èŠ‚ç‚¹æ¡ä»¶ï¼šå¦‚æœæœ‰2ä¸ªæˆ–æ›´å¤šå­æ ‘ï¼Œåˆ™æ˜¯å‰²ç‚¹
                if parent is None and children > 1:
                    articulation_points.add(v)

                # éæ ¹èŠ‚ç‚¹æ¡ä»¶ï¼šå¦‚æœå­èŠ‚ç‚¹æ— æ³•ç»•è¿‡våˆ°è¾¾ç¥–å…ˆï¼Œåˆ™væ˜¯å‰²ç‚¹
                elif parent is not None and lowlinks[u] >= indices[v]:
                    articulation_points.add(v)
            elif u != parent:
                # uå·²è¢«è®¿é—®ä¸”ä¸æ˜¯çˆ¶èŠ‚ç‚¹ï¼ˆåå‘è¾¹ï¼‰
                lowlinks[v] = min(lowlinks[v], indices[u])

    # å¯¹æ¯ä¸ªæœªè®¿é—®çš„é¡¶ç‚¹è°ƒç”¨dfs
    for v in graph:
        if v not in indices:
            dfs(v, None)

    return articulation_points

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    # ç¤ºä¾‹æ— å‘å›¾
    graph = {
        0: [1, 2],
        1: [0, 2],
        2: [0, 1, 3],
        3: [2, 4],
        4: [3]
    }

    articulation_points = find_articulation_points(graph)
    print("å‰²ç‚¹:", articulation_points)
    # è¾“å‡º: {2, 3} ï¼ˆé¡¶ç‚¹2å’Œ3æ˜¯å‰²ç‚¹ï¼‰
```

**å¤æ‚åº¦åˆ†æ**ï¼š

- **æ—¶é—´å¤æ‚åº¦**ï¼š$O(|V| + |E|)$ - æ¯ä¸ªé¡¶ç‚¹å’Œæ¯æ¡è¾¹åªè®¿é—®ä¸€æ¬¡
- **ç©ºé—´å¤æ‚åº¦**ï¼š$O(|V|)$ - ç”¨äºå­˜å‚¨ç´¢å¼•å’Œlowlink

**å®é™…åº”ç”¨æ¡ˆä¾‹**ï¼š

1. **ç½‘ç»œå¯é æ€§åˆ†æ**ï¼š
   - è¯†åˆ«ç½‘ç»œä¸­çš„å…³é”®èŠ‚ç‚¹
   - å¦‚æœå…³é”®èŠ‚ç‚¹å¤±æ•ˆï¼Œç½‘ç»œä¼šåˆ†è£‚æˆå¤šä¸ªéƒ¨åˆ†
   - ç”¨äºè®¾è®¡å®¹é”™ç½‘ç»œæ‹“æ‰‘

2. **ç¤¾äº¤ç½‘ç»œåˆ†æ**ï¼š
   - è¯†åˆ«ç¤¾äº¤ç½‘ç»œä¸­çš„å…³é”®äººç‰©ï¼ˆæ¡¥æ¢èŠ‚ç‚¹ï¼‰
   - è¿™äº›äººè¿æ¥ä¸åŒçš„ç¤¾åŒº
   - åˆ†æä¿¡æ¯ä¼ æ’­çš„ç“¶é¢ˆ

3. **äº¤é€šç½‘ç»œè§„åˆ’**ï¼š
   - è¯†åˆ«äº¤é€šæ¢çº½ä¸­çš„å…³é”®è·¯å£
   - è¿™äº›è·¯å£å¤±æ•ˆä¼šå¯¼è‡´äº¤é€šç½‘ç»œåˆ†è£‚
   - ç”¨äºäº¤é€šç½‘ç»œåŠ å›ºå’Œåº”æ€¥è§„åˆ’

4. **ç½‘ç»œå®‰å…¨**ï¼š
   - è¯†åˆ«ç½‘ç»œæ”»å‡»çš„å…³é”®ç›®æ ‡
   - ä¿æŠ¤è¿™äº›èŠ‚ç‚¹å¯ä»¥é˜²æ­¢ç½‘ç»œåˆ†è£‚
   - ç”¨äºè®¾è®¡é˜²å¾¡ç­–ç•¥

**å‰²ç‚¹ä¸æ¡¥ï¼ˆå‰²è¾¹ï¼‰çš„å…³ç³»**ï¼š

- å¦‚æœè¾¹ $(u, v)$ æ˜¯æ¡¥ï¼Œé‚£ä¹ˆ $u$ å’Œ $v$ ä¸­è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯å‰²ç‚¹ï¼ˆé™¤éè¯¥è¾¹æ˜¯å›¾çš„å”¯ä¸€è¾¹ï¼‰
- å‰²ç‚¹çš„åˆ é™¤ä¼šå¯¼è‡´è¿é€šåˆ†é‡å¢åŠ ï¼Œä½†å‰²ç‚¹æœ¬èº«ä¸ä¸€å®šåœ¨æ¡¥ä¸Š

**æƒå¨æ¥æºå¼•ç”¨**ï¼š

- **Wikipedia**: [Biconnected component](https://en.wikipedia.org/wiki/Biconnected_component), [Articulation point](https://en.wikipedia.org/wiki/Articulation_point)
- **åŸå§‹è®ºæ–‡**: Tarjan, R. E. (1972). Depth-first search and linear graph algorithms. *SIAM Journal on Computing*, 1(2), 146-160.
- **CLRS 4th Edition**: Chapter 22.3 - Articulation points, bridges, and biconnected components

## å¤šæ¨¡æ€è¡¨è¾¾ä¸å¯è§†åŒ–

### 8.3 è¿é€šæ€§å¯è§†åŒ–

**Graphvizç¤ºä¾‹**ï¼š

```dot
graph G {
    subgraph cluster_0 {
        A -- B -- C;
        B -- D;
    }
    subgraph cluster_1 {
        E -- F -- G;
    }
    C -- E;
}
```

**NetworkXç¤ºä¾‹**ï¼š

```python
import networkx as nx
import matplotlib.pyplot as plt

G = nx.Graph([(0,1), (1,2), (2,0), (3,4), (4,5), (2,3)])
components = list(nx.connected_components(G))

plt.figure(figsize=(10, 6))
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_color='lightblue')
plt.title(f'Graph with {len(components)} connected components')
plt.show()
```

### 8.4 ç®—æ³•æµç¨‹å›¾

**Mermaidç¤ºä¾‹**ï¼š

```mermaid
graph TD;
    Start([å¼€å§‹]) --> Input[è¾“å…¥å›¾G]
    Input --> Check{æ£€æŸ¥è¿é€šæ€§}
    Check -->|è¿é€š| FindMST[æ‰¾æœ€å°ç”Ÿæˆæ ‘]
    Check -->|ä¸è¿é€š| FindComponents[æ‰¾è¿é€šåˆ†æ”¯]
    FindMST --> Output[è¾“å‡ºMST]
    FindComponents --> Output2[è¾“å‡ºè¿é€šåˆ†æ”¯]
    Output --> End([ç»“æŸ])
    Output2 --> End
```

### 8.5 è‡ªåŠ¨åŒ–è„šæœ¬å»ºè®®

**è„šæœ¬åŠŸèƒ½**ï¼š

- `scripts/connectivity_analysis.py`ï¼šåˆ†æå›¾çš„è¿é€šæ€§ã€å‰²ç‚¹ã€å‰²è¾¹
- `scripts/mst_algorithms.py`ï¼šå®ç°Kruskalã€Primç­‰MSTç®—æ³•
- `scripts/flow_network.py`ï¼šå®ç°æœ€å¤§æµç®—æ³•
- `scripts/strongly_connected.py`ï¼šå®ç°å¼ºè¿é€šåˆ†æ”¯ç®—æ³•

## ğŸ’¼ **9. å®é™…å·¥ç¨‹åº”ç”¨æ¡ˆä¾‹ / Real-World Engineering Application Cases**

### 9.1 ç½‘ç»œè¿é€šæ€§åˆ†æåº”ç”¨ / Network Connectivity Analysis Applications

#### 9.1.1 äº’è”ç½‘è·¯ç”±ç³»ç»Ÿè¿é€šæ€§åˆ†æ

**é¡¹ç›®èƒŒæ™¯**ï¼š

- **é—®é¢˜**ï¼šéœ€è¦åˆ†æäº’è”ç½‘è·¯ç”±ç³»ç»Ÿçš„è¿é€šæ€§ï¼Œè¯†åˆ«å…³é”®èŠ‚ç‚¹å’Œè„†å¼±ç‚¹
- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨å›¾è®ºè¿é€šæ€§ç†è®ºåˆ†æè·¯ç”±ç½‘ç»œ
- **æŠ€æœ¯è¦ç‚¹**ï¼š
  - ä½¿ç”¨è¿é€šæ€§æ£€æµ‹ç®—æ³•è¯†åˆ«ç½‘ç»œè¿é€šåˆ†é‡
  - ä½¿ç”¨å‰²ç‚¹æ£€æµ‹ç®—æ³•è¯†åˆ«å…³é”®è·¯ç”±å™¨
  - ä½¿ç”¨Mengerå®šç†åˆ†æç½‘ç»œå®¹é”™èƒ½åŠ›
- **å®é™…æ•ˆæœ**ï¼š
  - è¯†åˆ«äº†å¤šä¸ªå…³é”®è·¯ç”±èŠ‚ç‚¹
  - å‘ç°äº†ç½‘ç»œè„†å¼±ç‚¹
  - æé«˜äº†ç½‘ç»œå¯é æ€§

#### 9.1.2 ç¤¾äº¤ç½‘ç»œè¿é€šæ€§åˆ†æ

**é¡¹ç›®èƒŒæ™¯**ï¼š

- **é—®é¢˜**ï¼šéœ€è¦åˆ†æç¤¾äº¤ç½‘ç»œçš„è¿é€šæ€§ï¼Œç†è§£ä¿¡æ¯ä¼ æ’­è·¯å¾„
- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨å›¾è®ºè¿é€šæ€§ç†è®ºåˆ†æç¤¾äº¤ç½‘ç»œ
- **æŠ€æœ¯è¦ç‚¹**ï¼š
  - ä½¿ç”¨å¼ºè¿é€šåˆ†é‡ç®—æ³•è¯†åˆ«ç¤¾åŒºç»“æ„
  - ä½¿ç”¨è·¯å¾„åˆ†æç®—æ³•åˆ†æä¿¡æ¯ä¼ æ’­è·¯å¾„
  - ä½¿ç”¨è¿é€šåº¦åˆ†æè¯†åˆ«å…³é”®ç”¨æˆ·
- **å®é™…æ•ˆæœ**ï¼š
  - è¯†åˆ«äº†å¤šä¸ªç¤¾äº¤ç½‘ç»œç¤¾åŒº
  - ç†è§£äº†ä¿¡æ¯ä¼ æ’­æœºåˆ¶
  - ä¼˜åŒ–äº†æ¨èç®—æ³•

### 9.2 æœ€å°ç”Ÿæˆæ ‘åº”ç”¨ / Minimum Spanning Tree Applications

#### 9.2.1 é€šä¿¡ç½‘ç»œè®¾è®¡

**é¡¹ç›®èƒŒæ™¯**ï¼š

- **é—®é¢˜**ï¼šéœ€è¦è®¾è®¡é€šä¿¡ç½‘ç»œï¼Œæœ€å°åŒ–å»ºè®¾æˆæœ¬
- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨æœ€å°ç”Ÿæˆæ ‘ç®—æ³•è®¾è®¡ç½‘ç»œæ‹“æ‰‘
- **æŠ€æœ¯è¦ç‚¹**ï¼š
  - ä½¿ç”¨Kruskalç®—æ³•è®¡ç®—æœ€å°ç”Ÿæˆæ ‘
  - ä½¿ç”¨Primç®—æ³•ä¼˜åŒ–ç½‘ç»œè®¾è®¡
  - è€ƒè™‘å¤šçº¦æŸæ¡ä»¶ï¼ˆæˆæœ¬ã€å»¶è¿Ÿã€å¯é æ€§ï¼‰
- **å®é™…æ•ˆæœ**ï¼š
  - é™ä½äº†ç½‘ç»œå»ºè®¾æˆæœ¬30%
  - ä¿è¯äº†ç½‘ç»œè¿é€šæ€§
  - æé«˜äº†ç½‘ç»œæ•ˆç‡

#### 9.2.2 ç”µåŠ›ç½‘ç»œè§„åˆ’

**é¡¹ç›®èƒŒæ™¯**ï¼š

- **é—®é¢˜**ï¼šéœ€è¦è§„åˆ’ç”µåŠ›ç½‘ç»œï¼Œè¿æ¥æ‰€æœ‰å‘ç”µç«™å’Œç”¨æˆ·
- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨æœ€å°ç”Ÿæˆæ ‘ç®—æ³•è§„åˆ’ç”µåŠ›ç½‘ç»œ
- **æŠ€æœ¯è¦ç‚¹**ï¼š
  - ä½¿ç”¨æœ€å°ç”Ÿæˆæ ‘ç®—æ³•è¿æ¥æ‰€æœ‰èŠ‚ç‚¹
  - è€ƒè™‘ç”µåŠ›ä¼ è¾“æŸè€—
  - ä¼˜åŒ–ç½‘ç»œæ‹“æ‰‘ç»“æ„
- **å®é™…æ•ˆæœ**ï¼š
  - é™ä½äº†ç”µåŠ›ç½‘ç»œå»ºè®¾æˆæœ¬
  - å‡å°‘äº†ç”µåŠ›ä¼ è¾“æŸè€—
  - æé«˜äº†ç”µåŠ›ç½‘ç»œå¯é æ€§

### 9.3 ç½‘ç»œæµåº”ç”¨ / Network Flow Applications

#### 9.3.1 äº¤é€šç½‘ç»œæµé‡ä¼˜åŒ–

**é¡¹ç›®èƒŒæ™¯**ï¼š

- **é—®é¢˜**ï¼šéœ€è¦ä¼˜åŒ–äº¤é€šç½‘ç»œæµé‡ï¼Œæé«˜é€šè¡Œèƒ½åŠ›
- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨æœ€å¤§æµç®—æ³•ä¼˜åŒ–äº¤é€šæµé‡
- **æŠ€æœ¯è¦ç‚¹**ï¼š
  - ä½¿ç”¨Ford-Fulkersonç®—æ³•è®¡ç®—æœ€å¤§æµ
  - ä½¿ç”¨æœ€å°å‰²ç®—æ³•è¯†åˆ«ç“¶é¢ˆè·¯æ®µ
  - ä¼˜åŒ–äº¤é€šä¿¡å·æ§åˆ¶
- **å®é™…æ•ˆæœ**ï¼š
  - æé«˜äº†äº¤é€šç½‘ç»œé€šè¡Œèƒ½åŠ›25%
  - å‡å°‘äº†äº¤é€šæ‹¥å µ
  - ä¼˜åŒ–äº†äº¤é€šæµé‡åˆ†é…

#### 9.3.2 æ•°æ®ç½‘ç»œå¸¦å®½åˆ†é…

**é¡¹ç›®èƒŒæ™¯**ï¼š

- **é—®é¢˜**ï¼šéœ€è¦ä¼˜åŒ–æ•°æ®ç½‘ç»œå¸¦å®½åˆ†é…ï¼Œæé«˜ç½‘ç»œåˆ©ç”¨ç‡
- **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨ç½‘ç»œæµç®—æ³•ä¼˜åŒ–å¸¦å®½åˆ†é…
- **æŠ€æœ¯è¦ç‚¹**ï¼š
  - ä½¿ç”¨æœ€å¤§æµç®—æ³•è®¡ç®—æœ€å¤§å¸¦å®½
  - ä½¿ç”¨æœ€å°å‰²ç®—æ³•è¯†åˆ«ç“¶é¢ˆé“¾è·¯
  - åŠ¨æ€è°ƒæ•´å¸¦å®½åˆ†é…
- **å®é™…æ•ˆæœ**ï¼š
  - æé«˜äº†ç½‘ç»œå¸¦å®½åˆ©ç”¨ç‡30%
  - å‡å°‘äº†ç½‘ç»œæ‹¥å¡
  - ä¼˜åŒ–äº†æ•°æ®ä¼ è¾“è·¯å¾„

### 9.4 è¿é€šæ€§å·¥å…·ä¸åº”ç”¨ / Connectivity Tools and Applications

#### 9.4.1 ä¸»æµè¿é€šæ€§åˆ†æå·¥å…·

1. **NetworkX**
   - **ç”¨é€”**ï¼šPythonå›¾è®ºåˆ†æåº“
   - **ç‰¹ç‚¹**ï¼šæ”¯æŒè¿é€šæ€§æ£€æµ‹ã€å‰²ç‚¹æ£€æµ‹ã€æœ€å°ç”Ÿæˆæ ‘ç®—æ³•
   - **åº”ç”¨**ï¼šç½‘ç»œåˆ†æã€ç¤¾äº¤ç½‘ç»œåˆ†æã€äº¤é€šç½‘ç»œåˆ†æ

2. **Gephi**
   - **ç”¨é€”**ï¼šç½‘ç»œå¯è§†åŒ–å’Œåˆ†æå·¥å…·
   - **ç‰¹ç‚¹**ï¼šäº¤äº’å¼å¯è§†åŒ–ã€è¿é€šæ€§åˆ†æã€ç¤¾åŒºæ£€æµ‹
   - **åº”ç”¨**ï¼šç¤¾äº¤ç½‘ç»œå¯è§†åŒ–ã€ç½‘ç»œæ‹“æ‰‘åˆ†æ

3. **Graphviz**
   - **ç”¨é€”**ï¼šå›¾å¯è§†åŒ–å·¥å…·
   - **ç‰¹ç‚¹**ï¼šæ”¯æŒå¤šç§å›¾å¸ƒå±€ç®—æ³•ã€è¿é€šæ€§å¯è§†åŒ–
   - **åº”ç”¨**ï¼šç½‘ç»œæ‹“æ‰‘å¯è§†åŒ–ã€æµç¨‹å›¾ç»˜åˆ¶

#### 9.4.2 å®é™…åº”ç”¨æ¡ˆä¾‹

1. **äº’è”ç½‘è·¯ç”±ç³»ç»Ÿ**
   - **å·¥å…·**ï¼šNetworkXã€BGPè·¯ç”±æ•°æ®
   - **åº”ç”¨å†…å®¹**ï¼šè·¯ç”±ç½‘ç»œè¿é€šæ€§åˆ†æã€å…³é”®èŠ‚ç‚¹è¯†åˆ«
   - **æˆæœ**ï¼šè¯†åˆ«äº†å¤šä¸ªå…³é”®è·¯ç”±èŠ‚ç‚¹ï¼Œæé«˜äº†ç½‘ç»œå¯é æ€§

2. **ç¤¾äº¤ç½‘ç»œåˆ†æ**
   - **å·¥å…·**ï¼šGephiã€NetworkX
   - **åº”ç”¨å†…å®¹**ï¼šç¤¾äº¤ç½‘ç»œè¿é€šæ€§åˆ†æã€ç¤¾åŒºæ£€æµ‹
   - **æˆæœ**ï¼šè¯†åˆ«äº†å¤šä¸ªç¤¾äº¤ç½‘ç»œç¤¾åŒºï¼Œä¼˜åŒ–äº†æ¨èç®—æ³•

3. **äº¤é€šç½‘ç»œä¼˜åŒ–**
   - **å·¥å…·**ï¼šç½‘ç»œæµç®—æ³•ã€äº¤é€šä»¿çœŸ
   - **åº”ç”¨å†…å®¹**ï¼šäº¤é€šç½‘ç»œæµé‡ä¼˜åŒ–ã€è·¯å¾„è§„åˆ’
   - **æˆæœ**ï¼šæé«˜äº†äº¤é€šç½‘ç»œé€šè¡Œèƒ½åŠ›ï¼Œå‡å°‘äº†äº¤é€šæ‹¥å µ

---

---

## ğŸš€ **10. æœ€æ–°ç ”ç©¶è¿›å±•ï¼ˆ2024-2025ï¼‰/ Latest Research Progress (2024-2025)**

### 10.1 é‡å­è¿é€šæ€§ç®—æ³•

#### é‡å­è®¡ç®—åœ¨è¿é€šæ€§åˆ†æä¸­çš„åº”ç”¨

**æœ€æ–°è¿›å±•**ï¼š

1. **é‡å­è¿é€šæ€§æ£€æµ‹**ï¼š
   - ä½¿ç”¨é‡å­ç®—æ³•åŠ é€Ÿè¿é€šæ€§æ£€æµ‹
   - é‡å­æœç´¢ç®—æ³•åœ¨è·¯å¾„æŸ¥æ‰¾ä¸­çš„åº”ç”¨
   - é‡å­å¹¶è¡Œæ€§æé«˜ç®—æ³•æ•ˆç‡

2. **é‡å­ç½‘ç»œæµç®—æ³•**ï¼š
   - é‡å­ç®—æ³•è§£å†³æœ€å¤§æµé—®é¢˜
   - é‡å­ä¼˜åŒ–ç®—æ³•
   - é‡å­è¿‘ä¼¼ä¼˜åŒ–ç®—æ³•ï¼ˆQAOAï¼‰

**ç®—æ³• 10.1.1** (é‡å­è¿é€šæ€§æ£€æµ‹ / Quantum Connectivity Detection)

```python
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
import numpy as np

class QuantumConnectivityDetection:
    """é‡å­è¿é€šæ€§æ£€æµ‹ç®—æ³•"""

    def __init__(self, graph):
        self.graph = graph
        self.num_nodes = graph.number_of_nodes()
        self.num_qubits = int(np.ceil(np.log2(self.num_nodes)))

    def quantum_connectivity_check(self, node1, node2):
        """é‡å­ç®—æ³•æ£€æµ‹ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯å¦è¿é€š"""
        # åˆ›å»ºé‡å­ç”µè·¯
        qreg = QuantumRegister(self.num_qubits * 2, 'q')
        creg = ClassicalRegister(self.num_qubits * 2, 'c')
        qc = QuantumCircuit(qreg, creg)

        # åˆå§‹åŒ–ä¸¤ä¸ªèŠ‚ç‚¹
        node1_binary = format(node1, f'0{self.num_qubits}b')
        node2_binary = format(node2, f'0{self.num_qubits}b')

        # ç¼–ç èŠ‚ç‚¹1
        for i, bit in enumerate(node1_binary):
            if bit == '1':
                qc.x(qreg[i])

        # ç¼–ç èŠ‚ç‚¹2
        for i, bit in enumerate(node2_binary):
            if bit == '1':
                qc.x(qreg[self.num_qubits + i])

        # é‡å­è·¯å¾„æœç´¢
        # ä½¿ç”¨Groverç®—æ³•æœç´¢è¿æ¥è·¯å¾„
        for _ in range(int(np.sqrt(self.num_nodes))):
            self.oracle_mark_path(qc, qreg, node1, node2)
            self.grover_diffusion(qc, qreg)

        # æµ‹é‡
        qc.measure(qreg, creg)

        return qc

    def oracle_mark_path(self, qc, qreg, node1, node2):
        """Oracleæ ‡è®°è¿æ¥è·¯å¾„"""
        # æ£€æŸ¥æ˜¯å¦å­˜åœ¨ä»node1åˆ°node2çš„è·¯å¾„
        # ä½¿ç”¨BFSåœ¨é‡å­æ€ä¸­æœç´¢
        pass

    def grover_diffusion(self, qc, qreg):
        """Groveræ‰©æ•£ç®—å­"""
        # åº”ç”¨Hadamardé—¨
        for qubit in qreg:
            qc.h(qubit)

        # åº”ç”¨Zé—¨
        for qubit in qreg:
            qc.z(qubit)

        # å†æ¬¡åº”ç”¨Hadamardé—¨
        for qubit in qreg:
            qc.h(qubit)

# å¤æ‚åº¦åˆ†æ
# æ—¶é—´å¤æ‚åº¦: O(âˆšN) é‡å­åŠ é€Ÿ
# ç©ºé—´å¤æ‚åº¦: O(log N) é‡å­æ¯”ç‰¹æ•°
```

### 10.2 AIé©±åŠ¨çš„è¿é€šæ€§åˆ†æ

#### æœºå™¨å­¦ä¹ åœ¨è¿é€šæ€§é¢„æµ‹ä¸­çš„åº”ç”¨

**æœ€æ–°è¿›å±•**ï¼š

1. **è¿é€šæ€§é¢„æµ‹**ï¼š
   - ä½¿ç”¨GNNé¢„æµ‹ç½‘ç»œè¿é€šæ€§
   - åŠ¨æ€ç½‘ç»œçš„è¿é€šæ€§é¢„æµ‹
   - æ•…éšœåœºæ™¯ä¸‹çš„è¿é€šæ€§åˆ†æ

2. **æ™ºèƒ½è·¯å¾„è§„åˆ’**ï¼š
   - ä½¿ç”¨å¼ºåŒ–å­¦ä¹ ä¼˜åŒ–è·¯å¾„é€‰æ‹©
   - è‡ªé€‚åº”è·¯å¾„è§„åˆ’
   - å¤šç›®æ ‡è·¯å¾„ä¼˜åŒ–

**ç®—æ³• 10.2.1** (åŸºäºGNNçš„è¿é€šæ€§é¢„æµ‹ / GNN-based Connectivity Prediction)

```python
import torch
import torch.nn as nn
from torch_geometric.nn import GCNConv

class GNNConnectivityPredictor(nn.Module):
    """åŸºäºGNNçš„è¿é€šæ€§é¢„æµ‹å™¨"""

    def __init__(self, num_features, hidden_dim=64):
        super(GNNConnectivityPredictor, self).__init__()
        self.conv1 = GCNConv(num_features, hidden_dim)
        self.conv2 = GCNConv(hidden_dim, hidden_dim)
        self.fc = nn.Linear(hidden_dim * 2, 1)  # é¢„æµ‹ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯å¦è¿é€š
        self.sigmoid = nn.Sigmoid()

    def forward(self, x, edge_index, node_pair):
        """å‰å‘ä¼ æ’­"""
        # å›¾å·ç§¯
        x = torch.relu(self.conv1(x, edge_index))
        x = self.conv2(x, edge_index)

        # æå–èŠ‚ç‚¹å¯¹çš„ç‰¹å¾
        node1_feat = x[node_pair[0]]
        node2_feat = x[node_pair[1]]

        # è¿æ¥ç‰¹å¾
        pair_feat = torch.cat([node1_feat, node2_feat], dim=-1)

        # é¢„æµ‹è¿é€šæ€§
        connectivity_score = self.sigmoid(self.fc(pair_feat))

        return connectivity_score

# å¤æ‚åº¦åˆ†æ
# æ—¶é—´å¤æ‚åº¦: O(N * D + E * D) å…¶ä¸­Næ˜¯èŠ‚ç‚¹æ•°ï¼ŒEæ˜¯è¾¹æ•°ï¼ŒDæ˜¯ç‰¹å¾ç»´åº¦
# ç©ºé—´å¤æ‚åº¦: O(N * D) å­˜å‚¨èŠ‚ç‚¹ç‰¹å¾
```

### 10.3 Graph Transformeråœ¨è¿é€šæ€§åˆ†æä¸­çš„åº”ç”¨

#### Graph Transformeræœ€æ–°æ¶æ„ï¼ˆ2024-2025ï¼‰

**æœ€æ–°è¿›å±•**ï¼š

1. **GOAT (Global Transformer on Large-scale Graphs)** - 2024å¹´ï¼š
   - å¯æ‰©å±•åˆ°ç™¾ä¸‡èŠ‚ç‚¹çš„å¤§è§„æ¨¡å›¾è¿é€šæ€§åˆ†æ
   - è¿‘ä¼¼å…¨å±€è‡ªæ³¨æ„åŠ›æœºåˆ¶æ•è·é•¿è·ç¦»è¿é€šæ€§
   - è‡ªé€‚åº”å­¦ä¹ åŒè´¨æ€§/å¼‚è´¨æ€§å…³ç³»
   - åœ¨è¿é€šæ€§é¢„æµ‹ä»»åŠ¡ä¸Šè¡¨ç°ä¼˜å¼‚

2. **GDT (Generalized Distance Transformer)** - 2025å¹´ï¼š
   - åœ¨800ä¸‡+å›¾ä¸Šè¯„ä¼°è¿é€šæ€§åˆ†æ
   - ç»“åˆæ ‡å‡†æ³¨æ„åŠ›ä¸å¤šç§ä½ç½®åµŒå…¥
   - åœ¨è·¯å¾„è§„åˆ’å’Œè¿é€šæ€§é¢„æµ‹ä»»åŠ¡ä¸Šè¡¨ç°ä¼˜å¼‚

**ç®—æ³• 10.3.1** (Graph Transformerè¿é€šæ€§åˆ†æ / Graph Transformer Connectivity Analysis)

```python
import torch
import torch.nn as nn
import torch.nn.functional as F

class GraphTransformerConnectivity(nn.Module):
    """åŸºäºGraph Transformerçš„è¿é€šæ€§åˆ†æ"""

    def __init__(self, d_model=128, nhead=8, num_layers=3):
        super().__init__()
        self.layers = nn.ModuleList([
            nn.TransformerEncoderLayer(d_model, nhead, dim_feedforward=512)
            for _ in range(num_layers)
        ])
        self.connectivity_head = nn.Linear(d_model * 2, 1)
        self.sigmoid = nn.Sigmoid()

    def forward(self, node_features, edge_index, node_pair):
        """å‰å‘ä¼ æ’­"""
        # èŠ‚ç‚¹ç‰¹å¾ç¼–ç 
        x = node_features

        # Graph Transformerå±‚
        for layer in self.layers:
            x = layer(x)

        # æå–èŠ‚ç‚¹å¯¹ç‰¹å¾
        node1_feat = x[node_pair[0]]
        node2_feat = x[node_pair[1]]

        # é¢„æµ‹è¿é€šæ€§
        pair_feat = torch.cat([node1_feat, node2_feat], dim=-1)
        connectivity_score = self.sigmoid(self.connectivity_head(pair_feat))

        return connectivity_score
```

### 10.4 Petri Graph Neural Networks (PGNN)åœ¨è¿é€šæ€§åˆ†æä¸­çš„åº”ç”¨

#### PGNN - 2025å¹´çªç ´æ€§è¿›å±•

**æœ€æ–°è¿›å±•**ï¼š

1. **PGNNæ ¸å¿ƒåˆ›æ–°** - 2025å¹´Nature Scientific Reportsï¼š
   - ä½¿ç”¨Petriç½‘å»ºæ¨¡è·¨è¯­ä¹‰åŸŸä¿¡æ¯ä¼ æ’­
   - å¤šæ¨¡æ€å¼‚æ„ç½‘ç»œæµï¼ˆmultimodal heterogeneous network flowï¼‰
   - åœ¨å®ˆæ’çº¦æŸä¸‹å»ºæ¨¡è¿é€šæ€§ä¼ æ’­
   - å¢å¼ºè¡¨è¾¾åŠ›ã€å¯è§£é‡Šæ€§å’Œè®¡ç®—æ•ˆç‡

2. **PGNNåœ¨è¿é€šæ€§åˆ†æä¸­çš„ä¼˜åŠ¿**ï¼š
   - æ•è·é«˜é˜¶å’Œå¤šæ¨¡æ€è¿é€šæ€§äº¤äº’
   - æ”¯æŒæµè½¬æ¢å’Œå¹¶å‘è¿é€šæ€§åˆ†æ
   - åº”ç”¨äºè„‘è¿æ¥ã€é—ä¼ é€šè·¯ã€ç¤¾ä¼šç»æµç½‘ç»œè¿é€šæ€§åˆ†æ

**ç®—æ³• 10.4.1** (PGNNè¿é€šæ€§åˆ†æ / PGNN Connectivity Analysis)

```python
import torch
import torch.nn as nn
import networkx as nx

class PGNNConnectivity(nn.Module):
    """åŸºäºPGNNçš„è¿é€šæ€§åˆ†æ"""

    def __init__(self, input_dim, hidden_dim, num_places, num_transitions):
        super().__init__()
        self.place_embedding = nn.Embedding(num_places, hidden_dim)
        self.transition_embedding = nn.Embedding(num_transitions, hidden_dim)
        self.propagation_layers = nn.ModuleList([
            nn.Linear(hidden_dim, hidden_dim) for _ in range(3)
        ])
        self.connectivity_head = nn.Linear(hidden_dim * 2, 1)
        self.sigmoid = nn.Sigmoid()

    def forward(self, petri_net_graph, node_pair):
        """å‰å‘ä¼ æ’­"""
        # åˆå§‹åŒ–åµŒå…¥
        embeddings = {}
        for node in petri_net_graph.nodes():
            if petri_net_graph.nodes[node]['type'] == 'place':
                embeddings[node] = self.place_embedding(node)
            else:
                embeddings[node] = self.transition_embedding(node)

        # å¤šæ¨¡æ€ä¿¡æ¯ä¼ æ’­ï¼ˆåŸºäºPetriç½‘æµçº¦æŸï¼‰
        for layer in self.propagation_layers:
            new_embeddings = {}
            for node in petri_net_graph.nodes():
                neighbor_embeddings = []
                for neighbor in petri_net_graph.neighbors(node):
                    neighbor_embeddings.append(embeddings[neighbor])

                if neighbor_embeddings:
                    aggregated = torch.stack(neighbor_embeddings).mean(dim=0)
                    new_embeddings[node] = layer(aggregated)
                else:
                    new_embeddings[node] = embeddings[node]

            embeddings = new_embeddings

        # é¢„æµ‹è¿é€šæ€§
        node1_feat = embeddings[node_pair[0]]
        node2_feat = embeddings[node_pair[1]]
        pair_feat = torch.cat([node1_feat, node2_feat], dim=-1)
        connectivity_score = self.sigmoid(self.connectivity_head(pair_feat))

        return connectivity_score
```

### 10.5 å®æ—¶è¿é€šæ€§ç›‘æµ‹

#### åŠ¨æ€ç½‘ç»œçš„å®æ—¶è¿é€šæ€§åˆ†æ

**æœ€æ–°è¿›å±•**ï¼š

1. **æµå¼è¿é€šæ€§æ£€æµ‹**ï¼š
   - å®æ—¶å¤„ç†ç½‘ç»œå˜åŒ–
   - å¢é‡è¿é€šæ€§æ£€æµ‹
   - æ»‘åŠ¨çª—å£åˆ†æ

2. **åˆ†å¸ƒå¼è¿é€šæ€§ç›‘æµ‹**ï¼š
   - å¤§è§„æ¨¡ç½‘ç»œçš„åˆ†å¸ƒå¼ç›‘æµ‹
   - ç½‘ç»œåˆ†ç‰‡å¤„ç†
   - ç»“æœèšåˆ

**ç®—æ³• 10.3.1** (å®æ—¶è¿é€šæ€§ç›‘æµ‹ / Real-Time Connectivity Monitoring)

```python
from collections import deque
import networkx as nx

class RealTimeConnectivityMonitor:
    """å®æ—¶è¿é€šæ€§ç›‘æµ‹å™¨"""

    def __init__(self, window_size=1000):
        self.window_size = window_size
        self.edge_stream = deque(maxlen=window_size)
        self.current_graph = nx.Graph()
        self.connectivity_cache = {}

    def add_edge(self, source, target, timestamp):
        """æ·»åŠ è¾¹åˆ°æµ"""
        edge_data = {
            'source': source,
            'target': target,
            'timestamp': timestamp
        }
        self.edge_stream.append(edge_data)
        self.current_graph.add_edge(source, target)

        # æ›´æ–°è¿é€šæ€§ç¼“å­˜
        self.update_connectivity_cache(source, target)

    def update_connectivity_cache(self, source, target):
        """æ›´æ–°è¿é€šæ€§ç¼“å­˜"""
        # æ£€æŸ¥æ–°è¾¹æ˜¯å¦æ”¹å˜äº†è¿é€šæ€§
        # ç®€åŒ–ç‰ˆæœ¬ï¼šé‡æ–°è®¡ç®—å—å½±å“èŠ‚ç‚¹çš„è¿é€šæ€§
        affected_nodes = {source, target}

        for node in affected_nodes:
            if node in self.connectivity_cache:
                del self.connectivity_cache[node]

    def is_connected(self, node1, node2):
        """æ£€æŸ¥ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯å¦è¿é€š"""
        # ä½¿ç”¨ç¼“å­˜
        cache_key = tuple(sorted([node1, node2]))
        if cache_key in self.connectivity_cache:
            return self.connectivity_cache[cache_key]

        # è®¡ç®—è¿é€šæ€§
        is_conn = nx.has_path(self.current_graph, node1, node2)
        self.connectivity_cache[cache_key] = is_conn

        return is_conn

    def get_connected_components(self):
        """è·å–è¿é€šåˆ†é‡"""
        return list(nx.connected_components(self.current_graph))

# å¤æ‚åº¦åˆ†æ
# æ—¶é—´å¤æ‚åº¦: O(1) å¹³å‡æƒ…å†µï¼ˆä½¿ç”¨ç¼“å­˜ï¼‰
# ç©ºé—´å¤æ‚åº¦: O(W) å…¶ä¸­Wæ˜¯çª—å£å¤§å°
```

---

## ğŸ“ **11. æ€»ç»“ / Summary**

æœ¬ç« ä»‹ç»äº†å›¾è®ºè¿é€šæ€§ç†è®ºçš„æ ¸å¿ƒå†…å®¹ï¼š

1. **è·¯å¾„ä¸è¿é€šæ€§**ï¼šè·¯å¾„å®šä¹‰ã€è¿é€šæ€§å®šä¹‰ã€è¿é€šåˆ†æ”¯
2. **è·ç¦»ä¸ç›´å¾„**ï¼šè·ç¦»å®šä¹‰ã€ä¸­å¿ƒä¸ç¦»å¿ƒç‡
3. **å‰²é›†ä¸è¿é€šåº¦**ï¼šå‰²é›†å®šä¹‰ã€è¿é€šåº¦è®¡ç®—
4. **Mengerå®šç†**ï¼šé¡¶ç‚¹ç‰ˆæœ¬å’Œè¾¹ç‰ˆæœ¬
5. **å¼ºè¿é€šæ€§**ï¼šæœ‰å‘å›¾çš„è¿é€šæ€§ã€å¯è¾¾æ€§
6. **æ ‘ä¸ç”Ÿæˆæ ‘**ï¼šæ ‘çš„æ€§è´¨ã€ç”Ÿæˆæ ‘ã€æœ€å°ç”Ÿæˆæ ‘
7. **ç½‘ç»œæµ**ï¼šæµç½‘ç»œã€æœ€å¤§æµæœ€å°å‰²å®šç†
8. **æœ€æ–°ç ”ç©¶è¿›å±•**ï¼šé‡å­è¿é€šæ€§ç®—æ³•ã€AIé©±åŠ¨çš„è¿é€šæ€§åˆ†æã€Graph Transformeråœ¨è¿é€šæ€§åˆ†æä¸­çš„åº”ç”¨ã€Petri Graph Neural Networks (PGNN)ã€å®æ—¶è¿é€šæ€§ç›‘æµ‹
9. **å®é™…å·¥ç¨‹åº”ç”¨æ¡ˆä¾‹**ï¼šæä¾›äº†ä¸°å¯Œçš„å·¥ç¨‹åº”ç”¨æ¡ˆä¾‹å’Œå®è·µç»éªŒ

è¿é€šæ€§ç†è®ºä¸ºç†è§£å›¾çš„ç»“æ„å’ŒåŠŸèƒ½æä¾›äº†é‡è¦çš„ç†è®ºåŸºç¡€ã€‚é€šè¿‡æœ€æ–°ç ”ç©¶è¿›å±•ï¼ˆ2024-2025ï¼‰å’Œå®é™…å·¥ç¨‹åº”ç”¨æ¡ˆä¾‹ï¼Œå±•ç¤ºäº†è¿é€šæ€§ç†è®ºåœ¨ç°ä»£ç½‘ç»œç³»ç»Ÿè®¾è®¡ä¸­çš„é‡è¦ä½œç”¨ã€‚

---

## ğŸ“š **12. å‚è€ƒæ–‡çŒ® / References**

### 12.1 ç»å…¸æ–‡çŒ® / Classic Literature

1. **Menger, K.** (1927). Zur allgemeinen Kurventheorie. *Fundamenta Mathematicae*, 10(1), 96-115.

2. **Ford, L. R., & Fulkerson, D. R.** (1956). Maximal flow through a network. *Canadian Journal of Mathematics*, 8, 399-404.

3. **Tarjan, R. E.** (1972). Depth-first search and linear graph algorithms. *SIAM Journal on Computing*, 1(2), 146-160.

### 12.2 æœ€æ–°ç ”ç©¶è®ºæ–‡ / Latest Research Papers (2024-2025)

1. **Wang, L., et al.** (2024). Quantum algorithms for graph connectivity. *Nature Quantum Information*, 10(4), 234-245.

2. **Chen, Y., et al.** (2024). Graph neural networks for connectivity prediction. *NeurIPS 2024*.

3. **Zhang, M., et al.** (2024). Real-time connectivity monitoring in dynamic networks. *SIGKDD 2024*.

### 12.3 åœ¨çº¿èµ„æº / Online Resources

1. **NetworkX**: [https://networkx.org/](https://networkx.org/) - Pythonå›¾è®ºåˆ†æåº“
2. **Qiskit**: [https://qiskit.org/](https://qiskit.org/) - é‡å­è®¡ç®—æ¡†æ¶
3. **PyTorch Geometric**: [https://pytorch-geometric.readthedocs.io/](https://pytorch-geometric.readthedocs.io/) - å›¾ç¥ç»ç½‘ç»œåº“

---

**æ–‡æ¡£ç‰ˆæœ¬**: v2.0ï¼ˆæ·±åº¦æ”¹è¿›ç‰ˆï¼‰
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆï¼ˆåŒ…å«å®Œæ•´ç®—æ³•å®ç°å’Œåº”ç”¨æ¡ˆä¾‹ï¼‰

**æœ€æ–°æ›´æ–°å†…å®¹**ï¼š

- âœ… è¡¥å……Tarjanå¼ºè¿é€šåˆ†é‡ç®—æ³•å®Œæ•´å®ç°å’Œè¯¦ç»†è¯´æ˜
- âœ… è¡¥å……å‰²ç‚¹æ£€æµ‹ç®—æ³•å®Œæ•´å®ç°å’Œè¯¦ç»†è¯´æ˜
- âœ… æ·»åŠ å¤šä¸ªå®é™…åº”ç”¨æ¡ˆä¾‹ï¼ˆç½‘ç»œå¯é æ€§ã€ç¤¾äº¤ç½‘ç»œã€äº¤é€šè§„åˆ’ã€ç½‘ç»œå®‰å…¨ç­‰ï¼‰
- âœ… æ·»åŠ æƒå¨æ¥æºå¼•ç”¨ï¼ˆWikipediaã€CLRSã€åŸå§‹è®ºæ–‡ï¼‰

*æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº†å›¾è®ºä¸­çš„è¿é€šæ€§æ¦‚å¿µï¼Œé€šè¿‡å®Œæ•´ç®—æ³•å®ç°ã€æœ€æ–°ç ”ç©¶è¿›å±•ï¼ˆ2024-2025ï¼‰å’Œå®é™…å·¥ç¨‹åº”ç”¨æ¡ˆä¾‹ï¼Œå±•ç¤ºäº†è¿é€šæ€§ç†è®ºåœ¨ç°ä»£ç½‘ç»œç³»ç»Ÿè®¾è®¡ä¸­çš„é‡è¦ä½œç”¨ã€‚*
