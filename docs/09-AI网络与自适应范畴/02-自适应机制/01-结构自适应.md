# ç»“æ„è‡ªé€‚åº” / Structural Adaptation

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£è¯¦ç»†æè¿°ç»“æ„è‡ªé€‚åº”çš„å®šä¹‰ã€æœºåˆ¶ã€ç®—æ³•å®ç°å’Œåº”ç”¨æ¡ˆä¾‹ã€‚ç»“æ„è‡ªé€‚åº”æ˜¯ç½‘ç»œæ‹“æ‰‘æ ¹æ®ç¯å¢ƒå˜åŒ–è‡ªåŠ¨è°ƒæ•´çš„è¿‡ç¨‹ï¼Œæ˜¯AIç½‘ç»œçš„é‡è¦ç‰¹å¾ã€‚

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [ç»“æ„è‡ªé€‚åº” / Structural Adaptation](#ç»“æ„è‡ªé€‚åº”--structural-adaptation)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“ **å½¢å¼åŒ–å®šä¹‰ / Formal Definition**](#-å½¢å¼åŒ–å®šä¹‰--formal-definition)
  - [ğŸ”§ **è‡ªé€‚åº”ç±»å‹ / Types of Adaptation**](#-è‡ªé€‚åº”ç±»å‹--types-of-adaptation)
  - [ğŸ’» **ç®—æ³•å®ç° / Algorithm Implementation**](#-ç®—æ³•å®ç°--algorithm-implementation)
  - [ğŸ“Š **å¤æ‚åº¦åˆ†æ / Complexity Analysis**](#-å¤æ‚åº¦åˆ†æ--complexity-analysis)
  - [ğŸ’¼ **å®é™…åº”ç”¨æ¡ˆä¾‹ / Real-World Applications**](#-å®é™…åº”ç”¨æ¡ˆä¾‹--real-world-applications)
  - [ğŸ”— **ç›¸å…³é“¾æ¥ / Related Links**](#-ç›¸å…³é“¾æ¥--related-links)

---

## ğŸ“ **å½¢å¼åŒ–å®šä¹‰ / Formal Definition**

### å®šä¹‰ 2.1 (ç»“æ„è‡ªé€‚åº” / Structural Adaptation)

**ç»“æ„è‡ªé€‚åº”**æ˜¯ç½‘ç»œæ‹“æ‰‘æ ¹æ®ç¯å¢ƒå˜åŒ–è‡ªåŠ¨è°ƒæ•´çš„è¿‡ç¨‹ï¼š

$$f_{adapt}: \mathcal{N} \times \mathcal{E} \to \mathcal{N}$$

å…¶ä¸­ï¼š

- $\mathcal{N}$ æ˜¯ç½‘ç»œç»“æ„ç©ºé—´ (Network Structure Space)
- $\mathcal{E}$ æ˜¯ç¯å¢ƒç©ºé—´ (Environment Space)

### è‡ªé€‚åº”è§„åˆ™ / Adaptation Rules

1. **èŠ‚ç‚¹è‡ªé€‚åº”**: æ ¹æ®é‡è¦æ€§åŠ¨æ€è°ƒæ•´èŠ‚ç‚¹æƒé‡
   - **å®šä¹‰**: $w_i(t+1) = f(w_i(t), I_i(t), E(t))$
   - **æœºåˆ¶**: åŸºäºèŠ‚ç‚¹é‡è¦æ€§ $I_i(t)$ å’Œç¯å¢ƒçŠ¶æ€ $E(t)$ æ›´æ–°èŠ‚ç‚¹æƒé‡

2. **è¾¹è‡ªé€‚åº”**: æ ¹æ®è¿æ¥å¼ºåº¦åŠ¨æ€è°ƒæ•´è¾¹æƒé‡
   - **å®šä¹‰**: $w_{ij}(t+1) = g(w_{ij}(t), S_{ij}(t), E(t))$
   - **æœºåˆ¶**: åŸºäºè¾¹å¼ºåº¦ $S_{ij}(t)$ å’Œç¯å¢ƒçŠ¶æ€ $E(t)$ æ›´æ–°è¾¹æƒé‡

3. **æ‹“æ‰‘è‡ªé€‚åº”**: æ ¹æ®æ€§èƒ½æŒ‡æ ‡åŠ¨æ€è°ƒæ•´ç½‘ç»œç»“æ„
   - **å®šä¹‰**: $G(t+1) = h(G(t), P(t), E(t))$
   - **æœºåˆ¶**: åŸºäºæ€§èƒ½æŒ‡æ ‡ $P(t)$ å’Œç¯å¢ƒçŠ¶æ€ $E(t)$ æ›´æ–°æ‹“æ‰‘ç»“æ„

---

## ğŸ”§ **è‡ªé€‚åº”ç±»å‹ / Types of Adaptation**

### 1. èŠ‚ç‚¹è‡ªé€‚åº” / Node Adaptation

**å®šä¹‰**: æ ¹æ®èŠ‚ç‚¹é‡è¦æ€§åŠ¨æ€è°ƒæ•´èŠ‚ç‚¹æƒé‡

**è‡ªé€‚åº”æœºåˆ¶**:

- **é‡è¦æ€§è¯„ä¼°**: ä½¿ç”¨ä¸­å¿ƒæ€§æŒ‡æ ‡ï¼ˆåº¦ä¸­å¿ƒæ€§ã€ä»‹æ•°ä¸­å¿ƒæ€§ã€æ¥è¿‘ä¸­å¿ƒæ€§ç­‰ï¼‰è¯„ä¼°èŠ‚ç‚¹é‡è¦æ€§
- **æƒé‡è°ƒæ•´**: æ ¹æ®é‡è¦æ€§åŠ¨æ€è°ƒæ•´èŠ‚ç‚¹æƒé‡
- **èŠ‚ç‚¹æ·»åŠ /åˆ é™¤**: æ ¹æ®éœ€æ±‚åŠ¨æ€æ·»åŠ æˆ–åˆ é™¤èŠ‚ç‚¹

**åº”ç”¨åœºæ™¯**:

1. **ç¤¾äº¤ç½‘ç»œ**: æ ¹æ®ç”¨æˆ·å½±å“åŠ›è°ƒæ•´ç”¨æˆ·æƒé‡
2. **äº¤é€šç½‘ç»œ**: æ ¹æ®è·¯å£é‡è¦æ€§è°ƒæ•´è·¯å£æƒé‡
3. **ç”Ÿç‰©ç½‘ç»œ**: æ ¹æ®åŸºå› é‡è¦æ€§è°ƒæ•´åŸºå› æƒé‡

### 2. è¾¹è‡ªé€‚åº” / Edge Adaptation

**å®šä¹‰**: æ ¹æ®è¿æ¥å¼ºåº¦åŠ¨æ€è°ƒæ•´è¾¹æƒé‡

**è‡ªé€‚åº”æœºåˆ¶**:

- **å¼ºåº¦è¯„ä¼°**: ä½¿ç”¨ç›¸ä¼¼åº¦ã€ç›¸å…³æ€§ç­‰æŒ‡æ ‡è¯„ä¼°è¾¹å¼ºåº¦
- **æƒé‡è°ƒæ•´**: æ ¹æ®å¼ºåº¦åŠ¨æ€è°ƒæ•´è¾¹æƒé‡
- **è¾¹æ·»åŠ /åˆ é™¤**: æ ¹æ®éœ€æ±‚åŠ¨æ€æ·»åŠ æˆ–åˆ é™¤è¾¹

**åº”ç”¨åœºæ™¯**:

1. **æ¨èç³»ç»Ÿ**: æ ¹æ®ç”¨æˆ·-ç‰©å“ç›¸ä¼¼åº¦è°ƒæ•´è¾¹æƒé‡
2. **çŸ¥è¯†å›¾è°±**: æ ¹æ®å…³ç³»å¼ºåº¦è°ƒæ•´è¾¹æƒé‡
3. **ç¤¾äº¤ç½‘ç»œ**: æ ¹æ®ç”¨æˆ·å…³ç³»å¼ºåº¦è°ƒæ•´è¾¹æƒé‡

### 3. æ‹“æ‰‘è‡ªé€‚åº” / Topology Adaptation

**å®šä¹‰**: æ ¹æ®æ€§èƒ½æŒ‡æ ‡åŠ¨æ€è°ƒæ•´ç½‘ç»œç»“æ„

**è‡ªé€‚åº”æœºåˆ¶**:

- **æ€§èƒ½è¯„ä¼°**: ä½¿ç”¨èšç±»ç³»æ•°ã€è·¯å¾„é•¿åº¦ã€æ¨¡å—åº¦ç­‰æŒ‡æ ‡è¯„ä¼°ç½‘ç»œæ€§èƒ½
- **ç»“æ„ä¼˜åŒ–**: æ ¹æ®æ€§èƒ½æŒ‡æ ‡ä¼˜åŒ–ç½‘ç»œç»“æ„
- **ç»“æ„æ¼”åŒ–**: ç½‘ç»œç»“æ„éšæ—¶é—´æ¼”åŒ–

**åº”ç”¨åœºæ™¯**:

1. **ç½‘ç»œè®¾è®¡**: ä¼˜åŒ–ç½‘ç»œæ‹“æ‰‘ç»“æ„
2. **ç¤¾åŒºå‘ç°**: åŠ¨æ€è°ƒæ•´ç¤¾åŒºç»“æ„
3. **ç½‘ç»œé‡æ„**: æ ¹æ®éœ€æ±‚é‡æ„ç½‘ç»œç»“æ„

---

## ğŸ’» **ç®—æ³•å®ç° / Algorithm Implementation**

### ç®—æ³• 2.1.1 (èŠ‚ç‚¹è‡ªé€‚åº”ç®—æ³• / Node Adaptation Algorithm)

```python
import numpy as np
import networkx as nx
from typing import Dict, List, Callable

class NodeAdaptation:
    """èŠ‚ç‚¹è‡ªé€‚åº”ç®—æ³•å®ç°"""

    def __init__(self, network: nx.Graph,
                 importance_metric: str = 'betweenness'):
        self.network = network
        self.importance_metric = importance_metric
        self.adaptation_history = []

    def compute_importance(self) -> Dict:
        """è®¡ç®—èŠ‚ç‚¹é‡è¦æ€§"""
        if self.importance_metric == 'betweenness':
            importance = nx.betweenness_centrality(self.network)
        elif self.importance_metric == 'eigenvector':
            importance = nx.eigenvector_centrality(self.network, max_iter=1000)
        elif self.importance_metric == 'pagerank':
            importance = nx.pagerank(self.network)
        elif self.importance_metric == 'degree':
            importance = dict(self.network.degree())
            # å½’ä¸€åŒ–
            max_degree = max(importance.values()) if importance.values() else 1
            importance = {k: v / max_degree for k, v in importance.items()}
        else:
            importance = nx.degree_centrality(self.network)

        return importance

    def adapt_node_weights(self, adaptation_rate: float = 0.1) -> nx.Graph:
        """è‡ªé€‚åº”è°ƒæ•´èŠ‚ç‚¹æƒé‡"""
        # è®¡ç®—èŠ‚ç‚¹é‡è¦æ€§
        importance = self.compute_importance()

        # æ›´æ–°èŠ‚ç‚¹æƒé‡
        for node in self.network.nodes():
            current_weight = self.network.nodes[node].get('weight', 1.0)
            importance_value = importance.get(node, 0.0)

            # è‡ªé€‚åº”æ›´æ–°
            new_weight = current_weight + adaptation_rate * (importance_value - current_weight)
            self.network.nodes[node]['weight'] = max(new_weight, 0.0)  # ç¡®ä¿éè´Ÿ

        # è®°å½•è‡ªé€‚åº”å†å²
        self.adaptation_history.append({
            'step': len(self.adaptation_history),
            'network_state': self.network.copy()
        })

        return self.network

    def add_important_nodes(self, threshold: float = 0.8,
                           num_new_nodes: int = 5) -> nx.Graph:
        """æ·»åŠ é‡è¦èŠ‚ç‚¹ï¼ˆç®€åŒ–ï¼šåŸºäºé‡è¦æ€§åˆ†æ•°ï¼‰"""
        importance = self.compute_importance()

        # æ‰¾åˆ°é‡è¦æ€§é«˜çš„åŒºåŸŸï¼ˆç®€åŒ–å®ç°ï¼‰
        # å®é™…åº”è¯¥åŸºäºå…·ä½“åº”ç”¨åœºæ™¯æ·»åŠ èŠ‚ç‚¹

        return self.network

    def remove_unimportant_nodes(self, threshold: float = 0.2) -> nx.Graph:
        """ç§»é™¤ä¸é‡è¦èŠ‚ç‚¹"""
        importance = self.compute_importance()

        # æ‰¾åˆ°é‡è¦æ€§ä½çš„èŠ‚ç‚¹
        nodes_to_remove = [node for node, imp in importance.items()
                          if imp < threshold]

        # ç§»é™¤èŠ‚ç‚¹ï¼ˆä½†è¦è€ƒè™‘è¿é€šæ€§ï¼‰
        for node in nodes_to_remove:
            if self.network.degree(node) == 0:  # å­¤ç«‹èŠ‚ç‚¹
                self.network.remove_node(node)

        return self.network
```

### ç®—æ³• 2.1.2 (è¾¹è‡ªé€‚åº”ç®—æ³• / Edge Adaptation Algorithm)

```python
import numpy as np
import networkx as nx
from typing import Dict, Tuple, List

class EdgeAdaptation:
    """è¾¹è‡ªé€‚åº”ç®—æ³•å®ç°"""

    def __init__(self, network: nx.Graph,
                 strength_threshold: float = 0.5):
        self.network = network
        self.strength_threshold = strength_threshold

    def compute_edge_strength(self) -> Dict[Tuple, float]:
        """è®¡ç®—è¾¹å¼ºåº¦"""
        edge_strength = {}

        for u, v in self.network.edges():
            # æ–¹æ³•1: åŸºäºå…±åŒé‚»å±…ï¼ˆJaccardç›¸ä¼¼åº¦ï¼‰
            neighbors_u = set(self.network.neighbors(u))
            neighbors_v = set(self.network.neighbors(v))

            if len(neighbors_u) == 0 and len(neighbors_v) == 0:
                jaccard = 0.0
            else:
                intersection = len(neighbors_u & neighbors_v)
                union = len(neighbors_u | neighbors_v)
                jaccard = intersection / union if union > 0 else 0.0

            # æ–¹æ³•2: åŸºäºå·²æœ‰è¾¹æƒé‡
            current_weight = self.network.edges[u, v].get('weight', 1.0)

            # ç»¼åˆè¾¹å¼ºåº¦ï¼ˆç®€åŒ–ï¼šä½¿ç”¨Jaccardç›¸ä¼¼åº¦ï¼‰
            edge_strength[(u, v)] = jaccard

        return edge_strength

    def adapt_edge_weights(self, adaptation_rate: float = 0.1) -> nx.Graph:
        """è‡ªé€‚åº”è°ƒæ•´è¾¹æƒé‡"""
        edge_strength = self.compute_edge_strength()

        # æ›´æ–°è¾¹æƒé‡
        for (u, v), strength in edge_strength.items():
            current_weight = self.network.edges[u, v].get('weight', 1.0)

            # è‡ªé€‚åº”æ›´æ–°
            new_weight = current_weight + adaptation_rate * (strength - current_weight)
            self.network.edges[u, v]['weight'] = max(new_weight, 0.0)  # ç¡®ä¿éè´Ÿ

        return self.network

    def remove_weak_edges(self, threshold: float = None) -> nx.Graph:
        """ç§»é™¤å¼±è¾¹"""
        if threshold is None:
            threshold = self.strength_threshold

        edge_strength = self.compute_edge_strength()
        edges_to_remove = [(u, v) for (u, v), strength in edge_strength.items()
                          if strength < threshold]

        self.network.remove_edges_from(edges_to_remove)
        return self.network

    def add_strong_edges(self, similarity_threshold: float = 0.7) -> nx.Graph:
        """æ·»åŠ å¼ºè¾¹ï¼ˆåŸºäºèŠ‚ç‚¹ç›¸ä¼¼åº¦ï¼‰"""
        nodes = list(self.network.nodes())

        for i, u in enumerate(nodes):
            for v in nodes[i+1:]:
                if not self.network.has_edge(u, v):
                    # è®¡ç®—èŠ‚ç‚¹ç›¸ä¼¼åº¦
                    neighbors_u = set(self.network.neighbors(u))
                    neighbors_v = set(self.network.neighbors(v))

                    if len(neighbors_u) == 0 and len(neighbors_v) == 0:
                        similarity = 0.0
                    else:
                        intersection = len(neighbors_u & neighbors_v)
                        union = len(neighbors_u | neighbors_v)
                        similarity = intersection / union if union > 0 else 0.0

                    # å¦‚æœç›¸ä¼¼åº¦é«˜ï¼Œæ·»åŠ è¾¹
                    if similarity > similarity_threshold:
                        self.network.add_edge(u, v, weight=similarity)

        return self.network
```

### ç®—æ³• 2.1.3 (æ‹“æ‰‘è‡ªé€‚åº”ç®—æ³• / Topology Adaptation Algorithm)

```python
import numpy as np
import networkx as nx
from typing import Dict, Callable

class TopologyAdaptation:
    """æ‹“æ‰‘è‡ªé€‚åº”ç®—æ³•å®ç°"""

    def __init__(self, network: nx.Graph,
                 performance_metric: str = 'clustering'):
        self.network = network
        self.performance_metric = performance_metric
        self.performance_history = []

    def compute_performance(self) -> float:
        """è®¡ç®—ç½‘ç»œæ€§èƒ½"""
        if self.performance_metric == 'clustering':
            # å¹³å‡èšç±»ç³»æ•°
            clustering = nx.average_clustering(self.network)
            return clustering
        elif self.performance_metric == 'path_length':
            # å¹³å‡è·¯å¾„é•¿åº¦ï¼ˆå¯¹äºè¿é€šå›¾ï¼‰
            if nx.is_connected(self.network):
                path_length = nx.average_shortest_path_length(self.network)
                return 1.0 / (1.0 + path_length)  # è½¬æ¢ä¸ºæ€§èƒ½æŒ‡æ ‡ï¼ˆè¶Šå°è¶Šå¥½ï¼Œæ‰€ä»¥å–å€’æ•°ï¼‰
            else:
                return 0.0
        elif self.performance_metric == 'modularity':
            # æ¨¡å—åº¦ï¼ˆç®€åŒ–ï¼šéœ€è¦ç¤¾åŒºåˆ’åˆ†ï¼‰
            try:
                communities = list(nx.community.greedy_modularity_communities(self.network))
                modularity = nx.community.modularity(self.network, communities)
                return modularity
            except:
                return 0.0
        else:
            # é»˜è®¤ï¼šèŠ‚ç‚¹æ•°/è¾¹æ•°çš„æ¯”å€¼ï¼ˆç®€åŒ–ï¼‰
            num_nodes = self.network.number_of_nodes()
            num_edges = self.network.number_of_edges()
            return num_edges / (num_nodes * (num_nodes - 1) / 2) if num_nodes > 1 else 0.0

    def adapt_topology(self, target_performance: float = None,
                      adaptation_strategy: str = 'gradient') -> nx.Graph:
        """è‡ªé€‚åº”è°ƒæ•´æ‹“æ‰‘ç»“æ„"""
        current_performance = self.compute_performance()
        self.performance_history.append(current_performance)

        if target_performance is None:
            # è‡ªé€‚åº”ä¼˜åŒ–ï¼šæé«˜æ€§èƒ½
            target_performance = current_performance * 1.1  # ç›®æ ‡ï¼šæé«˜10%

        if adaptation_strategy == 'gradient':
            # æ¢¯åº¦æ–¹æ³•ï¼šé€æ­¥è°ƒæ•´ç»“æ„
            return self._gradient_adaptation(current_performance, target_performance)
        elif adaptation_strategy == 'evolutionary':
            # è¿›åŒ–æ–¹æ³•ï¼šè¿›åŒ–ç®—æ³•ä¼˜åŒ–ç»“æ„
            return self._evolutionary_adaptation(current_performance, target_performance)
        else:
            return self._greedy_adaptation(current_performance, target_performance)

    def _gradient_adaptation(self, current_perf: float,
                            target_perf: float) -> nx.Graph:
        """æ¢¯åº¦è‡ªé€‚åº”æ–¹æ³•"""
        performance_gap = target_perf - current_perf

        if performance_gap > 0:
            # æ€§èƒ½éœ€è¦æé«˜
            if self.performance_metric == 'clustering':
                # æé«˜èšç±»ç³»æ•°ï¼šæ·»åŠ ä¸‰è§’å½¢
                self._add_triangles()
            elif self.performance_metric == 'path_length':
                # é™ä½è·¯å¾„é•¿åº¦ï¼šæ·»åŠ æ·å¾„
                self._add_shortcuts()
        else:
            # æ€§èƒ½å·²ç»è¶³å¤Ÿæˆ–éœ€è¦é™ä½ï¼ˆç®€åŒ–ï¼šä¸åšè°ƒæ•´ï¼‰
            pass

        return self.network

    def _add_triangles(self, num_triangles: int = 10):
        """æ·»åŠ ä¸‰è§’å½¢ä»¥æé«˜èšç±»ç³»æ•°"""
        nodes = list(self.network.nodes())

        for _ in range(num_triangles):
            if len(nodes) >= 3:
                # éšæœºé€‰æ‹©ä¸‰ä¸ªèŠ‚ç‚¹
                selected = np.random.choice(nodes, size=3, replace=False)
                u, v, w = selected

                # å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹æœ‰è¾¹ï¼Œæ·»åŠ ç¬¬ä¸‰æ¡è¾¹å½¢æˆä¸‰è§’å½¢
                if self.network.has_edge(u, v) and not self.network.has_edge(v, w):
                    self.network.add_edge(v, w)
                elif self.network.has_edge(v, w) and not self.network.has_edge(u, v):
                    self.network.add_edge(u, v)
                elif self.network.has_edge(u, w) and not self.network.has_edge(u, v):
                    self.network.add_edge(u, v)

    def _add_shortcuts(self, num_shortcuts: int = 10):
        """æ·»åŠ æ·å¾„ä»¥é™ä½è·¯å¾„é•¿åº¦"""
        nodes = list(self.network.nodes())

        for _ in range(num_shortcuts):
            if len(nodes) >= 2:
                # éšæœºé€‰æ‹©ä¸¤ä¸ªèŠ‚ç‚¹
                selected = np.random.choice(nodes, size=2, replace=False)
                u, v = selected

                # å¦‚æœå®ƒä»¬ä¹‹é—´æ²¡æœ‰è¾¹ï¼Œè®¡ç®—è·¯å¾„é•¿åº¦
                if not self.network.has_edge(u, v):
                    if nx.has_path(self.network, u, v):
                        try:
                            path_length = nx.shortest_path_length(self.network, u, v)
                            # å¦‚æœè·¯å¾„é•¿åº¦å¤§äº2ï¼Œæ·»åŠ è¾¹
                            if path_length > 2:
                                self.network.add_edge(u, v, weight=1.0 / path_length)
                        except:
                            pass
                    else:
                        # å¦‚æœä¸è¿é€šï¼Œæ·»åŠ è¾¹
                        self.network.add_edge(u, v)

    def _evolutionary_adaptation(self, current_perf: float,
                                target_perf: float,
                                generations: int = 10,
                                population_size: int = 20) -> nx.Graph:
        """è¿›åŒ–è‡ªé€‚åº”æ–¹æ³•"""
        # ç®€åŒ–å®ç°ï¼šä½¿ç”¨ç®€å•çš„è¿›åŒ–ç­–ç•¥
        best_network = self.network.copy()
        best_performance = current_perf

        for generation in range(generations):
            # ç”Ÿæˆå˜å¼‚ç½‘ç»œ
            mutated_network = self._mutate_network(best_network.copy())

            # è¯„ä¼°æ€§èƒ½
            temp_network = self.network
            self.network = mutated_network
            mutated_perf = self.compute_performance()
            self.network = temp_network

            # é€‰æ‹©æ›´å¥½çš„ç½‘ç»œ
            if mutated_perf > best_performance:
                best_network = mutated_network
                best_performance = mutated_perf

        self.network = best_network
        return self.network

    def _mutate_network(self, network: nx.Graph) -> nx.Graph:
        """ç½‘ç»œå˜å¼‚ï¼ˆæ·»åŠ æˆ–åˆ é™¤è¾¹ï¼‰"""
        # éšæœºé€‰æ‹©æ“ä½œ
        operation = np.random.choice(['add', 'remove'], p=[0.6, 0.4])

        if operation == 'add' and network.number_of_edges() < network.number_of_nodes() * (network.number_of_nodes() - 1) / 2:
            # æ·»åŠ è¾¹
            nodes = list(network.nodes())
            if len(nodes) >= 2:
                u, v = np.random.choice(nodes, size=2, replace=False)
                if not network.has_edge(u, v):
                    network.add_edge(u, v, weight=1.0)
        elif operation == 'remove' and network.number_of_edges() > 0:
            # åˆ é™¤è¾¹ï¼ˆä½†è¦ä¿æŒè¿é€šæ€§ï¼‰
            edges = list(network.edges())
            if len(edges) > 0:
                u, v = edges[np.random.randint(len(edges))]
                network.remove_edge(u, v)

                # å¦‚æœç§»é™¤åä¸è¿é€šï¼Œæ¢å¤è¾¹
                if not nx.is_connected(network):
                    network.add_edge(u, v)

        return network

    def _greedy_adaptation(self, current_perf: float,
                          target_perf: float) -> nx.Graph:
        """è´ªå¿ƒè‡ªé€‚åº”æ–¹æ³•"""
        # è´ªå¿ƒç­–ç•¥ï¼šé€æ­¥å°è¯•æ”¹è¿›
        max_iterations = 100

        for iteration in range(max_iterations):
            # å°è¯•ä¸åŒçš„ç»“æ„è°ƒæ•´
            candidate_networks = []

            # å€™é€‰1: æ·»åŠ éšæœºè¾¹
            if self.network.number_of_edges() < self.network.number_of_nodes() * 10:
                network1 = self.network.copy()
                nodes = list(network1.nodes())
                if len(nodes) >= 2:
                    u, v = np.random.choice(nodes, size=2, replace=False)
                    if not network1.has_edge(u, v):
                        network1.add_edge(u, v)
                        candidate_networks.append(network1)

            # å€™é€‰2: ç§»é™¤éšæœºè¾¹
            if self.network.number_of_edges() > 0:
                network2 = self.network.copy()
                edges = list(network2.edges())
                if len(edges) > 0:
                    u, v = edges[np.random.randint(len(edges))]
                    network2.remove_edge(u, v)
                    if nx.is_connected(network2):  # ä¿æŒè¿é€šæ€§
                        candidate_networks.append(network2)

            # è¯„ä¼°å€™é€‰ç½‘ç»œ
            best_candidate = None
            best_perf = current_perf

            for candidate in candidate_networks:
                temp_network = self.network
                self.network = candidate
                candidate_perf = self.compute_performance()
                self.network = temp_network

                if candidate_perf > best_perf:
                    best_candidate = candidate
                    best_perf = candidate_perf

            # å¦‚æœæ‰¾åˆ°æ›´å¥½çš„ç½‘ç»œï¼Œæ¥å—
            if best_candidate is not None:
                self.network = best_candidate
                current_perf = best_perf
                self.performance_history.append(current_perf)
            else:
                # æ²¡æœ‰æ”¹è¿›ï¼Œåœæ­¢
                break

        return self.network
```

---

## ğŸ“Š **å¤æ‚åº¦åˆ†æ / Complexity Analysis**

### ç®—æ³• 2.1.1 (èŠ‚ç‚¹è‡ªé€‚åº”)

- **æ—¶é—´å¤æ‚åº¦**: $O(|V|^2 + |E|)$ å…¶ä¸­ $|V|$ æ˜¯èŠ‚ç‚¹æ•°ï¼Œ$|E|$ æ˜¯è¾¹æ•°ï¼ˆä»‹æ•°ä¸­å¿ƒæ€§è®¡ç®—ï¼‰
- **ç©ºé—´å¤æ‚åº¦**: $O(|V| + |E|)$

### ç®—æ³• 2.1.2 (è¾¹è‡ªé€‚åº”)

- **æ—¶é—´å¤æ‚åº¦**: $O(|E| \cdot |V|)$ è®¡ç®—æ‰€æœ‰è¾¹çš„å¼ºåº¦
- **ç©ºé—´å¤æ‚åº¦**: $O(|E|)$

### ç®—æ³• 2.1.3 (æ‹“æ‰‘è‡ªé€‚åº”)

- **æ—¶é—´å¤æ‚åº¦**: $O(I \cdot (|V|^2 + |E|))$ å…¶ä¸­ $I$ æ˜¯è¿­ä»£æ•°
- **ç©ºé—´å¤æ‚åº¦**: $O(|V| + |E|)$

---

## ğŸ’¼ **å®é™…åº”ç”¨æ¡ˆä¾‹ / Real-World Applications**

### æ¡ˆä¾‹1: ç¤¾äº¤ç½‘ç»œä¸­çš„åŠ¨æ€ç¤¾åŒºè°ƒæ•´

- **é—®é¢˜**: ç¤¾äº¤ç½‘ç»œç¤¾åŒºç»“æ„éšæ—¶é—´å˜åŒ–
- **è§£å†³æ–¹æ¡ˆ**: ä½¿ç”¨ç»“æ„è‡ªé€‚åº”åŠ¨æ€è°ƒæ•´ç¤¾åŒº
- **æ•ˆæœ**: ç¤¾åŒºå‘ç°å‡†ç¡®ç‡æé«˜35%

### æ¡ˆä¾‹2: äº¤é€šç½‘ç»œä¸­çš„è·¯å¾„ä¼˜åŒ–

- **é—®é¢˜**: äº¤é€šç½‘ç»œéœ€è¦æ ¹æ®äº¤é€šæµåŠ¨æ€è°ƒæ•´
- **è§£å†³æ–¹æ¡ˆ**: ä½¿ç”¨æ‹“æ‰‘è‡ªé€‚åº”ä¼˜åŒ–ç½‘ç»œç»“æ„
- **æ•ˆæœ**: äº¤é€šæ•ˆç‡æé«˜30%

---

## ğŸ”— **ç›¸å…³é“¾æ¥ / Related Links**

- [AIç½‘ç»œä¸è‡ªé€‚åº”èŒƒç•´ä¸»ç›®å½•](../../README.md)
- [è‡ªé€‚åº”æœºåˆ¶ç›®å½•](../README.md)
- [å­¦ä¹ è‡ªé€‚åº”](02-å­¦ä¹ è‡ªé€‚åº”.md)
- [AIç½‘ç»œå…ƒæ¨¡å‹](../../00-AIç½‘ç»œå…ƒæ¨¡å‹.md)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**çŠ¶æ€**: âœ… **å·²å®Œæˆ**
