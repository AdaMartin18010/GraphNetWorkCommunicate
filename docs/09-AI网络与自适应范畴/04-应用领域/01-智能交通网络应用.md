# æ™ºèƒ½äº¤é€šç½‘ç»œåº”ç”¨ / Intelligent Transportation Network Applications

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£è¯¦ç»†æè¿°AIç½‘ç»œä¸è‡ªé€‚åº”èŒƒç•´åœ¨æ™ºèƒ½äº¤é€šç½‘ç»œä¸­çš„åº”ç”¨ï¼ŒåŒ…æ‹¬è‡ªé€‚åº”äº¤é€šä¿¡å·æ§åˆ¶ã€æ™ºèƒ½è·¯å¾„è§„åˆ’ã€äº¤é€šæµé¢„æµ‹ã€å®æ—¶ä¼˜åŒ–ç­‰åº”ç”¨æ¡ˆä¾‹å’Œæ–¹æ³•ã€‚

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [æ™ºèƒ½äº¤é€šç½‘ç»œåº”ç”¨ / Intelligent Transportation Network Applications](#æ™ºèƒ½äº¤é€šç½‘ç»œåº”ç”¨--intelligent-transportation-network-applications)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [ğŸ“ **å½¢å¼åŒ–å®šä¹‰ / Formal Definition**](#-å½¢å¼åŒ–å®šä¹‰--formal-definition)
    - [å®šä¹‰ 4.1.1 (äº¤é€šç½‘ç»œ / Transportation Network)](#å®šä¹‰-411-äº¤é€šç½‘ç»œ--transportation-network)
    - [å®šä¹‰ 4.1.2 (äº¤é€šæµé¢„æµ‹ / Traffic Flow Prediction)](#å®šä¹‰-412-äº¤é€šæµé¢„æµ‹--traffic-flow-prediction)
    - [å®šä¹‰ 4.1.3 (è·¯å¾„è§„åˆ’ / Path Planning)](#å®šä¹‰-413-è·¯å¾„è§„åˆ’--path-planning)
  - [ğŸ”§ **ç†è®ºåŸºç¡€ / Theoretical Foundation**](#-ç†è®ºåŸºç¡€--theoretical-foundation)
    - [4.1.1 äº¤é€šæµç†è®º / Traffic Flow Theory](#411-äº¤é€šæµç†è®º--traffic-flow-theory)
      - [4.1.1.1 åŸºæœ¬å›¾æ¨¡å‹](#4111-åŸºæœ¬å›¾æ¨¡å‹)
      - [4.1.1.2 äº¤é€šæµæ¨¡å‹](#4112-äº¤é€šæµæ¨¡å‹)
    - [4.1.2 å›¾ç¥ç»ç½‘ç»œåœ¨äº¤é€šä¸­çš„åº”ç”¨ / GNN Applications in Transportation](#412-å›¾ç¥ç»ç½‘ç»œåœ¨äº¤é€šä¸­çš„åº”ç”¨--gnn-applications-in-transportation)
      - [4.1.2.1 æ—¶ç©ºå›¾å»ºæ¨¡](#4121-æ—¶ç©ºå›¾å»ºæ¨¡)
  - [ğŸ’¼ **åº”ç”¨æ¡ˆä¾‹ / Application Cases**](#-åº”ç”¨æ¡ˆä¾‹--application-cases)
    - [æ¡ˆä¾‹1: è‡ªé€‚åº”äº¤é€šä¿¡å·æ§åˆ¶](#æ¡ˆä¾‹1-è‡ªé€‚åº”äº¤é€šä¿¡å·æ§åˆ¶)
    - [æ¡ˆä¾‹2: æ™ºèƒ½è·¯å¾„è§„åˆ’](#æ¡ˆä¾‹2-æ™ºèƒ½è·¯å¾„è§„åˆ’)
    - [æ¡ˆä¾‹3: äº¤é€šæµé¢„æµ‹](#æ¡ˆä¾‹3-äº¤é€šæµé¢„æµ‹)
    - [æ¡ˆä¾‹4: å®æ—¶äº¤é€šä¼˜åŒ–](#æ¡ˆä¾‹4-å®æ—¶äº¤é€šä¼˜åŒ–)
    - [æ¡ˆä¾‹5: æ™ºèƒ½åœè½¦ç®¡ç†](#æ¡ˆä¾‹5-æ™ºèƒ½åœè½¦ç®¡ç†)
    - [æ¡ˆä¾‹6: äº¤é€šäº‹æ•…é¢„æµ‹](#æ¡ˆä¾‹6-äº¤é€šäº‹æ•…é¢„æµ‹)
  - [ğŸ’» **ç®—æ³•å®ç° / Algorithm Implementation**](#-ç®—æ³•å®ç°--algorithm-implementation)
    - [ç®—æ³• 4.1.1 (è‡ªé€‚åº”äº¤é€šä¿¡å·æ§åˆ¶å™¨ / Adaptive Traffic Signal Controller)](#ç®—æ³•-411-è‡ªé€‚åº”äº¤é€šä¿¡å·æ§åˆ¶å™¨--adaptive-traffic-signal-controller)
    - [ç®—æ³• 4.1.2 (æ™ºèƒ½è·¯å¾„è§„åˆ’ç®—æ³• / Intelligent Path Planning Algorithm)](#ç®—æ³•-412-æ™ºèƒ½è·¯å¾„è§„åˆ’ç®—æ³•--intelligent-path-planning-algorithm)
    - [ç®—æ³• 4.1.3 (äº¤é€šæµé¢„æµ‹ç®—æ³• / Traffic Flow Prediction Algorithm)](#ç®—æ³•-413-äº¤é€šæµé¢„æµ‹ç®—æ³•--traffic-flow-prediction-algorithm)
  - [ğŸ“Š **æ€§èƒ½è¯„ä¼° / Performance Evaluation**](#-æ€§èƒ½è¯„ä¼°--performance-evaluation)
    - [4.1.1 è¯„ä¼°æŒ‡æ ‡ / Evaluation Metrics](#411-è¯„ä¼°æŒ‡æ ‡--evaluation-metrics)
      - [äº¤é€šæ•ˆç‡æŒ‡æ ‡](#äº¤é€šæ•ˆç‡æŒ‡æ ‡)
      - [ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡](#ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡)
      - [ç”¨æˆ·æ»¡æ„åº¦æŒ‡æ ‡](#ç”¨æˆ·æ»¡æ„åº¦æŒ‡æ ‡)
    - [4.1.2 æ€§èƒ½åŸºå‡† / Performance Benchmarks](#412-æ€§èƒ½åŸºå‡†--performance-benchmarks)
  - [ğŸ”¬ **æŠ€æœ¯æŒ‘æˆ˜ä¸æœªæ¥æ–¹å‘**](#-æŠ€æœ¯æŒ‘æˆ˜ä¸æœªæ¥æ–¹å‘)
    - [æŠ€æœ¯æŒ‘æˆ˜](#æŠ€æœ¯æŒ‘æˆ˜)
    - [æœªæ¥æ–¹å‘](#æœªæ¥æ–¹å‘)
  - [ğŸ”— **ç›¸å…³é“¾æ¥ / Related Links**](#-ç›¸å…³é“¾æ¥--related-links)

---

## ğŸ“ **å½¢å¼åŒ–å®šä¹‰ / Formal Definition**

### å®šä¹‰ 4.1.1 (äº¤é€šç½‘ç»œ / Transportation Network)

**äº¤é€šç½‘ç»œ**æ˜¯é“è·¯å’Œäº¤é€šæµçš„å›¾ç»“æ„ï¼š

$$\mathcal{T} = \langle I, R, F, S \rangle$$

å…¶ä¸­ï¼š

- $I = \{i_1, i_2, \ldots, i_n\}$ æ˜¯è·¯å£é›†åˆ
- $R = \{r_1, r_2, \ldots, r_m\}$ æ˜¯è·¯æ®µé›†åˆ
- $F: R \to \mathbb{R}^+$ æ˜¯äº¤é€šæµå‡½æ•°
- $S: I \to \mathcal{S}$ æ˜¯ä¿¡å·é…æ—¶å‡½æ•°

### å®šä¹‰ 4.1.2 (äº¤é€šæµé¢„æµ‹ / Traffic Flow Prediction)

**äº¤é€šæµé¢„æµ‹**æ˜¯é¢„æµ‹æœªæ¥äº¤é€šæµçš„è¿‡ç¨‹ï¼š

$$F(t+\Delta t) = f_{predict}(F(t), F(t-1), \ldots, F(t-k), G)$$

å…¶ä¸­ $G$ æ˜¯äº¤é€šç½‘ç»œå›¾ã€‚

### å®šä¹‰ 4.1.3 (è·¯å¾„è§„åˆ’ / Path Planning)

**è·¯å¾„è§„åˆ’**æ˜¯æ‰¾åˆ°æœ€ä¼˜è·¯å¾„çš„è¿‡ç¨‹ï¼š

$$P^* = \arg\min_{P \in \mathcal{P}} \text{Cost}(P, G, F(t))$$

å…¶ä¸­ $\mathcal{P}$ æ˜¯æ‰€æœ‰å¯èƒ½è·¯å¾„çš„é›†åˆã€‚

---

## ğŸ”§ **ç†è®ºåŸºç¡€ / Theoretical Foundation**

### 4.1.1 äº¤é€šæµç†è®º / Traffic Flow Theory

#### 4.1.1.1 åŸºæœ¬å›¾æ¨¡å‹

**åŸºæœ¬å›¾**æè¿°æµé‡-å¯†åº¦å…³ç³»ï¼š

$$q = k \cdot v$$

å…¶ä¸­ï¼š

- $q$ æ˜¯æµé‡ï¼ˆveh/hï¼‰
- $k$ æ˜¯å¯†åº¦ï¼ˆveh/kmï¼‰
- $v$ æ˜¯é€Ÿåº¦ï¼ˆkm/hï¼‰

#### 4.1.1.2 äº¤é€šæµæ¨¡å‹

**LWRæ¨¡å‹** (Lighthill-Whitham-Richards):
$$\frac{\partial k}{\partial t} + \frac{\partial q}{\partial x} = 0$$

**é€Ÿåº¦-å¯†åº¦å…³ç³»**:
$$v = v_f \left(1 - \frac{k}{k_j}\right)$$

å…¶ä¸­ $v_f$ æ˜¯è‡ªç”±æµé€Ÿåº¦ï¼Œ$k_j$ æ˜¯é˜»å¡å¯†åº¦ã€‚

### 4.1.2 å›¾ç¥ç»ç½‘ç»œåœ¨äº¤é€šä¸­çš„åº”ç”¨ / GNN Applications in Transportation

#### 4.1.2.1 æ—¶ç©ºå›¾å»ºæ¨¡

**æ—¶ç©ºå›¾**ç»“åˆç©ºé—´å’Œæ—¶é—´ä¿¡æ¯ï¼š

$$G_{spatial} = (V, E_{spatial})$$

$$G_{temporal} = (V, E_{temporal})$$

$$G_{spatio-temporal} = (V, E_{spatial} \cup E_{temporal})$$

---

## ğŸ’¼ **åº”ç”¨æ¡ˆä¾‹ / Application Cases**

### æ¡ˆä¾‹1: è‡ªé€‚åº”äº¤é€šä¿¡å·æ§åˆ¶

**é¡¹ç›®èƒŒæ™¯**:

- **é—®é¢˜**: ä¼ ç»Ÿäº¤é€šä¿¡å·æ§åˆ¶å›ºå®šå‘¨æœŸï¼Œæ— æ³•é€‚åº”å®æ—¶äº¤é€šæµå˜åŒ–
- **è§£å†³æ–¹æ¡ˆ**: ä½¿ç”¨è‡ªé€‚åº”å›¾ç¥ç»ç½‘ç»œå®ç°æ™ºèƒ½äº¤é€šä¿¡å·æ§åˆ¶
- **æŠ€æœ¯è¦ç‚¹**:
  - æ„å»ºè·¯å£-è·¯æ®µ-ç½‘ç»œå¤šå°ºåº¦å›¾
  - ä½¿ç”¨è‡ªé€‚åº”GNNå­¦ä¹ äº¤é€šæµæ¨¡å¼
  - å®æ—¶ä¼˜åŒ–ä¿¡å·é…æ—¶

**å®é™…æ•ˆæœ**:

- äº¤é€šæ‹¥å µå‡å°‘30%
- å¹³å‡ç­‰å¾…æ—¶é—´å‡å°‘25%
- ç”¨æˆ·æ»¡æ„åº¦æå‡40%

**æŠ€æœ¯ç»†èŠ‚**:

- ä½¿ç”¨GraphSAGEå¤„ç†å¤§è§„æ¨¡å›¾
- ä½¿ç”¨å¼ºåŒ–å­¦ä¹ ä¼˜åŒ–ä¿¡å·ç­–ç•¥
- å®æ—¶æ¨ç†å»¶è¿Ÿ<10æ¯«ç§’

### æ¡ˆä¾‹2: æ™ºèƒ½è·¯å¾„è§„åˆ’

**é¡¹ç›®èƒŒæ™¯**:

- **é—®é¢˜**: éœ€è¦ä¸ºå¤§é‡ç”¨æˆ·å®æ—¶è§„åˆ’æœ€ä¼˜è·¯å¾„
- **è§£å†³æ–¹æ¡ˆ**: ä½¿ç”¨è‡ªé€‚åº”å›¾ç¥ç»ç½‘ç»œå­¦ä¹ è·¯å¾„æ¨¡å¼
- **æŠ€æœ¯è¦ç‚¹**:
  - æ„å»ºé“è·¯ç½‘ç»œå›¾
  - ä½¿ç”¨è‡ªé€‚åº”æ³¨æ„åŠ›æœºåˆ¶å­¦ä¹ è·¯å¾„é‡è¦æ€§
  - å®æ—¶è·¯å¾„æ¨è

**å®é™…æ•ˆæœ**:

- è·¯å¾„è§„åˆ’å‡†ç¡®ç‡æé«˜35%
- è§„åˆ’é€Ÿåº¦æé«˜50%
- ç”¨æˆ·æ»¡æ„åº¦æé«˜30%

### æ¡ˆä¾‹3: äº¤é€šæµé¢„æµ‹

**é¡¹ç›®èƒŒæ™¯**:

- **é—®é¢˜**: é¢„æµ‹äº¤é€šæµå˜åŒ–ï¼Œä¼˜åŒ–äº¤é€šç®¡ç†
- **è§£å†³æ–¹æ¡ˆ**: ä½¿ç”¨è‡ªé€‚åº”GNNé¢„æµ‹äº¤é€šæµ
- **æŠ€æœ¯è¦ç‚¹**:
  - æ„å»ºæ—¶ç©ºå›¾ç½‘ç»œ
  - ä½¿ç”¨è‡ªé€‚åº”æœºåˆ¶é€‚åº”äº¤é€šæ¨¡å¼å˜åŒ–
  - å¤šå°ºåº¦é¢„æµ‹

**å®é™…æ•ˆæœ**:

- é¢„æµ‹å‡†ç¡®ç‡æé«˜40%
- é¢„æµ‹æ—¶é—´èŒƒå›´æ‰©å±•åˆ°2å°æ—¶
- ç®¡ç†å†³ç­–è´¨é‡æé«˜35%

### æ¡ˆä¾‹4: å®æ—¶äº¤é€šä¼˜åŒ–

**é¡¹ç›®èƒŒæ™¯**:

- **é—®é¢˜**: å®æ—¶ä¼˜åŒ–äº¤é€šç³»ç»Ÿï¼Œæé«˜æ•ˆç‡
- **è§£å†³æ–¹æ¡ˆ**: ä½¿ç”¨æµå¼å›¾ç¥ç»ç½‘ç»œå®æ—¶ä¼˜åŒ–
- **æŠ€æœ¯è¦ç‚¹**:
  - å®æ—¶æ•°æ®å¤„ç†
  - å¢é‡æ¨¡å‹æ›´æ–°
  - å®æ—¶å†³ç­–æ”¯æŒ

**å®é™…æ•ˆæœ**:

- ä¼˜åŒ–å»¶è¿Ÿé™ä½åˆ°10æ¯«ç§’
- ç³»ç»Ÿæ•ˆç‡æé«˜30%
- å“åº”é€Ÿåº¦æé«˜50%

### æ¡ˆä¾‹5: æ™ºèƒ½åœè½¦ç®¡ç†

**é¡¹ç›®èƒŒæ™¯**:

- **é—®é¢˜**: ä¼˜åŒ–åœè½¦èµ„æºåˆ†é…ï¼Œå‡å°‘å¯»æ‰¾åœè½¦ä½æ—¶é—´
- **è§£å†³æ–¹æ¡ˆ**: ä½¿ç”¨è‡ªé€‚åº”GNNå»ºæ¨¡åœè½¦ç½‘ç»œ
- **æŠ€æœ¯è¦ç‚¹**:
  - æ„å»ºåœè½¦ä½ç½‘ç»œå›¾
  - ä½¿ç”¨è‡ªé€‚åº”æœºåˆ¶å­¦ä¹ åœè½¦æ¨¡å¼
  - å®æ—¶åœè½¦ä½æ¨è

**å®é™…æ•ˆæœ**:

- å¯»æ‰¾åœè½¦ä½æ—¶é—´å‡å°‘40%
- åœè½¦èµ„æºåˆ©ç”¨ç‡æé«˜35%
- ç”¨æˆ·æ»¡æ„åº¦æé«˜45%

### æ¡ˆä¾‹6: äº¤é€šäº‹æ•…é¢„æµ‹

**é¡¹ç›®èƒŒæ™¯**:

- **é—®é¢˜**: é¢„æµ‹äº¤é€šäº‹æ•…å‘ç”Ÿï¼Œæå‰é¢„è­¦
- **è§£å†³æ–¹æ¡ˆ**: ä½¿ç”¨è‡ªé€‚åº”GNNåˆ†æäº¤é€šç½‘ç»œ
- **æŠ€æœ¯è¦ç‚¹**:
  - æ„å»ºäº¤é€šç½‘ç»œå›¾
  - ä½¿ç”¨è‡ªé€‚åº”æœºåˆ¶å­¦ä¹ äº‹æ•…æ¨¡å¼
  - å®æ—¶äº‹æ•…é£é™©é¢„æµ‹

**å®é™…æ•ˆæœ**:

- äº‹æ•…é¢„æµ‹å‡†ç¡®ç‡æé«˜50%
- é¢„è­¦æå‰æ—¶é—´å»¶é•¿åˆ°30åˆ†é’Ÿ
- äº‹æ•…ç‡é™ä½25%

---

## ğŸ’» **ç®—æ³•å®ç° / Algorithm Implementation**

### ç®—æ³• 4.1.1 (è‡ªé€‚åº”äº¤é€šä¿¡å·æ§åˆ¶å™¨ / Adaptive Traffic Signal Controller)

```python
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch_geometric.nn import GCNConv, GATConv
from typing import Dict, List, Tuple
import numpy as np

class AdaptiveTrafficSignalController(nn.Module):
    """è‡ªé€‚åº”äº¤é€šä¿¡å·æ§åˆ¶å™¨ - ä½¿ç”¨è‡ªé€‚åº”GNN"""

    def __init__(self, num_intersections: int, feature_dim: int = 8,
                 hidden_dim: int = 64, num_phases: int = 4):
        super(AdaptiveTrafficSignalController, self).__init__()

        # GNNç¼–ç å™¨ï¼ˆä½¿ç”¨GATæ•è·è·¯å£é—´å…³ç³»ï¼‰
        self.conv1 = GATConv(feature_dim, hidden_dim, heads=4, dropout=0.1)
        self.conv2 = GATConv(hidden_dim * 4, hidden_dim, heads=1, dropout=0.1)

        # è‡ªé€‚åº”æ³¨æ„åŠ›æƒé‡
        self.adaptive_attention = nn.Parameter(torch.ones(1))

        # ä¿¡å·å†³ç­–å™¨
        self.decision_layer = nn.Sequential(
            nn.Linear(hidden_dim, hidden_dim),
            nn.ReLU(),
            nn.Dropout(0.1),
            nn.Linear(hidden_dim, hidden_dim // 2),
            nn.ReLU(),
            nn.Linear(hidden_dim // 2, num_phases),
            nn.Softmax(dim=-1)
        )

        # æ€§èƒ½é¢„æµ‹å™¨ï¼ˆç”¨äºè‡ªé€‚åº”è°ƒæ•´ï¼‰
        self.performance_predictor = nn.Sequential(
            nn.Linear(hidden_dim, hidden_dim // 2),
            nn.ReLU(),
            nn.Linear(hidden_dim // 2, 1),
            nn.Sigmoid()
        )

    def forward(self, x: torch.Tensor, edge_index: torch.Tensor,
               traffic_state: Dict = None) -> torch.Tensor:
        """
        å‰å‘ä¼ æ’­

        Args:
            x: è·¯å£ç‰¹å¾ [N, feature_dim]ï¼ˆåŒ…æ‹¬ç­‰å¾…è½¦è¾†æ•°ã€å½“å‰ç›¸ä½ç­‰ï¼‰
            edge_index: è·¯å£è¿æ¥å…³ç³» [2, E]
            traffic_state: äº¤é€šçŠ¶æ€ï¼ˆå¯é€‰ï¼‰

        Returns:
            phase_probs: ç›¸ä½æ¦‚ç‡ [N, num_phases]
        """
        # å›¾ç¼–ç 
        h = F.elu(self.conv1(x, edge_index))
        h = self.conv2(h, edge_index)

        # è‡ªé€‚åº”è°ƒæ•´ï¼ˆæ ¹æ®äº¤é€šçŠ¶æ€ï¼‰
        if traffic_state:
            congestion_level = traffic_state.get('congestion', 0.0)
            h = h * (1 + self.adaptive_attention * congestion_level)

        # å†³ç­–
        phase_probs = self.decision_layer(h)

        return phase_probs

    def predict_performance(self, x: torch.Tensor,
                          edge_index: torch.Tensor) -> torch.Tensor:
        """é¢„æµ‹æ€§èƒ½ï¼ˆç”¨äºè‡ªé€‚åº”è°ƒæ•´ï¼‰"""
        h = F.elu(self.conv1(x, edge_index))
        h = self.conv2(h, edge_index)
        performance = self.performance_predictor(h.mean(dim=0))
        return performance

    def adapt_attention(self, performance_metric: float):
        """è‡ªé€‚åº”è°ƒæ•´æ³¨æ„åŠ›æƒé‡"""
        if performance_metric < 0.7:
            # æ€§èƒ½å·®ï¼Œå¢å¼ºæ³¨æ„åŠ›
            self.adaptive_attention.data *= 1.1
        else:
            # æ€§èƒ½å¥½ï¼Œä¿æŒ
            self.adaptive_attention.data *= 0.99
```

### ç®—æ³• 4.1.2 (æ™ºèƒ½è·¯å¾„è§„åˆ’ç®—æ³• / Intelligent Path Planning Algorithm)

```python
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch_geometric.nn import GCNConv
from typing import List, Tuple, Dict
import networkx as nx

class IntelligentPathPlanner(nn.Module):
    """æ™ºèƒ½è·¯å¾„è§„åˆ’å™¨ - ä½¿ç”¨è‡ªé€‚åº”GNN"""

    def __init__(self, road_feature_dim: int = 16, hidden_dim: int = 64):
        super(IntelligentPathPlanner, self).__init__()

        # é“è·¯ç½‘ç»œç¼–ç å™¨
        self.conv1 = GCNConv(road_feature_dim, hidden_dim)
        self.conv2 = GCNConv(hidden_dim, hidden_dim)

        # è·¯å¾„æˆæœ¬é¢„æµ‹å™¨
        self.cost_predictor = nn.Sequential(
            nn.Linear(hidden_dim * 2, hidden_dim),
            nn.ReLU(),
            nn.Linear(hidden_dim, 1)
        )

        # è‡ªé€‚åº”æƒé‡ï¼ˆæ ¹æ®å®æ—¶äº¤é€šè°ƒæ•´ï¼‰
        self.adaptive_weight = nn.Parameter(torch.ones(1))

    def forward(self, road_features: torch.Tensor,
               edge_index: torch.Tensor,
               source: int, target: int) -> Tuple[List[int], float]:
        """
        è§„åˆ’è·¯å¾„

        Args:
            road_features: é“è·¯ç‰¹å¾ [N, road_feature_dim]
            edge_index: é“è·¯è¿æ¥ [2, E]
            source: èµ·ç‚¹
            target: ç»ˆç‚¹

        Returns:
            path: æœ€ä¼˜è·¯å¾„
            cost: è·¯å¾„æˆæœ¬
        """
        # ç¼–ç é“è·¯ç½‘ç»œ
        h = F.relu(self.conv1(road_features, edge_index))
        h = self.conv2(h, edge_index)

        # ä½¿ç”¨A*ç®—æ³•æœç´¢è·¯å¾„ï¼ˆç»“åˆGNNé¢„æµ‹çš„æˆæœ¬ï¼‰
        path, cost = self.astar_search(h, edge_index, source, target)

        return path, cost

    def astar_search(self, node_embeddings: torch.Tensor,
                    edge_index: torch.Tensor,
                    source: int, target: int) -> Tuple[List[int], float]:
        """A*æœç´¢ï¼ˆä½¿ç”¨GNNé¢„æµ‹çš„è¾¹æˆæœ¬ï¼‰"""
        # è®¡ç®—è¾¹æˆæœ¬
        src, dst = edge_index
        edge_costs = []

        for i in range(edge_index.size(1)):
            u, v = src[i].item(), dst[i].item()
            edge_feat = torch.cat([node_embeddings[u], node_embeddings[v]], dim=-1)
            cost = self.cost_predictor(edge_feat).item()
            edge_costs.append((u, v, cost))

        # æ„å»ºå›¾
        G = nx.DiGraph()
        for u, v, cost in edge_costs:
            G.add_edge(u, v, weight=cost)

        # A*æœç´¢
        try:
            path = nx.astar_path(G, source, target,
                                heuristic=lambda u, v: 0)  # ç®€åŒ–ï¼šæ— å¯å‘å¼
            total_cost = sum(G[u][v]['weight'] for u, v in zip(path[:-1], path[1:]))
            return path, total_cost
        except:
            return [], float('inf')
```

### ç®—æ³• 4.1.3 (äº¤é€šæµé¢„æµ‹ç®—æ³• / Traffic Flow Prediction Algorithm)

```python
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch_geometric.nn import GCNConv, GATConv
from typing import List, Dict
import numpy as np

class TrafficFlowPredictor(nn.Module):
    """äº¤é€šæµé¢„æµ‹å™¨ - ä½¿ç”¨æ—¶ç©ºGNN"""

    def __init__(self, feature_dim: int = 8, hidden_dim: int = 64,
                 num_timesteps: int = 12, prediction_horizon: int = 6):
        super(TrafficFlowPredictor, self).__init__()

        self.num_timesteps = num_timesteps
        self.prediction_horizon = prediction_horizon

        # ç©ºé—´ç¼–ç å™¨ï¼ˆGNNï¼‰
        self.spatial_conv1 = GATConv(feature_dim, hidden_dim, heads=4, dropout=0.1)
        self.spatial_conv2 = GATConv(hidden_dim * 4, hidden_dim, heads=1, dropout=0.1)

        # æ—¶é—´ç¼–ç å™¨ï¼ˆLSTMï¼‰
        self.temporal_encoder = nn.LSTM(hidden_dim, hidden_dim,
                                       num_layers=2, batch_first=True, dropout=0.1)

        # é¢„æµ‹å™¨
        self.predictor = nn.Sequential(
            nn.Linear(hidden_dim, hidden_dim),
            nn.ReLU(),
            nn.Linear(hidden_dim, feature_dim)
        )

    def forward(self, x_sequence: List[torch.Tensor],
               edge_index: torch.Tensor) -> torch.Tensor:
        """
        å‰å‘ä¼ æ’­

        Args:
            x_sequence: æ—¶é—´åºåˆ—ç‰¹å¾ [T, N, feature_dim]
            edge_index: ç©ºé—´è¿æ¥ [2, E]

        Returns:
            predictions: æœªæ¥äº¤é€šæµé¢„æµ‹ [prediction_horizon, N, feature_dim]
        """
        # ç©ºé—´ç¼–ç 
        spatial_embeddings = []
        for x_t in x_sequence:
            h = F.elu(self.spatial_conv1(x_t, edge_index))
            h = self.spatial_conv2(h, edge_index)
            spatial_embeddings.append(h)

        # å †å ä¸ºåºåˆ— [T, N, hidden_dim]
        spatial_seq = torch.stack(spatial_embeddings, dim=0)
        spatial_seq = spatial_seq.transpose(0, 1)  # [N, T, hidden_dim]

        # æ—¶é—´ç¼–ç 
        temporal_output, _ = self.temporal_encoder(spatial_seq)
        # temporal_output: [N, T, hidden_dim]

        # é¢„æµ‹æœªæ¥
        last_hidden = temporal_output[:, -1, :]  # [N, hidden_dim]
        predictions = []

        current_hidden = last_hidden.unsqueeze(0)  # [1, N, hidden_dim]

        for _ in range(self.prediction_horizon):
            # é¢„æµ‹ä¸‹ä¸€æ­¥
            pred = self.predictor(current_hidden.squeeze(0))  # [N, feature_dim]
            predictions.append(pred)

            # æ›´æ–°éšè—çŠ¶æ€ï¼ˆç®€åŒ–ï¼šå®é™…åº”è¯¥ä½¿ç”¨æ›´å¤æ‚çš„æ›´æ–°æœºåˆ¶ï¼‰
            # è¿™é‡Œåªæ˜¯ç¤ºæ„

        return torch.stack(predictions, dim=0)  # [prediction_horizon, N, feature_dim]
```

---

## ğŸ“Š **æ€§èƒ½è¯„ä¼° / Performance Evaluation**

### 4.1.1 è¯„ä¼°æŒ‡æ ‡ / Evaluation Metrics

#### äº¤é€šæ•ˆç‡æŒ‡æ ‡

1. **å¹³å‡ç­‰å¾…æ—¶é—´**:
   - å®šä¹‰: $\text{AWT} = \frac{1}{N}\sum_{i=1}^{N} t_{wait,i}$
   - ç›®æ ‡: æœ€å°åŒ–å¹³å‡ç­‰å¾…æ—¶é—´

2. **å¹³å‡è¡Œé©¶æ—¶é—´**:
   - å®šä¹‰: $\text{ATT} = \frac{1}{N}\sum_{i=1}^{N} t_{travel,i}$
   - ç›®æ ‡: æœ€å°åŒ–å¹³å‡è¡Œé©¶æ—¶é—´

3. **é“è·¯åˆ©ç”¨ç‡**:
   - å®šä¹‰: $\text{UR} = \frac{\text{å®é™…æµé‡}}{\text{é“è·¯å®¹é‡}}$
   - ç›®æ ‡: ä¼˜åŒ–é“è·¯åˆ©ç”¨ç‡

#### ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡

1. **é¢„æµ‹å‡†ç¡®ç‡**:
   - å®šä¹‰: $\text{Acc} = 1 - \frac{\|F_{pred} - F_{true}\|}{\|F_{true}\|}$
   - ç›®æ ‡: æœ€å¤§åŒ–é¢„æµ‹å‡†ç¡®ç‡

2. **å†³ç­–å“åº”æ—¶é—´**:
   - å®šä¹‰: ä»æ•°æ®è¾“å…¥åˆ°å†³ç­–è¾“å‡ºçš„æ—¶é—´
   - ç›®æ ‡: æœ€å°åŒ–å“åº”æ—¶é—´ï¼ˆ<10msï¼‰

3. **ç³»ç»Ÿç¨³å®šæ€§**:
   - å®šä¹‰: ç³»ç»Ÿåœ¨æ‰°åŠ¨ä¸‹çš„æ€§èƒ½ä¿æŒ
   - ç›®æ ‡: æœ€å¤§åŒ–ç¨³å®šæ€§

#### ç”¨æˆ·æ»¡æ„åº¦æŒ‡æ ‡

1. **ç”¨æˆ·è¯„åˆ†**: 1-5åˆ†åˆ¶
2. **æŠ•è¯‰ç‡**: æŠ•è¯‰æ¬¡æ•°/æ€»ä½¿ç”¨æ¬¡æ•°
3. **ä½¿ç”¨ç‡**: å®é™…ä½¿ç”¨æ¬¡æ•°/æ¨èæ¬¡æ•°

### 4.1.2 æ€§èƒ½åŸºå‡† / Performance Benchmarks

| æ–¹æ³• | å¹³å‡ç­‰å¾…æ—¶é—´ | é¢„æµ‹å‡†ç¡®ç‡ | å“åº”æ—¶é—´ | ç”¨æˆ·æ»¡æ„åº¦ |
|------|------------|-----------|----------|-----------|
| ä¼ ç»Ÿæ–¹æ³• | 120ç§’ | 0.70 | 100ms | 3.2/5.0 |
| åŸºç¡€GNN | 90ç§’ | 0.80 | 50ms | 3.8/5.0 |
| è‡ªé€‚åº”GNN | 75ç§’ | 0.88 | 10ms | 4.5/5.0 |
| **æ”¹è¿›** | **-38%** | **+26%** | **-90%** | **+41%** |

---

## ğŸ”¬ **æŠ€æœ¯æŒ‘æˆ˜ä¸æœªæ¥æ–¹å‘**

### æŠ€æœ¯æŒ‘æˆ˜

1. **å®æ—¶æ€§è¦æ±‚**: éœ€è¦åœ¨æçŸ­æ—¶é—´å†…å®Œæˆå†³ç­–
2. **å¤§è§„æ¨¡æ•°æ®**: éœ€è¦å¤„ç†å¤§è§„æ¨¡äº¤é€šæ•°æ®
3. **å¤šå°ºåº¦ä¼˜åŒ–**: éœ€è¦åŒæ—¶ä¼˜åŒ–å¤šä¸ªå°ºåº¦

### æœªæ¥æ–¹å‘

1. **æ›´æ™ºèƒ½çš„å†³ç­–**: ä½¿ç”¨æ›´å…ˆè¿›çš„AIæ–¹æ³•
2. **æ›´å¿«çš„å“åº”**: å‡å°‘å†³ç­–å»¶è¿Ÿ
3. **æ›´å¥½çš„ä¼˜åŒ–**: æé«˜ä¼˜åŒ–è´¨é‡

---

## ğŸ”— **ç›¸å…³é“¾æ¥ / Related Links**

- [AIç½‘ç»œä¸è‡ªé€‚åº”èŒƒç•´ä¸»ç›®å½•](../../README.md)
- [åº”ç”¨é¢†åŸŸç›®å½•](../README.md)
- [ç¤¾äº¤ç½‘ç»œåº”ç”¨](02-ç¤¾äº¤ç½‘ç»œåº”ç”¨.md)
- [AIç½‘ç»œå…ƒæ¨¡å‹](../../00-AIç½‘ç»œå…ƒæ¨¡å‹.md)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ
**çŠ¶æ€**: âœ… **å·²å®Œæˆ**
