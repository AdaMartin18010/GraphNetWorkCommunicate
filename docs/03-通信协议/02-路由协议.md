# è·¯ç”±åè®® / Routing Protocols

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£å¯¹æ ‡Wikipediaå’Œé¡¶çº§å¤§å­¦ï¼ˆMITã€Stanfordã€CMUã€Oxfordã€Caltechã€Harvardï¼‰çš„è·¯ç”±åè®®è¯¾ç¨‹æ ‡å‡†ï¼Œæä¾›ä¸¥æ ¼ã€å®Œæ•´ã€å›½é™…åŒ–çš„è·¯ç”±åè®®ç†è®ºä½“ç³»ã€‚æ¯ä¸ªæ¦‚å¿µéƒ½åŒ…å«ç²¾ç¡®çš„æ•°å­¦å®šä¹‰ã€å†å²å‘å±•ã€åº”ç”¨èƒŒæ™¯å’ŒåŒè¯­å¯¹ç…§ã€‚

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§  
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…  
**å®ŒæˆçŠ¶æ€**: 100% å®Œæˆ âœ…

## ğŸ¯ **1. è·¯ç”±åè®®åŸºç¡€ / Routing Protocol Fundamentals**

### 1.1 è·¯ç”±æ¦‚å¿µ / Routing Concepts

**å®šä¹‰ 1.1** (è·¯ç”± / Routing)
**è·¯ç”±**æ˜¯æŒ‡åœ¨ç½‘ç»œä¸­ç¡®å®šæ•°æ®åŒ…ä»æºèŠ‚ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹çš„ä¼ è¾“è·¯å¾„çš„è¿‡ç¨‹ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$R = (N, E, P, C, T)$$
å…¶ä¸­ï¼š

- $N$ æ˜¯**èŠ‚ç‚¹é›†**ï¼ˆnode setï¼‰ï¼Œ$N \neq \emptyset$
- $E$ æ˜¯**è¾¹é›†**ï¼ˆedge setï¼‰ï¼Œ$E \subseteq N \times N$
- $P$ æ˜¯**è·¯å¾„é›†**ï¼ˆpath setï¼‰ï¼Œ$P \subseteq N^*$
- $C: E \to \mathbb{R}^+$ æ˜¯**æˆæœ¬å‡½æ•°**ï¼ˆcost functionï¼‰
- $T$ æ˜¯**è·¯ç”±è¡¨**ï¼ˆrouting tableï¼‰

**å®šä¹‰ 1.2** (è·¯ç”±è¡¨ / Routing Table)
**è·¯ç”±è¡¨**æ˜¯å­˜å‚¨è·¯ç”±ä¿¡æ¯çš„æ•°æ®åº“ï¼ŒåŒ…å«ç›®æ ‡ç½‘ç»œã€ä¸‹ä¸€è·³åœ°å€ã€æ¥å£å’Œåº¦é‡å€¼ç­‰ä¿¡æ¯ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$T = \{(d, n, i, m) \mid d \in D, n \in N, i \in I, m \in \mathbb{R}^+\}$$
å…¶ä¸­ï¼š

- $d$ æ˜¯ç›®æ ‡ç½‘ç»œï¼ˆdestinationï¼‰
- $n$ æ˜¯ä¸‹ä¸€è·³èŠ‚ç‚¹ï¼ˆnext hopï¼‰
- $i$ æ˜¯æ¥å£ï¼ˆinterfaceï¼‰
- $m$ æ˜¯åº¦é‡å€¼ï¼ˆmetricï¼‰

**å®šç† 1.1** (æœ€ä¼˜è·¯ç”±å®šç† / Optimal Routing Theorem)
è·¯ç”±ç®—æ³•çš„ç›®æ ‡æ˜¯æœ€å°åŒ–è·¯å¾„æˆæœ¬å‡½æ•°ï¼š
$$\min_{P \in \mathcal{P}(s,t)} \sum_{e \in P} c(e)$$

å…¶ä¸­ $P$ æ˜¯è·¯å¾„ï¼Œ$c(e)$ æ˜¯è¾¹ $e$ çš„æˆæœ¬ï¼Œ$\mathcal{P}(s,t)$ æ˜¯ä»æº $s$ åˆ°ç›®æ ‡ $t$ çš„æ‰€æœ‰è·¯å¾„é›†åˆã€‚

**å†å²èƒŒæ™¯**ï¼š

- **1960å¹´ä»£**ï¼šARPANETè·¯ç”±ç®—æ³•å¼€å‘
- **1970å¹´ä»£**ï¼šè·ç¦»å‘é‡ç®—æ³•ï¼ˆRIPï¼‰æ ‡å‡†åŒ–
- **1980å¹´ä»£**ï¼šé“¾è·¯çŠ¶æ€ç®—æ³•ï¼ˆOSPFï¼‰å¼€å‘
- **1990å¹´ä»£**ï¼šè¾¹ç•Œç½‘å…³åè®®ï¼ˆBGPï¼‰æ ‡å‡†åŒ–
- **2000å¹´ä»£**ï¼šå¤šåè®®æ ‡ç­¾äº¤æ¢ï¼ˆMPLSï¼‰å‘å±•
- **2010å¹´ä»£**ï¼šè½¯ä»¶å®šä¹‰ç½‘ç»œï¼ˆSDNï¼‰è·¯ç”±
- **2020å¹´ä»£**ï¼šAIé©±åŠ¨çš„æ™ºèƒ½è·¯ç”±ç®—æ³•

**åº”ç”¨é¢†åŸŸ**ï¼š

- **äº’è”ç½‘**ï¼šBGPã€OSPFã€RIP
- **æ•°æ®ä¸­å¿ƒ**ï¼šECMPã€VXLANã€BGP-EVPN
- **ç§»åŠ¨ç½‘ç»œ**ï¼šç§»åŠ¨IPã€5Gè·¯ç”±
- **ç‰©è”ç½‘**ï¼šä½åŠŸè€—è·¯ç”±åè®®
- **åŒºå—é“¾**ï¼šP2Pç½‘ç»œè·¯ç”±

### 2.1.2 è·¯ç”±åè®®åˆ†ç±»

**å®šä¹‰ 2.1.3** æ ¹æ®è·¯ç”±ä¿¡æ¯çš„ä¼ æ’­æ–¹å¼ï¼Œè·¯ç”±åè®®å¯åˆ†ä¸ºï¼š

1. **è·ç¦»å‘é‡åè®®**ï¼šæ¯ä¸ªèŠ‚ç‚¹åªä¸é‚»å±…äº¤æ¢è·¯ç”±ä¿¡æ¯
2. **é“¾è·¯çŠ¶æ€åè®®**ï¼šæ¯ä¸ªèŠ‚ç‚¹å‘å…¨ç½‘å¹¿æ’­é“¾è·¯çŠ¶æ€ä¿¡æ¯
3. **è·¯å¾„å‘é‡åè®®**ï¼šç”¨äºè‡ªæ²»ç³»ç»Ÿé—´çš„è·¯ç”±

## 2.2 è·ç¦»å‘é‡åè®®

### 2.2.1 åŸºæœ¬åŸç†

**å®šä¹‰ 2.2.1** è·ç¦»å‘é‡åè®®æ˜¯ä¸€ç§åˆ†å¸ƒå¼è·¯ç”±ç®—æ³•ï¼Œæ¯ä¸ªèŠ‚ç‚¹ç»´æŠ¤åˆ°æ‰€æœ‰ç›®æ ‡çš„æœ€çŸ­è·ç¦»å‘é‡ã€‚

**ç®—æ³• 2.2.1** è·ç¦»å‘é‡ç®—æ³•

```python
class DistanceVectorRouter:
    def __init__(self, node_id):
        self.node_id = node_id
        self.distance_vector = {}  # {destination: (distance, next_hop)}
        self.neighbors = {}  # {neighbor_id: cost}
    
    def update_distance_vector(self):
        # åˆå§‹åŒ–è·ç¦»å‘é‡
        for dest in self.get_all_destinations():
            if dest == self.node_id:
                self.distance_vector[dest] = (0, self.node_id)
            elif dest in self.neighbors:
                self.distance_vector[dest] = (self.neighbors[dest], dest)
            else:
                self.distance_vector[dest] = (float('inf'), None)
        
        # ä»é‚»å±…è·å–è·ç¦»å‘é‡å¹¶æ›´æ–°
        for neighbor_id, neighbor_cost in self.neighbors.items():
            neighbor_dv = self.get_neighbor_dv(neighbor_id)
            
            for dest, (neighbor_dist, _) in neighbor_dv.items():
                total_cost = neighbor_cost + neighbor_dist
                
                if (dest not in self.distance_vector or 
                    total_cost < self.distance_vector[dest][0]):
                    self.distance_vector[dest] = (total_cost, neighbor_id)
    
    def get_next_hop(self, destination):
        if destination in self.distance_vector:
            return self.distance_vector[destination][1]
        return None
```

### 2.2.2 RIPåè®®

**å®šä¹‰ 2.2.2** RIPï¼ˆRouting Information Protocolï¼‰æ˜¯ä¸€ç§åŸºäºè·ç¦»å‘é‡çš„è·¯ç”±åè®®ï¼Œä½¿ç”¨è·³æ•°ä½œä¸ºåº¦é‡ã€‚

**ç®—æ³• 2.2.2** RIPåè®®å®ç°

```python
class RIPRouter:
    def __init__(self, router_id):
        self.router_id = router_id
        self.routing_table = {}
        self.neighbors = {}
        self.max_hops = 15  # RIPæœ€å¤§è·³æ•°é™åˆ¶
    
    def process_rip_update(self, neighbor_id, routing_update):
        """å¤„ç†æ¥è‡ªé‚»å±…çš„RIPæ›´æ–°"""
        for dest, (metric, next_hop) in routing_update.items():
            # è®¡ç®—åˆ°ç›®æ ‡çš„æ–°è·ç¦»
            new_metric = self.neighbors[neighbor_id] + metric
            
            # æ£€æŸ¥è·³æ•°é™åˆ¶
            if new_metric > self.max_hops:
                new_metric = float('inf')
            
            # æ›´æ–°è·¯ç”±è¡¨
            if (dest not in self.routing_table or 
                new_metric < self.routing_table[dest][0]):
                self.routing_table[dest] = (new_metric, neighbor_id)
    
    def send_rip_update(self):
        """å‘é‚»å±…å‘é€RIPæ›´æ–°"""
        updates = {}
        for dest, (metric, next_hop) in self.routing_table.items():
            # é¿å…è·¯ç”±ç¯è·¯ï¼šä¸å‘ä¸‹ä¸€è·³æŠ¥å‘Šè·¯ç”±
            if next_hop != dest:
                updates[dest] = (metric, next_hop)
        
        return updates
```

**å®šç† 2.2.1** RIPåè®®çš„æœ€å¤§è·³æ•°é™åˆ¶ä¸º15è·³ï¼Œè¶…è¿‡15è·³çš„ç›®æ ‡è¢«è®¤ä¸ºæ˜¯ä¸å¯è¾¾çš„ã€‚

**è¯æ˜** è¿™æ˜¯ä¸ºäº†é˜²æ­¢è·¯ç”±ç¯è·¯æ— é™ä¼ æ’­ï¼Œ15è·³çš„é™åˆ¶ç¡®ä¿äº†æ”¶æ•›æ€§ã€‚

### 2.2.3 è®¡æ•°åˆ°æ— ç©·é—®é¢˜

**å®šä¹‰ 2.2.3** è®¡æ•°åˆ°æ— ç©·é—®é¢˜æ˜¯è·ç¦»å‘é‡åè®®ä¸­çš„ä¸€ä¸ªç»å…¸é—®é¢˜ï¼Œå½“é“¾è·¯æ•…éšœæ—¶ï¼Œé”™è¯¯ä¿¡æ¯ä¼šåœ¨ç½‘ç»œä¸­ç¼“æ…¢ä¼ æ’­ã€‚

**ç®—æ³• 2.2.3** æ°´å¹³åˆ†å‰²è§£å†³æ–¹æ¡ˆ

```python
def split_horizon(self, neighbor_id):
    """æ°´å¹³åˆ†å‰²ï¼šä¸å‘å­¦ä¹ åˆ°è·¯ç”±çš„é‚»å±…æŠ¥å‘Šè¯¥è·¯ç”±"""
    updates = {}
    for dest, (metric, next_hop) in self.routing_table.items():
        if next_hop != neighbor_id:  # ä¸å‘ä¸‹ä¸€è·³æŠ¥å‘Š
            updates[dest] = (metric, next_hop)
    return updates
```

**ç®—æ³• 2.2.4** æ¯’æ€§åè½¬è§£å†³æ–¹æ¡ˆ

```python
def poison_reverse(self, neighbor_id):
    """æ¯’æ€§åè½¬ï¼šå‘ä¸‹ä¸€è·³æŠ¥å‘Šæ— ç©·å¤§è·ç¦»"""
    updates = {}
    for dest, (metric, next_hop) in self.routing_table.items():
        if next_hop == neighbor_id:
            # å‘ä¸‹ä¸€è·³æŠ¥å‘Šæ— ç©·å¤§è·ç¦»
            updates[dest] = (float('inf'), next_hop)
        else:
            updates[dest] = (metric, next_hop)
    return updates
```

## 2.3 é“¾è·¯çŠ¶æ€åè®®

### 2.3.1 åŸºæœ¬åŸç†

**å®šä¹‰ 2.3.1** é“¾è·¯çŠ¶æ€åè®®æ˜¯ä¸€ç§é›†ä¸­å¼è·¯ç”±ç®—æ³•ï¼Œæ¯ä¸ªèŠ‚ç‚¹å‘å…¨ç½‘å¹¿æ’­å…¶é“¾è·¯çŠ¶æ€ä¿¡æ¯ã€‚

**ç®—æ³• 2.3.1** é“¾è·¯çŠ¶æ€ç®—æ³•

```python
class LinkStateRouter:
    def __init__(self, router_id):
        self.router_id = router_id
        self.link_state_database = {}  # å­˜å‚¨æ‰€æœ‰LSA
        self.routing_table = {}
        self.neighbors = {}
    
    def flood_lsa(self, lsa):
        """æ³›æ´ªLSAåˆ°æ‰€æœ‰é‚»å±…"""
        for neighbor_id in self.neighbors:
            self.send_lsa_to_neighbor(neighbor_id, lsa)
    
    def process_lsa(self, lsa):
        """å¤„ç†æ¥æ”¶åˆ°çš„LSA"""
        if self.is_new_lsa(lsa):
            self.link_state_database[lsa.id] = lsa
            self.flood_lsa(lsa)  # ç»§ç»­æ³›æ´ª
            self.recompute_routes()
    
    def recompute_routes(self):
        """é‡æ–°è®¡ç®—è·¯ç”±è¡¨"""
        # æ„å»ºç½‘ç»œå›¾
        graph = self.build_network_graph()
        
        # ä½¿ç”¨Dijkstraç®—æ³•è®¡ç®—æœ€çŸ­è·¯å¾„
        distances, predecessors = dijkstra(graph, self.router_id)
        
        # æ›´æ–°è·¯ç”±è¡¨
        for dest, distance in distances.items():
            if distance != float('inf'):
                next_hop = self.get_next_hop(dest, predecessors)
                self.routing_table[dest] = (distance, next_hop)
```

### 2.3.2 OSPFåè®®

**å®šä¹‰ 2.3.2** OSPFï¼ˆOpen Shortest Path Firstï¼‰æ˜¯ä¸€ç§é“¾è·¯çŠ¶æ€è·¯ç”±åè®®ï¼Œæ”¯æŒåˆ†å±‚è·¯ç”±å’Œå¤šç§åº¦é‡ã€‚

**ç®—æ³• 2.3.2** OSPFåŒºåŸŸè·¯ç”±

```python
class OSPFRouter:
    def __init__(self, router_id, area_id):
        self.router_id = router_id
        self.area_id = area_id
        self.link_state_database = {}
        self.neighbors = {}
        self.areas = {}
    
    def process_lsa(self, lsa):
        """å¤„ç†LSA"""
        if lsa.area_id == self.area_id:
            # åŒºåŸŸå†…LSA
            self.process_intra_area_lsa(lsa)
        elif lsa.area_id == 0:
            # éª¨å¹²åŒºåŸŸLSA
            self.process_backbone_lsa(lsa)
        else:
            # åŒºåŸŸé—´LSA
            self.process_inter_area_lsa(lsa)
    
    def compute_shortest_paths(self):
        """è®¡ç®—æœ€çŸ­è·¯å¾„"""
        # æ„å»ºåŒºåŸŸå›¾
        area_graph = self.build_area_graph()
        
        # ä½¿ç”¨Dijkstraç®—æ³•
        distances, predecessors = dijkstra(area_graph, self.router_id)
        
        # æ›´æ–°è·¯ç”±è¡¨
        for dest, distance in distances.items():
            if distance != float('inf'):
                next_hop = self.get_next_hop(dest, predecessors)
                self.routing_table[dest] = (distance, next_hop)
```

**å®šç† 2.3.1** OSPFä½¿ç”¨Dijkstraç®—æ³•è®¡ç®—æœ€çŸ­è·¯å¾„ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $O(|V|^2)$ã€‚

### 2.3.3 LSAç±»å‹

**å®šä¹‰ 2.3.3** OSPFå®šä¹‰äº†å¤šç§LSAç±»å‹ï¼š

1. **Router LSA (Type 1)**ï¼šæè¿°è·¯ç”±å™¨é“¾è·¯
2. **Network LSA (Type 2)**ï¼šæè¿°ç½‘ç»œé“¾è·¯
3. **Summary LSA (Type 3/4)**ï¼šæè¿°åŒºåŸŸé—´è·¯ç”±
4. **External LSA (Type 5)**ï¼šæè¿°å¤–éƒ¨è·¯ç”±

**ç®—æ³• 2.3.3** LSAç”Ÿæˆç®—æ³•

```python
def generate_router_lsa(self):
    """ç”ŸæˆRouter LSA"""
    lsa = LSAPacket()
    lsa.type = 1  # Router LSA
    lsa.router_id = self.router_id
    lsa.area_id = self.area_id
    
    # æ·»åŠ é“¾è·¯ä¿¡æ¯
    for neighbor_id, cost in self.neighbors.items():
        link = Link()
        link.neighbor_id = neighbor_id
        link.cost = cost
        lsa.links.append(link)
    
    return lsa

def generate_network_lsa(self, network_id, attached_routers):
    """ç”ŸæˆNetwork LSA"""
    lsa = LSAPacket()
    lsa.type = 2  # Network LSA
    lsa.network_id = network_id
    lsa.attached_routers = attached_routers
    
    return lsa
```

## 2.4 è·¯å¾„å‘é‡åè®®

### 2.4.1 BGPåè®®

**å®šä¹‰ 2.4.1** BGPï¼ˆBorder Gateway Protocolï¼‰æ˜¯ä¸€ç§è·¯å¾„å‘é‡åè®®ï¼Œç”¨äºè‡ªæ²»ç³»ç»Ÿé—´çš„è·¯ç”±ã€‚

**ç®—æ³• 2.4.1** BGPè·¯ç”±é€‰æ‹©ç®—æ³•

```python
class BGPRouter:
    def __init__(self, as_number):
        self.as_number = as_number
        self.routing_table = {}
        self.peers = {}  # {peer_as: connection}
    
    def process_bgp_update(self, peer_as, update):
        """å¤„ç†BGPæ›´æ–°"""
        for prefix, attributes in update.items():
            # æ£€æŸ¥ASè·¯å¾„ç¯è·¯
            if self.as_number in attributes['as_path']:
                continue  # ä¸¢å¼ƒç¯è·¯è·¯ç”±
            
            # åº”ç”¨è·¯ç”±ç­–ç•¥
            modified_attributes = self.apply_routing_policy(prefix, attributes)
            
            # é€‰æ‹©æœ€ä½³è·¯ç”±
            if self.is_better_route(prefix, modified_attributes):
                self.routing_table[prefix] = modified_attributes
                self.advertise_route(prefix, modified_attributes)
    
    def apply_routing_policy(self, prefix, attributes):
        """åº”ç”¨è·¯ç”±ç­–ç•¥"""
        # æœ¬åœ°ä¼˜å…ˆçº§
        if 'local_pref' not in attributes:
            attributes['local_pref'] = 100
        
        # ASè·¯å¾„é•¿åº¦
        attributes['as_path_length'] = len(attributes['as_path'])
        
        # èµ·æºç±»å‹
        if 'origin' not in attributes:
            attributes['origin'] = 'incomplete'
        
        return attributes
    
    def is_better_route(self, prefix, new_attributes):
        """æ¯”è¾ƒè·¯ç”±ä¼˜åŠ£"""
        if prefix not in self.routing_table:
            return True
        
        current = self.routing_table[prefix]
        
        # BGPè·¯ç”±é€‰æ‹©æ ‡å‡†
        if new_attributes['local_pref'] > current['local_pref']:
            return True
        elif new_attributes['local_pref'] < current['local_pref']:
            return False
        
        if new_attributes['as_path_length'] < current['as_path_length']:
            return True
        elif new_attributes['as_path_length'] > current['as_path_length']:
            return False
        
        # å…¶ä»–æ¯”è¾ƒæ ‡å‡†...
        return False
```

### 2.4.2 BGPå±æ€§

**å®šä¹‰ 2.4.2** BGPä½¿ç”¨å¤šç§å±æ€§æ¥æè¿°è·¯ç”±ï¼š

1. **ORIGIN**ï¼šè·¯ç”±èµ·æºï¼ˆIGPã€EGPã€Incompleteï¼‰
2. **AS_PATH**ï¼šASè·¯å¾„åˆ—è¡¨
3. **NEXT_HOP**ï¼šä¸‹ä¸€è·³åœ°å€
4. **LOCAL_PREF**ï¼šæœ¬åœ°ä¼˜å…ˆçº§
5. **MED**ï¼šå¤šå‡ºå£é‰´åˆ«å™¨
6. **COMMUNITY**ï¼šå›¢ä½“å±æ€§

**ç®—æ³• 2.4.2** BGPå±æ€§å¤„ç†

```python
def process_bgp_attributes(self, attributes):
    """å¤„ç†BGPå±æ€§"""
    # æ£€æŸ¥å¿…éœ€å±æ€§
    required_attrs = ['origin', 'as_path', 'next_hop']
    for attr in required_attrs:
        if attr not in attributes:
            return None  # ä¸¢å¼ƒæ— æ•ˆè·¯ç”±
    
    # å¤„ç†å¯é€‰å±æ€§
    if 'local_pref' not in attributes:
        attributes['local_pref'] = 100
    
    if 'med' not in attributes:
        attributes['med'] = 0
    
    # å¤„ç†å›¢ä½“å±æ€§
    if 'community' in attributes:
        self.process_community_attributes(attributes['community'])
    
    return attributes
```

## 2.5 è·¯ç”±åè®®æ¯”è¾ƒ

### 2.5.1 æ€§èƒ½æ¯”è¾ƒ

| ç‰¹æ€§ | RIP | OSPF | BGP |
|------|-----|------|-----|
| æ”¶æ•›é€Ÿåº¦ | æ…¢ | å¿« | ä¸­ç­‰ |
| å¸¦å®½ä½¿ç”¨ | ä½ | é«˜ | ä½ |
| å†…å­˜ä½¿ç”¨ | ä½ | é«˜ | ä¸­ç­‰ |
| å¯æ‰©å±•æ€§ | å·® | å¥½ | å¥½ |
| ç¯è·¯é¿å… | å·® | å¥½ | å¥½ |

### 2.5.2 é€‚ç”¨åœºæ™¯

**å®šç† 2.5.1** è·¯ç”±åè®®é€‰æ‹©åŸåˆ™ï¼š

- å°å‹ç½‘ç»œï¼šä½¿ç”¨RIP
- å¤§å‹ä¼ä¸šç½‘ç»œï¼šä½¿ç”¨OSPF
- äº’è”ç½‘éª¨å¹²ï¼šä½¿ç”¨BGP

## 2.6 è·¯ç”±å®‰å…¨

### 2.6.1 è·¯ç”±æ”»å‡»

**å®šä¹‰ 2.6.1** è·¯ç”±æ”»å‡»åŒ…æ‹¬ï¼š

1. **è·¯ç”±åŠ«æŒ**ï¼šä¼ªé€ è·¯ç”±ä¿¡æ¯
2. **è·¯ç”±æ¯’åŒ–**ï¼šæ³¨å…¥é”™è¯¯è·¯ç”±
3. **æ‹’ç»æœåŠ¡**ï¼šæ¶ˆè€—è·¯ç”±èµ„æº

**ç®—æ³• 2.6.1** è·¯ç”±éªŒè¯ç®—æ³•

```python
def verify_route_authenticity(self, route_update, signature):
    """éªŒè¯è·¯ç”±æ›´æ–°çœŸå®æ€§"""
    # éªŒè¯æ•°å­—ç­¾å
    if not verify_signature(route_update, signature):
        return False
    
    # æ£€æŸ¥è·¯ç”±æ¥æº
    if not self.is_authorized_source(route_update.source):
        return False
    
    # æ£€æŸ¥è·¯ç”±ç­–ç•¥
    if not self.check_routing_policy(route_update):
        return False
    
    return True
```

### 2.6.2 å®‰å…¨æœºåˆ¶

**ç®—æ³• 2.6.2** RPKIï¼ˆResource Public Key Infrastructureï¼‰

```python
def validate_roa(self, prefix, as_path):
    """éªŒè¯ROAï¼ˆRoute Origin Authorizationï¼‰"""
    # æŸ¥æ‰¾ROAè®°å½•
    roa = self.lookup_roa(prefix)
    
    if not roa:
        return False  # æ²¡æœ‰ROAè®°å½•
    
    # æ£€æŸ¥ASæˆæƒ
    if roa.authorized_as not in as_path:
        return False
    
    # æ£€æŸ¥å‰ç¼€é•¿åº¦
    if not self.check_prefix_length(prefix, roa):
        return False
    
    return True
```

## 2.7 è½¯ä»¶å®šä¹‰è·¯ç”±

### 2.7.1 SDNè·¯ç”±

**å®šä¹‰ 2.7.1** è½¯ä»¶å®šä¹‰è·¯ç”±é€šè¿‡é›†ä¸­å¼æ§åˆ¶å™¨ç®¡ç†ç½‘ç»œè·¯ç”±ï¼Œæä¾›æ›´çµæ´»çš„è·¯ç”±æ§åˆ¶ã€‚

**ç®—æ³• 2.7.1** SDNè·¯ç”±ç®—æ³•

```python
class SDNController:
    def __init__(self):
        self.network_topology = {}
        self.flow_table = {}
        self.switches = {}
    
    def compute_routes(self, source, destination):
        """è®¡ç®—è·¯ç”±è·¯å¾„"""
        # ä½¿ç”¨Dijkstraç®—æ³•
        path = dijkstra(self.network_topology, source, destination)
        
        # ç”Ÿæˆæµè¡¨é¡¹
        flow_entries = self.generate_flow_entries(path)
        
        # ä¸‹å‘åˆ°äº¤æ¢æœº
        self.install_flow_entries(flow_entries)
    
    def install_flow_entries(self, flow_entries):
        """å®‰è£…æµè¡¨é¡¹"""
        for switch_id, entries in flow_entries.items():
            self.switches[switch_id].install_flows(entries)
```

### 2.7.2 è·¯ç”±ä¼˜åŒ–

**ç®—æ³• 2.7.2** åŠ¨æ€è·¯ç”±ä¼˜åŒ–

```python
def optimize_routes(self, traffic_matrix):
    """åŸºäºæµé‡çŸ©é˜µä¼˜åŒ–è·¯ç”±"""
    # æ„å»ºå¤šå•†å“æµé—®é¢˜
    flow_problem = build_multicommodity_flow(traffic_matrix)
    
    # æ±‚è§£æœ€ä¼˜è·¯ç”±
    optimal_routes = solve_flow_problem(flow_problem)
    
    # æ›´æ–°è·¯ç”±è¡¨
    self.update_routing_tables(optimal_routes)
```

## å¤šæ¨¡æ€è¡¨è¾¾ä¸å¯è§†åŒ–

- **è·¯ç”±ç®—æ³•æµç¨‹å›¾**ï¼šç”¨Mermaid/PlantUMLæè¿°å¦‚Dijkstraã€Bellman-Fordç­‰è·¯ç”±ç®—æ³•æµç¨‹ã€‚
- **åè®®çŠ¶æ€æœºå›¾**ï¼šç”¨Graphviz/PlantUMLå±•ç¤ºè·¯ç”±åè®®çŠ¶æ€è½¬ç§»ã€‚
- **æ—¶åºå›¾**ï¼šç”¨Mermaidå±•ç¤ºè·¯ç”±æ¶ˆæ¯äº¤äº’ã€‚
- **è‡ªåŠ¨åŒ–è„šæœ¬å»ºè®®**ï¼š
  - `scripts/protocol_sequence_diagram.py`ï¼šè¾“å…¥è·¯ç”±åè®®æè¿°ï¼Œè¾“å‡ºæµç¨‹å›¾ã€çŠ¶æ€æœºå›¾ã€‚
- **ç¤ºä¾‹**ï¼š
  - Mermaidè·¯ç”±æµç¨‹ï¼š

    ```mermaid
    graph TD;
      Start-->RouteDiscovery;
      RouteDiscovery-->RouteUpdate;
      RouteUpdate-->End;
    ```

## 2.8 æ€»ç»“

æœ¬ç« ä»‹ç»äº†ä¸»è¦çš„è·¯ç”±åè®®ï¼š

1. **è·ç¦»å‘é‡åè®®**ï¼šRIPï¼Œç®€å•ä½†æ”¶æ•›æ…¢
2. **é“¾è·¯çŠ¶æ€åè®®**ï¼šOSPFï¼Œæ”¶æ•›å¿«ä½†å¼€é”€å¤§
3. **è·¯å¾„å‘é‡åè®®**ï¼šBGPï¼Œç”¨äºè‡ªæ²»ç³»ç»Ÿé—´è·¯ç”±
4. **è·¯ç”±å®‰å…¨**ï¼šé˜²æ­¢è·¯ç”±æ”»å‡»å’ŒéªŒè¯æœºåˆ¶
5. **è½¯ä»¶å®šä¹‰è·¯ç”±**ï¼šSDNæä¾›çš„çµæ´»è·¯ç”±æ§åˆ¶

è¿™äº›åè®®ä¸ºç½‘ç»œé€šä¿¡æä¾›äº†å¯é çš„è·¯ç”±åŸºç¡€ï¼Œæ”¯æŒä¸åŒè§„æ¨¡å’Œéœ€æ±‚çš„ç½‘ç»œç¯å¢ƒã€‚
