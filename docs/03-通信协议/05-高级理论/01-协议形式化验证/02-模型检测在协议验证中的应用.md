# æ¨¡å‹æ£€æµ‹åœ¨åè®®éªŒè¯ä¸­çš„åº”ç”¨ / æ¨¡å‹æ£€æµ‹åœ¨åè®®éªŒè¯ä¸­çš„åº”ç”¨

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä»‹ç»æ¨¡å‹æ£€æµ‹åœ¨åè®®éªŒè¯ä¸­çš„åº”ç”¨çš„è¯¦ç»†ç†è®ºå’Œå®ç°ã€‚

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆ

---

## æ¨¡å‹æ£€æµ‹åœ¨åè®®éªŒè¯ä¸­çš„åº”ç”¨

**å®šä¹‰ 6.1.2** (æ¨¡å‹æ£€æµ‹ / Model Checking)

**æ¨¡å‹æ£€æµ‹**æ˜¯ä¸€ç§è‡ªåŠ¨éªŒè¯æ–¹æ³•ï¼Œé€šè¿‡ç©·ä¸¾æœç´¢ç³»ç»Ÿçš„æ‰€æœ‰å¯èƒ½çŠ¶æ€ï¼ŒéªŒè¯ç³»ç»Ÿæ˜¯å¦æ»¡è¶³ç»™å®šçš„æ—¶åºé€»è¾‘æ€§è´¨ã€‚

**æ—¶åºé€»è¾‘ï¼ˆTemporal Logicï¼‰**ï¼š

- **CTLï¼ˆComputation Tree Logicï¼‰**ï¼šè®¡ç®—æ ‘é€»è¾‘
  - $\mathbf{AG}\phi$ï¼šæ‰€æœ‰è·¯å¾„ä¸Šæ‰€æœ‰çŠ¶æ€éƒ½æ»¡è¶³$\phi$
  - $\mathbf{EF}\phi$ï¼šå­˜åœ¨ä¸€æ¡è·¯å¾„ä¸ŠæŸä¸ªçŠ¶æ€æ»¡è¶³$\phi$
  - $\mathbf{AX}\phi$ï¼šæ‰€æœ‰è·¯å¾„çš„ä¸‹ä¸€ä¸ªçŠ¶æ€éƒ½æ»¡è¶³$\phi$

- **LTLï¼ˆLinear Temporal Logicï¼‰**ï¼šçº¿æ€§æ—¶åºé€»è¾‘
  - $\mathbf{G}\phi$ï¼šå…¨å±€æ»¡è¶³$\phi$
  - $\mathbf{F}\phi$ï¼šæœ€ç»ˆæ»¡è¶³$\phi$
  - $\mathbf{X}\phi$ï¼šä¸‹ä¸€ä¸ªçŠ¶æ€æ»¡è¶³$\phi$

**ç®—æ³•å®ç°**ï¼š

```python
from typing import Dict, Set, List, Callable
from collections import deque

class ModelChecker:
    """
    æ¨¡å‹æ£€æµ‹å™¨å®ç°ã€‚
    """

    def __init__(self, model: FormalProtocolModel):
        """
        åˆå§‹åŒ–æ¨¡å‹æ£€æµ‹å™¨ã€‚

        Args:
            model: åè®®å½¢å¼åŒ–æ¨¡å‹
        """
        self.model = model

    def check_safety(self, bad_states: Set[ProtocolState]) -> Tuple[bool, List[ProtocolState]]:
        """
        æ£€æŸ¥å®‰å…¨æ€§æ€§è´¨ï¼ˆä¸å¯è¾¾æ€§ï¼‰ã€‚

        Args:
            bad_states: ç¦æ­¢çŠ¶æ€é›†åˆ

        Returns:
            (æ˜¯å¦å®‰å…¨, è¿è§„çŠ¶æ€åˆ—è¡¨)
        """
        reachable = self.model.reachable_states()
        violations = reachable & bad_states

        return len(violations) == 0, list(violations)

    def check_deadlock(self) -> Tuple[bool, List[ProtocolState]]:
        """
        æ£€æŸ¥æ­»é”çŠ¶æ€ã€‚

        Returns:
            (æ˜¯å¦å­˜åœ¨æ­»é”, æ­»é”çŠ¶æ€åˆ—è¡¨)
        """
        deadlock_states = []

        for state in self.model.states:
            has_transition = False
            for symbol in self.model.alphabet:
                if self.model.transition(state, symbol) is not None:
                    has_transition = True
                    break

            if not has_transition and state not in self.model.initial_states:
                deadlock_states.append(state)

        return len(deadlock_states) > 0, deadlock_states

    def check_liveness(self, target_states: Set[ProtocolState]) -> bool:
        """
        æ£€æŸ¥æ´»æ€§æ€§è´¨ï¼ˆå¯è¾¾æ€§ï¼‰ã€‚

        Args:
            target_states: ç›®æ ‡çŠ¶æ€é›†åˆ

        Returns:
            æ˜¯å¦å¯è¾¾
        """
        reachable = self.model.reachable_states()
        return len(reachable & target_states) > 0

    def check_invariant(self, invariant: Callable[[ProtocolState], bool]) -> Tuple[bool, List[ProtocolState]]:
        """
        æ£€æŸ¥ä¸å˜å¼ã€‚

        Args:
            invariant: ä¸å˜å¼å‡½æ•°

        Returns:
            (æ˜¯å¦æ»¡è¶³, è¿åä¸å˜å¼çš„çŠ¶æ€åˆ—è¡¨)
        """
        violations = []
        reachable = self.model.reachable_states()

        for state in reachable:
            if not invariant(state):
                violations.append(state)

        return len(violations) == 0, violations

# å¤æ‚åº¦åˆ†æ
# check_safety: O(|S| * |Î£|) - å¯è¾¾æ€§åˆ†æ
# check_deadlock: O(|S| * |Î£|) - æ£€æŸ¥æ¯ä¸ªçŠ¶æ€çš„è½¬ç§»
# check_liveness: O(|S| * |Î£|) - å¯è¾¾æ€§åˆ†æ
# check_invariant: O(|S| * |Î£|) - å¯è¾¾æ€§åˆ†æ + ä¸å˜å¼æ£€æŸ¥
```

**çŠ¶æ€ç©ºé—´æœç´¢ä¼˜åŒ–**ï¼š

```python
class OptimizedModelChecker(ModelChecker):
    """
    ä¼˜åŒ–çš„æ¨¡å‹æ£€æµ‹å™¨ï¼Œä½¿ç”¨ç¬¦å·æ–¹æ³•ã€‚
    """

    def __init__(self, model: FormalProtocolModel):
        super().__init__(model)
        self.cache = {}  # ç¼“å­˜è®¡ç®—ç»“æœ

    def check_reachability_with_cache(self,
                                      target: Set[ProtocolState],
                                      visited: Set[ProtocolState] = None) -> bool:
        """
        ä½¿ç”¨ç¼“å­˜æ£€æŸ¥å¯è¾¾æ€§ã€‚

        Args:
            target: ç›®æ ‡çŠ¶æ€é›†åˆ
            visited: å·²è®¿é—®çŠ¶æ€é›†åˆï¼ˆé€’å½’ä½¿ç”¨ï¼‰

        Returns:
            æ˜¯å¦å¯è¾¾
        """
        if visited is None:
            visited = set()

        # æ£€æŸ¥ç¼“å­˜
        cache_key = (frozenset(target), frozenset(visited))
        if cache_key in self.cache:
            return self.cache[cache_key]

        # é€’å½’æ£€æŸ¥
        result = self._reachability_dfs(target, visited)

        # ç¼“å­˜ç»“æœ
        self.cache[cache_key] = result
        return result

    def _reachability_dfs(self,
                          target: Set[ProtocolState],
                          visited: Set[ProtocolState]) -> bool:
        """æ·±åº¦ä¼˜å…ˆæœç´¢å¯è¾¾æ€§"""
        for init_state in self.model.initial_states:
            if self._dfs_helper(init_state, target, visited.copy()):
                return True
        return False

    def _dfs_helper(self,
                    state: ProtocolState,
                    target: Set[ProtocolState],
                    visited: Set[ProtocolState]) -> bool:
        """DFSè¾…åŠ©å‡½æ•°"""
        if state in target:
            return True

        if state in visited:
            return False

        visited.add(state)

        for symbol in self.model.alphabet:
            next_state = self.model.transition(state, symbol)
            if next_state and self._dfs_helper(next_state, target, visited):
                return True

        return False

# å¤æ‚åº¦åˆ†æ
# check_reachability_with_cache: O(|S| * |Î£|) æœ€åæƒ…å†µï¼Œä½†é€šè¿‡ç¼“å­˜ä¼˜åŒ–å¹³å‡æƒ…å†µ
```



---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆ
