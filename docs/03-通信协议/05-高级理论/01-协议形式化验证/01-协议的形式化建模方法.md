# åè®®çš„å½¢å¼åŒ–å»ºæ¨¡æ–¹æ³• / åè®®çš„å½¢å¼åŒ–å»ºæ¨¡æ–¹æ³•

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä»‹ç»åè®®çš„å½¢å¼åŒ–å»ºæ¨¡æ–¹æ³•çš„è¯¦ç»†ç†è®ºå’Œå®ç°ã€‚

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [åè®®çš„å½¢å¼åŒ–å»ºæ¨¡æ–¹æ³• / åè®®çš„å½¢å¼åŒ–å»ºæ¨¡æ–¹æ³•](#åè®®çš„å½¢å¼åŒ–å»ºæ¨¡æ–¹æ³•--åè®®çš„å½¢å¼åŒ–å»ºæ¨¡æ–¹æ³•)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [åè®®çš„å½¢å¼åŒ–å»ºæ¨¡æ–¹æ³•](#åè®®çš„å½¢å¼åŒ–å»ºæ¨¡æ–¹æ³•)

---

## åè®®çš„å½¢å¼åŒ–å»ºæ¨¡æ–¹æ³•

**å®šä¹‰ 6.1.1** (åè®®å½¢å¼åŒ–æ¨¡å‹ / Formal Protocol Model)

**åè®®å½¢å¼åŒ–æ¨¡å‹**æ˜¯ä¸€ä¸ªäº”å…ƒç»„ï¼š
$$\mathcal{P} = (S, S_0, \Sigma, \delta, \Phi)$$

å…¶ä¸­ï¼š

- $S$ æ˜¯çŠ¶æ€é›†åˆ
- $S_0 \subseteq S$ æ˜¯åˆå§‹çŠ¶æ€é›†åˆ
- $\Sigma$ æ˜¯è¾“å…¥/è¾“å‡ºç¬¦å·é›†åˆ
- $\delta: S \times \Sigma \rightarrow S$ æ˜¯çŠ¶æ€è½¬ç§»å‡½æ•°
- $\Phi$ æ˜¯åè®®æ€§è´¨é›†åˆï¼ˆå®‰å…¨æ€§ã€æ´»æ€§ç­‰ï¼‰

**æœ‰é™çŠ¶æ€è‡ªåŠ¨æœºï¼ˆFSAï¼‰æ¨¡å‹**ï¼š

```python
from typing import Set, Dict, List, Tuple, Optional
from enum import Enum
from collections import deque

class ProtocolState(Enum):
    """åè®®çŠ¶æ€æšä¸¾"""
    INIT = "INIT"
    WAITING = "WAITING"
    PROCESSING = "PROCESSING"
    COMPLETED = "COMPLETED"
    ERROR = "ERROR"

class FormalProtocolModel:
    """
    åè®®å½¢å¼åŒ–æ¨¡å‹å®ç°ã€‚
    """

    def __init__(self, states: Set[ProtocolState],
                 initial_states: Set[ProtocolState],
                 alphabet: Set[str],
                 transitions: Dict[Tuple[ProtocolState, str], ProtocolState],
                 properties: List[str] = None):
        """
        åˆå§‹åŒ–åè®®å½¢å¼åŒ–æ¨¡å‹ã€‚

        Args:
            states: çŠ¶æ€é›†åˆ
            initial_states: åˆå§‹çŠ¶æ€é›†åˆ
            alphabet: è¾“å…¥/è¾“å‡ºç¬¦å·é›†åˆ
            transitions: çŠ¶æ€è½¬ç§»å‡½æ•°
            properties: åè®®æ€§è´¨åˆ—è¡¨
        """
        self.states = states
        self.initial_states = initial_states
        self.alphabet = alphabet
        self.transitions = transitions
        self.properties = properties or []

        # éªŒè¯æ¨¡å‹å®Œæ•´æ€§
        self._validate_model()

    def _validate_model(self):
        """éªŒè¯æ¨¡å‹å®Œæ•´æ€§"""
        # åˆå§‹çŠ¶æ€å¿…é¡»åœ¨çŠ¶æ€é›†åˆä¸­
        assert self.initial_states.issubset(self.states), \
            "åˆå§‹çŠ¶æ€å¿…é¡»åœ¨çŠ¶æ€é›†åˆä¸­"

        # è½¬ç§»å‡½æ•°ä¸­çš„çŠ¶æ€å¿…é¡»åœ¨çŠ¶æ€é›†åˆä¸­
        for (state, symbol), next_state in self.transitions.items():
            assert state in self.states, f"çŠ¶æ€ {state} ä¸åœ¨çŠ¶æ€é›†åˆä¸­"
            assert next_state in self.states, f"çŠ¶æ€ {next_state} ä¸åœ¨çŠ¶æ€é›†åˆä¸­"
            assert symbol in self.alphabet, f"ç¬¦å· {symbol} ä¸åœ¨å­—æ¯è¡¨ä¸­"

    def transition(self, state: ProtocolState, symbol: str) -> Optional[ProtocolState]:
        """
        æ‰§è¡ŒçŠ¶æ€è½¬ç§»ã€‚

        Args:
            state: å½“å‰çŠ¶æ€
            symbol: è¾“å…¥ç¬¦å·

        Returns:
            ä¸‹ä¸€ä¸ªçŠ¶æ€ï¼Œå¦‚æœè½¬ç§»ä¸å­˜åœ¨åˆ™è¿”å›None
        """
        return self.transitions.get((state, symbol))

    def reachable_states(self) -> Set[ProtocolState]:
        """
        è®¡ç®—æ‰€æœ‰å¯è¾¾çŠ¶æ€ã€‚

        Returns:
            å¯è¾¾çŠ¶æ€é›†åˆ
        """
        reachable = set()
        queue = deque(self.initial_states)

        while queue:
            state = queue.popleft()
            if state in reachable:
                continue

            reachable.add(state)

            # æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„ä¸‹ä¸€çŠ¶æ€
            for symbol in self.alphabet:
                next_state = self.transition(state, symbol)
                if next_state and next_state not in reachable:
                    queue.append(next_state)

        return reachable

# å¤æ‚åº¦åˆ†æ
# transition: O(1) - å­—å…¸æŸ¥æ‰¾
# reachable_states: O(|S| * |Î£|) - BFSéå†
```

**æ ‡è®°è½¬ç§»ç³»ç»Ÿï¼ˆLTSï¼‰æ¨¡å‹**ï¼š

```python
from typing import Dict, List, Set

class LabeledTransitionSystem:
    """
    æ ‡è®°è½¬ç§»ç³»ç»Ÿï¼ˆLabeled Transition Systemï¼‰å®ç°ã€‚
    """

    def __init__(self, states: Set[str],
                 initial_state: str,
                 labels: Set[str],
                 transitions: Dict[Tuple[str, str], Set[str]]):
        """
        åˆå§‹åŒ–æ ‡è®°è½¬ç§»ç³»ç»Ÿã€‚

        Args:
            states: çŠ¶æ€é›†åˆ
            initial_state: åˆå§‹çŠ¶æ€
            labels: æ ‡è®°é›†åˆ
            transitions: è½¬ç§»å…³ç³» (state, label) -> {next_states}
        """
        self.states = states
        self.initial_state = initial_state
        self.labels = labels
        self.transitions = transitions

    def successors(self, state: str, label: str = None) -> Set[str]:
        """
        è·å–çŠ¶æ€çš„åç»§çŠ¶æ€ã€‚

        Args:
            state: å½“å‰çŠ¶æ€
            label: æ ‡è®°ï¼ˆå¯é€‰ï¼‰

        Returns:
            åç»§çŠ¶æ€é›†åˆ
        """
        if label is None:
            # è¿”å›æ‰€æœ‰æ ‡è®°çš„åç»§çŠ¶æ€
            successors = set()
            for (s, l), next_states in self.transitions.items():
                if s == state:
                    successors.update(next_states)
            return successors
        else:
            return self.transitions.get((state, label), set())

    def trace(self, path: List[str]) -> List[str]:
        """
        è®¡ç®—è·¯å¾„å¯¹åº”çš„çŠ¶æ€åºåˆ—ã€‚

        Args:
            path: æ ‡è®°åºåˆ—

        Returns:
            çŠ¶æ€åºåˆ—
        """
        states = [self.initial_state]
        current = self.initial_state

        for label in path:
            next_states = self.successors(current, label)
            if not next_states:
                return states  # æ— æ³•ç»§ç»­è½¬ç§»
            current = next(iter(next_states))  # é€‰æ‹©ç¬¬ä¸€ä¸ªåç»§çŠ¶æ€
            states.append(current)

        return states

# å¤æ‚åº¦åˆ†æ
# successors: O(|T|) å…¶ä¸­|T|æ˜¯è½¬ç§»æ•°é‡
# trace: O(|path| * |T|)
```



---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆ
