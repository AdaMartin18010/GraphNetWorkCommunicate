# åè®®ååé‡åˆ†æçš„æ•°å­¦æ–¹æ³• / åè®®ååé‡åˆ†æçš„æ•°å­¦æ–¹æ³•

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä»‹ç»åè®®ååé‡åˆ†æçš„æ•°å­¦æ–¹æ³•çš„è¯¦ç»†ç†è®ºå’Œå®ç°ã€‚

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆ

---

## åè®®ååé‡åˆ†æçš„æ•°å­¦æ–¹æ³•

**å®šä¹‰ 6.2.2** (åè®®ååé‡ / Protocol Throughput)

**åè®®ååé‡** $T$ æ˜¯å•ä½æ—¶é—´å†…æˆåŠŸä¼ è¾“çš„æ¶ˆæ¯æ•°ï¼š
$$T = \frac{N_{success}}{T_{total}}$$

**ååé‡æ¨¡å‹**ï¼š

å¯¹äºæ»‘åŠ¨çª—å£åè®®ï¼Œååé‡ä¸ºï¼š
$$T = \frac{W \times S}{RTT}$$

å…¶ä¸­ï¼š

- $W$ æ˜¯çª—å£å¤§å°
- $S$ æ˜¯æ•°æ®åŒ…å¤§å°
- $RTT$ æ˜¯å¾€è¿”æ—¶é—´

**ç®—æ³•å®ç°**ï¼š

```python
from typing import List
import time

class ThroughputAnalyzer:
    """
    ååé‡åˆ†æå™¨ã€‚
    """

    def __init__(self):
        self.successful_messages = 0
        self.total_bytes = 0
        self.start_time = None
        self.end_time = None

    def start_measurement(self):
        """å¼€å§‹æµ‹é‡"""
        self.start_time = time.time()
        self.successful_messages = 0
        self.total_bytes = 0

    def record_message(self, bytes_transferred: int):
        """è®°å½•æˆåŠŸä¼ è¾“çš„æ¶ˆæ¯"""
        self.successful_messages += 1
        self.total_bytes += bytes_transferred

    def end_measurement(self):
        """ç»“æŸæµ‹é‡"""
        self.end_time = time.time()

    def message_throughput(self) -> float:
        """
        è®¡ç®—æ¶ˆæ¯ååé‡ï¼ˆæ¶ˆæ¯/ç§’ï¼‰ã€‚

        Returns:
            æ¶ˆæ¯ååé‡
        """
        if self.start_time is None or self.end_time is None:
            return 0.0

        duration = self.end_time - self.start_time
        if duration == 0:
            return 0.0

        return self.successful_messages / duration

    def bandwidth_utilization(self, total_bandwidth: float) -> float:
        """
        è®¡ç®—å¸¦å®½åˆ©ç”¨ç‡ã€‚

        Args:
            total_bandwidth: æ€»å¸¦å®½ï¼ˆæ¯”ç‰¹/ç§’ï¼‰

        Returns:
            å¸¦å®½åˆ©ç”¨ç‡ï¼ˆ0-1ï¼‰
        """
        if self.start_time is None or self.end_time is None:
            return 0.0

        duration = self.end_time - self.start_time
        if duration == 0:
            return 0.0

        bytes_per_sec = (self.total_bytes * 8) / duration  # è½¬æ¢ä¸ºæ¯”ç‰¹/ç§’
        return bytes_per_sec / total_bandwidth

    def sliding_window_throughput(self,
                                 window_size: int,
                                 packet_size: int,
                                 rtt: float) -> float:
        """
        è®¡ç®—æ»‘åŠ¨çª—å£åè®®çš„ååé‡ã€‚

        Args:
            window_size: çª—å£å¤§å°
            packet_size: æ•°æ®åŒ…å¤§å°ï¼ˆå­—èŠ‚ï¼‰
            rtt: å¾€è¿”æ—¶é—´ï¼ˆç§’ï¼‰

        Returns:
            ååé‡ï¼ˆå­—èŠ‚/ç§’ï¼‰
        """
        if rtt == 0:
            return 0.0

        return (window_size * packet_size) / rtt

    def optimal_window_size(self,
                           bandwidth: float,
                           rtt: float) -> int:
        """
        è®¡ç®—æœ€ä¼˜çª—å£å¤§å°ã€‚

        Args:
            bandwidth: å¸¦å®½ï¼ˆå­—èŠ‚/ç§’ï¼‰
            rtt: å¾€è¿”æ—¶é—´ï¼ˆç§’ï¼‰

        Returns:
            æœ€ä¼˜çª—å£å¤§å°ï¼ˆæ•°æ®åŒ…æ•°ï¼‰
        """
        if rtt == 0:
            return 0

        # å¸¦å®½å»¶è¿Ÿç§¯
        bdp = bandwidth * rtt
        # å‡è®¾æ•°æ®åŒ…å¤§å°ï¼Œè®¡ç®—çª—å£å¤§å°
        packet_size = 1500  # æ ‡å‡†MTU
        optimal_window = int(math.ceil(bdp / packet_size))
        return optimal_window

# å¤æ‚åº¦åˆ†æ
# æ‰€æœ‰æ–¹æ³•: O(1)
```



---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆ
