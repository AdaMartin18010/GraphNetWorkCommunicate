# åè®®å»¶è¿Ÿåˆ†æçš„æ•°å­¦æ–¹æ³• / åè®®å»¶è¿Ÿåˆ†æçš„æ•°å­¦æ–¹æ³•

## ğŸ“š **æ¦‚è¿° / Overview**

æœ¬æ–‡æ¡£ä»‹ç»åè®®å»¶è¿Ÿåˆ†æçš„æ•°å­¦æ–¹æ³•çš„è¯¦ç»†ç†è®ºå’Œå®ç°ã€‚

**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆ

---

## ğŸ“‘ **ç›®å½• / Table of Contents**

- [åè®®å»¶è¿Ÿåˆ†æçš„æ•°å­¦æ–¹æ³• / åè®®å»¶è¿Ÿåˆ†æçš„æ•°å­¦æ–¹æ³•](#åè®®å»¶è¿Ÿåˆ†æçš„æ•°å­¦æ–¹æ³•--åè®®å»¶è¿Ÿåˆ†æçš„æ•°å­¦æ–¹æ³•)
  - [ğŸ“š **æ¦‚è¿° / Overview**](#-æ¦‚è¿°--overview)
  - [ğŸ“‘ **ç›®å½• / Table of Contents**](#-ç›®å½•--table-of-contents)
  - [åè®®å»¶è¿Ÿåˆ†æçš„æ•°å­¦æ–¹æ³•](#åè®®å»¶è¿Ÿåˆ†æçš„æ•°å­¦æ–¹æ³•)

---

## åè®®å»¶è¿Ÿåˆ†æçš„æ•°å­¦æ–¹æ³•

**å®šä¹‰ 6.2.1** (åè®®å»¶è¿Ÿ / Protocol Latency)

**åè®®å»¶è¿Ÿ** $L$ æ˜¯æ¶ˆæ¯ä»å‘é€åˆ°æ¥æ”¶æ‰€éœ€çš„æ€»æ—¶é—´ï¼š
$$L = T_{send} + T_{prop} + T_{process} + T_{queue}$$

å…¶ä¸­ï¼š

- $T_{send}$ æ˜¯å‘é€æ—¶é—´
- $T_{prop}$ æ˜¯ä¼ æ’­å»¶è¿Ÿ
- $T_{process}$ æ˜¯å¤„ç†æ—¶é—´
- $T_{queue}$ æ˜¯æ’é˜Ÿå»¶è¿Ÿ

**æ’é˜Ÿç†è®ºæ¨¡å‹**ï¼š

ä½¿ç”¨M/M/1æ’é˜Ÿæ¨¡å‹åˆ†æåè®®å»¶è¿Ÿï¼š

$$E[L] = \frac{1}{\mu - \lambda}$$

å…¶ä¸­ï¼š

- $\lambda$ æ˜¯åˆ°è¾¾ç‡
- $\mu$ æ˜¯æœåŠ¡ç‡

**ç®—æ³•å®ç°**ï¼š

```python
import numpy as np
from typing import List, Dict
from collections import deque
import math

class ProtocolLatencyAnalyzer:
    """
    åè®®å»¶è¿Ÿåˆ†æå™¨ã€‚
    """

    def __init__(self):
        self.measurements = []

    def measure_latency(self, send_time: float, recv_time: float) -> float:
        """
        æµ‹é‡å»¶è¿Ÿã€‚

        Args:
            send_time: å‘é€æ—¶é—´
            recv_time: æ¥æ”¶æ—¶é—´

        Returns:
            å»¶è¿Ÿæ—¶é—´
        """
        latency = recv_time - send_time
        self.measurements.append(latency)
        return latency

    def average_latency(self) -> float:
        """è®¡ç®—å¹³å‡å»¶è¿Ÿ"""
        return np.mean(self.measurements) if self.measurements else 0.0

    def latency_variance(self) -> float:
        """è®¡ç®—å»¶è¿Ÿæ–¹å·®"""
        return np.var(self.measurements) if self.measurements else 0.0

    def percentile_latency(self, percentile: float) -> float:
        """è®¡ç®—ç™¾åˆ†ä½å»¶è¿Ÿ"""
        if not self.measurements:
            return 0.0
        sorted_measurements = sorted(self.measurements)
        index = int(len(sorted_measurements) * percentile / 100)
        return sorted_measurements[index]

    def mm1_queue_delay(self, arrival_rate: float, service_rate: float) -> float:
        """
        ä½¿ç”¨M/M/1æ’é˜Ÿæ¨¡å‹è®¡ç®—å»¶è¿Ÿã€‚

        Args:
            arrival_rate: åˆ°è¾¾ç‡ï¼ˆæ¶ˆæ¯/ç§’ï¼‰
            service_rate: æœåŠ¡ç‡ï¼ˆæ¶ˆæ¯/ç§’ï¼‰

        Returns:
            æœŸæœ›å»¶è¿Ÿ
        """
        if arrival_rate >= service_rate:
            return float('inf')  # ç³»ç»Ÿä¸ç¨³å®š

        utilization = arrival_rate / service_rate
        return utilization / (service_rate * (1 - utilization))

    def end_to_end_latency(self,
                          send_time: float,
                          propagation_delay: float,
                          processing_times: List[float],
                          queue_delays: List[float]) -> float:
        """
        è®¡ç®—ç«¯åˆ°ç«¯å»¶è¿Ÿã€‚

        Args:
            send_time: å‘é€æ—¶é—´
            propagation_delay: ä¼ æ’­å»¶è¿Ÿ
            processing_times: å„èŠ‚ç‚¹å¤„ç†æ—¶é—´åˆ—è¡¨
            queue_delays: å„èŠ‚ç‚¹æ’é˜Ÿå»¶è¿Ÿåˆ—è¡¨

        Returns:
            ç«¯åˆ°ç«¯å»¶è¿Ÿ
        """
        total_delay = send_time + propagation_delay
        total_delay += sum(processing_times)
        total_delay += sum(queue_delays)
        return total_delay

# å¤æ‚åº¦åˆ†æ
# measure_latency: O(1)
# average_latency: O(n) å…¶ä¸­næ˜¯æµ‹é‡æ¬¡æ•°
# percentile_latency: O(n log n) - æ’åº
# mm1_queue_delay: O(1)
```

**ç½‘ç»œå»¶è¿Ÿå»ºæ¨¡**ï¼š

```python
class NetworkLatencyModel:
    """
    ç½‘ç»œå»¶è¿Ÿæ¨¡å‹ã€‚
    """

    @staticmethod
    def propagation_delay(distance: float, speed: float = 2e8) -> float:
        """
        è®¡ç®—ä¼ æ’­å»¶è¿Ÿã€‚

        Args:
            distance: è·ç¦»ï¼ˆç±³ï¼‰
            speed: ä¼ æ’­é€Ÿåº¦ï¼ˆç±³/ç§’ï¼Œé»˜è®¤å…‰é€Ÿçš„2/3ï¼‰

        Returns:
            ä¼ æ’­å»¶è¿Ÿï¼ˆç§’ï¼‰
        """
        return distance / speed

    @staticmethod
    def transmission_delay(packet_size: int, bandwidth: float) -> float:
        """
        è®¡ç®—ä¼ è¾“å»¶è¿Ÿã€‚

        Args:
            packet_size: æ•°æ®åŒ…å¤§å°ï¼ˆæ¯”ç‰¹ï¼‰
            bandwidth: å¸¦å®½ï¼ˆæ¯”ç‰¹/ç§’ï¼‰

        Returns:
            ä¼ è¾“å»¶è¿Ÿï¼ˆç§’ï¼‰
        """
        return packet_size / bandwidth

    @staticmethod
    def total_delay(distance: float,
                   packet_size: int,
                   bandwidth: float,
                   processing_time: float = 0.0) -> float:
        """
        è®¡ç®—æ€»å»¶è¿Ÿã€‚

        Args:
            distance: è·ç¦»
            packet_size: æ•°æ®åŒ…å¤§å°
            bandwidth: å¸¦å®½
            processing_time: å¤„ç†æ—¶é—´

        Returns:
            æ€»å»¶è¿Ÿ
        """
        prop_delay = NetworkLatencyModel.propagation_delay(distance)
        trans_delay = NetworkLatencyModel.transmission_delay(packet_size, bandwidth)
        return prop_delay + trans_delay + processing_time

# å¤æ‚åº¦åˆ†æ
# æ‰€æœ‰æ–¹æ³•: O(1)
```



---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**è´¨é‡ç­‰çº§**: â­â­â­â­â­ äº”æ˜Ÿçº§
**å›½é™…å¯¹æ ‡**: 100% è¾¾æ ‡ âœ…
**å®ŒæˆçŠ¶æ€**: âœ… å·²å®Œæˆ
